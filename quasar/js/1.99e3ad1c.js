(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[1],{"185a":function(e,t,n){"use strict";n("7f7f"),n("28a5");var i=[{name:"Rhino.AntialiasLevel",dataType:3,summary:"Provides the antialias levels used for render quality"},{name:"Rhino.ApplicationSettings.AppearanceSettings",dataType:1,summary:"Provides static methods and properties to deal with the appearance of the application.",properties:[{signature:"static Color CommandPromptBackgroundColor",summary:"Gets or sets the color of the command prompt background.",since:5},{signature:"static Color CommandPromptHypertextColor",summary:"Gets or sets the color of the command prompt hypertext.",since:5},{signature:"static CommandPromptPosition CommandPromptPosition",summary:"Gets or sets the command prompt position.",since:5},{signature:"static Color CommandPromptTextColor",summary:"Gets or sets the color of the command prompt text.",since:5},{signature:"static Color CrosshairColor",summary:"Gets or sets the color of the crosshair icon.",since:5},{signature:"static Color CurrentLayerBackgroundColor",summary:"Gets or sets the color used by the layer manager dialog as the background color for the current layer.",since:5},{signature:"static string DefaultFontFaceName",summary:"Gets or sets the default font face name used in Rhino.",since:5},{signature:"static Color DefaultLayerColor",summary:"Gets or sets the default layer color.",since:5},{signature:"static Color DefaultObjectColor",summary:"Gets or sets the default color for new objects.",since:5},{signature:"static bool EchoCommandsToHistoryWindow",summary:"Gets or sets a value that determines if command names are written to the history window.",since:5},{signature:"static bool EchoPromptsToHistoryWindow",summary:"Gets or sets a value that determines if prompt messages are written to the history window.",since:5},{signature:"static Color EditCandidateColor",summary:"Gets or sets the color of objects that are eligible to be edited.",since:6},{signature:"static Color FeedbackColor",summary:"Gets or sets the feedback color.",since:5},{signature:"static Color FrameBackgroundColor",summary:"Gets or sets the background color of the frame.",since:5},{signature:"static Color GridThickLineColor",summary:"Gets or sets the color of the thick line of the grid.",since:5},{signature:"static Color GridThinLineColor",summary:"Gets or sets the color of the thin line of the grid.",since:5},{signature:"static Color GridXAxisLineColor",summary:"Gets or sets the color of the X axis of the grid.",since:5},{signature:"static Color GridYAxisLineColor",summary:"Gets or sets the color of the Y axis of the grid.",since:5},{signature:"static Color GridZAxisLineColor",summary:"Gets or sets the color of the Z axis of the grid.",since:5},{signature:"static int LanguageIdentifier",summary:"Gets or sets the language identifier.",since:5},{signature:"static Color LockedObjectColor",summary:"color used to draw locked objects.",since:5},{signature:"static bool MenuVisible",summary:"Gets or sets a value that determines if the File menu is visible.",since:5},{signature:"static Color PageviewPaperColor",summary:"Gets or sets the paper background. A rectangle is drawn into the background\n     of page views to represent the printed area. The alpha portion of the color\n     is used to draw the paper blended into the background",since:5},{signature:"static int PreviousLanguageIdentifier",summary:"Gets or sets the previous language identifier.",since:5},{signature:"static Color SelectedObjectColor",summary:"The color used to draw selected objects.\n    The default is yellow, but this can be customized by the user.",since:5},{signature:"static bool ShowCrosshairs",summary:"Gets or sets a value that determines if cross hairs are visible.",since:5},{signature:"static bool ShowFullPathInTitleBar",summary:"Gets or sets a value that determines if the full path of the document is shown in the Rhino title bar.",since:5},{signature:"static bool ShowSideBar",summary:"Should the side bar be displayed",since:6},{signature:"static Color TrackingColor",summary:"Gets or sets the tracking color.",since:5},{signature:"static bool UsePaintColors",summary:"Gets or sets a value indicating if logical paint colors should be used.",since:5},{signature:"static Color ViewportBackgroundColor",summary:"Gets or sets the viewport background color.",since:5},{signature:"static Color WorldCoordIconXAxisColor",summary:"Gets or sets the color of the world coordinate X axis.",since:5},{signature:"static Color WorldCoordIconYAxisColor",summary:"Gets or sets the color of the world coordinate Y axis.",since:5},{signature:"static Color WorldCoordIconZAxisColor",summary:"Gets or sets the color of the world coordinate Z axis.",since:5}],methods:[{signature:"static AppearanceSettingsState GetCurrentState()",summary:"Gets the current settings of the application.",since:5,returns:"An instance of a class that represents all the settings as they appear in the Rhino _Options dialog,\n     joined in a single class."},{signature:"static AppearanceSettingsState GetDefaultState()",summary:"Gets the factory settings of the application.",since:5,returns:"An instance of a class that represents all the default settings joined together."},{signature:"static Color GetPaintColor(PaintColor whichColor)",summary:"Gets the .Net library color that is currently associated with a paint color.",since:5,returns:"A .Net library color."},{signature:"static Color GetWidgetColor(WidgetColor whichColor)",summary:"Gets the .Net library color that is currently associated with a widget color.",since:6,returns:"A .Net library color."},{signature:"static bool InitialMainWindowPosition(Rectangle bounds)",summary:"Location where the Main Rhino window attempts to show when the application is first\n     started.",since:6,returns:"False if the information could not be retrieved."},{signature:"static void RestoreDefaults()",summary:"Commits the default settings as the current settings.",since:5},{signature:"static void SetPaintColor(PaintColor whichColor,Color c)",summary:"Sets the logical paint color association to a spacific .Net library color, without forced UI update.",since:5},{signature:"static void SetPaintColor(PaintColor whichColor,Color c,bool forceUiUpdate)",summary:"Sets the logical paint color association to a spacific .Net library color.",since:5},{signature:"static void SetWidgetColor(WidgetColor whichColor,Color c)",summary:"Sets the logical widget color association to a spacific .Net library color, without forced UI update.",since:6},{signature:"static void SetWidgetColor(WidgetColor whichColor,Color c,bool forceUiUpdate)",summary:"Sets the logical widget color association to a spacific .Net library color.",since:6},{signature:"static void UpdateFromState(AppearanceSettingsState state)",summary:"Sets all settings to a particular defined joined state.",since:5}]},{name:"Rhino.ApplicationSettings.AppearanceSettingsState",dataType:1,summary:"Represents a snapshot of the values in .",properties:[{signature:"Color CommandPromptBackgroundColor",summary:"Gets or sets the comand prompt background color.",since:5},{signature:"Color CommandPromptHypertextColor",summary:"Gets or sets the comand prompt hypertext color.",since:5},{signature:"Color CommandPromptTextColor",summary:"Gets or sets the command prompt text color.",since:5},{signature:"Color CrosshairColor",summary:"Gets or sets the crosshair color.",since:5},{signature:"Color CurrentLayerBackgroundColor",summary:"Gets or sets the color used by the layer manager dialog as the background color for the current layer.",since:5},{signature:"string DefaultFontFaceName",summary:"Gets or sets the name of the default font face.",since:5},{signature:"Color DefaultLayerColor",summary:"Gets or sets the default layer color.",since:5},{signature:"Color DefaultObjectColor",summary:"Gets or sets the default object color.",since:5},{signature:"bool EchoCommandsToHistoryWindow",summary:"Gets or sets a value that determines if command names are written to the history window.",since:5},{signature:"bool EchoPromptsToHistoryWindow",summary:"Gets or sets a value that determines if prompt messages are written to the history window.",since:5},{signature:"Color FeedbackColor",summary:"Gets or sets the feedback color.",since:5},{signature:"Color FrameBackgroundColor",summary:"Gets or sets the frame background color.",since:5},{signature:"Color GridThickLineColor",summary:"Gets or sets the color of the thick line in the grid.",since:5},{signature:"Color GridThinLineColor",summary:"Gets or sets the color of the thin line in the grid.",since:5},{signature:"Color GridXAxisLineColor",summary:"Gets or sets the color of X axis line in the grid.",since:5},{signature:"Color GridYAxisLineColor",summary:"Gets or sets the color of Y axis line in the grid.",since:5},{signature:"Color GridZAxisLineColor",summary:"Gets or sets the color of Z axis line in the grid.",since:5},{signature:"Color LockedObjectColor",summary:"Gets or sets the color used to draw locked objects.",since:5},{signature:"Color PageviewPaperColor",summary:"CRhinoPageView paper background. A rectangle is drawn into the background\n    of page views to represent the printed area. The alpha portion of the color\n    is used to draw the paper blended into the background",since:5},{signature:"Color SelectedObjectColor",summary:"The color used to draw selected objects.\n    The default is yellow, but this can be customized by the user.",since:5},{signature:"bool ShowCrosshairs",summary:"Gets or sets a value that determines if cross hairs are visible.",since:5},{signature:"bool ShowFullPathInTitleBar",summary:"Gets or sets a value that determines if the full path of the document is shown in the Rhino title bar.",since:5},{signature:"Color TrackingColor",summary:"Gets or sets the tracking color.",since:5},{signature:"Color ViewportBackgroundColor",summary:"Gets or sets the viewport background color.",since:5},{signature:"Color WorldCoordIconXAxisColor",summary:"Gets or sets the color of the world X axis of the world coordinates icon,\n     appearing usually bottom left in viewports.",since:5},{signature:"Color WorldCoordIconYAxisColor",summary:"Gets or sets the color of the world Y axis of the world coordinate icon,\n     appearing usually bottom left in viewports.",since:5},{signature:"Color WorldCoordIconZAxisColor",summary:"Gets or sets the color of the world Z axis of the world coordinate icon,\n     appearing usually bottom left in viewports.",since:5}]},{name:"Rhino.ApplicationSettings.ClipboardState",dataType:3,summary:"Defines enumerated constant values for diferent behaviour that is related to clipboard data."},{name:"Rhino.ApplicationSettings.CommandAliasList",dataType:1,summary:"Contains static methods and properties to access command aliases.",properties:[{signature:"static int Count",summary:"Returns the number of command alias in Rhino.",since:5}],methods:[{signature:"static bool Add(string alias,string macro)",summary:"Adds a new command alias to Rhino.",since:5,returns:"True if successful."},{signature:"static void Clear()",summary:"Removes all aliases from the list.",since:5},{signature:"static bool Delete(string alias)",summary:"Deletes an existing command alias from Rhino.",since:5,returns:"True if successful."},{signature:"static System.Collections.Generic.Dictionary<string, string> GetDefaults()",summary:"Constructs a dictionary containing as keys the default names and as value the default macro.\n     The returned dicionary contains a copy of the settings.",since:5,returns:"A new dictionary with the default name/macro combinantions."},{signature:"static string GetMacro(string alias)",summary:"Returns the macro of a command alias.",since:5},{signature:"static string[] GetNames()",summary:"Returns a list of command alias names.",since:5,returns:"An array of strings. This can be empty."},{signature:"static bool IsAlias(string alias)",summary:"Verifies that a command alias exists in Rhino.",since:5,returns:"True if the alias exists."},{signature:"static bool IsDefault()",summary:"Computes a value indicating if the current alias list is the same as the default alias list.",since:5,returns:"True if the current alias list is exactly equal to the default alias list; False otherwise."},{signature:"static bool SetMacro(string alias,string macro)",summary:"Modifies the macro of a command alias.",since:5,returns:"True if successful."},{signature:"static System.Collections.Generic.Dictionary<string,string> ToDictionary()",summary:"Constructs a new dictionary that contains: as keys all names and as values all macros.\n     Modifications to this dictionary do not affect any Rhino command alias.",since:5,returns:"The new dictionary."}]},{name:"Rhino.ApplicationSettings.CommandPromptPosition",dataType:3,summary:"Defines enumerated constant values for default positions of the command prompt inside the frame of the full editor window."},{name:"Rhino.ApplicationSettings.CursorMode",dataType:3,summary:"Defines enumerated constant values for particular OSnap cursor colors."},{name:"Rhino.ApplicationSettings.CursorTooltipSettings",dataType:1,summary:"Cursor tooltips place information at the cursor location.\n   Note: Turning on cursor tooltips turns off object snap cursors.",properties:[{signature:"static bool AutoSuppress",summary:"Attempts to display only the most useful tooltip.",since:5},{signature:"static Color BackgroundColor",summary:"Tooltip background color.",since:5},{signature:"static bool CommandPromptPane",summary:"Displays the current command prompt.",since:5},{signature:"static bool DistancePane",summary:"Displays the distance from the last picked point.",since:5},{signature:"static Point Offset",summary:"The x and y distances in pixels from the cursor location to the tooltip.",since:5},{signature:"static bool OsnapPane",summary:"Displays the current object snap selection.",since:5},{signature:"static bool PointPane",summary:"Displays the current construction plane coordinates.",since:5},{signature:"static bool RelativePointPane",summary:"Displays the relative construction plane coordinates and angle from the last picked point.",since:5},{signature:"static Color TextColor",summary:"Tooltip text color.",since:5},{signature:"static bool TooltipsEnabled",summary:"Turns on/off cursor tooltips.",since:5}],methods:[{signature:"static CursorTooltipSettingsState GetCurrentState()",summary:"Gets the current settings.",since:5,returns:"A new cursor tooltip state with current settings."},{signature:"static CursorTooltipSettingsState GetDefaultState()",summary:"Gets the cursor tooltip factory settings.",since:5,returns:"A new cursor tooltip state with factory settings."}]},{name:"Rhino.ApplicationSettings.CursorTooltipSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"bool AutoSuppress",summary:"Attempts to display only the most useful tooltip.",since:5},{signature:"Color BackgroundColor",summary:"Tooltip background color.",since:5},{signature:"bool CommandPromptPane",summary:"Displays the current command prompt.",since:5},{signature:"bool DistancePane",summary:"Displays the distance from the last picked point.",since:5},{signature:"Point Offset",summary:"The x and y distances in pixels from the cursor location to the tooltip.",since:5},{signature:"bool OsnapPane",summary:"Displays the current object snap selection.",since:5},{signature:"bool PointPane",summary:"Displays the current construction plane coordinates.",since:5},{signature:"bool RelativePointPane",summary:"Displays the relative construction plane coordinates and angle from the last picked point.",since:5},{signature:"Color TextColor",summary:"Tooltip text color.",since:5},{signature:"bool TooltipsEnabled",summary:"Turns on/off cursor tooltips.",since:5}]},{name:"Rhino.ApplicationSettings.CurvatureAnalysisSettings",dataType:1,summary:"Contains static methods and properties to modify curvature analysis-related commands.",properties:[{signature:"static Interval GaussRange",summary:"Gets or sets the Gaussian curvature range.",since:6},{signature:"static Interval MaxRadiusRange",summary:"Gets or sets the Maximum Radius curvature range.",since:6},{signature:"static Interval MeanRange",summary:"Gets or sets the Mean curvature range.",since:6},{signature:"static Interval MinRadiusRange",summary:"Gets or sets the Minimum Radius curvature range.",since:6},{signature:"static CurvatureStyle Style",summary:"Gets or sets the curvature analysis style.",since:6}],methods:[{signature:"static bool CalculateCurvatureAutoRange(IEnumerable<Mesh> meshes,CurvatureAnalysisSettingsState settings)",since:6},{signature:"static CurvatureAnalysisSettingsState GetCurrentState()",summary:"Gets the current settings of the application.",since:6},{signature:"static CurvatureAnalysisSettingsState GetDefaultState()",summary:"Gets the factory settings of the application.",since:6},{signature:"static void RestoreDefaults()",summary:"Commits the default settings as the current settings.",since:6},{signature:"static void UpdateFromState(CurvatureAnalysisSettingsState state)",summary:"Sets all settings to a particular defined joined state.",since:6}]},{name:"Rhino.ApplicationSettings.CurvatureAnalysisSettings.CurvatureStyle",dataType:3,summary:"Curvature analysis styles"},{name:"Rhino.ApplicationSettings.CurvatureAnalysisSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"Interval GaussRange",summary:"Gets or sets the Gaussian curvature range.",since:6},{signature:"Interval MaxRadiusRange",summary:"Gets or sets the Maximum Radius curvature range.",since:6},{signature:"Interval MeanRange",summary:"Gets or sets the Mean curvature range.",since:6},{signature:"Interval MinRadiusRange",summary:"Gets or sets the Minimum Radius curvature range.",since:6},{signature:"CurvatureStyle Style",summary:"Gets or sets the curvature analysis style.",since:6}]},{name:"Rhino.ApplicationSettings.DraftAngleAnalysisSettings",dataType:1,summary:"",properties:[{signature:"static Interval AngleRange",summary:"The angle range.",since:7},{signature:"static bool ShowIsoCurves",summary:"Show isoparametric curves.",since:7},{signature:"static Vector3d UpDirection",summary:"The up direction.",since:7}],methods:[{signature:"static DraftAngleAnalysisSettingsState GetCurrentState()",summary:"Gets the current settings of the application.",since:7},{signature:"static DraftAngleAnalysisSettingsState GetDefaultState()",summary:"Gets the factory settings of the application.",since:7},{signature:"static void RestoreDefaults()",summary:"Commits the default settings as the current settings.",since:7},{signature:"static void UpdateFromState(DraftAngleAnalysisSettingsState state)",summary:"Sets all settings to a particular defined joined state.",since:7}]},{name:"Rhino.ApplicationSettings.DraftAngleAnalysisSettingsState",dataType:1,summary:"Represents a snapshot of",properties:[{signature:"Interval AngleRange",summary:"The angle range.",since:7},{signature:"bool ShowIsoCurves",summary:"Show isoparametric curves.",since:7},{signature:"Vector3d UpDirection",summary:"The up direction.",since:7}]},{name:"Rhino.ApplicationSettings.EdgeAnalysisSettings",dataType:1,summary:"Contains static methods and properties to modify the visibility of edges in edge-related commands.",properties:[{signature:"static Color ShowEdgeColor",summary:"Gets or sets a color used to enhance display\n    edges in commands like _ShowEdges and _ShowNakedEdges.",since:5},{signature:"static int ShowEdges",summary:"Gets or sets a value referring to the group of edges that are targeted.\n     0 = all.1 = naked.2 = non-manifold.",since:5}],methods:[{signature:"static EdgeAnalysisSettingsState GetCurrentState()",summary:"Gets the current settings of the application.",since:5},{signature:"static EdgeAnalysisSettingsState GetDefaultState()",summary:"Gets the factory settings of the application.",since:5},{signature:"static void RestoreDefaults()",summary:"Commits the default settings as the current settings.",since:5},{signature:"static void UpdateFromState(EdgeAnalysisSettingsState state)",summary:"Sets all settings to a particular defined joined state.",since:5}]},{name:"Rhino.ApplicationSettings.EdgeAnalysisSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"Color ShowEdgeColor",summary:"Gets or sets a color used to enhance display edges in commands like _ShowEdges and _ShowNakedEdges.",since:5},{signature:"int ShowEdges",summary:"Gets or sets a value referring to the group of edges that are targeted.\n     0 = all.1 = naked.2 = non-manifold.",since:5}]},{name:"Rhino.ApplicationSettings.FileSettings",dataType:1,summary:"Contains static methods and properties relating Rhino files.",properties:[{signature:"static bool AutoSaveEnabled",summary:"Enables or disables Rhino's automatic file saving mechanism.",since:5},{signature:"static string AutoSaveFile",summary:"the file name used by Rhino's automatic file saving mechanism.",since:5},{signature:"static TimeSpan AutoSaveInterval",summary:"how often the document will be saved when Rhino's automatic file saving mechanism is enabled.",since:5},{signature:"static bool AutoSaveMeshes",summary:"save render and display meshes in autosave file.",since:5},{signature:"static bool ClipboardCopyToPreviousRhinoVersion",summary:"Gets or sets a value that decides if copies to the clipboard are performed in both the current\n     and previous Rhino clipboard formats.  This means you will double the size of what is saved in\n     the clipboard but will be able to copy from the current to the previous version using the\n     clipboard.",since:5},{signature:"static ClipboardState ClipboardOnExit",summary:"Gets or sets a value that determines what to do with clipboad data on exit.",since:5},{signature:"static bool CreateBackupFiles",summary:"Gets or sets a value that controls the creation of backup files.",since:5},{signature:"static string DefaultRuiFile",summary:"Gets the path to the default RUI file.",since:5},{signature:"static string ExecutableFolder",summary:"Returns the directory where the main Rhino executable is located.",since:5},{signature:"static bool FileLockingEnabled",summary:"Ensure that only one person at a time can have a file open for saving.",since:5},{signature:"static bool FileLockingOpenWarning",summary:"Gets or sets whether to display the information dialog which identifies computer files.",since:5},{signature:"static string HelpFilePath",summary:"Gets the Rhino help file path.",since:5},{signature:"static DirectoryInfo InstallFolder",summary:"Returns Rhino's installation folder.",since:5},{signature:"static string LocalProfileDataFolder",summary:'Get full path to a Rhino specific sub-folder under the per-user Local\n     (non-roaming) Profile folder.  This is the folder where user-specific\n     data is stored.\n     \n     On Windows 7, 8, usually someplace like:\n       "C:\\Users\\[USERNAME]\\AppData\\Local\\McNeel\\Rhinoceros\\[VERSION_NUMBER]\\"',since:5.8},{signature:"static bool SaveViewChanges",summary:"True for users who consider view changes a document change.",since:5},{signature:"static int SearchPathCount",summary:"Gets the amount of search paths that are currently defined.",since:5},{signature:"static string TemplateFile",summary:"Returns or sets the location of Rhino's template file.",since:5},{signature:"static string TemplateFolder",summary:"Returns or sets the location of Rhino's template files.",since:5},{signature:"static string WorkingFolder",summary:"Returns or sets Rhino's working directory, or folder.\n     The working folder is the default folder for all file operations.",since:5}],methods:[{signature:"static int AddSearchPath(string folder,int index)",summary:'Adds a new imagePath to Rhino\'s search imagePath list.\n     See "Options Files settings" in the Rhino help file for more details.',since:5,returns:"The index where the item was inserted if success.\n     -1 on failure."},{signature:"static string[] AutoSaveBeforeCommands()",summary:"Input list of commands that force AutoSave prior to running.",since:5},{signature:"static bool DeleteSearchPath(string folder)",summary:'Removes an existing imagePath from Rhino\'s search imagePath list.\n     See "Options Files settings" in the Rhino help file for more details.',since:5,returns:"True or False indicating success or failure."},{signature:"static string FindFile(string fileName)",summary:"Searches for a file using Rhino's search imagePath. Rhino will look for a file in the following locations:\n     1. The current document's folder.\n     2. Folder's specified in Options dialog, File tab.\n     3. Rhino's System folders.",since:5,returns:"full imagePath on success; None on error."},{signature:"static FileSettingsState GetCurrentState()",summary:"Returns the current state.",since:5,returns:"A new instance containing the current state."},{signature:"static string GetDataFolder(bool currentUser)",summary:"Gets the data folder for machine or current user.",since:5,returns:"A directory to user or machine data."},{signature:"static FileSettingsState GetDefaultState()",summary:"Returns the default state.",since:5,returns:"A new instance containing the default state."},{signature:"static string[] GetSearchPaths()",summary:'Returns all of the imagePath items in Rhino\'s search imagePath list. See "Options Files settings" in the Rhino help file for more details.',since:5},{signature:"static string[] RecentlyOpenedFiles()",summary:"Returns a list of recently opened files. Note that this function does not\n     check to make sure that these files still exist.",since:5,returns:"An array of strings with the paths to the recently opened files."},{signature:"static void SetAutoSaveBeforeCommands(string[] commands)",summary:"Set list of commands that force AutoSave prior to running.",since:5}]},{name:"Rhino.ApplicationSettings.FileSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"bool AutoSaveEnabled",summary:"Enables or disables Rhino's automatic file saving mechanism.",since:5},{signature:"TimeSpan AutoSaveInterval",summary:"How often the document will be saved when Rhino's automatic file saving mechanism is enabled.",since:5},{signature:"bool AutoSaveMeshes",summary:"Saves render and display meshes in autosave file.",since:5},{signature:"bool ClipboardCopyToPreviousRhinoVersion",summary:"Gets or sets a value that decides if copies to the clipboard are performed in both the current\n     and previous Rhino clipboard formats.  This means you will double the size of what is saved in\n     the clipboard but will be able to copy from the current to the previous version using the\n     clipboard.",since:5},{signature:"ClipboardState ClipboardOnExit",summary:"Gets or sets a value that determines what to do with clipboad data on exit.",since:5},{signature:"bool CreateBackupFiles",summary:"Gets or sets a value indicating whether to create backup files.",since:5},{signature:"bool FileLockingEnabled",summary:"Ensures that only one person at a time can have a file open for saving.",since:5},{signature:"bool FileLockingOpenWarning",summary:"Displays an information dialog which identifies computer file is open on.",since:5},{signature:"bool SaveViewChanges",summary:"True for users who consider view changes a document change.",since:5}]},{name:"Rhino.ApplicationSettings.GeneralSettings",dataType:1,summary:"Contains static methods and properties to give access to Rhinoceros settings.",properties:[{signature:"static bool AutoUpdateCommandHelp",summary:"Command help dialog auto-update feature.",since:5},{signature:"static TimeSpan ContextMenuDelay",summary:"Time to wait before permitting context menu display.",since:5},{signature:"static bool EnableContextMenu",summary:"True if right mouse down + delay will pop up context menu on a mouse up if no move happens.",since:5},{signature:"static int MaximumPopupMenuLines",summary:"Gets or sets the maximum number of popup menu lines.",since:5},{signature:"static int MaximumUndoMemoryMb",summary:"Gets or sets the minimum undo memory Mb.\n     Undo records will be purged if there are more than MinimumUndoSteps and\n     they use more than MaximumUndoMemoryMb.",since:5},{signature:"static string MiddleMouseMacro",summary:"Gets or sets the toolbar to popup when the middle mouse is clicked on\n     a view, this value is only used when MiddleMouseMode is set to\n     PopupToolbar.",since:5},{signature:"static MiddleMouseMode MiddleMouseMode",summary:"Gets or sets what happens when the user clicks the middle mouse.",since:5},{signature:"static string MiddleMousePopupToolbar",summary:"Gets or sets the toolbar to popup when the middle mouse is clicked on\n     a view, this value is only used when MiddleMouseMode is set to\n     PopupToolbar.",since:5},{signature:"static int MinimumUndoSteps",summary:"Gets or sets the minimum undo steps.\n     Undo records will be purged if there are more than MinimumUndoSteps and\n     they use more than MaximumUndoMemoryMb.",since:5},{signature:"static MouseSelectMode MouseSelectMode",summary:"Gets or sets the current selection mode.",since:5},{signature:"static int NewObjectIsoparmCount",summary:"Gets or sets the number of isoparm curves to show on new objects.",since:5},{signature:"static bool UseExtrusions",summary:"Should extrusion objects be created for things like cylinders",since:6}],methods:[{signature:"static GeneralSettingsState GetCurrentState()",summary:"Gets the current settings.",since:5,returns:"A new general state with current settings."},{signature:"static GeneralSettingsState GetDefaultState()",summary:"Gets the factory settings.",since:5,returns:"A new general state with factory settings."}]},{name:"Rhino.ApplicationSettings.GeneralSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"bool AutoUpdateCommandHelp",summary:"Gets or sets the command help dialog auto-update feature.",since:5},{signature:"TimeSpan ContextMenuDelay",summary:"Gets or sets the time to wait before permitting context menu display.",since:5},{signature:"bool EnableContextMenu",summary:"True if right mouse down + delay will pop up context menu on a mouse up if no move happens.",since:5},{signature:"int MaximumPopupMenuLines",summary:"Gets or sets the maximum number of popup menu lines.",since:5},{signature:"int MaximumUndoMemoryMb",summary:"Gets or sets the minimum undo memory Mb.\n     Undo records will be purged if there are more than MinimumUndoSteps and\n     they use more than MaximumUndoMemoryMb.",since:5},{signature:"string MiddleMouseMacro",summary:"Gets or sets the toolbar to popup when the middle mouse is clicked on\n     a view, this value is only used when MiddleMouseMode is set to\n     PopupToolbar.",since:5},{signature:"MiddleMouseMode MiddleMouseMode",summary:"Gets or sets what happens when the user clicks the middle mouse.",since:5},{signature:"string MiddleMousePopupToolbar",summary:"Gets or sets the toolbar to popup when the middle mouse is clicked on\n     a view, this value is only used when MiddleMouseMode is set to\n     PopupToolbar.",since:5},{signature:"int MinimumUndoSteps",summary:"Gets or sets the minimum undo steps.\n     Undo records will be purged if there are more than MinimumUndoSteps and\n     they use more than MaximumUndoMemoryMb.",since:5},{signature:"MouseSelectMode MouseSelectMode",summary:"Gets or sets the current selection mode.",since:5},{signature:"int NewObjectIsoparmCount",summary:"Gets or sets the number of isoparm curves to show on new objects.",since:5}]},{name:"Rhino.ApplicationSettings.HistorySettings",dataType:1,summary:"Provides static (Shared in Vb.Net) properties to modify Rhino History settings.",properties:[{signature:"static bool BrokenRecordWarningEnabled",summary:"Displays a warning dialog when an action is taken that breaks the link between the output and input objects.",since:6.1},{signature:"static bool ObjectLockingEnabled",summary:"When history object locking is enabled, objects with history on them act as if\n     they were locked and the only way to modify these objects is to edit their inputs.",since:5},{signature:"static bool RecordingEnabled",summary:"When history recording is enabled, new objects keep a record of how they\n     were constructed so that they can be updated if an input object changes.",since:5},{signature:"static bool UpdateEnabled",summary:"When history update is enabled, dependant objects are automatically updated\n     when an antecedent is modified.",since:5}]},{name:"Rhino.ApplicationSettings.Installation",dataType:3,summary:"The type of Rhino executable that is executing"},{name:"Rhino.ApplicationSettings.LicenseNode",dataType:3,summary:"License node types."},{name:"Rhino.ApplicationSettings.MiddleMouseMode",dataType:3,summary:"Defines enumerated constant values to define what happens when\n   either the middle mouse button on a three-button mouse is clicked or after pressing the wheel on a wheeled mouse."},{name:"Rhino.ApplicationSettings.ModelAidSettings",dataType:1,summary:"Contains static methods and properties to modify model aid settings.",properties:[{signature:"static bool AltPlusArrow",summary:"True means Alt+arrow is used for nudging.",since:5},{signature:"static bool AutoGumballEnabled",summary:"When AutoGumball is on, a gumball automatically appears\n     when objects are prepicked.",since:5},{signature:"static int ControlPolygonDisplayDensity",summary:"Gets or sets the control polygon display density.",since:5},{signature:"static double CtrlNudgeKeyStep",summary:"Gets or sets the Ctrl-key based nudge step amount.",since:5},{signature:"static bool DisplayControlPolygon",summary:"Gets or sets the enabled state of Rhino's display control polygon.",since:5},{signature:"static bool ExtendToApparentIntersection",summary:"Gets or sets the enabled state of Rhino's extend to apparent intersections.",since:5},{signature:"static bool ExtendTrimLines",summary:"Gets or sets the enabled state of Rhino's extend trim lines.",since:5},{signature:"static bool GridSnap",summary:"Gets or sets the enabled state of Rhino's grid snap modeling aid.",since:5},{signature:"static bool HighlightControlPolygon",summary:"Gets or sets the enabled state of Rhino's highlight dialog modeling aid.",since:5},{signature:"static int MousePickboxRadius",summary:"radius of mouse pick box in pixels.",since:5},{signature:"static double NudgeKeyStep",summary:"Gets or sets the nudge step amount.",since:5},{signature:"static int NudgeMode",summary:"0 = world, 1 = cplane, 2 = view, 3 = uvn, -1 = not set.",since:5},{signature:"static bool Ortho",summary:"Gets or sets the enabled state of Rhino's ortho modeling aid.",since:5},{signature:"static double OrthoAngle",summary:"Gets or sets the base orthogonal angle.",since:5},{signature:"static bool Osnap",summary:"Enables or disables Rhino's object snap modeling aid.",since:5},{signature:"static CursorMode OsnapCursorMode",summary:"Gets or sets the OSnap cursor mode.",since:5},{signature:"static OsnapModes OsnapModes",summary:"Returns or sets Rhino's current object snap mode.\n    The mode is a bitwise value based on the OsnapModes enumeration.",since:5},{signature:"static int OsnapPickboxRadius",summary:"Enables or disables Rhino's planar modeling aid.",since:5},{signature:"static bool Planar",summary:"Gets or sets the enabled state of Rhino's Planar modeling aid.",since:5},{signature:"static PointDisplayMode PointDisplay",summary:"Gets or sets the point display mode.",since:5},{signature:"static bool ProjectSnapToCPlane",summary:"Gets or sets the enabled state of Rhino's Project modeling aid.",since:5},{signature:"static double ShiftNudgeKeyStep",summary:"Gets or sets the Shift-key based nudge step amount.",since:5},{signature:"static bool SnappyGumballEnabled",summary:"When SnappyGumball is on, a dragging a gumball moves the center point.\n     When snappy gumball is off, dragging a gumball moves the mouse down point.",since:5},{signature:"static bool SnapToLocked",summary:"Gets or sets the locked state of the snap modeling aid.",since:5},{signature:"static bool UniversalConstructionPlaneMode",summary:"Gets or sets the locked state of the snap modeling aid.",since:5},{signature:"static bool UseHorizontalDialog",summary:"Gets or sets the enabled state of Rhino's use horizontal dialog modeling aid.",since:5}],methods:[{signature:"static ModelAidSettingsState GetCurrentState()",summary:"Gets the current settings.",since:5,returns:"A new model aid state with current settings."},{signature:"static ModelAidSettingsState GetDefaultState()",summary:"Gets the factory settings.",since:5,returns:"A new model aid state with factory settings."},{signature:"static void UpdateFromState(ModelAidSettingsState state)",summary:"Updates from a particular setting state.",since:5}]},{name:"Rhino.ApplicationSettings.ModelAidSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"bool AltPlusArrow",summary:"True mean Alt+arrow is used for nudging.",since:5},{signature:"int ControlPolygonDisplayDensity",summary:"Gets or sets the control polygon display density.",since:5},{signature:"double CtrlNudgeKeyStep",summary:"Gets or sets the Ctrl-key based nudge step amount.",since:5},{signature:"bool DisplayControlPolygon",summary:"Gets or sets the enabled state of Rhino's display control polygon.",since:5},{signature:"bool ExtendToApparentIntersection",summary:"Gets or sets the enabled state of Rhino's extend to apparent intersections.",since:5},{signature:"bool ExtendTrimLines",summary:"Gets or sets the enabled state of Rhino's extend trim lines.",since:5},{signature:"bool GridSnap",summary:"Gets or sets the enabled state of Rhino's grid snap modeling aid.",since:5},{signature:"bool HighlightControlPolygon",summary:"Gets or sets the enabled state of Rhino's highlight dialog modeling aid.",since:5},{signature:"int MousePickboxRadius",summary:"Gets or sets the radius of the mouse pick box in pixels.",since:5},{signature:"double NudgeKeyStep",summary:"Gets or sets the nudge step amount.",since:5},{signature:"int NudgeMode",summary:"0 = world, 1 = cplane, 2 = view, 3 = uvn, -1 = not set.",since:5},{signature:"bool Ortho",summary:"Gets or sets the enabled state of Rhino's ortho modeling aid.",since:5},{signature:"double OrthoAngle",summary:"Gets or sets the base orthogonal angle.",since:5},{signature:"bool Osnap",summary:"Gets or sets the enabled state of Rhino's object snap modeling aid.",since:5},{signature:"CursorMode OsnapCursorMode",summary:"Gets or sets the OSnap cursor mode.",since:5},{signature:"OsnapModes OsnapModes",summary:"Returns or sets Rhino's current object snap mode.\n     The mode is a bitwise value based on the OsnapModes enumeration.",since:5},{signature:"int OsnapPickboxRadius",summary:"Enables or disables Rhino's planar modeling aid.",since:5},{signature:"bool Planar",summary:"Gets or sets the enabled state of Rhino's Planar modeling aid.",since:5},{signature:"PointDisplayMode PointDisplay",summary:"Gets or sets the point display mode.",since:5},{signature:"bool ProjectSnapToCPlane",summary:"Gets or sets the enabled state of Rhino's Project modeling aid.",since:5},{signature:"double ShiftNudgeKeyStep",summary:"Gets or sets the Shift-key based nudge step amount.",since:5},{signature:"bool SnapToLocked",summary:"Gets or sets the locked state of the snap modeling aid.",since:5},{signature:"bool UniversalConstructionPlaneMode",summary:"Gets or sets the locked state of the snap modeling aid.",since:5},{signature:"bool UseHorizontalDialog",summary:"Gets or sets the enabled state of Rhino's use horizontal dialog modeling aid.",since:5}]},{name:"Rhino.ApplicationSettings.MouseSelectMode",dataType:3,summary:"Defines enumerated constant values to indicate a particular window selection mode."},{name:"Rhino.ApplicationSettings.NeverRepeatList",dataType:1,summary:"Contains static methods and properties relating to the list of commands that are never repeated.",properties:[{signature:"static bool UseNeverRepeatList",summary:"Only use the list if somebody modifies it via CRhinoAppSettings::SetDontRepeatCommands().\n     Return value of True means CRhinoCommand don't repeat flags will be ignored and the m_dont_repeat_list\n     will be used instead.  False means the individual CRhinoCommands will determine if they are repeatable.",since:5}],methods:[{signature:"static string[] CommandNames()",summary:"The list of commands to not repeat.",since:5},{signature:"static int SetList(string[] commandNames)",summary:"Puts the command name tokens in m_dont_repeat_list.",since:5,returns:"Number of items added to m_dont_repeat_list."}]},{name:"Rhino.ApplicationSettings.OpenGLSettings",dataType:1,summary:"Static methods and properties to control OpenGL settings",properties:[{signature:"static AntialiasLevel AntialiasLevel",summary:"Gets or sets the antialias level used by OpenGL viewports",since:6.1}],methods:[{signature:"static OpenGLSettingsState GetCurrentState()",summary:"Gets the current settings.",since:6.1,returns:"A new OpenGL state with current settings."},{signature:"static OpenGLSettingsState GetDefaultState()",summary:"Gets the OpenGL factory settings.",since:6.1,returns:"A new OpenGL state with factory settings."},{signature:"static void RestoreDefaults()",summary:"Updates from the default setting state.",since:6.1},{signature:"static void UpdateFromState(OpenGLSettingsState state)",summary:"Updates from a particular setting state.",since:6.1}]},{name:"Rhino.ApplicationSettings.OpenGLSettingsState",dataType:1,summary:"Represents a sapshot of",properties:[{signature:"AntialiasLevel AntialiasLevel",summary:"AA level used in OpenGL viewports",since:6.1}]},{name:"Rhino.ApplicationSettings.OsnapModes",dataType:3,summary:"Defines several bit masks for each of the OSnap that are defined.\n   Refer to the Rhino Help file for further information."},{name:"Rhino.ApplicationSettings.PointDisplayMode",dataType:3,summary:"Defines enumerated constant values for world coordinates and CPlane point display modes."},{name:"Rhino.ApplicationSettings.SelectionFilterSettings",dataType:1,summary:"Selection filter settings restrict any selection mode (SelWindow, SelCrossing, SelAll, etc.) to specified object types.\n   Note, selection filter settings are not persistent.",properties:[{signature:"static bool Enabled",summary:"Enables or disables the global object selection filter.",since:7},{signature:"static ObjectType GlobalGeometryFilter",summary:"The global geometry type filter controls which types of geometry will be be filtered.\n     Note, the filter can be a bitwise combination of multiple object types.",since:7},{signature:"static ObjectType OneShotGeometryFilter",summary:"The one-shot geometry type filter controls which types of geometry will be be filtered for one selection.\n     Note, the filter can be a bitwise combination of multiple object types.",since:7},{signature:"static bool SubObjectSelect",summary:"Enables or disabled sub-object selection.",since:7}],methods:[{signature:"static SelectionFilterSettingsState GetCurrentState()",summary:"Gets the current settings of the application.",since:7},{signature:"static SelectionFilterSettingsState GetDefaultState()",summary:"Gets the factory settings of the application.",since:7},{signature:"static void RestoreDefaults()",summary:"Commits the default settings as the current settings.",since:7},{signature:"static void UpdateFromState(SelectionFilterSettingsState state)",summary:"Sets all settings to a particular defined joined state.",since:7}]},{name:"Rhino.ApplicationSettings.SelectionFilterSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"bool Enabled",summary:"Enables or disables the global object selection filter.",since:7},{signature:"ObjectType GlobalGeometryFilter",summary:"The global geometry type filter controls which types of geometry will be be filtered.\n     Note, the filter can be a bitwise combination of multiple object types.",since:7},{signature:"ObjectType OneShotGeometryFilter",summary:"The one-shot geometry type filter controls which types of geometry will be be filtered for one selection.\n     Note, the filter can be a bitwise combination of multiple object types.",since:7},{signature:"bool SubObjectSelect",summary:"Enables or disabled sub-object selection.",since:7}]},{name:"Rhino.ApplicationSettings.ShortcutKey",dataType:3,summary:"Shortcut key combinations"},{name:"Rhino.ApplicationSettings.ShortcutKeySettings",dataType:1,summary:"Contains static methods and properties to control keyboard shortcut keys",methods:[{signature:"static string GetMacro(ShortcutKey key)",summary:"Get macro associated with a given keyboard shortcut",since:5},{signature:"static void SetMacro(ShortcutKey key,string macro)",summary:"Set macro associated with a keyboard shortcut",since:5}]},{name:"Rhino.ApplicationSettings.SmartTrackSettings",dataType:1,summary:"Contains static methods and properties that target the Smart Track feature behavior.",properties:[{signature:"static int ActivationDelayMilliseconds",summary:"Gets or sets the activation delay in milliseconds.",since:5},{signature:"static Color ActivePointColor",summary:"Gets or sets the active point color.",since:5},{signature:"static Color LineColor",summary:"Gets or sets the smart track line color.",since:5},{signature:"static int MaxSmartPoints",summary:"Gets or sets the maximum number of smart points.",since:5},{signature:"static Color PointColor",summary:"Gets or sets the point color.",since:5},{signature:"static bool SmartOrtho",summary:"Gets or sets a value indicating if the 'Smart Ortho' feature is active.\n     Orthogonal lines are then drawn automatically.",since:5},{signature:"static bool SmartTangents",summary:"Gets or sets a value indicating if the 'Smart Tangents' feature is active.",since:5},{signature:"static Color TanPerpLineColor",summary:"Gets or sets the tangent and perpendicular line color.",since:5},{signature:"static bool UseDottedLines",summary:"Gets or sets a value indicating if lines are drawn dotted.",since:5},{signature:"static bool UseSmartTrack",summary:"Gets or sets if the Smart Track feature is active.",since:5}],methods:[{signature:"static SmartTrackSettingsState GetCurrentState()",summary:"Gets the current settings.",since:5,returns:"A new Smart Track state with current settings."},{signature:"static SmartTrackSettingsState GetDefaultState()",summary:"Gets the Smart Track factory settings.",since:5,returns:"A new Smart Track state with factory settings."},{signature:"static void UpdateFromState(SmartTrackSettingsState state)",summary:"Updates from a particular setting state.",since:5}]},{name:"Rhino.ApplicationSettings.SmartTrackSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"static int MaxSmartPoints",summary:"Gets or sets the maximum number of smart points.",since:5},{signature:"int ActivationDelayMilliseconds",summary:"Gets or sets the activation delay in milliseconds.",since:5},{signature:"Color ActivePointColor",summary:"Gets or sets the active point color.",since:5},{signature:"Color LineColor",summary:"Gets or sets the smart track line color.",since:5},{signature:"Color PointColor",summary:"Gets or sets the point color.",since:5},{signature:"bool SmartOrtho",summary:"Gets or sets a value indicating if the 'Smart Ortho' feature is active.",since:5},{signature:"bool SmartTangents",summary:"Gets or sets a value indicating if the 'Smart Tangents' feature is active.",since:5},{signature:"Color TanPerpLineColor",summary:"Gets or sets the tangent and perpendicular line color.",since:5},{signature:"bool UseDottedLines",summary:"Gets or sets a value indicating if lines are drawn dotted.",since:5},{signature:"bool UseSmartTrack",summary:"Gets or sets if the 'smart track' feature is active.",since:5}]},{name:"Rhino.ApplicationSettings.ViewSettings",dataType:1,summary:"Contains static methods and properties to control view settings.",properties:[{signature:"static bool AlwaysPanParallelViews",summary:"Gets or sets the 'always pan parallel views' value.\n     If the view is not looking straight at the construction plane, then\n     sets parallel viewports so they will not rotate.",since:5},{signature:"static bool DefinedViewSetCPlane",summary:"Gets or sets the 'named views set CPlane' value.\n     When true, restoring a named view causes the construction plane saved with that view to also restore.",since:5},{signature:"static bool DefinedViewSetProjection",summary:"Gets or sets the 'named views set projection' value.\n     When true, restoring a named view causes the viewport projection saved with the view to also restore.",since:5},{signature:"static bool LinkedViewports",summary:"Gets or sets the 'linked views' activated setting.\n     True enables real-time view synchronization.\n     When a standard view is manipulated, the camera lens length of all parallel projection\n     viewports are set to match the current viewport.",since:5},{signature:"static bool PanReverseKeyboardAction",summary:"Gets or sets if panning with the keyboard is reversed.\n     false, then Rhino pans the camera in the direction of the arrow key you press.\n     true, then Rhino pans the scene instead.",since:5},{signature:"static double PanScreenFraction",summary:"Gets or sets the faction used as multiplier to pan the screen.",since:5},{signature:"static int RotateCircleIncrement",summary:"Gets or sets the rotation increment.\n     When the user rotates a view with the keyboard, Rhino rotates the view in steps.\n     The usual step is 1/60th of a circle, which equals six degrees.",since:5},{signature:"static bool RotateReverseKeyboard",summary:"Gets or sets the rotation direction.\n     If true, then Rhino rotates the camera around the scene, otherwise, rotates the scene itself.",since:5},{signature:"static bool RotateToView",summary:"Gets or sets the rotation reference.\n     If true, then the views rotates relative to the view axes; false, than relative to the world x, y, and z axes.",since:5},{signature:"static bool SingleClickMaximize",summary:"Gets or sets the 'single-click maximize' value.\n     When true, maximizing a viewport needs a single click on the viewport title rather than a double-click.",since:5},{signature:"static double ZoomExtentsParallelViewBorder",summary:"Border amount to apply to parallel viewport during zoom extents",since:6.3},{signature:"static double ZoomExtentsPerspectiveViewBorder",summary:"Border amount to apply to perspective viewport during zoom extents",since:6.3},{signature:"static double ZoomScale",summary:"Gets or sets the step size for zooming with a wheeled mouse or the Page Up and Page Down keys.",since:5}],methods:[{signature:"static ViewSettingsState GetCurrentState()",summary:"Gets the current settings.",since:5,returns:"A new view state with current settings."},{signature:"static ViewSettingsState GetDefaultState()",summary:"Gets the view factory settings.",since:5,returns:"A new view state with factory settings."},{signature:"static void RestoreDefaults()",summary:"Updates from the default setting state.",since:5},{signature:"static void UpdateFromState(ViewSettingsState state)",summary:"Updates from a particular setting state.",since:5}]},{name:"Rhino.ApplicationSettings.ViewSettingsState",dataType:1,summary:"Represents a snapshot of .",properties:[{signature:"bool AlwaysPanParallelViews",summary:"Gets or sets the 'always pan parallel views' value.\n     If the view is not looking straight at the construction plane, then\n     sets parallel viewports so they will not rotate.",since:5},{signature:"bool DefinedViewSetCPlane",summary:"Gets or sets the 'named views set CPlane' value.\n     When true, restoring a named view causes the construction plane saved with that view to also restore.",since:5},{signature:"bool DefinedViewSetProjection",summary:"Gets or sets the 'named views set projection' value.\n     When true, restoring a named view causes the viewport projection saved with the view to also restore.",since:5},{signature:"bool LinkedViewports",summary:"Gets or sets the 'linked views' activated setting.\n     True enables real-time view synchronization.\n     When a standard view is manipulated, the camera lens length of all parallel projection\n     viewports are set to match the current viewport.",since:5},{signature:"bool PanReverseKeyboardAction",summary:"Gets or sets if panning with the keyboard is reversed.\n     false, then Rhino pans the camera in the direction of the arrow key you press.\n     true, then Rhino pans the scene instead.",since:5},{signature:"double PanScreenFraction",summary:"Gets or sets the faction used as multiplier to pan the screen.",since:5},{signature:"int RotateCircleIncrement",summary:"Gets or sets the rotation increment.\n     When the user rotates a view with the keyboard, Rhino rotates the view in steps.\n     The usual step is 1/60th of a circle, which equals six degrees.",since:5},{signature:"bool RotateReverseKeyboard",summary:"Gets or sets the rotation direction.\n     If true, then Rhino rotates the camera around the scene, otherwise, rotates the scene itself.",since:5},{signature:"bool RotateToView",summary:"Gets or sets the rotation reference.\n     If true, then the views rotates relative to the view axes; false, than relative to the world x, y, and z axes.",since:5},{signature:"bool SingleClickMaximize",summary:"Gets or sets the 'single-click maximize' value.\n     When true, maximizing a viewport needs a single click on the viewport title rather than a double-click.",since:5},{signature:"double ZoomExtentsParallelViewBorder",summary:"Border amount to apply to parallel viewport during zoom extents",since:6.3},{signature:"double ZoomExtentsPerspectiveViewBorder",summary:"Border amount to apply to perspective viewport during zoom extents",since:6.3},{signature:"double ZoomScale",summary:"Gets or sets the step size for zooming with a wheeled mouse or the Page Up and Page Down keys.",since:5}]},{name:"Rhino.Collections.ArchivableDictionary",dataType:1,summary:"Represents a dictionary class that can be attached to objects and\n   can be serialized (saved) at necessity.See remarks for layout.",constructors:[{signature:"ArchivableDictionary()",summary:"Initializes an instance of a dictionary for writing to a 3dm archive.",since:5},{signature:"ArchivableDictionary(int version)",summary:"Initializes an instance of a dictionary for writing to a 3dm archive.",since:5},{signature:"ArchivableDictionary(int version,string name)",summary:"Initializes an instance of a dictionary for writing to a 3dm archive.",since:5},{signature:"ArchivableDictionary(UserData parentUserData)",summary:"Initializes an instance of a dictionary for writing to a 3dm archive",since:5}],properties:[{signature:"int Count",summary:"Gets the number of key/value pairs contained in the dictionary.",since:5},{signature:"string[] Keys",summary:"Gets all entry names or keys.",since:5},{signature:"string Name",summary:"Gets or sets the name string of this .",since:5},{signature:"UserData ParentUserData",summary:"If this dictionary is part of userdata (or is a UserDictionary), then\n     this is the parent user data. None if this dictionary is not part of\n     userdata",since:5},{signature:"object[] Values",summary:"Gets all values in this dictionary.",since:5},{signature:"int Version",summary:"Gets or sets the version of this .",since:5}],methods:[{signature:"bool AddContentsFrom(ArchivableDictionary source)",summary:"Add the contents from the source dictionary.",since:5.4},{signature:"void Clear()",summary:"Removes all keys and values from the dictionary.",since:5},{signature:"ArchivableDictionary Clone()",summary:"Constructs a deep copy of this object.",since:5,returns:"The copy of this object."},{signature:"bool ContainsKey(string key)",summary:"Determines whether the dictionary contains the specified key.",since:5,returns:"True if the dictionary contains an element with the specified key; otherwise, false."},{signature:"bool GetBool(string key)",summary:"Get value as bool, will only succeed if value was created using Set(string key, bool value)",since:5},{signature:"bool GetBool(string key,bool defaultValue)",summary:"Get value as bool, will return defaultValue unless value was created using Set(string key, bool value)",since:5},{signature:"byte[] GetBytes(string key)",summary:"Get value as byte[], will only succeed if value was created\n     using Set(string key, byte[] value)",since:5.9},{signature:"byte[] GetBytes(string key,byte[] defaultValue)",summary:"Get value as byte[], will return defaultValue unless\n     value was created using Set(string key, byte[] value)",since:5.9},{signature:"ArchivableDictionary GetDictionary(string key)",summary:"Get value as ArchivableDictionary, will only succeed if value was created\n     using Set(string key, ArchivableDictionary value)",since:5.9},{signature:"ArchivableDictionary GetDictionary(string key,ArchivableDictionary defaultValue)",summary:"Get value as ArchivableDictionary, will return defaultValue unless\n     value was created using Set(string key, ArchivableDictionary value)",since:5.9},{signature:"double GetDouble(string key)",summary:"Get value as double, will only succeed if value was created using Set(string key, double value)",since:5},{signature:"double GetDouble(string key,double defaultValue)",summary:"Get value as double, will only succeed if value was created using Set(string key, double value)",since:5.1},{signature:"IEnumerator<KeyValuePair<string, object>> GetEnumerator()",summary:"Gets the enumerator of this dictionary.",since:5,returns:"A , where T is an instance of , with T0 set as string, and T1 as Syste.Object."},{signature:"T GetEnumValue()",summary:"Get an enum value",since:5.4},{signature:"T GetEnumValue(string key)",summary:"Get an enum value from the dictionary using a custom key.",since:5.4},{signature:"float GetFloat(string key)",summary:"Get value as float, will only succeed if value was created using Set(string key, float value)",since:5},{signature:"float GetFloat(string key,float defaultValue)",summary:"Get value as float, will return defaultValue unless value was created using Set(string key, float value)",since:5},{signature:"Guid GetGuid(string key)",summary:"Get value as Guid, will only succeed if value was created using Set(string key, Guid value)",since:5},{signature:"Guid GetGuid(string key,Guid defaultValue)",summary:"Get value as Guid, will return defaultValue unless value was created using Set(string key, Guid value)",since:5},{signature:"int Getint(string key,int defaultValue)",summary:"Get value as int, will return defaultValue unless value was created using Set(string key, int value)",since:5},{signature:"int GetInteger(string key)",summary:"Get value as int, will only succeed if value was created using Set(string key, int value)",since:5},{signature:"int GetInteger(string key,int defaultValue)",summary:"Get value as int, will return defaultValue unless value was created using Set(string key, int value)",since:5},{signature:"void GetObjectData(SerializationInfo info,StreamingContext context)",summary:"Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.",since:7},{signature:"Geometry.Plane GetPlane(string key)",summary:"Get value as Plane, will return defaultValue unless value was created using Set(string key, Plane value)",since:6.11,returns:"The value as Plane."},{signature:"Geometry.Plane GetPlane(string key,Plane defaultValue)",summary:"Get value as Plane, will return defaultValue unless value was created using Set(string key, Plane value)",since:6.11,returns:"The value as Plane."},{signature:"Geometry.Point3d GetPoint3d(string key)",summary:"Get value as Point3d, will only succeed if value was created using Set(string key, Point3d value)",since:5},{signature:"Geometry.Point3d GetPoint3d(string key,Point3d defaultValue)",summary:"Get value as Point3d, will return defaultValue unless value was created using Set(string key, Point3d value)",since:5},{signature:"Geometry.Point3f GetPoint3f(string key)",summary:"Get value as Point3f, will only succeed if value was created using Set(string key, Point3f value)",since:5},{signature:"Geometry.Point3f GetPoint3f(string key,Point3f defaultValue)",summary:"Get value as Point3f, will return defaultValue unless value was created using Set(string key, Point3f value)",since:5},{signature:"string GetString(string key)",summary:"Get value as string, will only succeed if value was created using Set(string key, string value)",since:5,returns:"The string"},{signature:"string GetString(string key,string defaultValue)",summary:"Get value as string, will return defaultValue unless value was created using Set(string key, string value)",since:5},{signature:"Geometry.Vector3d GetVector3d(string key)",summary:"Get value as Vector3d, will only succeed if value was created using Set(string key, Vector3d value)",since:5},{signature:"Geometry.Vector3d GetVector3d(string key,Vector3d defaultValue)",summary:"Get value as Vector3d, will return defaultValue unless value was created using Set(string key, Vector3d value)",since:5},{signature:"bool Remove(string key)",summary:"Removes the value with the specified key from the dictionary.",since:5,returns:"True if the element is successfully found and removed; otherwise, false.\n     This method returns False if key is not found."},{signature:"bool RemoveEnumValue()",summary:"Remmove an enum value from the dictionary.",since:5.4},{signature:"bool ReplaceContentsWith(ArchivableDictionary source)",summary:"Replace the contents of the dictionary with that of the given source dictionary.",since:5.4},{signature:"bool Set(string key,ArchivableDictionary val)",summary:"Sets another  as entry in this dictionary.",since:5},{signature:"bool Set(string key,bool val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,BoundingBox val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,byte val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Color val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,double val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,float val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Font val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,GeometryBase val)",summary:"Sets any class deriving from the  base class.",since:5},{signature:"bool Set(string key,Guid val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<bool> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<byte> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<double> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<float> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<GeometryBase> val)",since:7},{signature:"bool Set(string key,IEnumerable<Guid> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<int> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<ObjRef> val)",summary:"Sets an array of",since:5.8},{signature:"bool Set(string key,IEnumerable<sbyte> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<short> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,IEnumerable<string> val)",summary:"Sets a list, an array or any enumerable of .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,int val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Int64 val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Interval val)",summary:"Sets an .",since:5},{signature:"bool Set(string key,Line val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,MeshingParameters val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,ObjRef val)",summary:"Sets a",since:5.8},{signature:"bool Set(string key,Plane val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Point val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Point2d val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Point3d val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Point3f val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Point4d val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,PointF val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Ray3d val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Rectangle val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,RectangleF val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,sbyte val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,short val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Size val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,SizeF val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,string val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Transform val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,uint val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,ushort val)",summary:"Sets a .",since:5,returns:"True if set operation succeeded, otherwise false."},{signature:"bool Set(string key,Vector2d val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Vector3d val)",summary:"Sets a .",since:5},{signature:"bool Set(string key,Vector3f val)",summary:"Sets a .",since:5},{signature:"bool SetEnumValue(string key,T enumValue)",summary:"Set an enum value in the dictionary with a custom key.",since:5.4},{signature:"bool SetEnumValue(T enumValue)",summary:"Set an enum value",since:5.4},{signature:"bool TryGetBool(string key,bool value)",summary:"Get value as bool, will only succeed if value was created using Set(string key, bool value)",since:5},{signature:"bool TryGetBytes(string key,byte[] value)",summary:"Get value as byte[], will only succeed if value was\n     created using Set(string key, byte[] value)",since:5.9},{signature:"bool TryGetDictionary(string key,ArchivableDictionary value)",summary:"Get value as ArchivableDictionary, will only succeed if value was\n     created using Set(string key, ArchivableDictionary value)",since:5.9},{signature:"bool TryGetDouble(string key,double value)",summary:"Get value as double, will only succeed if value was created using Set(string key, double value)",since:5},{signature:"bool TryGetEnumValue(string key,T enumValue)",summary:"Attempt to get an enum value from the dictionary using a custom key.",since:5.4},{signature:"bool TryGetFloat(string key,float value)",summary:"Get value as float, will only succeed if value was created using Set(string key, float value)",since:5},{signature:"bool TryGetGuid(string key,Guid value)",summary:"Get value as Guid, will only succeed if value was created using Set(string key, Guid value)",since:5},{signature:"bool TryGetInteger(string key,int value)",summary:"Get value as int, will only succeed if value was created using Set(string key, int value)",since:5},{signature:"bool TryGetPlane(string key,Plane value)",summary:"Get value as Plane, will only succeed if value was created using Set(string key, Plane value)",since:6.11,returns:"The value as Plane."},{signature:"bool TryGetPoint3d(string key,Point3d value)",summary:"Get value as Point3d, will only succeed if value was created using Set(string key, Point3d value)",since:5},{signature:"bool TryGetPoint3f(string key,Point3f value)",summary:"Get value as Point3f, will only succeed if value was created using Set(string key, Point3f value)",since:5},{signature:"bool TryGetString(string key,string value)",summary:"Get value as string, will only succeed if value was created using Set(string key, string value)",since:5},{signature:"bool TryGetValue(string key,object value)",summary:"Gets the value associated with the specified key.",since:5,returns:"True if the dictionary contains an element with the specified key; otherwise, false."},{signature:"bool TryGetVector3d(string key,Vector3d value)",summary:"Get value as Vector3d, will only succeed if value was created using Set(string key, Vector3d value)",since:5}]},{name:"Rhino.Collections.CurveList",dataType:1,summary:"Represents a list of curves.",constructors:[{signature:"CurveList()",summary:"Initializes a new empty list of curves.",since:5},{signature:"CurveList(IEnumerable<Curve> collection)",summary:"Initializes a new list that is filled with all items of the input enumerable.\n     Input items are not explicitly duplicated (this is a shallow copy).",since:5},{signature:"CurveList(int initialCapacity)",summary:"Initializes a new empty list of curves with a predefined capacity.\n     This is the amount of items the list will accept before resizing.",since:5}],methods:[{signature:"void Add(Arc arc)",summary:"Adds an arc to this list.",since:5},{signature:"void Add(Circle circle)",summary:"Adds a circle to this list.",since:5},{signature:"void Add(Ellipse ellipse)",summary:"Adds an ellipse to this list.",since:5},{signature:"void Add(IEnumerable<Point3d> polyline)",summary:"Adds a polyline to this list.",since:5},{signature:"void Add(Line line)",summary:"Adds a line to this list.",since:5},{signature:"void Insert(int index,Arc arc)",summary:"Inserts an arc at a given index of this list.",since:5},{signature:"void Insert(int index,Circle circle)",summary:"Inserts a line at a given index of this list.",since:5},{signature:"void Insert(int index,Ellipse ellipse)",summary:"Inserts an ellipse at a given index of this list.",since:5},{signature:"void Insert(int index,IEnumerable<Point3d> polyline)",summary:"Inserts a polyline at a given index of this list.",since:5},{signature:"void Insert(int index,Line line)",summary:"Inserts a line at a given index of this list.",since:5},{signature:"bool Transform(Transform xform)",summary:"Transform all the curves in this list. If at least a single transform failed \n     this function returns false.",since:5}]},{name:"Rhino.Collections.IResizableList",dataType:4,summary:"Provides the ability to resize a generic list by setting the Count property."},{name:"Rhino.Collections.Point3dList",dataType:1,summary:"Represents a list of .",constructors:[{signature:"Point3dList()",summary:"Initializes a new empty list with default capacity.",since:5},{signature:"Point3dList(IEnumerable<Point3d> collection)",summary:"Initializes a new point list by copying the values from another set.",since:5},{signature:"Point3dList(int initialCapacity)",summary:"Initializes a new point list with a preallocated initial capacity.",since:5},{signature:"Point3dList(Point3d[] initialPoints)",summary:"Constructs a new point list from values in a point array.",since:5}],properties:[{signature:"BoundingBox BoundingBox",summary:'Even though this is a property, it is not a "fast" calculation. Every point is\n     evaluated in order to get the bounding box of the list.',since:5},{signature:"XAccess X",summary:"Returns an indexer with all X coordinates in this list.",since:5},{signature:"YAccess Y",summary:"Returns an indexer with all Y coordinates in this list.",since:5},{signature:"ZAccess Z",summary:"Returns an indexer with all Z coordinates in this list.",since:5}],methods:[{signature:"static int ClosestIndexInList(IList<Point3d> list,Point3d testPoint)",summary:"Finds the index of the point in a list of points that is closest to a test point.",since:5,returns:"Index of closest point in the list on success or -1 on error."},{signature:"static Point3d ClosestPointInList(IList<Point3d> list,Point3d testPoint)",summary:"Finds the point in a list of points that is closest to a test point.",since:5,returns:"A point."},{signature:"void Add(double x,double y,double z)",summary:"Adds a Point3d to the end of the list with given x,y,z coordinates.",since:5},{signature:"int ClosestIndex(Point3d testPoint)",summary:"Finds the index of the point that is closest to a test point in this list.",since:5,returns:"index of closest point in the list on success. -1 on error."},{signature:"Point3dList Duplicate()",summary:"Returns a deep copy of this point list instance.",since:6,returns:"The duplicated list."},{signature:"void SetAllX(double xValue)",summary:"Set all the X values for the points to a single value",since:5.6},{signature:"void SetAllY(double yValue)",summary:"Set all the Y values for the points to a single value",since:5.6},{signature:"void SetAllZ(double zValue)",summary:"Set all the Z values for the points to a single value",since:5.6},{signature:"void Transform(Transform xform)",summary:"Applies a transform to all the points in the list.",since:5}]},{name:"Rhino.Collections.Point3dList.XAccess",dataType:1,summary:"Utility class for easy-access of x-components of points inside an ON_3dPointList."},{name:"Rhino.Collections.Point3dList.YAccess",dataType:1,summary:"Utility class for easy-access of x-components of points inside an ON_3dPointList."},{name:"Rhino.Collections.Point3dList.ZAccess",dataType:1,summary:"Utility class for easy-access of z-components of points inside an ON_3dPointList."},{name:"Rhino.Collections.RhinoList",dataType:1,summary:"Provides helper methods to work with  and other collections.",constructors:[{signature:"RhinoList()",summary:"Initializes a new, empty list."},{signature:"RhinoList(IEnumerable<T> collection)",summary:"Initializes this list as a shallow duplicate of another list, array or any other enumerable set of T."},{signature:"RhinoList(int initialCapacity)",summary:"Initializes an empty list with a certain capacity."},{signature:"RhinoList(int amount,T defaultValue)",summary:"Initializes a new list with a specified amount of values."},{signature:"RhinoList(RhinoList<T> list)",summary:"Initializes an new list by shallow duplicating another list."}],properties:[{signature:"int Capacity",summary:"Gets or sets the total number of elements the internal data structure can hold without resizing."},{signature:"int Count",summary:"Gets the number of elements actually contained in the List."},{signature:"T First",summary:"Gets or sets the first item in the list. This is synonymous to calling List[0]."},{signature:"T Last",summary:"Gets or sets the last item in the list. This is synonymous to calling List[Count-1]."},{signature:"int NullCount",summary:"Gets the number of None references (Nothing in Visual Basic) in this list. \n     If T is a ValueType, this property always return zero."}],methods:[{signature:"static IEnumerable<int[]> Point2dKNeighbors(IEnumerable<Point2d> hayPoints,IEnumerable<Point2d> needlePoints,int amount)",summary:'Finds a certain amout of points in a list of single-precision 2D points that are the k-closest to a test point.\n     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".',since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> Point2fKNeighbors(IEnumerable<Point2f> hayPoints,IEnumerable<Point2f> needlePoints,int amount)",summary:'Finds a certain amout of points in a list of single-precision 2D points that are the k-closest to a test point.\n     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".',since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> Point3dKNeighbors(IEnumerable<Point3d> hayPoints,IEnumerable<Point3d> needlePoints,int amount)",summary:'Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.\n     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".\n     See RTree KNeighbors for alternatives.',since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> Point3fKNeighbors(IEnumerable<Point3f> hayPoints,IEnumerable<Point3f> needlePoints,int amount)",summary:'Finds a certain amout of points in a list of single-precision 3D points that are the k-closest to a test point.\n     This method searches needlePoints by computing all distances from each pointcloud point and keeping a "short list".',since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> PointCloudKNeighbors(PointCloud pointcloud,IEnumerable<Point3d> needlePoints,int amount)",summary:"Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.\n     This method searches needlePoints by computing all distances from each pointcloud point and keeping a short list.",since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"void Add(T item)",summary:"Adds an object to the end of the List."},{signature:"void AddRange(IEnumerable collection)",summary:"Adds the elements of the specified collection to the end of the List."},{signature:"void AddRange(IEnumerable<T> collection)",summary:"Adds the elements of the specified collection to the end of the List."},{signature:"ReadOnlyCollection<T> AsReadOnly()",summary:"Constructs a read-only wrapper of this class.",returns:"A wrapper."},{signature:"int BinarySearch(int index,int count,T item,IComparer<T> comparer)",summary:"Searches the entire sorted List for an element using the specified \n     comparer and returns the zero-based index of the element.",returns:"The zero-based index of item in the sorted List, if item is found; \n     otherwise, a negative number that is the bitwise complement of the index \n     of the next element that is larger than item or, if there is no larger element, \n     the bitwise complement of Count."},{signature:"int BinarySearch(T item)",summary:"Searches the entire sorted List for an element using the default comparer \n     and returns the zero-based index of the element.",returns:"The zero-based index of item in the sorted List, if item is found; \n     otherwise, a negative number that is the bitwise complement of the index \n     of the next element that is larger than item or, if there is no larger element, \n     the bitwise complement of Count."},{signature:"int BinarySearch(T item,IComparer<T> comparer)",summary:"Searches the entire sorted List for an element using the specified \n     comparer and returns the zero-based index of the element.",returns:"The zero-based index of item in the sorted List, if item is found; \n     otherwise, a negative number that is the bitwise complement of the index \n     of the next element that is larger than item or, if there is no larger element, \n     the bitwise complement of Count."},{signature:"void Clear()",summary:"Removes all elements from the List."},{signature:"bool Contains(T item)",summary:"Determines whether an element is in the List.",returns:"True if item is found in the List; otherwise, false."},{signature:"RhinoList<TOutput> ConvertAll(Converter<T, TOutput> converter)",summary:"Aggregates all results of a conversion function over this table into a new list.",returns:"The new list."},{signature:"void CopyTo(int index,T[] array,int arrayIndex,int count)",summary:"Copies a range of elements from the List to a compatible one-dimensional array, \n     starting at the specified index of the target array."},{signature:"void CopyTo(T[] array)",summary:"Copies the entire List to a compatible one-dimensional array, \n     starting at the beginning of the target array."},{signature:"void CopyTo(T[] array,int arrayIndex)",summary:"Copies the entire List to a compatible one-dimensional array, \n     starting at the specified index of the target array."},{signature:"RhinoList<T> Duplicate()",summary:"Returns a shallow copy of this instance.\n     If the generic type is comprised of only value types (struct, enum, ptr), then the result will be a deep copy.",returns:"The duplicated list."},{signature:"bool Exists(Predicate<T> match)",summary:"Determines whether the List contains elements that match the \n     conditions defined by the specified predicate.",returns:"True if the List contains one or more elements that match the \n     conditions defined by the specified predicate; otherwise, false."},{signature:"T Find(Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the first occurrence within the entire List.",returns:"The first element that matches the conditions defined by the specified predicate, \n     if found; otherwise, the default value for type T."},{signature:"RhinoList<T> FindAll(Predicate<T> match)",summary:"Retrieves all the elements that match the conditions defined by the specified predicate.",returns:"A ON_List(T) containing all the elements that match the conditions \n     defined by the specified predicate, if found; otherwise, an empty ON_List(T)."},{signature:"int FindIndex(int startIndex,int count,Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the specified predicate, \n     and returns the zero-based index of the first occurrence within the range of elements \n     in the List that extends from the specified index to the last element.",returns:"The zero-based index of the first occurrence of an element that \n     matches the conditions defined by match, if found; otherwise, -1."},{signature:"int FindIndex(int startIndex,Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the zero-based index of the first \n     occurrence within the entire List.",returns:"The zero-based index of the first occurrence of an element that \n     matches the conditions defined by match, if found; otherwise, -1."},{signature:"int FindIndex(Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the zero-based index of the first \n     occurrence within the entire List.",returns:"The zero-based index of the first occurrence of an element that \n     matches the conditions defined by match, if found; otherwise, -1."},{signature:"T FindLast(Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the last occurrence within the entire List.",returns:"The last element that matches the conditions defined by the specified predicate, \n     if found; otherwise, the default value for type T."},{signature:"int FindLastIndex(int startIndex,int count,Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the zero-based index of the last \n     occurrence within the entire List.",returns:"The zero-based index of the last occurrence of an element that matches \n     the conditions defined by match, if found; otherwise, -1."},{signature:"int FindLastIndex(int startIndex,Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the zero-based index of the last \n     occurrence within the entire List.",returns:"The zero-based index of the last occurrence of an element that matches \n     the conditions defined by match, if found; otherwise, -1."},{signature:"int FindLastIndex(Predicate<T> match)",summary:"Searches for an element that matches the conditions defined by the \n     specified predicate, and returns the zero-based index of the last \n     occurrence within the entire List.",returns:"The zero-based index of the last occurrence of an element that matches \n     the conditions defined by match, if found; otherwise, -1."},{signature:"void ForEach(Action<T> action)",summary:"Performs the specified action on each element of the List."},{signature:"IEnumerator<T> GetEnumerator()",summary:"Constructs an enumerator that is capable of iterating over all items in this list.",returns:"The new enumerator."},{signature:"RhinoList<T> GetRange(int index,int count)",summary:"Constructs a shallow copy of a range of elements in the source List.",returns:"A shallow copy of a range of elements in the source List."},{signature:"int IndexOf(T item)",summary:"Searches for the specified object and returns the zero-based index of the \n     first occurrence within the entire List.",returns:"The zero-based index of the first occurrence of item within \n     the entire List, if found; otherwise, -1."},{signature:"int IndexOf(T item,int index)",summary:"Searches for the specified object and returns the zero-based index of \n     the first occurrence within the range of elements in the List that \n     extends from the specified index to the last element.",returns:"The zero-based index of the first occurrence of item within \n     the entire List, if found; otherwise, -1."},{signature:"int IndexOf(T item,int index,int count)",summary:"Searches for the specified object and returns the zero-based index of the first \n     occurrence within the range of elements in the List that starts at the specified \n     index and contains the specified number of elements.",returns:"The zero-based index of the first occurrence of item within \n     the entire List, if found; otherwise, -1."},{signature:"void Insert(int index,T item)",summary:"Inserts an element into the List at the specified index."},{signature:"void InsertRange(int index,IEnumerable<T> collection)",summary:"Inserts the elements of a collection into the List at the specified index."},{signature:"int LastIndexOf(T item)",summary:"Searches for the specified object and returns the zero-based \n     index of the last occurrence within the entire List.",returns:"The zero-based index of the last occurrence of item within \n     the entire the List, if found; otherwise, -1."},{signature:"int LastIndexOf(T item,int index)",summary:"Searches for the specified object and returns the zero-based index \n     of the last occurrence within the range of elements in the List \n     that extends from the first element to the specified index.",returns:"The zero-based index of the last occurrence of item within \n     the entire the List, if found; otherwise, -1."},{signature:"int LastIndexOf(T item,int index,int count)",summary:"Searches for the specified object and returns the zero-based index of the \n     last occurrence within the range of elements in the List that contains \n     the specified number of elements and ends at the specified index.",returns:"The zero-based index of the last occurrence of item within \n     the entire the List, if found; otherwise, -1."},{signature:"int RemapIndex(int index)",summary:"Remap an index in the infinite range onto the List index range.",returns:"Remapped index."},{signature:"bool Remove(T item)",summary:"Removes the first occurrence of a specific object from the List.",returns:"True if item is successfully removed; otherwise, false. \n     This method also returns False if item was not found in the List."},{signature:"int RemoveAll(Predicate<T> match)",summary:"Removes the all the elements that match the conditions defined by the specified predicate.",returns:"The number of elements removed from the List."},{signature:"void RemoveAt(int index)",summary:"Removes the element at the specified index of the List."},{signature:"int RemoveNulls()",summary:"Removes all elements from the List that are None references (Nothing in Visual Basic). \n     This function will not do anything if T is not a Reference type.",returns:"The number of nulls removed from the List."},{signature:"void RemoveRange(int index,int count)",summary:"Removes a range of elements from the List."},{signature:"void Reverse()",summary:"Reverses the order of the elements in the entire List."},{signature:"void Reverse(int index,int count)",summary:"Reverses the order of the elements in the specified range."},{signature:"void Sort()",summary:"Sorts the elements in the entire List using the default comparer."},{signature:"void Sort(Comparison<T> comparison)",summary:"Sorts the elements in the entire list using the specified comparer."},{signature:"void Sort(double[] keys)",summary:"Sort this list based on a list of numeric keys of equal length. \n     The keys array will not be altered."},{signature:"void Sort(IComparer<T> comparer)",summary:"Sorts the elements in the entire list using the specified System.Comparison(T)"},{signature:"void Sort(int index,int count,IComparer<T> comparer)",summary:"Sorts the elements in a range of elements in list using the specified comparer."},{signature:"void Sort(int[] keys)",summary:"Sort this list based on a list of numeric keys of equal length. \n     The keys array will not be altered."},{signature:"T[] ToArray()",summary:"Constructs an array that contains all items in this list.",returns:"An array containing all items in this list."},{signature:"void TrimExcess()",summary:"Sets the capacity to the actual number of elements in the List, \n     if that number is less than a threshold value."},{signature:"bool TrueForAll(Predicate<T> match)",summary:"Determines whether every element in the List matches the conditions defined by the specified predicate.",returns:"True if every element in the List matches the conditions defined by \n     the specified predicate; otherwise, false. If the list has no elements, the return value is true."}]},{name:"Rhino.Collections.TransformObjectList",dataType:1,summary:"Used by the TransformCommand and GetTransform classes.",constructors:[{signature:"TransformObjectList()",since:5}],properties:[{signature:"int Count",summary:"Number of elements in this list",since:5.1},{signature:"bool DisplayFeedbackEnabled",since:5},{signature:"int GripCount",summary:"Number of elements in grip list",since:6},{signature:"int GripOwnerCount",summary:"Number of elements in grip owner list",since:6}],methods:[{signature:"void Add(ObjRef objref)",summary:"Add an ObjRef to this list. Use this to add Polyedges so the references are properly counted",since:5.1},{signature:"void Add(RhinoObject rhinoObject)",summary:"Add a RhinoObject to this list",since:5.1},{signature:"int AddObjects(GetObject go,bool allowGrips)",summary:"Add objects to list with a GetObject",since:6,returns:"Number of objects selected."},{signature:"void Clear()",summary:"Remove all elements from this list",since:5.1},{signature:"void Dispose()",since:5},{signature:"BoundingBox GetBoundingBox(bool regularObjects,bool grips)",summary:"Gets the bounding box of all of the objects that this list contains.",since:5,returns:"Unset BoundingBox if this list is empty."},{signature:"GripObject[] GripArray()",summary:"Gets access to the GripObject array of the TransformObjectList object.",since:6,returns:"An array of GripObjects, empty if there were no GripObjects"},{signature:"RhinoObject[] GripOwnerArray()",summary:"Gets access to the  GripOwner array of the TransformObjectList object.",since:6,returns:"An array of GripOwner, empty if there were no GripOwners."},{signature:"bool UpdateDisplayFeedbackTransform(Transform xform)",since:5}]},{name:"Rhino.Commands.Command",dataType:1,summary:"Defines a base class for all commands. This class is abstract.",properties:[{signature:"static Guid LastCommandId",summary:"Gets the ID of the last commands.",since:5},{signature:"static Result LastCommandResult",summary:"Gets the result code of the last command.",since:5},{signature:"string EnglishName",summary:"Gets the name of the command.\n     This method is abstract.",since:5},{signature:"Guid Id",summary:"Gets the  unique ID of this command. It is best to use a Guid\n     attribute for each custom derived command class since this will\n     keep the id consistent between sessions of Rhino\n     GuidAttribute",since:5},{signature:"string LocalName",summary:"Gets the local name of the command.",since:5},{signature:"PlugIn PlugIn",summary:"Gets the plug-in where this commands is placed.",since:5},{signature:"PersistentSettings Settings",summary:"Gets the settings of the command.",since:5}],methods:[{signature:"static void DisplayHelp(Guid commandId)",summary:"Displays help for a command.",since:5},{signature:"static string[] GetCommandNames(bool english,bool loaded)",summary:"Gets list of command names in Rhino. This list does not include Test, Alpha, or System commands.",since:5,returns:"An array instance with command names. This array could be empty, but not null."},{signature:"static Guid[] GetCommandStack()",summary:"Determines if Rhino is currently running a command. Because Rhino allow for transparent commands\n     (commands that can be run from inside of other commands), this method returns the total ids of\n     active commands.",since:5,returns:'Ids of running commands or None if no commands are currently running. \n     The "active" command is at the end of this list.'},{signature:"static MostRecentCommandDescription[] GetMostRecentCommands()",summary:"Gets an array of most recent command descriptions.",since:5,returns:"An array of command descriptions."},{signature:"static bool InCommand()",summary:"Determines if Rhino is currently running a command.",since:5,returns:"True if a command is currently running, False if no commands are currently running."},{signature:"static bool InScriptRunnerCommand()",summary:'This is a low level tool to determine if Rhino is currently running\n     a script running command like "ReadCommandFile" or the RhinoScript\n     plug-in\'s "RunScript".',since:5,returns:"True if a script running command is active."},{signature:"static bool IsCommand(string name)",summary:"Determines is a string is a command.",since:5,returns:"True if the string is a command."},{signature:"static bool IsValidCommandName(string name)",summary:"Determines if a string is a valid command name.",since:5,returns:"True if the string is a valid command name."},{signature:"static Guid LookupCommandId(string name,bool searchForEnglishName)",summary:"Returns the ID of a command.",since:5,returns:"An of the command, or  on error."},{signature:"static string LookupCommandName(Guid commandId,bool englishName)",summary:"Returns the command name given a command ID.",since:5,returns:"The command name, or None on error."},{signature:"static void RunProxyCommand(RunCommandDelegate commandCallback,RhinoDoc doc,object data)",summary:"Execute some code as if it were running in a command",since:6.13}],events:[{signature:"static BeginCommand",summary:"Called just before command.RunCommand().",since:5},{signature:"static EndCommand",summary:"Called immediately after command.RunCommand().",since:5},{signature:"static UndoRedo",summary:"Used to monitor Rhino's built in undo/redo support.",since:5}]},{name:"Rhino.Commands.CommandEventArgs",dataType:1,summary:"",properties:[{signature:"string CommandEnglishName",summary:"Gets the English name of the command that raised this event.",since:5},{signature:"Guid CommandId",summary:"Gets the ID of the command that raised this event.",since:5},{signature:"string CommandLocalName",summary:"Gets the name of the command that raised this event in the local language.",since:5},{signature:"string CommandPluginName",summary:"Gets the name of the plug-in that this command belongs to.  If the command is internal\n     to Rhino, then this propert is an empty string.",since:5},{signature:"Result CommandResult",summary:"Gets the result of the command that raised this event. \n     This value is only meaningful during EndCommand events.",since:5},{signature:"RhinoDoc Document",since:6},{signature:"uint DocumentRuntimeSerialNumber",since:6}]},{name:"Rhino.Commands.CommandStyleAttribute",dataType:1,summary:"Decorates commands to provide styles.",constructors:[{signature:"CommandStyleAttribute(Style styles)",summary:"Initializes a new command style attribute class.",since:5}],properties:[{signature:"Style Styles",summary:"Gets the associated style.",since:5}]},{name:"Rhino.Commands.CustomUndoEventArgs",dataType:1,summary:"Argument package that is passed to a custom undo delegate",properties:[{signature:"string ActionDescription",since:5},{signature:"Guid CommandId",since:5},{signature:"bool CreatedByRedo",since:5},{signature:"RhinoDoc Document",since:5},{signature:"object Tag",since:5},{signature:"uint UndoSerialNumber",since:5}]},{name:"Rhino.Commands.MostRecentCommandDescription",dataType:1,summary:"Stores the macro and display string of the most recent command.",properties:[{signature:"string DisplayString",since:5},{signature:"string Macro",since:5}]},{name:"Rhino.Commands.Result",dataType:3,summary:"Defines enumerated constant values for several command result types."},{name:"Rhino.Commands.RunMode",dataType:3,summary:"Provides enumerated constants for a command running mode. This is currently interactive or scripted."},{name:"Rhino.Commands.SelCommand",dataType:1,summary:"For adding nestable selection commands that work like the native Rhino\n   SelCrv command, derive your command from SelCommand and override the\n   virtual SelFilter function.",properties:[{signature:"bool BeQuiet",since:5},{signature:"bool TestGrips",since:5},{signature:"bool TestLights",since:5}]},{name:"Rhino.Commands.Style",dataType:3,summary:"Defines bitwise mask flags for different styles of commands, such as\n   Hidden or DoNotRepeat."},{name:"Rhino.Commands.TransformCommand",dataType:1,summary:""},{name:"Rhino.Commands.UndoRedoEventArgs",dataType:1,summary:"",properties:[{signature:"Guid CommandId",since:5},{signature:"bool IsBeginRecording",since:5},{signature:"bool IsBeginRedo",since:5},{signature:"bool IsBeginUndo",since:5},{signature:"bool IsEndRecording",since:5},{signature:"bool IsEndRedo",since:5},{signature:"bool IsEndUndo",since:5},{signature:"bool IsPurgeRecord",since:5},{signature:"uint UndoSerialNumber",since:5}]},{name:"Rhino.Display.BackgroundStyle",dataType:3,summary:"Constants that define how the background of a viewport should be filled."},{name:"Rhino.Display.BlendMode",dataType:3,summary:"Defines enmerated constants for display blend modes."},{name:"Rhino.Display.CalculateBoundingBoxEventArgs",dataType:1,summary:"",properties:[{signature:"BoundingBox BoundingBox",summary:"Gets the current bounding box.",since:5}],methods:[{signature:"void IncludeBoundingBox(BoundingBox box)",summary:'Unites a bounding box with the current display bounding box in order to ensure\n     dynamic objects in "box" are drawn.',since:5}]},{name:"Rhino.Display.Color4f",dataType:2,summary:"Color defined by 4 floating point values.",constructors:[{signature:"Color4f(Color color)",since:5},{signature:"Color4f(Color4f color)",since:5},{signature:"Color4f(float red,float green,float blue,float alpha)",since:5},{signature:"Color4f(int argb)",since:7}],properties:[{signature:"static Color4f Black",since:5},{signature:"static Color4f Empty",since:5},{signature:"static Color4f White",since:5},{signature:"float A",since:5},{signature:"float B",since:5},{signature:"float G",since:5},{signature:"float L",since:6.3},{signature:"float R",since:5}],methods:[{signature:"static Color4f ApplyGamma(Color4f col,float gamma)",since:6},{signature:"static Color4f FromArgb(float a,Color4f color)",since:5.11},{signature:"static Color4f FromArgb(float a,float r,float g,float b)",since:5.11},{signature:"System.Drawing.Color AsSystemColor()",since:5},{signature:"Color4f BlendTo(float t,Color4f col)",since:5},{signature:"bool Equals(object obj)"},{signature:"int GetHashCode()"}]},{name:"Rhino.Display.ColorCMYK",dataType:2,summary:"Represents a CMYK (Cyan, Magenta, Yellow, Key) color with double precision floating point channels. \n   CMYK colors are used primarily in printing environments as they provide a good simulation of physical ink.",constructors:[{signature:"ColorCMYK(Color rgb)",summary:"Initializes a new instance of ColorCMYK that is equivalent to an RGB color.",since:5},{signature:"ColorCMYK(double cyan,double magenta,double yellow)",summary:"Initializes a new instance of ColorCMYK with custom channel values. \n     The cyan, magenta and yellow values will be adjusted based on their \n     combined darkness.",since:5},{signature:"ColorCMYK(double cyan,double magenta,double yellow,double key)",summary:"Initializes a new instance of ColorCMYK with custom channel values.",since:5},{signature:"ColorCMYK(double alpha,double cyan,double magenta,double yellow,double key)",summary:"Initializes a new instance of ColorCMYK with custom channel values.",since:5}],properties:[{signature:"double A",summary:"Gets or sets the Alpha channel value. \n     Alpha channels are limited to the 0~1 range.",since:5},{signature:"double C",summary:"Gets or sets the Cyan channel value. \n     Cyan channels are limited to the 0~1 range.",since:5},{signature:"double K",summary:"Gets or sets the Key channel value. \n     Key channels are limited to the 0~1 range.",since:5},{signature:"double M",summary:"Gets or sets the Magenta channel value. \n     Magenta channels are limited to the 0~1 range.",since:5},{signature:"double Y",summary:"Gets or sets the Yellow channel value. \n     Yellow channels are limited to the 0~1 range.",since:5}],methods:[{signature:"static ColorCMYK CreateFromHSL(ColorHSL hsl)",summary:"Constructs the nearest CMYK equivalent of an HSL color.",since:5,returns:"The CMYK equivalent of the HSL color."},{signature:"static ColorCMYK CreateFromHSV(ColorHSV hsv)",summary:"Constructs the nearest CMYK equivalent of an HSV color.",since:6,returns:"The CMYK equivalent of the HSV color."},{signature:"static ColorCMYK CreateFromLAB(ColorLAB lab)",summary:"Constructs the nearest CMYK equivalent of a LAB color.",since:5,returns:"The CMYK equivalent of the LAB color."},{signature:"static ColorCMYK CreateFromLCH(ColorLCH lch)",summary:"Constructs the nearest CMYK equivalent of a LCH color.",since:5,returns:"The CMYK equivalent of the LCH color."},{signature:"static ColorCMYK CreateFromXYZ(ColorXYZ xyz)",summary:"Constructs the nearest CMYK equivalent of an XYZ color.",since:5,returns:"The CMYK equivalent of the XYZ color."}]},{name:"Rhino.Display.ColorGradient",dataType:1,summary:"",properties:[{signature:"Point3d EndPoint",summary:"End point of gradient",since:7},{signature:"GradientType GradientType",summary:"Gradient fill type associated with this hatch",since:7},{signature:"double Repeat",summary:"Repeat factor for gradient. Factors greater than 1 define a reflected\n     repeat factor while values less than -1 define a wrapped repeat factor.",since:7},{signature:"Point3d StartPoint",summary:"Start point of gradient",since:7}],methods:[{signature:"ColorStop[] GetColorStops()",summary:"Get sorted list of colors / positions that a gradient is defined over",since:7},{signature:"void SetColorStops(IEnumerable<ColorStop> stops)",summary:"Set color stops for the gradient",since:7}]},{name:"Rhino.Display.ColorHSL",dataType:2,summary:"Represents an HSL (Hue, Saturation, Luminance) color with double precision floating point channels. \n   HSL colors are used primarily in Graphical User Interface environments as they provide a \n   very natural approach to picking colors.",constructors:[{signature:"ColorHSL(Color rgb)",summary:"Constructs a new instance of ColorHSL that is equivalent to an RGB color.",since:5},{signature:"ColorHSL(double hue,double saturation,double luminance)",summary:"Constructs a new instance of ColorHSL with custom channel values.",since:5},{signature:"ColorHSL(double alpha,double hue,double saturation,double luminance)",summary:"Constructs a new instance of ColorHSL with custom channel values.",since:5}],properties:[{signature:"double A",summary:"Gets or sets the alpha channel value. \n     Alpha channels are limited to a 0~1 range.",since:5},{signature:"double H",summary:"Gets or sets the hue channel value. \n     Hue channels rotate between 0.0 and 1.0.",since:5},{signature:"double L",summary:"Gets or sets the luminance channel value. \n     Luminance channels are limited to a 0~1 range.",since:5},{signature:"double S",summary:"Gets or sets the saturation channel value. \n     Saturation channels are limited to a 0~1 range.",since:5}],methods:[{signature:"static ColorHSL CreateFromCMYK(ColorCMYK cmyk)",summary:"Create the nearest HSL equivalent of a CMYK color.",since:5,returns:"The HSL equivalent of the CMYK color."},{signature:"static ColorHSL CreateFromHSV(ColorHSV hsv)",summary:"Constructs the nearest HSL equivalent of an HSV color.",since:6,returns:"The HSL equivalent of the HSV color."},{signature:"static ColorHSL CreateFromLAB(ColorLAB lab)",summary:"Create the nearest HSL equivalent of a LAB color.",since:5,returns:"The HSL equivalent of the LAB color."},{signature:"static ColorHSL CreateFromLCH(ColorLCH lch)",summary:"Create the nearest HSL equivalent of a LCH color.",since:5,returns:"The HSL equivalent of the LCH color."},{signature:"static ColorHSL CreateFromXYZ(ColorXYZ xyz)",summary:"Create the nearest HSL equivalent of an XYZ color.",since:5,returns:"The HSL equivalent of the XYZ color."},{signature:"System.Drawing.Color ToArgbColor()",summary:"Convert HSL color to an equivalent System.Drawing.Color.",since:5,returns:"A .Net framework library color value."}]},{name:"Rhino.Display.ColorHSV",dataType:2,summary:"Represents an HSV (Hue, Saturation, Value) color with double precision floating point channels. \n   HSV colors (also sometimes called HSB, where B means Brightness) are similar to HSL colors in that they\n   represent colors in a cylindrical color space, and are intended to provide intuitive means to edit the \n   brightness of a particular color over RGB color space where each each color channel would need to be \n   modified to affect the color brightness.",constructors:[{signature:"ColorHSV(Color rgb)",summary:"Constructs a new instance of ColorHSV that is equivalent to an RGB color.",since:6},{signature:"ColorHSV(double hue,double saturation,double value)",summary:"Constructs a new instance of ColorHSV with custom channel values.",since:6},{signature:"ColorHSV(double alpha,double hue,double saturation,double value)",summary:"Constructs a new instance of ColorHSV with custom channel values.",since:6}],properties:[{signature:"double A",summary:"Gets or sets the alpha channel value. \n     Alpha channels are limited to a 0~1 range.",since:6},{signature:"double H",summary:"Gets or sets the hue channel value. \n     Hue channels rotate between 0.0 and 1.0.",since:6},{signature:"double S",summary:"Gets or sets the saturation channel value. \n     Saturation channels are limited to a 0~1 range.",since:6},{signature:"double V",summary:"Gets or sets the value (brightness) channel value. \n     Value channels are limited to a 0~1 range.",since:6}],methods:[{signature:"static ColorHSV CreateFromCMYK(ColorCMYK cmyk)",summary:"Create the nearest HSV equivalent of a CMYK color.",since:6,returns:"The HSV equivalent of the CMYK color."},{signature:"static ColorHSV CreateFromHSL(ColorHSL hsl)",summary:"Constructs the nearest CMYK equivalent of an HSV color.",since:6,returns:"The HSV equivalent of the HSL color."},{signature:"static ColorHSV CreateFromLAB(ColorLAB lab)",summary:"Create the nearest HSV equivalent of a LAB color.",since:6,returns:"The HSV equivalent of the LAB color."},{signature:"static ColorHSV CreateFromLCH(ColorLCH lch)",summary:"Create the nearest HSV equivalent of a LCH color.",since:6,returns:"The HSV equivalent of the LCH color."},{signature:"static ColorHSV CreateFromXYZ(ColorXYZ xyz)",summary:"Create the nearest HSV equivalent of an XYZ color.",since:6,returns:"The HSV equivalent of the XYZ color."},{signature:"System.Drawing.Color ToArgbColor()",summary:"Convert HSV color to an equivalent System.Drawing.Color.",since:6,returns:"A .Net framework library color value."}]},{name:"Rhino.Display.ColorLAB",dataType:2,summary:"Represents a LAB (Lightness, A, B) color with double precision floating point channels. \n   LAB colors are based on nonlinearly compressed CIE XYZ color space coordinates.  \n   The A and B parameters of a LAB color represent the opponents.",constructors:[{signature:"ColorLAB(Color rgb)",summary:"Constructs a new instance of ColorLAB that is equivalent to an RGB color.",since:5},{signature:"ColorLAB(double lightness,double a,double b)",summary:"Constructs a new instance of ColorLAB with custom channel values.",since:5},{signature:"ColorLAB(double alpha,double lightness,double a,double b)",summary:"Constructs a new instance of ColorLAB with custom channel values.",since:5}],properties:[{signature:"double A",summary:"Gets or sets the Base channel. The channel is limited to 0~1.",since:5},{signature:"double Alpha",summary:"Gets or sets the Alpha channel. The channel is limited to 0~1.",since:5},{signature:"double B",summary:"Gets or sets the Opponent channel. The channel is limited to 0~1.",since:5},{signature:"double L",summary:"Gets or sets the lightness channel. The channel is limited to 0~1.",since:5}],methods:[{signature:"static ColorLAB CreateFromCMYK(ColorCMYK cmyk)",summary:"Create the nearest LAB equivalent of a CMYK color.",since:5,returns:"The LAB equivalent of the CMYK color."},{signature:"static ColorLAB CreateFromHSL(ColorHSL hsl)",summary:"Create the nearest LAB equivalent of an HSL color.",since:5,returns:"The LAB equivalent of the HSL color."},{signature:"static ColorLAB CreateFromHSV(ColorHSV hsv)",summary:"Constructs the nearest LAB equivalent of an HSV color.",since:6,returns:"The LAB equivalent of the HSV color."},{signature:"static ColorLAB CreateFromLCH(ColorLCH lch)",summary:"Create the nearest LAB equivalent of an LCH color.",since:5,returns:"The LAB equivalent of the LCH color."},{signature:"static ColorLAB CreateFromXYZ(ColorXYZ xyz)",summary:"Create the nearest LAB equivalent of an XYZ color.",since:5,returns:"The LAB equivalent of the XYZ color."}]},{name:"Rhino.Display.ColorLCH",dataType:2,summary:"Represents an LCH (Lightness, A, B) color with double precision floating point channels. \n   LCH colors (also sometimes called CIELUV) are transformation of the 1931 CIE XYZ color space, \n   in order to approach perceptual uniformity. They are primarily used in computer graphics which \n   deal with colored lights.",constructors:[{signature:"ColorLCH(Color rgb)",summary:"Constructs a new instance of ColorLCH that is equivalent to an RGB color.",since:5},{signature:"ColorLCH(double lightness,double chroma,double hue)",summary:"Constructs a new instance of ColorLCH with custom channel values.",since:5},{signature:"ColorLCH(double alpha,double lightness,double chroma,double hue)",summary:"Constructs a new instance of ColorLCH with custom channel values.",since:5}],properties:[{signature:"double A",summary:"Gets or sets the Alpha channel. The Alpha channel is limited to the 0~1 range.",since:5},{signature:"double C",summary:"Gets or sets the Chroma channel. Chroma is defined from -1.0 to +1.0.",since:5},{signature:"double H",summary:"Gets or sets the Hue channel. The hue channel is limited to the 0~360 degree range.",since:5},{signature:"double L",summary:"Gets or sets the Lightness channel.",since:5}],methods:[{signature:"static ColorLCH CreateFromCMYK(ColorCMYK cmyk)",summary:"Create the nearest LCH equivalent of a CMYK color.",since:5,returns:"The LCH equivalent of the CMYK color."},{signature:"static ColorLCH CreateFromHSL(ColorHSL hsl)",summary:"Create the nearest LCH equivalent of an HSL color.",since:5,returns:"The LCH equivalent of the HSL color."},{signature:"static ColorLCH CreateFromLAB(ColorLAB lab)",summary:"Create the nearest LCH equivalent of a LAB color.",since:5,returns:"The LCH equivalent of the LAB color."},{signature:"static ColorLCH CreateFromXYZ(ColorXYZ xyz)",summary:"Create the nearest LCH equivalent of an XYZ color.",since:5,returns:"The LCH equivalent of the XYZ color."},{signature:"void MakePositive()",summary:"Ensure the Chromaticity of this color is positive.",since:5}]},{name:"Rhino.Display.ColorStop",dataType:2,summary:"Combination of a color and position. Used in defining gradient fills",constructors:[{signature:"ColorStop(Color color,double t)",summary:"Create color stop from a color and position",since:7}],properties:[{signature:"Color Color",since:7},{signature:"double Position",summary:"Parameter that Color is defined at",since:7}]},{name:"Rhino.Display.ColorXYZ",dataType:2,summary:"Represents an XYZ (Hue, Saturation, Luminance) color with double precision floating point channels. \n   XYZ colors are based on the CIE 1931 XYZ color space standard and they mimic the natural \n   sensitivity of cones in the human retina.",constructors:[{signature:"ColorXYZ(Color rgb)",summary:"Constructs a new instance of ColorXYZ that is equivalent to an RGB color.",since:5},{signature:"ColorXYZ(double x,double y,double z)",summary:"Constructs a new instance of ColorXYZ with custom channel values.",since:5},{signature:"ColorXYZ(double alpha,double x,double y,double z)",summary:"Constructs a new instance of ColorXYZ with custom channel values.",since:5}],properties:[{signature:"double A",summary:"Gets or set the Alpha channel value. Channel will be limited to 0~1.",since:5},{signature:"double X",summary:"Gets or set the X channel value. Channel will be limited to 0~1.",since:5},{signature:"double Y",summary:"Gets or set the Y channel value. Channel will be limited to 0~1.",since:5},{signature:"double Z",summary:"Gets or set the Z channel value. Channel will be limited to 0~1.",since:5}],methods:[{signature:"static ColorXYZ CreateFromCMYK(ColorCMYK cmyk)",summary:"Create the nearest XYZ equivalent of a CMYK color.",since:5,returns:"The XYZ equivalent of the CMYK color."},{signature:"static ColorXYZ CreateFromHSL(ColorHSL hsl)",summary:"Create the nearest XYZ equivalent of an HSL color.",since:5,returns:"The XYZ equivalent of the HSL color."},{signature:"static ColorXYZ CreateFromHSV(ColorHSV hsv)",summary:"Constructs the nearest XYZ equivalent of an HSV color.",since:6,returns:"The XYZ equivalent of the HSV color."},{signature:"static ColorXYZ CreateFromLAB(ColorLAB lab)",summary:"Create the nearest XYZ equivalent of a Lab color.",since:5,returns:"The XYZ equivalent of the LAB color."},{signature:"static ColorXYZ CreateFromLCH(ColorLCH lch)",summary:"Create the nearest XYZ equivalent of an LCH color.",since:5,returns:"The XYZ equivalent of the LCH color."}]},{name:"Rhino.Display.CullFaceMode",dataType:3,summary:""},{name:"Rhino.Display.CullObjectEventArgs",dataType:1,summary:"",properties:[{signature:"bool CullObject",since:5.3},{signature:"RhinoObject RhinoObject",since:5.3},{signature:"uint RhinoObjectSerialNumber",summary:"Gets the rhino object runtime serial number.",since:6.14}]},{name:"Rhino.Display.CustomDisplay",dataType:1,summary:"Provides some basic (indeed, very basic) mechanisms for drawing custom geometry in viewports.",constructors:[{signature:"CustomDisplay(bool enable)",summary:"Constructs a new CustomDisplay instance. You must call\n     Dispose() when you are done with this instance, otherwise\n     the display methods will never be switched off.",since:5}],properties:[{signature:"BoundingBox ClippingBox",summary:"Gets the clipping box of this CustomDisplay.",since:5},{signature:"bool Enabled",summary:"Gets or sets the Enabled state of this CustomDisplay instance. \n     If you wish to terminate this CustomDisplay, place a call to Dispose() instead.",since:5},{signature:"bool IsDisposed",summary:"Gets a value indicating whether this CustomDisplay instance has been disposed. \n     Once a CustomDisplay has been disposed, you can no longer use it.",since:5}],methods:[{signature:"void AddArc(Arc arc)",summary:"Adds a new, black arc to the display list.",since:5},{signature:"void AddArc(Arc arc,Color color)",summary:"Adds a new, colored arc to the display list.",since:5},{signature:"void AddArc(Arc arc,Color color,int thickness)",summary:"Adds a new, colored arc to the display list.",since:5},{signature:"void AddCircle(Circle circle)",summary:"Adds a new, black circle to the display list.",since:5},{signature:"void AddCircle(Circle circle,Color color)",summary:"Adds a new, colored arc to the display list.",since:5},{signature:"void AddCircle(Circle circle,Color color,int thickness)",summary:"Adds a new, colored circle to the display list.",since:5},{signature:"void AddCurve(Curve curve)",summary:"Adds a new, black curve to the display list. \n     The curve will be duplicated so changes to the \n     original will not affect the display.",since:5},{signature:"void AddCurve(Curve curve,Color color)",summary:"Adds a new, colored curve to the display list.\n     The curve will be duplicated so changes to the \n     original will not affect the display.",since:5},{signature:"void AddCurve(Curve curve,Color color,int thickness)",summary:"Adds a new, colored curve to the display list.\n     The curve will be duplicated so changes to the \n     original will not affect the display.",since:5},{signature:"void AddLine(Line line)",summary:"Adds a new, black line to the display list.",since:5},{signature:"void AddLine(Line line,Color color)",summary:"Adds a new, colored line to the display list.",since:5},{signature:"void AddLine(Line line,Color color,int thickness)",summary:"Adds a new, colored line to the display list.",since:5},{signature:"void AddPoint(Point3d point)",summary:"Adds a new, black point to the display list.",since:5},{signature:"void AddPoint(Point3d point,Color color)",summary:"Adds a new colored point to the display list.",since:5},{signature:"void AddPoint(Point3d point,Color color,PointStyle style,int radius)",summary:"Adds a new stylized point to the display list.",since:5},{signature:"void AddPoints(IEnumerable<Point3d> points)",summary:"Adds a collection of black points to the display list.",since:5},{signature:"void AddPoints(IEnumerable<Point3d> points,Color color)",summary:"Adds a collection of colored points to the display list.",since:5},{signature:"void AddPoints(IEnumerable<Point3d> points,Color color,PointStyle style,int radius)",summary:"Adds a collection of stylized points to the display list.",since:5},{signature:"void AddPolygon(IEnumerable<Point3d> polygon,Color fillColor,Color edgeColor,bool drawFill,bool drawEdge)",summary:"Adds a polygon to the drawing list. Polygons are not like Hatches, when you supply a concave \n     polygon, the shading probably won't work.",since:5},{signature:"void AddText(string text,Plane plane,double size)",summary:"Adds a new, black 3D text object to the display list.",since:5},{signature:"void AddText(string text,Plane plane,double size,Color color)",summary:"Adds a new, colored 3D text object to the display list.",since:5},{signature:"void AddText(Text3d text,Color color)",summary:"Adds a new 3D text object to the display list.",since:5},{signature:"void AddVector(Point3d anchor,Vector3d span)",summary:"Adds a new, black vector to the display list.",since:5},{signature:"void AddVector(Point3d anchor,Vector3d span,Color color)",summary:"Adds a new, colored vector to the display list.",since:5},{signature:"void AddVector(Point3d anchor,Vector3d span,Color color,bool drawAnchor)",summary:"Adds a new, colored vector to the display list.",since:5},{signature:"void Clear()",summary:"Clear the drawing lists.",since:5},{signature:"void Dispose()",summary:"Dispose this CustomDisplay instance. You must call this function in order to \n     properly shut down the CustomDisplay.",since:5}]},{name:"Rhino.Display.DefinedViewportProjection",dataType:3,summary:'Parallel and perspective projections that are "standard" in Rhino'},{name:"Rhino.Display.DepthMode",dataType:3,summary:""},{name:"Rhino.Display.DisplayBitmap",dataType:1,summary:"A bitmap resource that can be used by the display pipeline (currently only\n   in OpenGL display).  Reuse DisplayBitmaps for drawing if possible; it is\n   much more expensive to construct new DisplayBitmaps than it is to reuse\n   existing DisplayBitmaps.",constructors:[{signature:"DisplayBitmap(Bitmap bitmap)",summary:"Constructs a DisplayBitmap from an existing bitmap.",since:5}],methods:[{signature:"static DisplayBitmap Load(string path)",summary:"Load a DisplayBitmap from and image file on disk.",since:5,returns:"The new display bitmap, or None on error."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"void GetBlendModes(BlendMode source,BlendMode destination)",summary:"Gets the source and destination blend modes.",since:5},{signature:"void SetBlendFunction(BlendMode source,BlendMode destination)",summary:"Sets blending function used to determine how this bitmap is blended\n     with the current framebuffer color.  The default setting is SourceAlpha\n     for source and OneMinusSourceAlpha for destination.  See OpenGL's\n     glBlendFunc for details.\n     http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml",since:5}]},{name:"Rhino.Display.DisplayBitmapDrawList",dataType:1,summary:"",constructors:[{signature:"DisplayBitmapDrawList()",since:5}],properties:[{signature:"BoundingBox BoundingBox",since:5},{signature:"int MaximumCachedSortLists",summary:"Maximum number of cached sort order index lists stored on this class.\n     Default is 10, but depending on the number of points in this list you\n     may get better performance by setting this value to a certain percentage\n     of the point count.",since:5},{signature:"double SortAngleTolerance",summary:'Angle in radians used to determine if an index list is "parallel enough"\n     to a viewports camera angle. Default is 0.0873 radians (5 degrees)',since:5}],methods:[{signature:"void SetPoints(IEnumerable<Point3d> points)",since:5},{signature:"void SetPoints(IEnumerable<Point3d> points,Color blendColor)",since:5},{signature:"void SetPoints(IEnumerable<Point3d> points,IEnumerable<Color> colors)",since:5},{signature:"int[] Sort(Vector3d cameraDirection)",since:5}]},{name:"Rhino.Display.DisplayConduit",dataType:1,summary:"",properties:[{signature:"bool Enabled",since:5},{signature:"ActiveSpace SpaceFilter",summary:"If you want this conduit to only work in a specific space (model or page),\n     then set this filter to that specific space. The default is None meaning\n     no filter is applied",since:6}]},{name:"Rhino.Display.DisplayEngine",dataType:1,summary:"",methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6}]},{name:"Rhino.Display.DisplayMaterial",dataType:1,summary:"",constructors:[{signature:"DisplayMaterial()",summary:"Constructs a default material.",since:5},{signature:"DisplayMaterial(Color diffuse)",summary:"Constructs a default material with a specific diffuse color.",since:5},{signature:"DisplayMaterial(Color diffuse,Color specular,Color ambient,Color emission,double shine,double transparency)",summary:"Constructs a material with custom properties.",since:5},{signature:"DisplayMaterial(Color diffuse,double transparency)",summary:"Constructs a default material with a specific diffuse color and transparency.",since:5},{signature:"DisplayMaterial(DisplayMaterial other)",summary:"Duplicate another material.",since:5},{signature:"DisplayMaterial(Material material)",since:5}],properties:[{signature:"Color Ambient",summary:"Gets or sets the Ambient color of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"Color BackAmbient",summary:"Gets or sets the Ambient color of the back side of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"Color BackDiffuse",summary:"Gets or sets the Diffuse color of the back side of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"Color BackEmission",summary:"Gets or sets the Emissive color of the back side of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"double BackShine",summary:"Gets or sets the shine factor of the back side of the material (0.0 to 1.0)",since:5},{signature:"Color BackSpecular",summary:"Gets or sets the Specular color of the back side of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"double BackTransparency",summary:"Gets or sets the transparency of the back side material (0.0 = opaque to 1.0 = transparent)",since:5},{signature:"Color Diffuse",summary:"Gets or sets the Diffuse color of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"Color Emission",summary:"Gets or sets the Emissive color of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"bool IsTwoSided",since:5},{signature:"double Shine",summary:"Gets or sets the shine factor of the material (0.0 to 1.0)",since:5},{signature:"Color Specular",summary:"Gets or sets the Specular color of the Material. \n     The alpha component of the color will be ignored.",since:5},{signature:"double Transparency",summary:"Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)",since:5}],methods:[{signature:"void Dispose()",since:5},{signature:"Rhino.DocObjects.Texture GetBitmapTexture(bool front)",since:5},{signature:"Rhino.DocObjects.Texture GetBumpTexture(bool front)",summary:"Gets the bump texture for this display material.",since:5,returns:"The texture, or None if no bump texture has been added to this material."},{signature:"Rhino.DocObjects.Texture GetEnvironmentTexture(bool front)",since:5},{signature:"Rhino.DocObjects.Texture GetTransparencyTexture(bool front)",since:5},{signature:"bool SetBitmapTexture(string filename,bool front)",since:5},{signature:"bool SetBitmapTexture(Texture texture,bool front)",since:5},{signature:"bool SetBumpTexture(string filename,bool front)",since:5},{signature:"bool SetBumpTexture(Texture texture,bool front)",since:5},{signature:"bool SetEnvironmentTexture(string filename,bool front)",since:5},{signature:"bool SetEnvironmentTexture(Texture texture,bool front)",since:5},{signature:"bool SetTransparencyTexture(string filename,bool front)",since:5},{signature:"bool SetTransparencyTexture(Texture texture,bool front)",since:5}]},{name:"Rhino.Display.DisplayModeChangedEventArgs",dataType:1,summary:"",properties:[{signature:"Guid ChangedDisplayModeId",since:6.18},{signature:"Guid OldDisplayModeId",since:6.18},{signature:"RhinoDoc RhinoDoc",since:6.18},{signature:"RhinoViewport Viewport",since:6.18}]},{name:"Rhino.Display.DisplayModeDescription",dataType:1,summary:'Description of a how Rhino will display in a viewport. These are the modes\n   that are listed under "Advanced display" in the options dialog.',properties:[{signature:"static Guid AmbientOcclusionId",since:6},{signature:"static Guid GhostedId",since:6},{signature:"static Guid PenId",since:6},{signature:"static Guid RaytracedId",since:6},{signature:"static Guid RenderedId",since:6},{signature:"static Guid RenderedShadowsId",since:6},{signature:"static Guid ShadedId",since:6},{signature:"static Guid TechId",since:6},{signature:"static Guid WireframeId",since:6},{signature:"static Guid XRayId",since:6},{signature:"bool AllowObjectAssignment",since:5},{signature:"DisplayPipelineAttributes DisplayAttributes",since:5},{signature:"string EnglishName",since:5},{signature:"Guid Id",since:5},{signature:"bool InMenu",since:5},{signature:"string LocalName",since:5},{signature:"bool PipelineLocked",since:5},{signature:"bool ShadedPipelineRequired",since:5},{signature:"bool SupportsShadeCommand",since:5},{signature:"bool SupportsShading",since:5},{signature:"bool WireframePipelineRequired",since:5}],methods:[{signature:"static Guid AddDisplayMode(DisplayModeDescription displayMode)",since:5},{signature:"static Guid AddDisplayMode(string name)",summary:"Adds a new display mode.",since:6.7,returns:"The id of the new display mode if successful. Guid.Empty on error."},{signature:"static Guid CopyDisplayMode(Guid id,string name)",summary:"Copies an existing display mode.",since:6.7,returns:"The id of the new display mode if successful. Guid.Empty on error."},{signature:"static bool DeleteDiplayMode(Guid id)",summary:"Deletes an existing display mode.",since:5,returns:"True if successful, False oteherwise."},{signature:"static bool DeleteDisplayMode(Guid id)",summary:"Deletes an existing display mode.",since:7,returns:"True if successful, False oteherwise."},{signature:"static bool ExportToFile(DisplayModeDescription displayMode,string filename)",summary:"Exports a DisplayModeDescription to a Windows-style .ini file.",since:6},{signature:"static DisplayModeDescription FindByName(string englishName)",since:5},{signature:"static DisplayModeDescription GetDisplayMode(Guid id)",since:5},{signature:"static DisplayModeDescription[] GetDisplayModes()",summary:"Gets all display mode descriptions that Rhino currently knows about.",since:5,returns:"Copies of all of the display mode descriptions. If you want to modify\n     these descriptions, you must call UpdateDisplayMode or AddDisplayMode."},{signature:"static Guid ImportFromFile(string filename)",summary:"Imports a DisplayModeDescription from a Windows-style .ini file.",since:6,returns:"The id of the DisplayModeDescription if successsful."},{signature:"static bool UpdateDisplayMode(DisplayModeDescription displayMode)",since:5},{signature:"void Dispose()",since:5}]},{name:"Rhino.Display.DisplayPipeline",dataType:1,summary:"The display pipeline calls events during specific phases of drawing\n   During the drawing of a single frame the events are called in the following order.\n   \n   [Begin Drawing of a Frame]\n   CalculateBoundingBoxCalculateClippingPanesSetupFrustumSetupLightingInitializeFrameBufferDrawBackgroundIf this is a layout and detail objects exist the channels are called in the\n     same order for each detail object (drawn as a nested viewport)PreDrawObjectsFor Each Visible Non Highlighted ObjectSetupObjectDisplayAttributesPreDrawObjectDrawObjectPostDrawObjectPostDrawObjects - depth writing/testing onDrawForeGround - depth writing/testing offFor Each Visible Highlighted ObjectSetupObjectDisplayAttributesPreDrawObjectDrawObjectPostDrawObjectPostProcessFrameBuffer (If a delegate exists that requires this)DrawOverlay (if Rhino is in a feedback mode)\n   [End of Drawing of a Frame]\n  \n   NOTE: There may be multiple DrawObject calls for a single object. An example of when this could\n         happen would be with a shaded sphere. The shaded mesh is first drawn and these channels would\n         be processed; then at a later time the isocurves for the sphere would be drawn.",properties:[{signature:"RhinoObject ActiveObject",since:6.7},{signature:"int ActiveObjectNestingLevel",since:6.7},{signature:"RhinoObject[] ActiveObjectNestingStack",since:6.7},{signature:"RhinoObject ActiveTopLevelObject",since:6.7},{signature:"int DefaultCurveThickness",summary:"Gets the curve thickness as defined by the current display mode. \n     Note: this only applies to curve objects, Brep and Mesh wires may have different settings.",since:5},{signature:"DepthMode DepthMode",since:5},{signature:"DisplayPipelineAttributes DisplayPipelineAttributes",since:5.3},{signature:"float DpiScale",summary:"Scale factor used for high resolution displays. When a monitor that this\n     pipeline is drawing to is at a DPI of 96, this value is one. On high\n     DPI monitors, this value will commonly be greater than one.",since:6},{signature:"bool DrawingGrips",summary:"Gets a value that indicates whether the pipeline is currently in a grip drawing operation.",since:5},{signature:"bool DrawingSurfaces",summary:"Gets a value that indicates whether the pipeline is currently in a surface\n     drawing operation.  Surface drawing means draw the shaded triangles of a mesh\n     representing the surface (mesh, extrusion, or brep).  This is useful when\n     inside of a draw event or display conduit to check and see if the geometry is\n     about to be drawn as a shaded set of triangles representing the geometry.\n     See DrawingWires to check and see if the wireframe representation of the\n     geometry is going to be drawn.",since:5},{signature:"bool DrawingWires",summary:"Gets a value that indicates whether the pipeline is currently in a curve\n     drawing operation. This is useful when inside of a draw event or display\n     conduit to check and see if the geometry is about to be drawn is going to\n     be drawing the wire representation of the geometry (mesh, extrusion, or\n     brep).  See DrawingSurfaces to check and see if the shaded mesh representation\n     of the geometry is going to be drawn.",since:5},{signature:"Bitmap FrameBuffer",summary:"Gets the contents of the framebuffer that this pipeline is drawing to.",since:6},{signature:"Size FrameSize",summary:"Gets the size of the framebuffer that this pipeline is drawing to.",since:5},{signature:"bool IsDynamicDisplay",summary:"Gets a value that indicates whether the viewport is in Dynamic Display state. \n     Dynamic display is the state a viewport is in when it is rapidly redrawing because of\n     an operation like panning or rotating. The pipeline will drop some level of detail\n     while inside a dynamic display state to keep the frame rate as high as possible.",since:5},{signature:"bool IsInViewCapture",summary:"Gets a value that indicates whether this pipeline is currently drawing\n     for ViewCaptureToFile or ViewCaptureToClipboard",since:6},{signature:"bool IsOpen",summary:"Is True of the pipeline is open, False otherwise.",since:7},{signature:"bool IsOpenGL",summary:"Gets a value indicating whether or not this pipeline is drawing into an OpenGL context.",since:5},{signature:"bool IsPrinting",summary:"Gets a value that indicates whether this pipeline \n     is currently drawing for printing purposes.",since:5},{signature:"bool IsStereoMode",summary:'Gets a value that indicates whether this pipeline is currently using an \n     engine that is performing stereo style drawing. Stereo drawing is for \n     providing an "enhanced 3-D" effect through stereo viewing devices.',since:5},{signature:"Transform ModelTransform",summary:"Gets or sets the current model transformation that is applied to vertices when drawing.",since:5},{signature:"bool ModelTransformIsIdentity",summary:"Gets a value that indicates whether the Model Transform is an Identity transformation.",since:5},{signature:"int NestLevel",summary:"Gets the current nested viewport drawing level. \n     This is used to know if you are currently inside the drawing of a nested viewport (detail object in Rhino). \n     Nest level = 0 Drawing is occuring in a standard Rhino viewport or on the page viewport.Nest level = 1 Drawing is occuring inside a detail view object.",since:5},{signature:"int RenderPass",summary:"Gets the current pass that the pipeline is in for drawing a frame. \n     Typically drawing a frame requires a single pass through the DrawFrameBuffer \n     function, but some special display effects can be achieved through \n     drawing with multiple passes.",since:5},{signature:"bool ShadingRequired",summary:'Gets or sets the "ShadingRequired" flag. This flag gets set inside the pipeline when a request is \n     made to draw a shaded mesh but the current render engine doesn\'t support shaded \n     mesh drawing...at this point the redraw mechanism will make sure everything will \n     work the next time around.',since:5},{signature:"int StereoProjection",summary:"Gets the current stereo projection if stereo mode is on.\n     0 = left1 = right\n     If stereo mode is not enables, this property always returns 0.",since:5},{signature:"bool SupportsShading",summary:"Gets whether or not this pipeline supports shaded meshes.",since:5},{signature:"RhinoViewport Viewport",since:5},{signature:"ZBiasMode ZBiasMode",since:5}],methods:[{signature:"static uint AvailableOpenGLVersion(bool coreProfile)",summary:"If Rhino is using OpenGL for display, this function will return\n     major.minor version of OpenGL available for this instance of Rhino",since:6.21,returns:"major version * 10 + minor version\n     For example, OpenGL 4.5 returns 45"},{signature:"static string CrossCompileHLSL(string hlsl,string functionName,ShaderLanguage targetLanguage)",summary:"Convert HLSL code to a different shading language",since:7},{signature:"static bool CullControlPolygon()",summary:"Returns a value indicating if only points on the side of the surface that\n     face the camera are displayed.",since:5,returns:"True if backfaces of surface and mesh control polygons are culled.\n     This value is determined by the _CullControlPolygon command."},{signature:"static System.Drawing.Bitmap DrawToBitmap(RhinoViewport viewport,int width,int height)",summary:"Draw a given viewport to an off-screen bitmap.",since:5,returns:"A bitmap containing the given view, or None on error."},{signature:"static void GetDrawListSerialNumbers(uint modelSerialNumber,uint pageSerialNumber)",summary:"Gets the current model and page view draw list serial numbers, which can\n     be used to determine if a model or page view needs to be redrawn.",since:7},{signature:"static bool MakeDefaultOpenGLContextCurrent()",summary:'Make a "default" OpenGL context current',since:7},{signature:"int AddClippingPlane(Point3d point,Vector3d normal)",summary:"Add a clipping plane to be used during the drawing of this frame",since:6.3,returns:"index for the added clipping plane"},{signature:"DisplayPipeline Clone(RhinoViewport viewport)",summary:'Clones the pipeline. Creates an identical copy of "this" pipeline.\n     Copies all conduits from "this" pipeline to the new pipeline.',since:7,returns:"The newly cloned pipeline if successful, None otherwise.\n     or failed to close."},{signature:"bool Close()",summary:"Closes the pipeline.",since:7,returns:"True if the pipeline was closed, False if it was already closed\n     or failed to close."},{signature:"void Draw2dLine(Point from,Point to,Color color,float thickness)",since:6},{signature:"void Draw2dLine(PointF from,PointF to,Color color,float thickness)",since:6},{signature:"void Draw2dRectangle(Rectangle rectangle,Color strokeColor,int thickness,Color fillColor)",since:5.1},{signature:"void Draw2dText(string text,Color color,Point2d screenCoordinate,bool middleJustified)",summary:"Draws 2D text on the viewport.",since:5},{signature:"void Draw2dText(string text,Color color,Point2d screenCoordinate,bool middleJustified,int height)",summary:"Draws 2D text on the viewport.",since:5},{signature:"void Draw2dText(string text,Color color,Point2d screenCoordinate,bool middleJustified,int height,string fontface)",summary:"Draws 2D text on the viewport.",since:5},{signature:"void Draw2dText(string text,Color color,Point3d worldCoordinate,bool middleJustified)",summary:"Draws 2D text on the viewport.",since:5},{signature:"void Draw2dText(string text,Color color,Point3d worldCoordinate,bool middleJustified,int height)",summary:"Draws 2D text on the viewport.",since:5},{signature:"void Draw2dText(string text,Color color,Point3d worldCoordinate,bool middleJustified,int height,string fontface)",summary:"Draws 2D text on the viewport.",since:5},{signature:"void Draw3dText(string text,Color color,Plane textPlane,double height,string fontface)",since:5},{signature:"void Draw3dText(string text,Color color,Plane textPlane,double height,string fontface,bool bold,bool italic)",since:6},{signature:"void Draw3dText(string text,Color color,Plane textPlane,double height,string fontface,bool bold,bool italic,TextHorizontalAlignment horizontalAlignment,TextVerticalAlignment verticalAlignment)",since:6.4},{signature:"void Draw3dText(Text3d text,Color color)",since:5},{signature:"void Draw3dText(Text3d text,Color color,Plane textPlane)",summary:"Draws 3d text with a different plane than what is defined in the Text3d class.",since:5},{signature:"void Draw3dText(Text3d text,Color color,Point3d textPlaneOrigin)",summary:"Draws 3d text using the Text3d plane with an adjusted origin.",since:5},{signature:"void DrawActivePoint(Point3d point)",summary:'Draws a point in style used during "GetPoint" operations',since:6},{signature:"void DrawAnnotation(AnnotationBase annotation,Color color)",since:6},{signature:"void DrawAnnotationArrowhead(Arrowhead arrowhead,Transform xform,Color color)",since:6},{signature:"void DrawArc(Arc arc,Color color)",summary:"Draw a single arc object.",since:5},{signature:"void DrawArc(Arc arc,Color color,int thickness)",summary:"Draw a single arc object.",since:5},{signature:"void DrawArrow(Line line,Color color)",summary:"Draws a single arrow object. An arrow consists of a Shaft and an Arrow head at the end of the shaft.",since:5},{signature:"void DrawArrow(Line line,Color color,double screenSize,double relativeSize)",summary:"Draws a single arrow object. \n     An arrow consists of a Shaft and an Arrow head at the end of the shaft.",since:5},{signature:"void DrawArrowHead(Point3d tip,Vector3d direction,Color color,double screenSize,double worldSize)",summary:"Draws a single arrow head.",since:5},{signature:"void DrawArrows(IEnumerable<Line> lines,Color color)",summary:"Draws a collection of arrow objects. An arrow consists of a Shaft and an Arrow head at the end of the shaft.",since:5},{signature:"void DrawArrows(Line[] lines,Color color)",summary:"Draws a collection of arrow objects. An arrow consists of a Shaft and an Arrow head at the end of the shaft.",since:5},{signature:"void DrawBitmap(DisplayBitmap bitmap,int left,int top)",summary:"Draws a bitmap in screen coordinates",since:5.1},{signature:"void DrawBox(BoundingBox box,Color color)",summary:"Draws the edges of a BoundingBox.",since:5},{signature:"void DrawBox(BoundingBox box,Color color,int thickness)",summary:"Draws the edges of a BoundingBox.",since:5},{signature:"void DrawBox(Box box,Color color)",summary:"Draws the edges of a Box object.",since:5},{signature:"void DrawBox(Box box,Color color,int thickness)",summary:"Draws the edges of a Box object.",since:5},{signature:"void DrawBoxCorners(BoundingBox box,Color color)",summary:"Draws corner widgets of a world aligned boundingbox. \n     Widget size will be 5% of the Box diagonal.",since:5},{signature:"void DrawBoxCorners(BoundingBox box,Color color,double size)",summary:"Draws corner widgets of a world aligned boundingbox.",since:5},{signature:"void DrawBoxCorners(BoundingBox box,Color color,double size,int thickness)",summary:"Draws corner widgets of a world aligned boundingbox.",since:5},{signature:"void DrawBrepShaded(Brep brep,DisplayMaterial material)",summary:"Draws a shaded mesh representation of a brep.",since:5},{signature:"void DrawBrepWires(Brep brep,Color color)",summary:"Draws all the wireframe curves of a brep object.",since:5},{signature:"void DrawBrepWires(Brep brep,Color color,int wireDensity)",summary:"Draws all the wireframe curves of a brep object.",since:5},{signature:"void DrawCircle(Circle circle,Color color)",summary:"Draw a single circle object.",since:5},{signature:"void DrawCircle(Circle circle,Color color,int thickness)",summary:"Draw a single circle object.",since:5},{signature:"void DrawCone(Cone cone,Color color)",summary:"Draw a wireframe cone.",since:5},{signature:"void DrawCone(Cone cone,Color color,int thickness)",summary:"Draw a wireframe cone.",since:5},{signature:"void DrawConstructionPlane(ConstructionPlane constructionPlane)",since:5},{signature:"void DrawCurvatureGraph(Curve curve,Color color)",summary:"Draw a typical Rhino Curvature Graph.",since:5},{signature:"void DrawCurvatureGraph(Curve curve,Color color,int hairScale)",summary:"Draw a typical Rhino Curvature Graph.",since:5},{signature:"void DrawCurvatureGraph(Curve curve,Color color,int hairScale,int hairDensity,int sampleDensity)",summary:"Draw a typical Rhino Curvature Graph.",since:5},{signature:"void DrawCurve(Curve curve,Color color)",summary:"Draw a single Curve object.",since:5},{signature:"void DrawCurve(Curve curve,Color color,int thickness)",summary:"Draw a single Curve object.",since:5},{signature:"void DrawCylinder(Cylinder cylinder,Color color)",summary:"Draw a wireframe cylinder.",since:5},{signature:"void DrawCylinder(Cylinder cylinder,Color color,int thickness)",summary:"Draw a wireframe cylinder.",since:5},{signature:"void DrawDirectionArrow(Point3d location,Vector3d direction,Color color)",since:5},{signature:"void DrawDot(float screenX,float screenY,string text)",summary:"Draws a text dot in screen coordinates.",since:6},{signature:"void DrawDot(float screenX,float screenY,string text,Color dotColor,Color textColor)",summary:"Draws a text dot in screen coordinates.",since:6},{signature:"void DrawDot(Point3d worldPosition,string text)",summary:"Draws a text dot in world coordinates.",since:5},{signature:"void DrawDot(Point3d worldPosition,string text,Color dotColor,Color textColor)",summary:"Draw a text dot in world coordinates.",since:5},{signature:"void DrawDot(TextDot dot,Color fillColor,Color textColor,Color borderColor)",summary:"Draw a text dot as defined by the text dot class",since:6},{signature:"void DrawDottedLine(Line line,Color color)",summary:"Draws a single dotted line.",since:5},{signature:"void DrawDottedLine(Point3d from,Point3d to,Color color)",summary:"Draws a single dotted line.",since:5},{signature:"void DrawDottedPolyline(IEnumerable<Point3d> points,Color color,bool close)",summary:"Draws a set of connected lines (polyline) in a dotted pattern (0x00001111).",since:5},{signature:"void DrawExtrusionWires(Extrusion extrusion,Color color)",summary:"Draws all the wireframe curves of an extrusion object.",since:6},{signature:"void DrawExtrusionWires(Extrusion extrusion,Color color,int wireDensity)",summary:"Draws all the wireframe curves of an extrusion object.",since:6},{signature:"void DrawGradientHatch(Hatch hatch,Color color1,Color color2,Point3d point1,Point3d point2,bool linearGradient,float boundaryThickness,Color boundaryColor)",summary:"Draw a two point gradient filled hatch",since:7},{signature:"void DrawGradientHatch(Hatch hatch,IEnumerable<ColorStop> stops,Point3d point1,Point3d point2,bool linearGradient,float repeat,float boundaryThickness,Color boundaryColor)",since:7},{signature:"void DrawGradientLines(IEnumerable<Line> lines,float strokeWidth,IEnumerable<ColorStop> stops,Point3d point1,Point3d point2,bool linearGradient,float repeat)",since:7},{signature:"void DrawGradientMesh(Mesh mesh,IEnumerable<ColorStop> stops,Point3d point1,Point3d point2,bool linearGradient,float repeat)",since:7},{signature:"void DrawHatch(Hatch hatch,Color hatchColor,Color boundaryColor)",since:6},{signature:"void DrawLine(Line line,Color color)",summary:"Draws a single line object.",since:5},{signature:"void DrawLine(Line line,Color color,int thickness)",summary:"Draws a single line object.",since:5},{signature:"void DrawLine(Point3d from,Point3d to,Color color)",summary:"Draws a single line object.",since:5},{signature:"void DrawLine(Point3d from,Point3d to,Color color,int thickness)",summary:"Draws a single line object.",since:5},{signature:"void DrawLineArrow(Line line,Color color,int thickness,double size)",summary:"Draws an arrow made up of three line segments.",since:5},{signature:"void DrawLines(IEnumerable<Line> lines,Color color)",summary:"Draws a set of lines with a given color and thickness. If you want the fastest possible set of lines\n     to be drawn, pass a Line[] for lines.",since:5},{signature:"void DrawLines(IEnumerable<Line> lines,Color color,int thickness)",summary:"Draws a set of lines with a given color and thickness. If you want the fastest possible set of lines\n     to be drawn, pass a Line[] for lines.",since:5},{signature:"void DrawMarker(Point3d tip,Vector3d direction,Color color)",summary:"Draws an arrow marker as a view-aligned widget.",since:5},{signature:"void DrawMarker(Point3d tip,Vector3d direction,Color color,int thickness)",summary:"Draws an arrow marker as a view-aligned widget.",since:5},{signature:"void DrawMarker(Point3d tip,Vector3d direction,Color color,int thickness,double size)",summary:"Draws an arrow marker as a view-aligned widget.",since:5},{signature:"void DrawMarker(Point3d tip,Vector3d direction,Color color,int thickness,double size,double rotation)",summary:"Draws an arrow marker as a view-aligned widget.",since:5},{signature:"void DrawMeshFalseColors(Mesh mesh)",summary:"Draws the mesh faces as False color patches. \n     The mesh must have Vertex Colors defined for this to work.",since:5},{signature:"void DrawMeshShaded(Mesh mesh,DisplayMaterial material)",summary:"Draws the shaded faces of a given mesh.",since:5},{signature:"void DrawMeshShaded(Mesh mesh,DisplayMaterial material,int[] faceIndices)",summary:"Draws the shaded faces of a given mesh.",since:5},{signature:"void DrawMeshVertices(Mesh mesh,Color color)",summary:"Draws all the vertices in a given mesh.",since:5},{signature:"void DrawMeshWires(Mesh mesh,Color color)",summary:"Draws all the wires in a given mesh.",since:5},{signature:"void DrawMeshWires(Mesh mesh,Color color,int thickness)",summary:"Draws all the wires in a given mesh.",since:5},{signature:"void DrawObject(RhinoObject rhinoObject)",since:5},{signature:"void DrawObject(RhinoObject rhinoObject,Transform xform)",summary:"Draws a RhinoObject with an applied transformation.",since:5},{signature:"void DrawParticles(ParticleSystem particles)",since:5},{signature:"void DrawParticles(ParticleSystem particles,DisplayBitmap bitmap)",since:5},{signature:"void DrawParticles(ParticleSystem particles,DisplayBitmap[] bitmaps)",since:5},{signature:"void DrawPatternedLine(Line line,Color color,int pattern,int thickness)",summary:"Draws a single line with specified pattern.",since:6},{signature:"void DrawPatternedLine(Point3d from,Point3d to,Color color,int pattern,int thickness)",summary:"Draws a single line with specified pattern.",since:6},{signature:"void DrawPatternedPolyline(IEnumerable<Point3d> points,Color color,int pattern,int thickness,bool close)",summary:"Draws a set of connected lines (polyline) with specified pattern.",since:6},{signature:"void DrawPoint(Point3d point)",summary:"Draws a point using the current display attribute size, style and color",since:6},{signature:"void DrawPoint(Point3d point,Color color)",summary:"Draws a point with a given radius, style and color.",since:5},{signature:"void DrawPoint(Point3d point,PointStyle style,Color strokeColor,Color fillColor,float radius,float strokeWidth,float secondarySize,float rotationRadians,bool diameterIsInPixels,bool autoScaleForDpi)",since:6},{signature:"void DrawPoint(Point3d point,PointStyle style,float radius,Color color)",summary:"Draws a point with a given radius, style and color.",since:6},{signature:"void DrawPoint(Point3d point,PointStyle style,int radius,Color color)",summary:"Draws a point with a given radius, style and color.",since:5},{signature:"void DrawPointCloud(PointCloud cloud,float size)",summary:"Draws a point cloud.",since:6},{signature:"void DrawPointCloud(PointCloud cloud,float size,Color color)",summary:"Draws a point cloud.",since:6},{signature:"void DrawPointCloud(PointCloud cloud,int size)",summary:"Draws a point cloud.",since:5},{signature:"void DrawPointCloud(PointCloud cloud,int size,Color color)",summary:"Draws a point cloud.",since:5},{signature:"void DrawPoints(IEnumerable<Point3d> points,PointStyle style,Color strokeColor,Color fillColor,float radius,float strokeWidth,float secondarySize,float rotationRadians,bool diameterIsInPixels,bool autoScaleForDpi)",since:6},{signature:"void DrawPoints(IEnumerable<Point3d> points,PointStyle style,float radius,Color color)",summary:"Draw a set of points with a given radius, style and color.",since:6},{signature:"void DrawPoints(IEnumerable<Point3d> points,PointStyle style,int radius,Color color)",summary:"Draw a set of points with a given radius, style and color.",since:5},{signature:"void DrawPolygon(IEnumerable<Point3d> points,Color color,bool filled)",summary:"Draws a filled, convex polygon from a collection of points.",since:5},{signature:"void DrawPolyline(IEnumerable<Point3d> polyline,Color color)",summary:"Draws a single Polyline object.",since:5},{signature:"void DrawPolyline(IEnumerable<Point3d> polyline,Color color,int thickness)",summary:"Draws a single Polyline object.",since:5},{signature:"void DrawRoundedRectangle(PointF center,float pixelWidth,float pixelHeight,float cornerRadius,Color strokeColor,float strokeWidth,Color fillColor)",since:6},{signature:"void DrawSphere(Sphere sphere,Color color)",summary:"Draw a wireframe sphere.",since:5},{signature:"void DrawSphere(Sphere sphere,Color color,int thickness)",summary:"Draw a wireframe sphere.",since:5},{signature:"void DrawSprite(DisplayBitmap bitmap,Point2d screenLocation,float size)",since:5},{signature:"void DrawSprite(DisplayBitmap bitmap,Point2d screenLocation,float size,Color blendColor)",since:5},{signature:"void DrawSprite(DisplayBitmap bitmap,Point3d worldLocation,float size,bool sizeInWorldSpace)",since:5},{signature:"void DrawSprite(DisplayBitmap bitmap,Point3d worldLocation,float size,Color blendColor,bool sizeInWorldSpace)",since:5},{signature:"void DrawSprites(DisplayBitmap bitmap,DisplayBitmapDrawList items,float size,bool sizeInWorldSpace)",since:5},{signature:"void DrawSprites(DisplayBitmap bitmap,DisplayBitmapDrawList items,float size,Vector3d translation,bool sizeInWorldSpace)",since:5},{signature:"bool DrawStereoFrameBuffer(ViewportInfo viewportLeft,ViewportInfo viewportRight,uint handleLeft,uint handleRight)",summary:"Draws the viewport as seen from the left and the right eye viewports\n     and returns the result as OpenGL texture handles.",since:6.8,returns:"True if drawing succedded, False otherwise."},{signature:"void DrawSubDShaded(SubD subd,DisplayMaterial material)",summary:"Draw a shaded mesh representation of a SubD",since:7},{signature:"void DrawSubDWires(SubD subd,Color color,float thickness)",summary:"Draws all the wireframe curves of a SubD object",since:7},{signature:"void DrawSurface(Surface surface,Color wireColor,int wireDensity)",summary:"Draw wireframe display for a single surface.",since:5},{signature:"void DrawText(TextEntity text,Color color)",since:6},{signature:"void DrawText(TextEntity text,Color color,double scale)",since:6},{signature:"void DrawText(TextEntity text,Color color,Transform xform)",since:6},{signature:"void DrawTorus(Torus torus,Color color)",summary:"Draw a wireframe torus.",since:5},{signature:"void DrawTorus(Torus torus,Color color,int thickness)",summary:"Draw a wireframe torus.",since:5},{signature:"void DrawZebraPreview(Brep brep,Color color)",summary:"Draws a shaded Brep with Zebra stripe preview.",since:6.16},{signature:"void EnableClippingPlanes(bool enable)",summary:"Enable or disable the Clipping Plane logic of the engine.",since:5},{signature:"void EnableColorWriting(bool enable)",summary:"Enable or disable the ColorWriting behaviour of the engine.",since:5},{signature:"void EnableDepthTesting(bool enable)",summary:"Enable or disable the DepthTesting behaviour of the engine. \n     When DepthTesting is disabled, objects in front will no \n     longer occlude objects behind them.",since:5},{signature:"void EnableDepthWriting(bool enable)",summary:"Enable or disable the DepthWriting behaviour of the engine. \n     When DepthWriting is disabled, drawn geometry does not affect the Z-Buffer.",since:5},{signature:"void EnableLighting(bool enable)",summary:"Enable or disable the Lighting logic of the engine.",since:5},{signature:"Light[] GetLights()",summary:"Get lights that this pipeline is current using",since:6.3},{signature:"float[] GetOpenGLCameraToClip()",summary:'Get an array of 16 floats that represents the "camera" to "clip" coordinate\n     transformation in OpenGL\'s right handed coordinate system',since:6},{signature:"float[] GetOpenGLWorldToCamera(bool includeModelTransform)",summary:'Get an array of 16 floats that represents the "world" to "camera" coordinate\n     transformation in OpenGL\'s right handed coordinate system',since:6},{signature:"float[] GetOpenGLWorldToClip(bool includeModelTransform)",summary:'Get an array of 16 floats that represents the "world" to "clip" coordinate\n     transformation in OpenGL\'s right handed coordinate system',since:6},{signature:"bool InterruptDrawing()",summary:"Tests to see if the pipeline should stop drawing more geometry and just show what it has so far. \n     If a drawing operation is taking a long time, this function will return True and tell Rhino it should just \n     finish up and show the frame buffer. This is used in dynamic drawing operations.",since:5,returns:"True if the pipeline should stop attempting to draw more geometry and just show the frame buffer."},{signature:"bool IsActive(RhinoObject rhinoObject)",summary:'Determines if an object can be visible in this viewport based on it\'s object type and display attributes. \n     This test does not check for visibility based on location of the object. \n     NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility" \n           tests based on location (is some part of the object in the view frustum). \n           Use CRhinoDisplayPipeline::IsActive() to perform "visibility" \n           tests based on object type.',since:5,returns:"True if this object can be drawn in the pipeline's viewport based on it's object type and display attributes."},{signature:"bool IsVisible(BoundingBox bbox)",summary:"Test a given box for visibility inside the view frustum under the current \n     viewport and model transformation settings.",since:5,returns:"True if at least some portion of the box is visible, False if not."},{signature:"bool IsVisible(Point3d worldCoordinate)",summary:"Test a given 3d world coordinate point for visibility inside the view \n     frustum under the current viewport and model transformation settings.",since:5,returns:"True if the point is visible, False if it is not."},{signature:"bool IsVisible(RhinoObject rhinoObject)",summary:'Test a given object for visibility inside the view frustum under the current viewport and model \n     transformation settings. This function calls a virtual IsVisibleFinal function that \n     subclassed pipelines can add extra tests to. In the base class, this test only tests \n     visibility based on the objects world coordinates location and does not pay attention \n     to the object\'s attributes.\n     \n     NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility" \n           tests based on location (is some part of the object in the view frustum). \n           Use CRhinoDisplayPipeline::IsActive() to perform "visibility" \n           tests based on object type.',since:5,returns:"True if the object is visible, False if not."},{signature:"System.Drawing.Rectangle Measure2dText(string text,Point2d definitionPoint,bool middleJustified,double rotationRadians,int height,string fontFace)",summary:"Determines screen rectangle that would be drawn to using the Draw2dText(..) function\n     with the same parameters.",since:5.1,returns:"rectangle in the viewport's screen coordinates on success."},{signature:"bool Open()",summary:"Opens the pipeline.",since:7,returns:"True if the pipeline was opened, False if it was already open\n     or failed to open."},{signature:"void PopClipTesting()",summary:"Pop a ClipTesting flag off the engine's stack.",since:5},{signature:"void PopCullFaceMode()",summary:"Pop a FaceCull flag off the engine's stack.",since:5},{signature:"void PopDepthTesting()",summary:"Pop a DepthTesting flag off the engine's stack.",since:5},{signature:"void PopDepthWriting()",summary:"Pop a DepthWriting flag off the engine's stack.",since:5},{signature:"void PopModelTransform()",summary:"Pop a model transformation off the engine's model transform stack.",since:5},{signature:"void PushClipTesting(bool enable)",summary:"Push a ClipTesting flag on the engine's stack.",since:5},{signature:"void PushCullFaceMode(CullFaceMode mode)",summary:"Push a FaceCull flag on the engine's stack.",since:5},{signature:"void PushDepthTesting(bool enable)",summary:"Push a DepthTesting flag on the engine's stack.",since:5},{signature:"void PushDepthWriting(bool enable)",summary:"Push a DepthWriting flag on the engine's stack.",since:5},{signature:"void PushModelTransform(Transform xform)",summary:"Push a model transformation on the engine's model transform stack.",since:5},{signature:"void RemoveClippingPlane(int index)",summary:"Remove a clipping plane from the pipeline for this frame",since:6.3}],events:[{signature:"static CalculateBoundingBox",since:5},{signature:"static CalculateBoundingBoxZoomExtents",summary:"Calculate a bounding to include in the Zoom Extents command.",since:5},{signature:"static DisplayModeChanged",since:6.18},{signature:"static DrawForeground",summary:"Called after all non-highlighted objects have been drawn and PostDrawObjects has been called.\n     Depth writing and testing are turned OFF. If you want to draw with depth writing/testing,\n     see PostDrawObjects.",since:5},{signature:"static DrawOverlay",summary:"If Rhino is in a feedback mode, the draw overlay call allows for temporary geometry to be drawn on top of\n     everything in the scene. This is similar to the dynamic draw routine that occurs with custom get point.",since:5},{signature:"static InitFrameBuffer",since:6.18},{signature:"static ObjectCulling",since:5.3},{signature:"static PostDrawObjects",summary:"Called after all non-highlighted objects have been drawn. Depth writing and testing are\n     still turned on. If you want to draw without depth writing/testing, see DrawForeground.",since:5},{signature:"static PreDrawObject",summary:"Called right before an individual object is being drawn. NOTE: Do not use this event\n     unless you absolutely need to.  It is called for every object in the document and can\n     slow disply down if a large number of objects exist in the document",since:5},{signature:"static PreDrawObjects",summary:"Called before objects are been drawn. Depth writing and testing are on.",since:5},{signature:"static PreDrawTransparentObjects",summary:"Called before transparent objects have been drawn. Depth writing and testing are on.",since:6.12},{signature:"static ViewportProjectionChanged",summary:"Called when the projection changes for a viewport being drawn.",since:6.18}]},{name:"Rhino.Display.DisplayPipelineAttributes",dataType:1,summary:'Represents display pipeline settings, such as "show transparency" and "show grips".',properties:[{signature:"Color AmbientLightingColor",since:6.3},{signature:"BoundingBoxDisplayMode BoundingBoxMode",since:6.1},{signature:"bool CastShadows",summary:"Cast shadows.",since:6.4},{signature:"ContextsForDraw ContextForDraw",since:6.5},{signature:"Color CurveColor",summary:"Color used for drawing curves",since:5.1},{signature:"int CurveThickness",summary:"Pixel thickness for curves",since:5.1},{signature:"bool DisableConduits",since:5},{signature:"bool DisableTransparency",since:5},{signature:"string EnglishName",since:5},{signature:"FrameBufferFillMode FillMode",summary:"Get or set the frame buffer fill mode.",since:6},{signature:"Guid Id",since:5},{signature:"bool IgnoreHighlights",since:5},{signature:"string LocalName",since:5},{signature:"bool LockedObjectsDrawBehindOthers",summary:"Locked object are drawn behind other objects",since:5.1},{signature:"MeshDisplayAttributes MeshSpecificAttributes",since:5},{signature:"Color ObjectColor",since:5},{signature:"float PointRadius",since:6},{signature:"PointStyle PointStyle",since:6},{signature:"Guid RealtimeDisplayId",summary:"Get the ID of the realtime display engine attached to the view. This will be\n     Guid.Empty if no realtime display engine is in use. This can be the case for instance\n     when starting a _Render session for a realtime viewport integration. That still would\n     cause this ID to be Guid.Empty.",since:6},{signature:"int RealtimeRenderPasses",summary:"Get or set the realtime passes amount",since:6},{signature:"bool ShadeVertexColors",summary:"Shade using vertex colors.",since:6.4},{signature:"bool ShadingEnabled",summary:"Draw shaded meshes and surfaces. Set to False to use Flat Shading.",since:5.1},{signature:"Color ShadowColor",since:6.3},{signature:"bool ShowAnnotations",summary:"Show annotations.",since:6.4},{signature:"bool ShowClippingPlanes",summary:"Show clipping planes.",since:6.4},{signature:"bool ShowCurves",summary:"Draw curves",since:5.1},{signature:"bool ShowGrips",since:5},{signature:"bool ShowIsoCurves",summary:"Draw surface ISO curves.",since:6.4},{signature:"bool ShowLights",summary:"Show light widgets.",since:6.4},{signature:"bool ShowPointClouds",summary:"Show point clouds.",since:6.4},{signature:"bool ShowPoints",summary:"Show points.",since:6.4},{signature:"bool ShowRealtimeRenderProgressBar",summary:"Get or set whether the display is used for preview rendering or not.",since:6},{signature:"bool ShowSurfaceEdges",summary:"Show surface edges.",since:6.4},{signature:"bool ShowTangentEdges",summary:"Show tangent edges.",since:6.4},{signature:"bool ShowTangentSeams",summary:"Show tangent seams.",since:6.4},{signature:"bool ShowText",summary:"Show text.",since:6.4},{signature:"StereoRenderContextEnum StereoRenderContext",summary:"Get or set the stereo render context.",since:7},{signature:"int SurfaceEdgeThickness",summary:"Thickness for surface edges",since:6.1},{signature:"bool UseAssignedObjectMaterial",summary:"Gets whether objects ought to be drawn using their assigned rendering material.",since:6},{signature:"bool UseCustomObjectColor",summary:"Gets whether objects ought to be drawn using a custom color.",since:6},{signature:"bool UseCustomObjectMaterial",summary:"Gets whether objects ought to be drawn using a custom material.",since:6},{signature:"bool UseSingleCurveColor",summary:"Use a single color for drawing curves",since:6.3},{signature:"ViewDisplayAttributes ViewSpecificAttributes",since:5},{signature:"bool XrayAllObjects",since:5}],methods:[{signature:"void Dispose()",since:5},{signature:"void GetFill(Color topLeft,Color bottomLeft,Color topRight,Color bottomRight)",summary:"Get fill colors used for clearing the frame buffer",since:6.23},{signature:"void GetObjectData(SerializationInfo info,StreamingContext context)",since:5},{signature:"void SetFill(Color singleColor)",summary:"Set fill mode to solid color and set the fill color",since:6.23},{signature:"void SetFill(Color gradientTop,Color gradientBottom)",summary:"Set fill mode to two color and set the colors",since:6.23},{signature:"void SetFill(Color gradientTopLeft,Color gradientBottomLeft,Color gradientTopRight,Color gradientBottomRight)",summary:"Set the fill mode to four color gradient and set the colors",since:6.23}]},{name:"Rhino.Display.DisplayPipelineAttributes.BoundingBoxDisplayMode",dataType:3,summary:""},{name:"Rhino.Display.DisplayPipelineAttributes.ContextsForDraw",dataType:3,summary:""},{name:"Rhino.Display.DisplayPipelineAttributes.FrameBufferFillMode",dataType:3,summary:""},{name:"Rhino.Display.DisplayPipelineAttributes.MeshDisplayAttributes",dataType:1,summary:"",properties:[{signature:"Color AllMeshWiresColor",summary:"Color.Empty means that we are NOT using a single color for all mesh wires.",since:5},{signature:"bool HighlightMeshes",since:5},{signature:"int MeshWireThickness",since:5},{signature:"bool ShowMeshVertices",since:5},{signature:"bool ShowMeshWires",since:5}]},{name:"Rhino.Display.DisplayPipelineAttributes.StereoRenderContextEnum",dataType:3,summary:""},{name:"Rhino.Display.DisplayPipelineAttributes.ViewDisplayAttributes",dataType:1,summary:"",properties:[{signature:"bool BlendGrid",since:5},{signature:"bool DrawGrid",since:5},{signature:"bool DrawGridAxes",since:5},{signature:"bool DrawTransparentGridPlane",since:5},{signature:"bool DrawWorldAxes",since:5},{signature:"bool DrawZAxis",since:5},{signature:"double HorizontalViewportScale",since:5},{signature:"bool ShowGridOnTop",since:5},{signature:"bool UseDocumentGrid",since:5},{signature:"double VerticalViewportScale",since:5},{signature:"Color WorldAxisColorX",since:5},{signature:"Color WorldAxisColorY",since:5},{signature:"Color WorldAxisColorZ",since:5}]},{name:"Rhino.Display.DrawEventArgs",dataType:1,summary:"",properties:[{signature:"DisplayPipeline Display",since:5},{signature:"RhinoDoc RhinoDoc",since:5},{signature:"RhinoViewport Viewport",since:5}]},{name:"Rhino.Display.DrawForegroundEventArgs",dataType:1,summary:"",properties:[{signature:"bool DrawWorldAxes",since:5},{signature:"bool WorldAxesDrawn",since:5}]},{name:"Rhino.Display.DrawFrameStages",dataType:3,summary:""},{name:"Rhino.Display.DrawObjectEventArgs",dataType:1,summary:"",properties:[{signature:"bool DrawObject",since:5},{signature:"RhinoObject RhinoObject",since:5}]},{name:"Rhino.Display.GradientType",dataType:3,summary:"Style of color gradient"},{name:"Rhino.Display.InitFrameBufferEventArgs",dataType:1,summary:"",methods:[{signature:"void SetFill(Color color)",since:6.18},{signature:"void SetFill(Color top,Color bottom)",since:6.18},{signature:"void SetFill(Color topLeft,Color bottomLeft,Color topRight,Color bottomRight)",since:6.18}]},{name:"Rhino.Display.PageViewSpaceChangeEventArgs",dataType:1,summary:"",properties:[{signature:"Guid NewActiveDetailId",summary:"The id of the detail object was set active.  Note, if this id is\n     equal to Guid.Empty, then the active detail object is the page\n     view itself.",since:5},{signature:"Guid OldActiveDetailId",summary:"The id of the previously active detail object. Note, if this id\n     is equal to Guid.Empty, then the active detail object was the\n     page view itself.",since:5},{signature:"RhinoPageView PageView",summary:"The page view on which a different detail object was set active.",since:5}]},{name:"Rhino.Display.RhinoPageView",dataType:1,summary:"A window that contains a single layout 'page'",properties:[{signature:"RhinoViewport ActiveViewport",summary:"The ActiveViewport is the same as the MainViewport for standard RhinoViews. In\n     a RhinoPageView, the active viewport may be the RhinoViewport of a child detail object.\n     Most of the time, you will use ActiveViewport unless you explicitly need to work with\n     the main viewport.",since:5},{signature:"double PageHeight",summary:"Height of the page in the document's PageUnitSystem",since:5.1},{signature:"bool PageIsActive",summary:"True if the page is active instead of any detail views. This occurs\n     when the MainViewport.Id == ActiveViewportID.",since:5},{signature:"string PageName",summary:"Same as the MainViewport.Name.",since:5},{signature:"int PageNumber",summary:"Gets or sets the runtime page number and updates the page number for all\n     of the other pages. The first page has a value of 0.",since:5},{signature:"double PageWidth",summary:"Width of the page in the document's PageUnitSystem",since:5.1},{signature:"string PaperName",summary:"Returns the name of the layout's media, or paper (e.g. Letter, Legal, A1, etc.),\n     used to determine the page width and page height.",since:6.15},{signature:"string PrinterName",summary:"Returns the name of the layout's destination printer.",since:6.15}],methods:[{signature:"DetailViewObject AddDetailView(string title,Point2d corner0,Point2d corner1,DefinedViewportProjection initialProjection)",summary:"Creates a detail view object that is displayed on this page and adds it to the doc.",since:5,returns:"Newly created detail view on success. None on error."},{signature:"RhinoPageView Duplicate(bool duplicatePageGeometry)",summary:"Copy a page view",since:6.3},{signature:"DetailViewObject[] GetDetailViews()",summary:"Gets a list of the detail view objects associated with this layout.",since:5,returns:"An array of detail view objects if successful, an empty array if the layout has no details."},{signature:"System.Drawing.Bitmap GetPreviewImage(Size size,bool grayScale)",summary:"Creates a preview image of the page.",since:7,returns:"A bitmap if successful, None othewise."},{signature:"bool SetActiveDetail(Guid detailId)",since:5},{signature:"bool SetActiveDetail(string detailName,bool compareCase)",since:5},{signature:"void SetPageAsActive()",since:5}],events:[{signature:"static PageViewSpaceChange",since:5}]},{name:"Rhino.Display.RhinoView",dataType:1,summary:'A RhinoView represents a single "window" display of a document. A view could\n   contain one or many RhinoViewports (many in the case of Layout views with detail viewports).\n   Standard Rhino modeling views have one viewport.',properties:[{signature:"static bool EnableDrawing",summary:"Gets or sets the 'drawing enabled' flag. By default, drawing is enabled.\n     There are some rare situations where scipts want to disable drawing for a while.",since:5},{signature:"RhinoViewport ActiveViewport",summary:"The ActiveViewport is the same as the MainViewport for standard RhinoViews. In\n     a RhinoPageView, the active viewport may be the RhinoViewport of a child detail object.\n     Most of the time, you will use ActiveViewport unless you explicitly need to work with\n     the main viewport.",since:5},{signature:"Guid ActiveViewportID",summary:"Returns viewport ID for the active viewport. Faster than ActiveViewport function when\n     working with page views.",since:5},{signature:"Rectangle Bounds",summary:"Gets the size and location of the view including its nonclient elements, in pixels, relative to the parent control.",since:5},{signature:"Rectangle ClientRectangle",summary:"Gets the rectangle that represents the client area of the view.",since:5},{signature:"DisplayPipeline DisplayPipeline",summary:"Gets the display pipeline used for this view.",since:6},{signature:"RhinoDoc Document",since:5},{signature:"bool Floating",summary:"Floating state of RhinoView.\n     if true, then the view will be in a floating frame window. Otherwise\n     the view will be embeded in the main frame.",since:5},{signature:"IntPtr Handle",summary:"Gets the window handle that this view is bound to.",since:5},{signature:"bool IsPageView",summary:"Return True if this view is a RhinoPageView.",since:7},{signature:"RhinoViewport MainViewport",summary:'A RhinoView contains a "main viewport" that fills the entire view client window.\n     RhinoPageViews may also contain nested child RhinoViewports for implementing\n     detail viewports.\n     The MainViewport will always return this RhinoView\'s m_vp.',since:5},{signature:"bool Maximized",since:5},{signature:"RealtimeDisplayMode RealtimeDisplayMode",summary:"Gets the RealtimeDisplayMode active for this view. None if the view doesn't have a RealtimeDisplayMode set.",since:6},{signature:"uint RuntimeSerialNumber",since:6},{signature:"Rectangle ScreenRectangle",summary:"Gets the rectangle that represents the client area of the view in screen coordinates.",since:5},{signature:"Size Size",summary:"Gets or sets the size of the view",since:6},{signature:"bool TitleVisible",summary:"Visibility of the viewport title window.",since:5}],methods:[{signature:"static RhinoView FromRuntimeSerialNumber(uint serialNumber)",summary:"Get a RhinoView from it's unique runtime serial number",since:6,returns:"RhinoView or None if no view exists for a given serial number"},{signature:"System.Drawing.Bitmap CaptureToBitmap()",summary:"Capture View contents to a bitmap.",since:5,returns:"The bitmap of the complete view."},{signature:"System.Drawing.Bitmap CaptureToBitmap(bool grid,bool worldAxes,bool cplaneAxes)",summary:"Captures the view contents to a bitmap allowing for visibility of grid and axes.",since:5,returns:"A new bitmap."},{signature:"System.Drawing.Bitmap CaptureToBitmap(DisplayModeDescription mode)",summary:"Capture View contents to a bitmap using a display mode description to define\n     how drawing is performed.",since:5,returns:"A new bitmap."},{signature:"System.Drawing.Bitmap CaptureToBitmap(DisplayPipelineAttributes attributes)",summary:"Captures view contents to a bitmap using display attributes to define how\n     drawing is performed.",since:5,returns:"A new bitmap."},{signature:"System.Drawing.Bitmap CaptureToBitmap(Size size)",summary:"Capture View contents to a bitmap.",since:5,returns:"The bitmap of the specified part of the view."},{signature:"System.Drawing.Bitmap CaptureToBitmap(Size size,bool grid,bool worldAxes,bool cplaneAxes)",summary:"Captures a part of the view contents to a bitmap allowing for visibility of grid and axes.",since:5,returns:"A new bitmap."},{signature:"System.Drawing.Bitmap CaptureToBitmap(Size size,DisplayModeDescription mode)",summary:"Capture View contents to a bitmap using a display mode description to define\n     how drawing is performed.",since:5,returns:"A new bitmap."},{signature:"System.Drawing.Bitmap CaptureToBitmap(Size size,DisplayPipelineAttributes attributes)",summary:"Capture View contents to a bitmap using display attributes to define how\n     drawing is performed.",since:5,returns:"A new bitmap."},{signature:"System.Drawing.Point ClientToScreen(Point clientPoint)",since:5},{signature:"Geometry.Point2d ClientToScreen(Point2d clientPoint)",since:5},{signature:"bool Close()",summary:"Remove this View from Rhino. DO NOT attempt to use this instance of this\n     class after calling Close.",since:5,returns:"True on success"},{signature:"bool CreateShadedPreviewImage(string imagePath,Size size,bool ignoreHighlights,bool drawConstructionPlane,bool useGhostedShading)",summary:"Creates a bitmap preview image of model.",since:5,returns:"True if successful."},{signature:"bool CreateWireframePreviewImage(string imagePath,Size size,bool ignoreHighlights,bool drawConstructionPlane)",summary:"Creates a bitmap preview image of model.",since:5,returns:"True if successful."},{signature:"bool Equals(object obj)"},{signature:"int GetHashCode()"},{signature:"bool MouseCaptured(bool bIncludeMovement)",summary:"Returns whether or not the mouse is captured in this view.",since:6,returns:"True if captured, False otherwise."},{signature:"void Redraw()",summary:"Redraws this view.",since:5},{signature:"System.Drawing.Point ScreenToClient(Point screenPoint)",summary:"Converts a point in screen coordinates to client coordinates for this view.",since:5,returns:"A 2D point in client coordinates."},{signature:"Geometry.Point2d ScreenToClient(Point2d screenPoint)",since:5.8},{signature:"double SpeedTest(int frameCount,bool freezeDrawList,int direction,double angleDeltaRadians)",since:5.8}],events:[{signature:"static Create",since:5},{signature:"static Destroy",since:5},{signature:"static Modified",since:7},{signature:"static Rename",since:5},{signature:"static SetActive",since:5}]},{name:"Rhino.Display.RhinoViewport",dataType:1,summary:"Displays geometry with a given projection. In standard modeling views there\n   is a one to one relationship between RhinoView and RhinoViewports. In a page\n   layout, there may be multiple RhinoViewports for a single layout.",constructors:[{signature:"RhinoViewport()",since:5},{signature:"RhinoViewport(RhinoViewport other)",since:5}],properties:[{signature:"Rectangle Bounds",summary:"Gets the size and location of the viewport, in pixels, relative to the parent view.",since:5},{signature:"double Camera35mmLensLength",since:5},{signature:"Vector3d CameraDirection",since:5},{signature:"Point3d CameraLocation",since:5},{signature:"Point3d CameraTarget",summary:"Viewport target point.",since:5},{signature:"Vector3d CameraUp",since:5},{signature:"Vector3d CameraX",summary:'Gets the "unit to the right" vector.',since:5},{signature:"Vector3d CameraY",summary:'Gets the "unit up" vector.',since:5},{signature:"Vector3d CameraZ",summary:"Gets the unit vector in CameraDirection.",since:5},{signature:"uint ChangeCounter",summary:"The value of change counter is incremented every time the view projection\n     or construction plane changes. The user can the mouse and nestable view \n     manipulation commands to change a view at any time. The value of change\n     counter can be used to detect these changes in code that is sensitive to\n     the view projection.",since:5},{signature:"bool ConstructionAxesVisible",since:5},{signature:"bool ConstructionGridVisible",since:5},{signature:"DisplayModeDescription DisplayMode",since:5},{signature:"double FrustumAspect",summary:"Gets the width/height ratio of the frustum.",since:5},{signature:"Guid Id",summary:"Unique id for this viewport.",since:5},{signature:"bool IsParallelProjection",since:5},{signature:"bool IsPerspectiveProjection",since:5},{signature:"bool IsPlanView",summary:"True if construction plane z axis is parallel to camera direction.",since:5},{signature:"bool IsTwoPointPerspectiveProjection",since:5},{signature:"bool IsValidCamera",since:5},{signature:"bool IsValidFrustum",since:5},{signature:"string Name",summary:"Name associated with this viewport.",since:5},{signature:"RhinoView ParentView",summary:"Gets the parent view, if there is one\n     \n     Every RhinoView has an associated RhinoViewport that does all the 3d display work.\n     Those associated viewports return the RhinoView as their parent view. However,\n     RhinoViewports are used in other image creating contexts that do not have a parent\n     RhinoView.  If you call ParentView, you MUST check for NULL return values.",since:5},{signature:"double ScreenPortAspect",summary:"screen port's width/height.",since:5},{signature:"Size Size",summary:"Gets or sets the height and width of the viewport (in pixels)",since:5},{signature:"int UserStringCount",since:6.18},{signature:"ViewportType ViewportType",since:5},{signature:"string WallpaperFilename",since:5},{signature:"bool WallpaperGrayscale",since:5},{signature:"bool WallpaperVisible",since:5},{signature:"bool WorldAxesVisible",since:5}],methods:[{signature:"static RhinoViewport FromId(Guid id)",summary:"Call this method to get the viewport with the specified Id.",since:6,returns:"Returns a RhinoViewport if the Id is found otherwise null."},{signature:"bool ChangeToParallelProjection(bool symmetricFrustum)",summary:"Use this function to change projections of valid viewports from persective to parallel.\n     It will make common additional adjustments to the frustum so the resulting views are\n     similar. The camera location and direction will not be changed.",since:5,returns:"If the current projection is parallel and bSymmetricFrustum, FrustumIsLeftRightSymmetric()\n     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{signature:"bool ChangeToPerspectiveProjection(bool symmetricFrustum,double lensLength)",summary:"Use this function to change projections of valid viewports from parallel to perspective.\n     It will make common additional adjustments to the frustum and camera location so the\n     resulting views are similar. The camera direction and target point are not be changed.",since:5,returns:"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()\n     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{signature:"bool ChangeToPerspectiveProjection(double targetDistance,bool symmetricFrustum,double lensLength)",summary:"Use this function to change projections of valid viewports from parallel to perspective.\n     It will make common additional adjustments to the frustum and camera location so the\n     resulting views are similar. The camera direction and target point are not be changed.",since:5,returns:"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()\n     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{signature:"bool ChangeToTwoPointPerspectiveProjection(double lensLength)",summary:"Use this function to change projections of valid viewports\n     to a two point perspective.  It will make common additional\n     adjustments to the frustum and camera location and direction\n     so the resulting views are similar.",since:6,returns:"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()\n     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{signature:"bool ChangeToTwoPointPerspectiveProjection(double targetDistance,Vector3d up,double lensLength)",summary:"Use this function to change projections of valid viewports\n     to a two point perspective.  It will make common additional\n     adjustments to the frustum and camera location and direction\n     so the resulting views are similar.",since:6,returns:"If the current projection is perspective and bSymmetricFrustum, FrustumIsLeftRightSymmetric()\n     and FrustumIsTopBottomSymmetric() are all equal, then no changes are made and True is returned."},{signature:"void ClearTraceImage()",summary:"Remove trace image (background bitmap) for this viewport if one exists.",since:5},{signature:"System.Drawing.Point ClientToScreen(Point clientPoint)",since:5},{signature:"System.Drawing.Point ClientToScreen(Point2d clientPoint)",since:5},{signature:"Line ClientToWorld(Point clientPoint)",since:5},{signature:"Line ClientToWorld(Point2d clientPoint)",since:5},{signature:"Plane ConstructionPlane()",summary:"Simple plane information for this viewport's construction plane. If you want\n     detailed construction lpane information, use GetConstructionPlane.",since:5},{signature:"void DeleteAllUserStrings()",since:6.18},{signature:"bool DeleteUserString(string key)",since:6.18},{signature:"void Dispose()",since:5},{signature:"bool GetCameraAngle(double halfDiagonalAngle,double halfVerticalAngle,double halfHorizontalAngle)",since:5},{signature:"BoundingBox GetCameraExtents(IEnumerable<Point3d> points)",since:5},{signature:"bool GetCameraFrame(Plane frame)",summary:"Gets the camera plane.",since:5,returns:"True if current camera orientation is valid."},{signature:"DocObjects.ConstructionPlane GetConstructionPlane()",since:5},{signature:"bool GetDepth(BoundingBox bbox,double nearDistance,double farDistance)",summary:"Gets near and far clipping distances of a bounding box.",since:5,returns:"True if the bounding box intersects the view frustum and near_dist/far_dist were set.\n     False if the bounding box does not intesect the view frustum."},{signature:"bool GetDepth(Point3d point,double distance)",summary:"Gets clipping distance of a point.",since:5,returns:"True if the point is ing the view frustum and near_dist/far_dist were set.\n     False if the bounding box does not intesect the view frustum."},{signature:"bool GetDepth(Sphere sphere,double nearDistance,double farDistance)",summary:"Gets near and far clipping distances of a sphere.",since:5,returns:"True if the sphere intersects the view frustum and near_dist/far_dist were set.\n     False if the sphere does not intesect the view frustum."},{signature:"Point3d[] GetFarRect()",summary:"Get corners of far clipping plane rectangle.",since:5,returns:"[left_bottom, right_bottom, left_top, right_top] points on success\n     None on failure."},{signature:"bool GetFrustum(double left,double right,double bottom,double top,double nearDistance,double farDistance)",summary:"Gets the view frustum.",since:5,returns:"True if operation succeeded."},{signature:"bool GetFrustumBottomPlane(Plane plane)",summary:"Get bottom world frustum clipping plane.",since:5,returns:"True if camera and frustum are valid and plane was set."},{signature:"BoundingBox GetFrustumBoundingBox()",since:5},{signature:"bool GetFrustumCenter(Point3d center)",summary:"Returns world coordinates of frustum's center.",since:5,returns:"True if the center was successfully computed."},{signature:"bool GetFrustumFarPlane(Plane plane)",summary:"Get far clipping plane.",since:5,returns:"True if camera and frustum are valid."},{signature:"bool GetFrustumLeftPlane(Plane plane)",summary:"Get left world frustum clipping plane.",since:5,returns:"True if camera and frustum are valid and plane was set."},{signature:"bool GetFrustumLine(double screenX,double screenY,Line worldLine)",summary:"Gets the world coordinate line in the view frustum that projects to a point on the screen.",since:5,returns:"True if successful.\n     False if view projection or frustum is invalid."},{signature:"bool GetFrustumNearPlane(Plane plane)",summary:"Get near clipping plane.",since:5,returns:"True if camera and frustum are valid."},{signature:"bool GetFrustumRightPlane(Plane plane)",summary:"Get right world frustum clipping plane.",since:5,returns:"True if camera and frustum are valid and plane was set."},{signature:"bool GetFrustumTopPlane(Plane plane)",summary:"Get top world frustum clipping plane.",since:5,returns:"True if camera and frustum are valid and plane was set."},{signature:"Point3d[] GetNearRect()",summary:"Get corners of near clipping plane rectangle.",since:5,returns:"[left_bottom, right_bottom, left_top, right_top] points on success\n     None on failure."},{signature:"Transform GetPickTransform(int clientX,int clientY)",summary:"Takes a rectangle in screen coordinates and returns a transformation\n     that maps the 3d frustum defined by the rectangle to a -1/+1 clipping\n     coordinate box. This takes a single point and inflates it by\n     Rhino.ApplicationSettings.ModelAidSettings.MousePickBoxRadius to define\n     the screen rectangle.",since:5,returns:"A transformation matrix."},{signature:"Transform GetPickTransform(Point clientPoint)",summary:"Takes a rectangle in screen coordinates and returns a transformation\n     that maps the 3d frustum defined by the rectangle to a -1/+1 clipping\n     coordinate box. This takes a single point and inflates it by\n     Rhino.ApplicationSettings.ModelAidSettings.MousePickBoxRadius to define\n     the screen rectangle.",since:5,returns:"A transformation matrix."},{signature:"Transform GetPickTransform(Rectangle clientRectangle)",summary:"Takes a rectangle in screen coordinates and returns a transformation\n     that maps the 3d frustum defined by the rectangle to a -1/+1 clipping\n     coordinate box.",since:5,returns:"A transformation matrix."},{signature:"bool GetScreenPort(int portLeft,int portRight,int portBottom,int portTop,int portNear,int portFar)",summary:"Location of viewport in pixels.  These are provided so you can set the port you are using\n     and get the appropriate transformations to and from screen space.",since:5,returns:"True if the operation is successful."},{signature:"Transform GetTransform(CoordinateSystem sourceSystem,CoordinateSystem destinationSystem)",summary:"Gets a transform from origin coordinate system to a target coordinate system.",since:5,returns:"4x4 transformation matrix (acts on the left)\n     Identity matrix is returned if this function fails."},{signature:"string GetUserString(string key)",summary:"Gets a user string.",since:6.18,returns:"string associated with the key if successful. None if no key was found."},{signature:"System.Collections.Specialized.NameValueCollection GetUserStrings()",summary:"Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.",since:6.18,returns:"A collection of key strings and values strings. This"},{signature:"bool GetWorldToScreenScale(Point3d pointInFrustum,double pixelsPerUnit)",summary:"Gets the world to screen size scaling factor at a point in frustum.",since:5,returns:"True if the operation is successful."},{signature:"bool IsVisible(BoundingBox bbox)",summary:"Returns True if some portion of a world coordinate bounding box is\n     potentially visible in the viewing frustum.",since:5,returns:"True if the box is potentially visible; otherwise false."},{signature:"bool IsVisible(Point3d point)",summary:"Deterines if a world coordinate point is visible in the viewing frustum.",since:5,returns:"True if the point is visible; otherwise false."},{signature:"bool KeyboardDolly(bool leftRight,double amount)",summary:"Emulates the keyboard arrow key in terms of interaction.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool KeyboardDollyInOut(double amount)",summary:"Emulates the keyboard arrow key in terms of interaction.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool KeyboardRotate(bool leftRight,double angleRadians)",summary:"Emulates the keyboard arrow key in terms of interaction.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool Magnify(double magnificationFactor,bool mode)",summary:"Zooms or dollies in order to scale the viewport projection of observed objects.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool Magnify(double magnificationFactor,bool mode,Point fixedScreenPoint)",summary:"Zooms or dollies in order to scale the viewport projection of observed objects.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool MouseAdjustLensLength(Point mousePreviousPoint,Point mouseCurrentPoint,bool moveTarget)",summary:"Adjusts the camera lens length.",since:6},{signature:"bool MouseDollyZoom(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Zooms lens (thus adjusting the field of view) while moving the camera.",since:5},{signature:"bool MouseInOutDolly(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Moves the camera towards or away from the view maintaing focus on the view.",since:5},{signature:"bool MouseLateralDolly(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Pans the camera",since:6},{signature:"bool MouseMagnify(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Moves the camera towards or away from the view.",since:5},{signature:"bool MouseRotateAroundTarget(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Rotates the viewport around target.",since:5},{signature:"bool MouseRotateCamera(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Rotates the view around the camera location.",since:5},{signature:"bool MouseTilt(Point mousePreviousPoint,Point mouseCurrentPoint)",summary:"Tilts the camera view.",since:5},{signature:"bool NextConstructionPlane()",summary:"Sets the construction plane to the plane that was\n     active before the last call to PreviousConstructionPlane.",since:5,returns:"True if successful."},{signature:"bool NextViewProjection()",summary:"Sets the view projection and target to the settings that \n     were active before the last call to PrevView.",since:5,returns:"True if the view stack was popped."},{signature:"bool PopConstructionPlane()",summary:"Sets the construction plane to the plane that was\n     active before the last call to PushConstructionPlane.",since:5,returns:"True if a construction plane was popped."},{signature:"bool PopViewProjection()",summary:"Sets the view projection and target to the settings at the top of\n     the view stack and removes those settings from the view stack.",since:5,returns:"True if there were settings that could be popped from the stack."},{signature:"bool PreviousConstructionPlane()",summary:"Sets the construction plane to the plane that was\n     active before the last call to NextConstructionPlane\n     or SetConstructionPlane.",since:5,returns:"True if successful."},{signature:"bool PreviousViewProjection()",summary:"Sets the view projection and target to the settings that\n     were active before the last call to NextViewProjection.",since:5,returns:"True if the view stack was popped."},{signature:"void PushConstructionPlane(ConstructionPlane cplane)",summary:"Pushes the current construction plane on the viewport's\n     construction plane stack and sets the construction plane\n     to cplane.",since:5},{signature:"bool PushViewInfo(ViewInfo viewinfo,bool includeTraceImage)",since:5},{signature:"void PushViewProjection()",summary:"Appends the current view projection and target to the viewport's view stack.",since:5},{signature:"bool Rotate(double angleRadians,Vector3d rotationAxis,Point3d rotationCenter)",summary:"Rotates about the specified axis. A positive rotation angle results\n     in a counter-clockwise rotation about the axis (right hand rule).",since:5,returns:"True if geometry successfully rotated."},{signature:"System.Drawing.Point ScreenToClient(Point screenPoint)",since:5},{signature:"void SetCameraDirection(Vector3d cameraDirection,bool updateTargetLocation)",summary:"Set viewport camera direction. By default the target location is changed so that\n     the vector from the camera location to the target is parallel to the camera direction.",since:5},{signature:"void SetCameraLocation(Point3d cameraLocation,bool updateTargetLocation)",summary:"Set viewport camera location. By default the target location is changed so that\n      the vector from the camera location to the target is parallel to the camera direction\n      vector.",since:5},{signature:"void SetCameraLocations(Point3d targetLocation,Point3d cameraLocation)",summary:"Set viewport camera location and target location. The camera direction vector is\n     changed so that it is parallel to the vector from the camera location to\n     the target location.",since:5},{signature:"void SetCameraTarget(Point3d targetLocation,bool updateCameraLocation)",summary:"Set viewport target point. By default the camera location\n     is translated so that the camera direction vector is parallel\n     to the vector from the camera location to the target location.",since:5},{signature:"void SetClippingPlanes(BoundingBox box)",summary:"Sets optimal clipping planes to view objects in a world coordinate 3d bounding box.",since:5},{signature:"void SetConstructionPlane(ConstructionPlane cplane)",summary:"Sets the construction plane to cplane.",since:5},{signature:"void SetConstructionPlane(Plane plane)",since:5},{signature:"bool SetProjection(DefinedViewportProjection projection,string viewName,bool updateConstructionPlane)",summary:"Set viewport to a defined projection.",since:5,returns:"True if successful."},{signature:"bool SetToPlanView(Point3d planeOrigin,Vector3d planeXaxis,Vector3d planeYaxis,bool setConstructionPlane)",since:5},{signature:"bool SetTraceImage(string bitmapFileName,Plane plane,double width,double height,bool grayscale,bool filtered)",summary:"Set trace image (background bitmap) for this viewport.",since:5,returns:"True if successful."},{signature:"bool SetUserString(string key,string value)",summary:"Attach a user string (key,value combination) to this geometry.",since:6.18,returns:"True on success."},{signature:"bool SetViewProjection(ViewportInfo projection,bool updateTargetLocation)",summary:"Sets the viewport camera projection.",since:5,returns:"True on success."},{signature:"bool SetWallpaper(string imageFilename,bool grayscale)",since:5},{signature:"bool SetWallpaper(string imageFilename,bool grayscale,bool visible)",since:5},{signature:"Point2d WorldToClient(Point3d worldPoint)",summary:"Convert a point from world coordinates in the viewport to a 2d screen\n     point in the local coordinates of the viewport (X/Y of point is relative\n     to top left corner of viewport on screen)",since:5,returns:"The 2D point on the screen."},{signature:"bool ZoomBoundingBox(BoundingBox box)",summary:"Zooms the viewport to the given bounding box.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool ZoomExtents()",summary:"Dollies the camera location and so that the view frustum contains all of the\n     selected document objects that can be seen in view. If the projection is\n     perspective, the camera angle is not changed.",since:5,returns:"True if successful."},{signature:"bool ZoomExtentsSelected()",summary:"Dollies the camera location and so that the view frustum contains all of the\n     selected document objects that can be seen in view. If the projection is\n     perspective, the camera angle is not changed.",since:5,returns:"True if successful."}]},{name:"Rhino.Display.Text3d",dataType:1,summary:"3D aligned text with font settings.",constructors:[{signature:"Text3d(string text)",summary:"Constructs a new instance of Text3d.",since:5},{signature:"Text3d(string text,Plane plane,double height)",summary:"Constructs a new instance of Text3d.",since:5}],properties:[{signature:"bool Bold",summary:"Gets or sets whether this Text3d object will be drawn in Bold.",since:5},{signature:"BoundingBox BoundingBox",summary:"Gets the boundingbox for this Text3d object.",since:5},{signature:"string FontFace",summary:"Gets or sets the FontFace name.",since:5},{signature:"double Height",summary:"Gets or sets the height (in units) of this Text3d object. \n     The height should be a positive number larger than zero.",since:5},{signature:"TextHorizontalAlignment HorizontalAlignment",summary:"Horizontal alignment that this Text3d is drawn with",since:6.4},{signature:"bool Italic",summary:"Gets or sets whether this Text3d object will be drawn in Italics.",since:5},{signature:"string Text",summary:"Gets or sets the text string for this Text3d object.",since:5},{signature:"Plane TextPlane",summary:"Gets or sets the 3D aligned plane for this Text3d object.",since:5},{signature:"TextVerticalAlignment VerticalAlignment",summary:"Vertical alignment that this Text3d is drawn with",since:6.4}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5}]},{name:"Rhino.Display.ViewCapture",dataType:1,summary:"",constructors:[{signature:"ViewCapture()",since:6}],properties:[{signature:"bool DrawAxes",since:6},{signature:"bool DrawGrid",since:6},{signature:"bool DrawGridAxes",since:6},{signature:"int Height",summary:"Height of capture in Pixels",since:6},{signature:"bool Preview",since:6},{signature:"int RealtimeRenderPasses",since:6},{signature:"bool ScaleScreenItems",since:6},{signature:"bool TransparentBackground",since:6},{signature:"int Width",summary:"Width of capture in Pixels",since:6}],methods:[{signature:"static Bitmap CaptureToBitmap(ViewCaptureSettings settings)",since:6},{signature:"static System.Xml.XmlDocument CaptureToSvg(ViewCaptureSettings settings)",since:6},{signature:"Bitmap CaptureToBitmap(RhinoView sourceView)",since:6}]},{name:"Rhino.Display.ViewCaptureSettings",dataType:1,summary:"Used to hold the information required to generate high resolution output\n   of a RhinoViewport.  This is used for generating paper prints or image files",constructors:[{signature:"ViewCaptureSettings()",since:6},{signature:"ViewCaptureSettings(RhinoPageView sourcePageView,double dpi)",since:6},{signature:"ViewCaptureSettings(RhinoView sourceView,Size mediaSize,double dpi)",since:6}],properties:[{signature:"double ArrowheadSizeMillimeters",summary:"arrowhead size in millimeters",since:6.15},{signature:"Rectangle CropRectangle",summary:"Actual area of output rectangle that view capture is sent to.",since:6},{signature:"double DefaultPrintWidthMillimeters",summary:"Line thickness used to print objects with no defined thickness (in mm)",since:6.15},{signature:"RhinoDoc Document",since:6.15},{signature:"bool DrawAxis",since:6},{signature:"bool DrawBackground",since:6},{signature:"bool DrawBackgroundBitmap",since:6.2},{signature:"bool DrawClippingPlanes",since:6},{signature:"bool DrawGrid",since:6},{signature:"bool DrawLights",since:6},{signature:"bool DrawLockedObjects",since:6},{signature:"bool DrawMargins",since:6},{signature:"bool DrawSelectedObjectsOnly",since:6},{signature:"bool DrawWallpaper",since:6.2},{signature:"bool IsScaleToFit",summary:"Returns True if the model has been scaled to fit.",since:6.21},{signature:"bool IsValid",since:6},{signature:"Size MediaSize",summary:"Total size of the image or page in dots",since:6},{signature:"int ModelScaleType",since:6.21},{signature:"AnchorLocation OffsetAnchor",since:6.2},{signature:"ColorMode OutputColor",since:6.8},{signature:"double PointSizeMillimeters",summary:"size of point objects in millimeters\n     if scale <= 0 the size is minimized so points are always drawn as small as possible",since:6.15},{signature:"bool RasterMode",since:6.17},{signature:"double Resolution",summary:'Capture "density" in dots per inch',since:6},{signature:"bool UsePrintWidths",since:6.15},{signature:"double WireThicknessScale",summary:"scaling factor to apply to object print widths (typically 1.0). This is\n     helpful when printing something at 1/2 scale and having all of the curves\n     print 1/2 as thick",since:6.15}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"bool GetMargins(UnitSystem lengthUnits,double left,double top,double right,double bottom)",summary:"Get distances from the edge of the paper (MediaSize) to the CropRectangle\n     in a defined unit system",since:6.2,returns:"True if successful.\n     False if unsuccessful (this could happen if there is no set device_dpi)"},{signature:"double GetModelScale(UnitSystem pageUnits,UnitSystem modelUnits)",summary:"Returns the model scale factor.",since:6.21,returns:"The model scale factor."},{signature:"void GetOffset(UnitSystem lengthUnits,bool fromMargin,double x,double y)",since:6.2},{signature:"void SetLayout(Size mediaSize,Rectangle cropRectangle)",since:6},{signature:"bool SetMargins(UnitSystem lengthUnits,double left,double top,double right,double bottom)",summary:"Set distances from the edge of the paper (MediaSize) to the CropRectange\n     in a defined unit system",since:6.2,returns:"True if successful.\n     False if unsuccessful (this could happen if there is no set device_dpi)"},{signature:"void SetModelScaleToFit(bool promptOnChange)",summary:"Scales the model to fit.",since:6.21},{signature:"void SetModelScaleToValue(double scale)",summary:"Sets the model scale to a value.",since:6.21},{signature:"void SetOffset(UnitSystem lengthUnits,bool fromMargin,double x,double y)",since:6.2},{signature:"void SetViewport(RhinoViewport viewport)",since:6.15}]},{name:"Rhino.Display.ViewCaptureSettings.AnchorLocation",dataType:3,summary:""},{name:"Rhino.Display.ViewCaptureSettings.ColorMode",dataType:3,summary:""},{name:"Rhino.Display.ViewEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoView View",since:5}]},{name:"Rhino.Display.ViewportType",dataType:3,summary:""},{name:"Rhino.Display.VisualAnalysisMode",dataType:1,summary:"Represents a base class for visual analysis modes.\n   This class is abstract.",properties:[{signature:"static Guid RhinoCurvatureColorAnalyisModeId",summary:"Id for Rhino's built-in curvature color analysis mode.  Surface curvature\n     is shown using False color mapping.",since:5},{signature:"static Guid RhinoCurvatureGraphAnalysisModeId",summary:"Id for Rhino's built-in curvature graphs analysis mode. Curvature hair\n     is shown on curves and surfaces.",since:5},{signature:"static Guid RhinoDraftAngleAnalysisModeId",summary:"Id for Rhino's built-in draft angle analysis mode.  Draft angle is \n     displayed using False colors.",since:5},{signature:"static Guid RhinoEdgeAnalysisModeId",summary:"Id for Rhino's built-in edge analysis mode. Brep and mesh edges are\n     shown in a selected color.",since:5},{signature:"static Guid RhinoEdgeContinuityAlalysisModeId",summary:"Id for Rhino's built-in edge continuity analysis mode.",since:7},{signature:"static Guid RhinoEmapAnalysisModeId",summary:"Id for Rhino's built-in emap analysis mode.  An environment map is\n     shown on sufaces and meshes.",since:5},{signature:"static Guid RhinoThicknessAnalysisModeId",summary:"Id for Rhino's built-in thickness analysis mode.",since:5},{signature:"static Guid RhinoZebraStripeAnalysisModeId",summary:"Id for Rhino's built-in zebra stripe analysis mode. Zebra stripes are\n     shown on surfaces and meshes.",since:5},{signature:"Guid Id",summary:"Gets the visual analysis mode GUID.\n     The Guid is specified with the GuidAttribute\n     applied to the class.",since:5},{signature:"string Name",summary:"Gets the name of the analysis mode. It is used by the _What command and the object\n     properties details window to describe the object.",since:5},{signature:"bool ShowIsoCurves",summary:"Gets True if this visual analysis mode will show isocuves on shaded surface\n     objects.  Often a mode's user interface will provide a way to change this\n     setting.\n     The default is false.",since:5},{signature:"AnalysisStyle Style",summary:"Gets the visual analysis mode style.",since:5}],methods:[{signature:"static bool AdjustAnalysisMeshes(RhinoDoc doc,Guid analysisModeId)",summary:"Interactively adjusts surface analysis meshes of objects using a Rhino built-in analysis mode.",since:7,returns:"True if successful, False otherwise."},{signature:"static VisualAnalysisMode Find(Guid id)",summary:"Finds a visual analysis mode by guid.",since:5,returns:"The found visual analysis mode, or None if it was not found, or on error."},{signature:"static VisualAnalysisMode Find(Type t)",summary:"Finds a visual analysis mode by type.",since:5,returns:"A visual analysis mode on success, or None on error."},{signature:"static VisualAnalysisMode Register(Type customAnalysisModeType)",summary:"Registers a custom visual analysis mode for use in Rhino.  It is OK to call\n     register multiple times for a single custom analysis mode type, since subsequent\n     register calls will notice that the type has already been registered.",since:5,returns:"An instance of registered analysis mode on success."},{signature:"void EnableUserInterface(bool on)",summary:"Turns the analysis mode's user interface on and off. For Rhino's built\n     in modes this opens or closes the modeless dialog that controls the\n     analysis mode's display settings.",since:5},{signature:"bool ObjectSupportsAnalysisMode(RhinoObject obj)",summary:"Gets a value indicating if this visual analysis mode can be used on a given Rhino object.",since:5,returns:"True if this mode can indeed be used on the object; otherwise false."}]},{name:"Rhino.Display.VisualAnalysisMode.AnalysisStyle",dataType:3,summary:"Contains enumerated values for analysis styles, such as wireframe, texture or False colors.."},{name:"Rhino.Display.ZBiasMode",dataType:3,summary:"Baising applied to geometry to attempt to get coplanar items\n   to draw on top of or below other geometry"},{name:"Rhino.Display.ZBufferCapture",dataType:1,summary:"Provides functionality for getting the zbuffer values from a viewport\n   and a given display mode",constructors:[{signature:"ZBufferCapture(RhinoViewport viewport)",since:5.3}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.3},{signature:"System.Drawing.Bitmap GrayscaleDib()",since:5.3},{signature:"int HitCount()",since:5.3},{signature:"float MaxZ()",since:5.3},{signature:"float MinZ()",since:5.3},{signature:"void SetDisplayMode(Guid modeId)",since:5.3},{signature:"void ShowAnnotations(bool on)",since:5.3},{signature:"void ShowCurves(bool on)",since:5.3},{signature:"void ShowIsocurves(bool on)",since:5.3},{signature:"void ShowLights(bool on)",since:5.3},{signature:"void ShowMeshWires(bool on)",since:5.3},{signature:"void ShowPoints(bool on)",since:5.3},{signature:"void ShowText(bool on)",since:5.3},{signature:"Point3d WorldPointAt(int x,int y)",since:5.3},{signature:"float ZValueAt(int x,int y)",since:5.3}]},{name:"Rhino.DocObjects.ActiveSpace",dataType:3,summary:"Defines the current working space."},{name:"Rhino.DocObjects.AngleDisplayMode",dataType:3,summary:"Defines enumerated values for the display of angles."},{name:"Rhino.DocObjects.AngularDimensionObject",dataType:1,summary:"Rhino Object that represents an angular dimension geometry and attributes",properties:[{signature:"AngularDimension AngularDimensionGeometry",summary:"Get the dimension geometry for this object.",since:6}]},{name:"Rhino.DocObjects.AnimationProperties",dataType:1,summary:"Contains information used by the Animation Tools to create sun, season,\n   turntable and fly through animations.",constructors:[{signature:"AnimationProperties()",summary:"Initializes a new instance of the  class.",since:6.11},{signature:"AnimationProperties(AnimationProperties source)",summary:"Initialize new instance of the AnimationProperties class.",since:6.11}],properties:[{signature:"string AnimationName",summary:"Gets or sets the name of the animation sequence.",since:6.11},{signature:"Guid CameraPathId",summary:"Gets or sets the object ID of the camera path.",since:6.11},{signature:"Point3d[] CameraPoints",summary:"Gets or sets points of the camera path.",since:6.11},{signature:"string CaptureMethod",summary:"Gets or sets the capture method of the animation which is either preview or full.",since:6.11},{signature:"CaptureTypes CaptureType",summary:"Gets or sets the capture type of the animation.",since:6.11},{signature:"string[] Dates",summary:"Gets or sets the dates that are calculated for seasonal/one day sun animations.",since:6.11},{signature:"int DaysBetweenFrames",summary:"Gets or sets the days between captured frames for seasonal sun animation.",since:6.11},{signature:"Guid DisplayMode",summary:"Gets or sets the ID of the view display mode (wireframe, shaded...).",since:6.11},{signature:"int EndDay",summary:"Gets or sets the end day for seasonal day sun animation in the range 1 to 31.",since:6.11},{signature:"int EndHour",summary:"Gets or sets the end hour for one day sun animation in the range 0 to 23.",since:6.11},{signature:"int EndMinutes",summary:"Gets or sets the end minutes for one day sun animation in the range 0 to 59.",since:6.11},{signature:"int EndMonth",summary:"Gets or sets the end month for seasonal day sun animation in the range 1 to 12.",since:6.11},{signature:"int EndSeconds",summary:"Gets or sets the end seconds for one day sun animation in the range 0 to 59.",since:6.11},{signature:"int EndYear",summary:"Gets or sets the end year for seasonal day sun animation in the range 1800 to 2199.",since:6.11},{signature:"string FileExtension",summary:"Gets or sets the file extension of the saved frames created by the animation.",since:6.11},{signature:"string FolderName",summary:"Gets or sets the location for the saved frames.",since:6.11},{signature:"int FrameCount",summary:"Gets or sets the number of frames to be captured.",since:6.11},{signature:"string[] Images",summary:"Gets or sets the full path to the saved frames of an animation.",since:6.11},{signature:"double Latitude",summary:"Gets or sets the latitude for sun animations in the range of -90 to +90.",since:6.11},{signature:"int LightIndex",summary:"Internal value used while previewing animation.",since:6.11},{signature:"double Longitude",summary:"Gets or sets the longitude for sun animations in the range of -180 to +180.",since:6.11},{signature:"int MinutesBetweenFrames",summary:"Gets or sets the minutes between captured frames for one day sun animation.",since:6.11},{signature:"double NorthAngle",summary:"Gets or sets the world angle corresponding to North in degrees.\n     This angle is zero along the x-axis and increases anticlockwise.",since:6.11},{signature:"bool RenderFull",summary:"Gets or sets a value indicating whether to capture a frame in rendered mode.",since:6.11},{signature:"bool RenderPreview",summary:"Gets or sets a value indicating whether to capture a frame in preview rendered mode.",since:6.11},{signature:"int StartDay",summary:"Gets or sets the start day for seasonal/one day sun animation in the range 1 to 31.",since:6.11},{signature:"int StartHour",summary:"Gets or sets the start hour for seasonal/one day sun animation in the range 0 to 23.",since:6.11},{signature:"int StartMinutes",summary:"Gets or sets the start minutes for seasonal/one day sun animation in the range 0 to 59.",since:6.11},{signature:"int StartMonth",summary:"Gets or sets the start month for seasonal/one day sun animation in the range 1 to 12.",since:6.11},{signature:"int StartSeconds",summary:"Gets or sets the start seconds for seasonal/one day sun animation in the range 0 to 59.",since:6.11},{signature:"int StartYear",summary:"Gets or sets the start year for seasonal/one day sun animation in the range 1800 to 2199.",since:6.11},{signature:"Guid TargetPathId",summary:"Gets or sets the object ID of the target path.",since:6.11},{signature:"Point3d[] TargetPoints",summary:"Gets or sets points of the target path.",since:6.11},{signature:"string ViewportName",summary:"Gets or sets the viewport that will be captured.",since:6.11}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6.11}]},{name:"Rhino.DocObjects.AnimationProperties.CaptureTypes",dataType:3,summary:"Constants that define the mode of the animation tools."},{name:"Rhino.DocObjects.AnnotationObjectBase",dataType:1,summary:"Base class for all annotation objects (text and dimensions)",properties:[{signature:"AnnotationBase AnnotationGeometry",summary:"Get the annotation base geometry for this object",since:6},{signature:"string DisplayText",summary:"Gets the text that is displayed to users.",since:5},{signature:"bool HasMeasurableTextFields",summary:"Test if the text in the annotation object contains fields\n     that involve length, area, or volume measurements",since:7}]},{name:"Rhino.DocObjects.BasepointZero",dataType:3,summary:"Specifies enumerated constants used to indicate the zero level convention relating to a location on Earth.\n   This is used in conjunction with the  class."},{name:"Rhino.DocObjects.BitmapEntry",dataType:1,summary:"Rhino.DocObjects.Tables.BitmapTable entry",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"string FileName",summary:"The name of this bitmap.",since:5.1},{signature:"bool IsReference",summary:"Gets a value indicting whether this bitmap is a referenced bitmap. \n     Referenced bitmaps are part of referenced documents.",since:5.1}],methods:[{signature:"bool Save(string fileName)",since:5.1}]},{name:"Rhino.DocObjects.BrepObject",dataType:1,summary:"Represents a brep in a document.",properties:[{signature:"Brep BrepGeometry",summary:"Gets the brep geometry linked with this object.",since:5}],methods:[{signature:"Brep DuplicateBrepGeometry()",summary:"Constructs a new deep copy of the brep geometry.",since:5,returns:"The copy of the geometry."}]},{name:"Rhino.DocObjects.CentermarkObject",dataType:1,summary:"Rhino Object that represents a centermark geometry and attributes",properties:[{signature:"Centermark CentermarkGeometry",summary:"Get the dimension geometry for this object.",since:6}]},{name:"Rhino.DocObjects.ClippingPlaneObject",dataType:1,summary:"Represents the object of a clipping plane,\n   stored in the Rhino document and with attributes.",properties:[{signature:"ClippingPlaneSurface ClippingPlaneGeometry",summary:"Gets the clipping plane surface.",since:5}],methods:[{signature:"bool AddClipViewport(RhinoViewport viewport,bool commit)",summary:"Adds a viewport to the list of viewports that this clipping plane clips.",since:6.1,returns:"True if the viewport was added, False if the viewport is already in the list."},{signature:"bool RemoveClipViewport(RhinoViewport viewport,bool commit)",summary:"Removes a viewport from the list of viewports that this clipping plane clips.",since:6.1,returns:"True if the viewport was removed, False if the viewport was not in the list."}]},{name:"Rhino.DocObjects.ConstructionPlane",dataType:1,summary:"Represents a contruction plane inside the document.\n   Use Rhino.DocObjects.Tables.NamedConstructionPlaneTable\n   methods and indexers to add and access a .",constructors:[{signature:"ConstructionPlane()",summary:"Initializes a new instance of .",since:5}],properties:[{signature:"bool DepthBuffered",summary:"Gets or sets whether the grid is drawn on top of geometry.\n     false=grid is always drawn behind 3d geometrytrue=grid is drawn at its depth as a 3d plane and grid lines obscure things behind the grid.",since:5},{signature:"int GridLineCount",summary:"Gets or sets the total amount of grid lines in each direction.",since:5},{signature:"double GridSpacing",summary:"Gets or sets the distance between grid lines.",since:5},{signature:"Color GridXColor",summary:"Gets or sets the color of the grid X-axis mark.",since:5},{signature:"Color GridYColor",summary:"Gets or sets the color of the grid Y-axis mark.",since:5},{signature:"Color GridZColor",summary:"Gets or sets the color of the grid Z-axis mark.",since:5},{signature:"string Name",summary:"Gets or sets the name of the construction plane.",since:5},{signature:"Plane Plane",summary:"Gets or sets the geometric plane to use for construction.",since:5},{signature:"bool ShowAxes",summary:"Gets or sets whether the axes of the grid shuld be visible.",since:5},{signature:"bool ShowGrid",summary:"Gets or sets whether the grid itself should be visible.",since:5},{signature:"bool ShowZAxis",summary:"Gets or sets whether the Z axis of the grid shuld be visible.",since:6},{signature:"double SnapSpacing",summary:'when "grid snap" is enabled, the distance between snap points.\n     Typically this is the same distance as grid spacing.',since:5},{signature:"Color ThickLineColor",summary:"Gets or sets the color of the thicker, wider line.",since:5},{signature:"int ThickLineFrequency",summary:"Gets or sets the recurrence of a wider line on the grid.\n     0: No lines are thick, all are drawn thin.1: All lines are thick.2: Every other line is thick.3: One line in three lines is thick (and two are thin).4: ...",since:5},{signature:"Color ThinLineColor",summary:"Gets or sets the color of the thinner, less prominent line.",since:5}]},{name:"Rhino.DocObjects.CoordinateSystem",dataType:3,summary:"Defines enumerated values for coordinate systems to use as references."},{name:"Rhino.DocObjects.CurveObject",dataType:1,summary:"A Rhino Object that represents curve geometry and attributes",properties:[{signature:"Curve CurveGeometry",since:5}],methods:[{signature:"Curve DuplicateCurveGeometry()",since:5}]},{name:"Rhino.DocObjects.Custom.ClassIdAttribute",dataType:1,summary:"Useful for legacy UserData",constructors:[{signature:"ClassIdAttribute(string id)",summary:"Initializes a class id attrbute.",since:6}],properties:[{signature:"Guid Id",summary:"Gets the associated style.",since:6}]},{name:"Rhino.DocObjects.Custom.CustomBrepObject",dataType:1,summary:""},{name:"Rhino.DocObjects.Custom.CustomCurveObject",dataType:1,summary:"",methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.DocObjects.Custom.CustomGripObject",dataType:1,summary:"",constructors:[{signature:"CustomGripObject()",since:5}],properties:[{signature:"int Index",since:5},{signature:"Point3d OriginalLocation",since:5},{signature:"double Weight",since:5}],methods:[{signature:"void Dispose()",since:5},{signature:"void NewLocation()",since:5}]},{name:"Rhino.DocObjects.Custom.CustomMeshObject",dataType:1,summary:"",methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.DocObjects.Custom.CustomObjectGrips",dataType:1,summary:"",properties:[{signature:"int GripCount",since:5},{signature:"bool GripsMoved",summary:"If GripsMoved is True if some of the grips have ever been moved\n     GripObject.NewLocation() sets GripsMoved=true.",since:5},{signature:"bool NewLocation",summary:"True if some of the grips have been moved. GripObject.NewLocation() sets\n     NewLocation=true.  Derived classes can set NewLocation to False after \n     updating temporary display information.",since:5},{signature:"RhinoObject OwnerObject",summary:"Owner of the grips.",since:5}],methods:[{signature:"static bool Dragging()",summary:"Determines if grips are currently being dragged.",since:5,returns:"True if grips are dragged."},{signature:"static void RegisterGripsEnabler(TurnOnGripsEventHandler enabler,Type customGripsType)",since:5},{signature:"void Dispose()",since:5},{signature:"CustomGripObject Grip(int index)",since:5}]},{name:"Rhino.DocObjects.Custom.CustomPointObject",dataType:1,summary:"",methods:[{signature:"void Dispose()",since:5.6}]},{name:"Rhino.DocObjects.Custom.GripsDrawEventArgs",dataType:1,summary:"",properties:[{signature:"int ControlPolygonStyle",summary:"What kind of line is used to display things like control polygons.\n     0 = no control polygon,  1 = solid control polygon,  2 = dotted control polygon.",since:5},{signature:"bool DrawDynamicStuff",summary:'If true, then draw stuff that does not move when grips are\n     dragged, like the control polygon of the "original" curve.',since:5},{signature:"bool DrawStaticStuff",summary:"If true, then draw stuff that moves when grips are dragged,\n     like the curve being bent by a dragged control point.",since:5},{signature:"Color GripColor",since:5},{signature:"int GripStatusCount",since:5},{signature:"Color LockedGripColor",since:5},{signature:"Color SelectedGripColor",since:5}],methods:[{signature:"void DrawControlPolygonLine(Line line,GripStatus startStatus,GripStatus endStatus)",summary:"Draws the lines in a control polygons.\n     This is an helper function.",since:5},{signature:"void DrawControlPolygonLine(Line line,int startStatus,int endStatus)",summary:"Draws the lines in a control polygons.\n     This is an helper function.",since:5},{signature:"void DrawControlPolygonLine(Point3d start,Point3d end,int startStatus,int endStatus)",summary:"Draws the lines in a control polygons.\n     This is an helper function.",since:5},{signature:"GripStatus GripStatus(int index)",since:5},{signature:"void RestoreViewportSettings()",since:5}]},{name:"Rhino.DocObjects.Custom.GripStatus",dataType:1,summary:"",properties:[{signature:"bool Culled",since:5},{signature:"bool Visible",since:5}]},{name:"Rhino.DocObjects.Custom.UnknownUserData",dataType:1,summary:"Represents user data with unknown origin.",constructors:[{signature:"UnknownUserData(IntPtr pointerNativeUserData)",summary:"Constructs a new unknown data entity.",since:5}]},{name:"Rhino.DocObjects.Custom.UserData",dataType:1,summary:"Provides a base class for custom classes of information which may be attached to\n   geometry or attribute classes.",properties:[{signature:"string Description",summary:"Descriptive name of the user data.",since:5},{signature:"bool ShouldWrite",summary:"If you want to save this user data in a 3dm file, override\n     ShouldWrite and return true.  If you do support serialization,\n     you must also override the Read and Write functions.",since:5},{signature:"Transform Transform",summary:"Updated if user data is attached to a piece of geometry that is\n     transformed and the virtual OnTransform() is not overridden.  If you\n     override OnTransform() and want Transform to be updated, then call the \n     base class OnTransform() in your override.\n     The default constructor sets Transform to the identity.",since:5}],methods:[{signature:"static void Copy(CommonObject source,CommonObject destination)",summary:"Expert user tool that copies user data that has a positive \n     CopyCount from the source object to a destination object.\n     Generally speaking you don't need to use Copy().\n     Simply rely on things like the copy constructors to do the right thing.",since:5},{signature:"static Guid MoveUserDataFrom(CommonObject objectWithUserData)",summary:"Moves the user data from objectWithUserData to a temporary data storage\n     identifierd by the return Guid.  When MoveUserDataFrom returns, the\n     objectWithUserData will not have any user data.",since:5,returns:"Guid identifier for storage of UserData that is held in a temporary list\n     by this class. This function should be used in conjunction with MoveUserDataTo\n     to transfer the user data to a different object.\n     Returns Guid.Empty if there was no user data to transfer."},{signature:"static void MoveUserDataTo(CommonObject objectToGetUserData,Guid id,bool append)",summary:"Moves the user data.\n     See  for more information.",since:5},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5}]},{name:"Rhino.DocObjects.Custom.UserDataList",dataType:1,summary:"Represents a collection of user data.",properties:[{signature:"int Count",summary:"Number of UserData objects in this list.",since:5}],methods:[{signature:"bool Add(UserData userdata)",summary:"If the userdata is already in a different UserDataList, it\n     will be removed from that list and added to this list.",since:5,returns:"Whether this operation succeeded."},{signature:"bool Contains(Guid userdataId)",summary:"Checks for the existence of a specific type of userdata in this list\n     Both .NET and native userdata is checked",since:6.1},{signature:"UserData Find(Type userdataType)",summary:"Finds a specific data type in this regulated collection.",since:5,returns:"The found data, or None of nothing was found."},{signature:"IEnumerator<UserData> GetEnumerator()",summary:"Get enumerator for UserDataList",since:6},{signature:"void Purge()",summary:"Removes all user data from this geometry.",since:6},{signature:"bool Remove(UserData userdata)",summary:"Remove the userdata from this list",since:5.6,returns:"True if the user data was successfully removed"}]},{name:"Rhino.DocObjects.Custom.UserDataListEnumerator",dataType:1,summary:"Enumerator for UserDataList",constructors:[{signature:"UserDataListEnumerator(UserDataList udl)",summary:"Create new UserDataListEnumerator",since:6}],properties:[{signature:"UserData Current",summary:"Get current UserData on the enumerator.",since:6}],methods:[{signature:"void Dispose()",summary:"Implement Dispose(). NOP.",since:6},{signature:"bool MoveNext()",summary:"Advance enumerator to next UserData item.",since:6,returns:"True if there is a next item."},{signature:"void Reset()",summary:"Reset the enumerator",since:6}]},{name:"Rhino.DocObjects.Custom.UserDictionary",dataType:1,summary:"Defines the storage data class for a user dictionary.",properties:[{signature:"string Description",summary:'Gets the text "RhinoCommon UserDictionary".',since:5},{signature:"ArchivableDictionary Dictionary",summary:"Gets the dictionary that is associated with this class.\n     This dictionary is unique.",since:5},{signature:"bool ShouldWrite",summary:"Writes this entity if the count is larger than 0.",since:5}]},{name:"Rhino.DocObjects.DetailViewObject",dataType:1,summary:"A detail view object is a nested Rhino viewport placed on a page view with a 2D closed curve\n   boundary. It can be any type of modeling view.",properties:[{signature:"string DescriptiveTitle",summary:'Detail objects have two strings that can be used to describe the detail:\n      1. The name string that is part of the object\'s attributes\n      2. The viewport projection title that is part of the viewport\n      This function combines these two strings to create a single "description" string in the form of attribute_name - projection_title.',since:7},{signature:"DetailView DetailGeometry",summary:"Returns the detail view geometry.",since:5},{signature:"bool IsActive",summary:"Gets or sets the active state of the detail view.",since:5},{signature:"Transform PageToWorldTransform",summary:"Returns the page coordinate to world coordinate transformation.",since:6},{signature:"RhinoViewport Viewport",summary:"Gets the detail view's viewport.",since:5},{signature:"Transform WorldToPageTransform",summary:"Gets the world coordinate to page coordinate transformation.",since:6}],methods:[{signature:"bool CommitViewportChanges()",since:5},{signature:"bool GetFormattedScale(ScaleFormat format,string value)",summary:"Returns the detail view object's scale as a formatted string. \n     The detail view object's viewport must be to parallel projection.",since:7,returns:"True if successful, False otherwise"}]},{name:"Rhino.DocObjects.DetailViewObject.ScaleFormat",dataType:3,summary:"Detail view object scale formats."},{name:"Rhino.DocObjects.DimensionObject",dataType:1,summary:"Rhino Object that represents dimension geometry and attributes",properties:[{signature:"DimensionStyle DimensionStyle",summary:"Gets the \n     associated with this OrdinateDimensionObject.",since:6}]},{name:"Rhino.DocObjects.DimensionStyle",dataType:1,summary:"Can also be considered an annotation style since it is used for\n   more than just dimensions",constructors:[{signature:"DimensionStyle()",summary:"Create a new non-document controlled annotation style",since:5}],properties:[{signature:"bool AlternateBelowLine",since:6},{signature:"LengthDisplay AlternateDimensionLengthDisplay",since:6},{signature:"double AlternateLengthFactor",since:5},{signature:"int AlternateLengthResolution",since:6},{signature:"string AlternatePrefix",since:6},{signature:"double AlternateRoundoff",since:6},{signature:"string AlternateSuffix",since:6},{signature:"int AlternateToleranceResolution",since:6},{signature:"bool AlternateUnitsDisplay",since:6},{signature:"ZeroSuppression AlternateZeroSuppress",since:6},{signature:"AngleDisplayFormat AngleFormat",since:6},{signature:"int AngleResolution",since:5},{signature:"ZeroSuppression AngleZeroSuppress",since:6},{signature:"double AngularRoundoff",since:6},{signature:"int ArcLengthSymbol",since:6},{signature:"Guid ArrowBlockId1",since:6},{signature:"Guid ArrowBlockId2",since:6},{signature:"double ArrowLength",since:5},{signature:"ArrowType ArrowType1",since:6},{signature:"ArrowType ArrowType2",since:6},{signature:"double BaselineSpacing",since:6},{signature:"double CentermarkSize",since:5},{signature:"CenterMarkStyle CenterMarkType",since:6},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"char DecimalSeparator",since:7},{signature:"LengthDisplay DimensionLengthDisplay",since:6},{signature:"double DimensionLineExtension",since:6},{signature:"double DimensionScale",since:6},{signature:"ScaleValue DimensionScaleValue",since:6},{signature:"LeaderContentAngleStyle DimRadialTextAngleType",since:6},{signature:"TextLocation DimRadialTextLocation",since:6},{signature:"TextOrientation DimRadialTextOrientation",since:6},{signature:"LeaderContentAngleStyle DimTextAngleType",since:6},{signature:"TextLocation DimTextLocation",since:6},{signature:"TextOrientation DimTextOrientation",since:6},{signature:"bool DrawForward",since:6},{signature:"bool DrawTextMask",since:6},{signature:"double ExtensionLineExtension",since:5},{signature:"double ExtensionLineOffset",since:5},{signature:"ArrowFit FitArrow",since:6.2},{signature:"TextFit FitText",since:6.2},{signature:"double FixedExtensionLength",since:6},{signature:"bool FixedExtensionOn",since:6},{signature:"Font Font",since:6},{signature:"bool ForceDimensionLineBetweenExtensionLines",since:6.2},{signature:"bool HasFieldOverrides",summary:"Checks if any fields in this DimensionStyle are overrides",since:6},{signature:"bool IsChild",summary:"Tests if this DimensionStyle is a child of any other DimensionStyle",since:6},{signature:"bool IsDeleted",since:6},{signature:"bool IsReference",since:5},{signature:"Guid LeaderArrowBlockId",since:6},{signature:"double LeaderArrowLength",since:5},{signature:"ArrowType LeaderArrowType",since:5.6},{signature:"LeaderContentAngleStyle LeaderContentAngleType",summary:"Style of leader content angle\n     Horizontal\n     Aligned\n     Rotated",since:6},{signature:"LeaderCurveStyle LeaderCurveType",since:6},{signature:"bool LeaderHasLanding",since:6},{signature:"double LeaderLandingLength",since:6},{signature:"TextHorizontalAlignment LeaderTextHorizontalAlignment",since:6},{signature:"TextOrientation LeaderTextOrientation",since:6},{signature:"double LeaderTextRotationDegrees",since:6},{signature:"double LeaderTextRotationRadians",summary:"Angle of leader text for Rotated style",since:6},{signature:"TextVerticalAlignment LeaderTextVerticalAlignment",since:6},{signature:"double LengthFactor",since:5},{signature:"int LengthResolution",since:5},{signature:"Color MaskColor",since:6},{signature:"MaskType MaskColorSource",since:6},{signature:"MaskFrame MaskFrameType",since:7},{signature:"double MaskOffset",since:6},{signature:"Guid ParentId",summary:"Get or Set the Id of this DimensionStyle's parent.\n     If ParentId is Guid.Empty, this DimensionStyle has no parent",since:6},{signature:"string Prefix",since:5},{signature:"double Roundoff",since:6},{signature:"double ScaleLeftLengthMillimeters",since:6},{signature:"double ScaleRightLengthMillimeters",since:6},{signature:"StackDisplayFormat StackFractionFormat",since:6},{signature:"double StackHeightScale",since:6},{signature:"string Suffix",since:5},{signature:"bool SuppressArrow1",since:6},{signature:"bool SuppressArrow2",since:6},{signature:"bool SuppressExtension1",since:6},{signature:"bool SuppressExtension2",since:6},{signature:"double TextGap",since:5},{signature:"double TextHeight",since:5},{signature:"TextHorizontalAlignment TextHorizontalAlignment",since:6},{signature:"int TextMoveLeader",since:6},{signature:"TextOrientation TextOrientation",since:6},{signature:"double TextRotation",since:6},{signature:"bool TextUnderlined",since:6},{signature:"TextVerticalAlignment TextVerticalAlignment",since:6},{signature:"ToleranceDisplayFormat ToleranceFormat",since:6},{signature:"double ToleranceHeightScale",since:6},{signature:"double ToleranceLowerValue",since:6},{signature:"int ToleranceResolution",since:6},{signature:"double ToleranceUpperValue",since:6},{signature:"ZeroSuppression ToleranceZeroSuppress",since:6},{signature:"ZeroSuppression ZeroSuppress",since:6}],methods:[{signature:"UnitSystem AlternateDimensionLengthDisplayUnit(uint model_serial_number)",since:6},{signature:"void ClearAllFieldOverrides()",summary:"Sets all the fields in this DimensionStyle to be not overridden\n     Does not change any dimstyle_id's or parent_id's",since:6},{signature:"void ClearFieldOverride(Field field)",summary:"Set the field as not overridden",since:6},{signature:"void CopyFrom(DimensionStyle source)",summary:"Copy settings from source dimension style without changing the name, Id or\n     index of this DimensionStyle.",since:6},{signature:"Bitmap CreatePreviewBitmap(int width,int height)",since:6},{signature:"UnitSystem DimensionLengthDisplayUnit(uint model_serial_number)",since:6},{signature:"DimensionStyle Duplicate()",summary:"Construct a deep (full) copy of this object.",since:6,returns:"An object of the same type as this, with the same properties and behavior."},{signature:"DimensionStyle Duplicate(string newName,Guid newId,Guid newParentId)",summary:"Construct a deep (full) copy of this object.",since:6,returns:"An object of the same type as this, with the same properties and behavior."},{signature:"bool IsChildOf(Guid parentId)",summary:"Tests if this DimensionStyle is a child of a specific DimensionStyle",since:6,returns:"True if this is a child of the DimensionStyle with Parent\n     False otherwise."},{signature:"bool IsFieldOverriden(Field field)"},{signature:"void ScaleLengthValues(double scale)",summary:"Scales all length values by 'scale'",since:6},{signature:"void SetFieldOverride(Field field)",summary:"Set a field as overridden",since:6}]},{name:"Rhino.DocObjects.DisplayMode",dataType:3,summary:"Defines enumerated values for display modes, such as wireframe or shaded."},{name:"Rhino.DocObjects.DistanceDisplayMode",dataType:3,summary:"Defines enumerated values for the display of distances in US customary and Imperial units."},{name:"Rhino.DocObjects.EarthAnchorPoint",dataType:1,summary:"Contains information about the model's position in latitude, longitude,\n   and elevation for GIS mapping applications.",constructors:[{signature:"EarthAnchorPoint()",summary:"Initializes a new instance of the  class.",since:5}],properties:[{signature:"string Description",summary:"Gets or sets the long form of the identifying information about this location.",since:5},{signature:"double EarthBasepointElevation",summary:"Gets or sets the point elevation on earth, in meters.",since:5},{signature:"BasepointZero EarthBasepointElevationZero",summary:"Gets or sets a value indicating the zero level convention relating to a location on Earth.",since:5},{signature:"double EarthBasepointLatitude",summary:"Gets or sets a point latitude on earth, in decimal degrees.\n     +90 = north pole, 0 = equator, -90 = south pole.",since:5},{signature:"double EarthBasepointLongitude",summary:"Gets or sets the point longitude on earth, in decimal degrees.\n     0 = prime meridian (Greenwich meridian)Values increase towards West",since:5},{signature:"Point3d ModelBasePoint",summary:"Corresponding model point in model coordinates.",since:5},{signature:"Vector3d ModelEast",summary:"Earth directions in model coordinates.",since:5},{signature:"Vector3d ModelNorth",summary:"Earth directions in model coordinates.",since:5},{signature:"string Name",summary:"Gets or sets the short form of the identifying information about this location.",since:5}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"bool EarthLocationIsSet()",summary:"Checks if the earth location is set or not.",since:6,returns:"Bool value, True if set else false"},{signature:"Plane GetEarthAnchorPlane(Vector3d anchorNorth)",summary:"Returns the earth anchor plane",since:6,returns:"A plane value."},{signature:"Plane GetModelCompass()",summary:"Returns a plane in model coordinates whose X axis points East,\n     Y axis points North and Z axis points Up. The origin\n     is set to ModelBasepoint.",since:5,returns:"A plane value. This might be invalid on error."},{signature:"Transform GetModelToEarthTransform(UnitSystem modelUnitSystem)",summary:"Gets a transformation from model coordinates to earth coordinates.\n     This transformation assumes the model is small enough that\n     the curvature of the earth can be ignored.",since:5,returns:"Transform on success. Inalid Transform on error."}]},{name:"Rhino.DocObjects.ExtrusionObject",dataType:1,summary:"",properties:[{signature:"Extrusion ExtrusionGeometry",since:5}],methods:[{signature:"Extrusion DuplicateExtrusionGeometry()",since:5}]},{name:"Rhino.DocObjects.Font",dataType:1,summary:"Defines a format for text.",constructors:[{signature:"Font(string familyName)",since:6},{signature:"Font(string familyName,FontWeight weight,FontStyle style,bool underlined,bool strikethrough)",since:6}],properties:[{signature:"bool Bold",since:5},{signature:"string Description",summary:"Returns a long description that includes family, face, weight, stretch and style information. \n     Generally not useful for finding matching fonts.",since:6.5},{signature:"string EnglishFaceName",summary:"Returns English Facename",since:6.9},{signature:"string EnglishFamilyName",since:6.9},{signature:"string EnglishQuartetName",since:6.12},{signature:"string FaceName",summary:"Returns Facename",since:5},{signature:"string FamilyName",since:6.5},{signature:"string FamilyPlusFaceName",summary:"Returns concatinated Family and Face names",since:6.9},{signature:"bool IsEngravingFont",since:6.1},{signature:"bool IsSimulated",since:6.5},{signature:"bool IsSingleStrokeFont",since:6.5},{signature:"bool IsSymbolFont",since:6.5},{signature:"bool Italic",since:5},{signature:"string LogfontName",summary:"Returns Windows Logfont Facename",since:6.5},{signature:"double PointSize",since:6},{signature:"string PostScriptName",summary:'Returns the Font PostScriptName - "Apple font name"',since:6.5},{signature:"string QuartetName",since:6.7},{signature:"string RichTextFontName",summary:"Returns the Font RichTextFontName used in RTF strings:\n     {\\\\fonttbl...{\\\\fN RichTextFontName;}...}",since:6.5},{signature:"bool Strikeout",since:6},{signature:"FontStyle Style",since:6},{signature:"bool Underlined",since:6},{signature:"FontWeight Weight",since:6}],methods:[{signature:"static string[] AvailableFontFaceNames()",since:5},{signature:"static Font FromQuartetProperties(string quartetName,bool bold,bool italic)",since:6.7},{signature:"static Font[] InstalledFonts()",since:6.5},{signature:"static Font[] InstalledFonts(string familyName)",since:6.5},{signature:"static FontQuartet[] InstalledFontsAsQuartets()",since:6.7}]},{name:"Rhino.DocObjects.FontQuartet",dataType:1,summary:"",properties:[{signature:"bool HasBoldFont",since:6.7},{signature:"bool HasBoldItalicFont",since:6.7},{signature:"bool HasItalicFont",since:6.7},{signature:"bool HasRegularFont",since:6.7},{signature:"string QuartetName",since:6.7}],methods:[{signature:"string ToString()"}]},{name:"Rhino.DocObjects.GripObject",dataType:1,summary:"",properties:[{signature:"Point3d CurrentLocation",since:5},{signature:"int Index",since:5},{signature:"bool Moved",summary:"True if the grip has moved from OriginalLocation.",since:5},{signature:"Point3d OriginalLocation",since:5},{signature:"Guid OwnerId",since:5},{signature:"double Weight",summary:"The weight of a NURBS control point grip or RhinoMath.UnsetValue\n     if the grip is not a NURBS control point grip.",since:5}],methods:[{signature:"bool GetCageParameters(double u,double v,double w)",summary:"Retrieves the 2d parameter space values of this GripObject from the cage it's associated with.",since:6,returns:"True on success. Output is unreliable if return is false."},{signature:"bool GetCurveParameters(double t)",summary:"Retrieves the 2d parameter space values of this GripObject from the curve it's associated with.",since:6,returns:"True on success. Output is unreliable if return is false."},{signature:"bool GetGripDirections(Vector3d u,Vector3d v,Vector3d normal)",summary:"Sometimes grips have directions.  These directions\n     can have any length and do not have to be orthoganal.",since:6,returns:"True if the grip has directions."},{signature:"bool GetSurfaceParameters(double u,double v)",summary:"Retrieves the 2d parameter space values of this GripObject from the surface it's associated with.",since:6,returns:"True on success. Output is unreliable if return is false."},{signature:"void Move(Point3d newLocation)",summary:"Moves the grip to a new location.",since:5},{signature:"void Move(Transform xform)",summary:"Moves the grip to a new location.",since:5},{signature:"void Move(Vector3d delta)",summary:"Moves the grip to a new location.",since:5},{signature:"GripObject NeighborGrip(int directionR,int directionS,int directionT,bool wrap)",summary:"Used to get a grip's logical neighbors, like NURBS curve, suface,\n     and cage control point grips.",since:5,returns:"logical neighbor or None if the is no logical neighbor"},{signature:"void UndoMove()",summary:"Undoes any grip moves made by calling Move.",since:5}]},{name:"Rhino.DocObjects.Group",dataType:1,summary:"",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"int UserStringCount",summary:"Gets the amount of user strings.",since:6.4}],methods:[{signature:"string GetUserString(string key)",summary:"Gets user string from this geometry.",since:6.4,returns:"string associated with the key if successful. None if no key was found."},{signature:"System.Collections.Specialized.NameValueCollection GetUserStrings()",summary:"Gets a copy of all (user key string, user value string) pairs attached to this geometry.",since:6.4,returns:"A new collection."},{signature:"bool SetUserString(string key,string value)",summary:"Attach a user string (key,value combination) to this geometry.",since:6.4,returns:"True on success."}]},{name:"Rhino.DocObjects.HatchObject",dataType:1,summary:"",properties:[{signature:"Hatch HatchGeometry",since:5}],methods:[{signature:"bool SetHatchGeometry(Hatch hatch)",summary:"Replaces a hatch object's underlying hatch geometry. This only works for non-document hatch objects.",since:7,returns:"True if successful, False otherwise."}]},{name:"Rhino.DocObjects.HatchPattern",dataType:1,summary:"",constructors:[{signature:"HatchPattern()",since:5}],properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"string Description",since:5},{signature:"HatchPatternFillType FillType",since:5},{signature:"int Index",summary:"Index in the hatch pattern table for this pattern. -1 if not in the table.",since:5},{signature:"bool IsDeleted",summary:"Deleted hatch patterns are kept in the runtime hatch pattern table so that undo\n     will work with hatch patterns.  Call IsDeleted to determine to determine if\n     a hatch pattern is deleted.",since:5},{signature:"bool IsReference",summary:'Rhino allows multiple files to be viewed simultaneously. Hatch patterns in the\n     document are "normal" or "reference". Reference hatch patterns are not saved.',since:5}],methods:[{signature:"static HatchPattern[] ReadFromFile(string filename,bool quiet)",summary:"Reads hatch pattern definitions from a file.",since:5,returns:"An array of hatch patterns. This can be null, but not empty."},{signature:"Rhino.Geometry.Line[] CreatePreviewGeometry(int width,int height,double angle)",summary:"Creates preview line segments of the hatch pattern.",since:6.8,returns:"The preview line segments if successful, an empty array on failure."}]},{name:"Rhino.DocObjects.HatchPattern.Defaults",dataType:1,summary:"",properties:[{signature:"static HatchPattern Dash",since:6},{signature:"static HatchPattern Grid",since:6},{signature:"static HatchPattern Grid60",since:6},{signature:"static HatchPattern Hatch1",since:6},{signature:"static HatchPattern Hatch2",since:6},{signature:"static HatchPattern Hatch3",since:6},{signature:"static HatchPattern Plus",since:6},{signature:"static HatchPattern Solid",since:6},{signature:"static HatchPattern Squares",since:6}]},{name:"Rhino.DocObjects.HatchPatternFillType",dataType:3,summary:""},{name:"Rhino.DocObjects.HistoryRecord",dataType:1,summary:"Provides a single bundling of information to be passed to Rhino when setting up history for an object.",constructors:[{signature:"HistoryRecord(Command command,int version)",since:5}],properties:[{signature:"bool CopyOnReplaceObject",summary:"When an object is replaced and the old object has a history record with\n     this field set, the history record is copied and attached to the new object.\n     That allows a descendant object to continue the history linkage after\n     it is edited.",since:6},{signature:"IntPtr Handle",summary:"Wrapped native C++ pointer to CRhinoHistory instance",since:5}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"bool SetBool(int id,bool value)",since:5},{signature:"bool SetBools(int id,IEnumerable<bool> values)",since:5},{signature:"bool SetBrep(int id,Brep value)",since:5},{signature:"bool SetColor(int id,Color value)",since:5},{signature:"bool SetColors(int id,IEnumerable<Color> values)",since:5},{signature:"bool SetCurve(int id,Curve value)",since:5},{signature:"bool SetDouble(int id,double value)",since:5},{signature:"bool SetDoubles(int id,IEnumerable<double> values)",since:5},{signature:"bool SetGuid(int id,Guid value)",since:5},{signature:"bool SetGuids(int id,IEnumerable<Guid> values)",since:5},{signature:"bool SetHistoryVersion(int historyVersion)",summary:"Specifies a non-zero integer that identifies the version of\n     this history record. The virtual ReplayHistory() functions\n     can check this version to avoid replaying history using\n     information created by earlier versions of the command.",since:6,returns:"True if successful."},{signature:"bool SetInt(int id,int value)",since:5},{signature:"bool SetInts(int id,IEnumerable<int> values)",since:5},{signature:"bool SetMesh(int id,Mesh value)",since:5},{signature:"bool SetObjRef(int id,ObjRef value)",since:5},{signature:"bool SetPoint3d(int id,Point3d value)",since:5},{signature:"bool SetPoint3dOnObject(int id,ObjRef objref,Point3d value)",since:5},{signature:"bool SetPoint3ds(int id,IEnumerable<Point3d> values)",since:5},{signature:"bool SetString(int id,string value)",since:5},{signature:"bool SetStrings(int id,IEnumerable<string> values)",since:5},{signature:"bool SetSurface(int id,Surface value)",since:5},{signature:"bool SetTransorm(int id,Transform value)",since:5},{signature:"bool SetVector3d(int id,Vector3d value)",since:5},{signature:"bool SetVector3ds(int id,IEnumerable<Vector3d> values)",since:5}]},{name:"Rhino.DocObjects.InstanceDefinition",dataType:1,summary:"This is the same as , but in a Rhino document.",properties:[{signature:"InstanceDefinitionArchiveFileStatus ArchiveFileStatus",summary:"Returns the archive file status of a linked instance definition.",since:5.2},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"string Description",since:5},{signature:"Guid Id",since:5},{signature:"int Index",summary:"Index of this instance definition in the index definition table.",since:5},{signature:"bool IsDeleted",since:5},{signature:"bool IsReference",summary:"An object from a work session reference model is reference a\n     reference object and cannot be modified.  An object is a reference\n     object if, and only if, it is on a reference layer.",since:5},{signature:"bool IsTenuous",since:5},{signature:"InstanceDefinitionLayerStyle LayerStyle",since:5},{signature:"string Name",since:5},{signature:"int ObjectCount",summary:"Number of objects this definition uses. This counts the objects that are used to define the geometry.\n     This does NOT count the number of references to this instance definition.",since:5},{signature:"bool SkipNestedLinkedDefinitions",summary:"Controls how much geometry is read when a linked InstanceDefinition is updated.",since:5},{signature:"string SourceArchive",since:5},{signature:"InstanceDefinitionUpdateType UpdateType",since:5},{signature:"string Url",summary:"The hyperlink URL that is executed when the UrlDescription hyperlink is clicked on in the Insert and Block UI",since:5},{signature:"string UrlDescription",summary:"The URL description displayed as a hyperlink in the Insert and Block UI",since:5}],methods:[{signature:"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,DisplayMode displayMode,Size bitmapSize)",summary:"Creates a preview bitmap of the instance definition.",since:5,returns:"The preview bitmap if successful, None otherwise."},{signature:"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,DisplayMode displayMode,Size bitmapSize,bool applyDpiScaling)",summary:"Creates a preview bitmap of the instance definition.",since:6,returns:"The preview bitmap if successful, None otherwise."},{signature:"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,Size bitmapSize)",summary:"Creates a wireframe preview bitmap of the instance definition.",since:5,returns:"The preview bitmap if successful, None otherwise."},{signature:"System.Drawing.Bitmap CreatePreviewBitmap(DefinedViewportProjection definedViewportProjection,Size bitmapSize,bool applyDpiScaling)",summary:"Creates a wireframe preview bitmap of the instance definition.",since:6,returns:"The preview bitmap if successful, None otherwise."},{signature:"System.Drawing.Bitmap CreatePreviewBitmap(Guid definitionObjectId,DefinedViewportProjection definedViewportProjection,DisplayMode displayMode,Size bitmapSize,bool applyDpiScaling)",summary:"Creates a preview bitmap of the instance definition.",since:6.21,returns:"The preview bitmap if successful, None otherwise."},{signature:"bool Equals(object obj)",summary:"Equality is checked against InstanceDefinition.Id",returns:"True if obj.Id equals Id"},{signature:"InstanceDefinition[] GetContainers()",summary:"Gets a list of all the InstanceDefinitions that contain a reference this InstanceDefinition.",since:5,returns:"An array of instance definitions. The returned array can be empty, but not null."},{signature:"int GetHashCode()",summary:"Use Id.GetHashCode()"},{signature:"RhinoObject[] GetObjects()",summary:"Gets an array with the objects that belong to this instance definition.",since:5,returns:"An array of Rhino objects. The returned array can be empty, but not null."},{signature:"InstanceObject[] GetReferences(int wheretoLook)",summary:"Gets a list of the CRhinoInstanceObjects (inserts) that contains\n     a reference this instance definition.",since:5,returns:"An array of instance objects. The returned array can be empty, but not null."},{signature:"bool InUse(int wheretoLook)",summary:"Determines whether the instance definition is referenced.",since:5,returns:"True if the instance definition is used; otherwise false."},{signature:"RhinoObject Object(int index)",summary:"returns an object used as part of this definition.",since:5,returns:"Returns an object that is used to define the geometry.\n     Does NOT return an object that references this definition.count the number of references to this instance."},{signature:"int UsesDefinition(int otherIdefIndex)",summary:"Determines if this instance definition contains a reference to another instance definition.",since:5,returns:"0      no\n       1      other_idef_index is the index of this instance definition\n      >1      This InstanceDefinition uses the instance definition\n              and the returned value is the nesting depth."}]},{name:"Rhino.DocObjects.InstanceDefinitionArchiveFileStatus",dataType:3,summary:"The archive file of a linked instance definition can have the following possible states.\n   Use InstanceObject.ArchiveFileStatus to query a instance definition's archive file status."},{name:"Rhino.DocObjects.InstanceDefinitionLayerStyle",dataType:3,summary:"A InstanceDefinitionUpdateType.Static or InstanceDefinitionUpdateType.LinkedAndEmbedded idef\n   must have LayerStyle = Unset, a InstanceDefinitionUpdateType.Linked InstanceDefnition must\n   have LayerStyle = Active or Reference"},{name:"Rhino.DocObjects.InstanceDefinitionUpdateType",dataType:3,summary:"The possible relationships between the instance definition geometry\n   and the archive containing the original defition."},{name:"Rhino.DocObjects.InstanceObject",dataType:1,summary:"",properties:[{signature:"Point3d InsertionPoint",summary:"Basepoint coordinates of a block.",since:5},{signature:"InstanceDefinition InstanceDefinition",summary:"instance definition that this object uses.",since:5},{signature:"Transform InstanceXform",summary:"transformation applied to an instance definition for this object.",since:5}],methods:[{signature:"void Explode(bool explodeNestedInstances,RhinoObject[] pieces,ObjectAttributes[] pieceAttributes,Transform[] pieceTransforms)",summary:"Explodes the instance reference into pieces.",since:5},{signature:"bool UsesDefinition(int definitionIndex,int nestingLevel)",summary:"Determine if this reference uses an instance definition",since:5.2,returns:"True or False depending on if the deifinition is used"}]},{name:"Rhino.DocObjects.Layer",dataType:1,summary:"",constructors:[{signature:"Layer()",since:5}],properties:[{signature:"static string PathSeparator",summary:'The string "::" (colon,colon) is used to\n     separate parent and child layer names.',since:6},{signature:"Color Color",summary:"Gets or sets the display color for this layer.",since:5},{signature:"ComponentStatus ComponentStatus",summary:"Gets or sets the status of the layer.",since:6},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"string FullPath",summary:"Gets the full path to this layer. The full path includes nesting information.",since:5},{signature:"Guid Id",summary:"Gets or sets the ID of this layer object. \n     You typically do not need to assign a custom ID.",since:5},{signature:"int IgesLevel",summary:"Gets or sets the IGES level for this layer.",since:5},{signature:"bool IsDeleted",summary:"Gets a value indicating whether this layer has been deleted and is \n     currently in the Undo buffer.",since:5},{signature:"bool IsExpanded",summary:"Gets or sets a value indicating whether this layer is expanded in the Rhino Layer dialog.",since:5},{signature:"bool IsLocked",summary:"Gets or sets a value indicating the locked state of this layer.",since:5},{signature:"bool IsReference",summary:"Gets a value indicting whether this layer is a referenced layer. \n     Referenced layers are part of referenced documents.",since:5},{signature:"bool IsVisible",summary:"Gets or sets the visibility of this layer.",since:5},{signature:"int LayerIndex",summary:"Gets or sets the index of this layer.",since:5},{signature:"int LinetypeIndex",summary:"Gets or sets the line-type index for this layer.",since:5},{signature:"string Name",summary:"Gets or sets the name of this layer.",since:5},{signature:"Guid ParentLayerId",summary:"Gets the ID of the parent layer. Layers can be origanized in a hierarchical structure, \n     in which case this returns the parent layer ID. If the layer has no parent, \n     Guid.Empty will be returned.",since:5},{signature:"Color PlotColor",summary:"Gets or sets the plot color for this layer.",since:5},{signature:"double PlotWeight",summary:'Gets or sets the weight of the plotting pen in millimeters. \n     A weight of 0.0 indicates the "default" pen weight should be used.\n     A weight of -1.0 indicates the layer should not be printed.',since:5},{signature:"RenderMaterial RenderMaterial",summary:"Gets or sets the  for objects on\n     this layer that have MaterialSource() == MaterialFromLayer.\n     A None result indicates that no  has\n     been assigned  and the material created by the default Material\n     constructor or the  should be used.",since:5.7},{signature:"int RenderMaterialIndex",summary:"Gets or sets the index of render material for objects on this layer that have\n     MaterialSource() == MaterialFromLayer. \n     A material index of -1 indicates no material has been assigned \n     and the material created by the default Material constructor \n     should be used.",since:5},{signature:"int SortIndex",summary:"Runtime index used to sort layers in layer dialog.",since:5},{signature:"int UserStringCount",summary:"Gets the amount of user strings.",since:5}],methods:[{signature:"static Layer GetDefaultLayerProperties()",summary:"Constructs a layer with the current default properties.\n     The default layer properties are:\n     color = Rhino.ApplicationSettings.AppearanceSettings.DefaultLayerColorline style = Rhino.ApplicationSettings.AppearanceSettings.DefaultLayerLineStylematerial index = -1iges level = -1mode = NormalLayername = emptylayer index = 0 (ignored by AddLayer)",since:5,returns:"A new layer instance."},{signature:"static string GetLeafName(Layer layer)",summary:'Get a layer name\'s "leaf" level name',since:6,returns:"leaf name or String.Empty if fullPath does not contain a leaf"},{signature:"static string GetLeafName(string fullPath)",summary:'Get a layer name\'s "leaf" level name',since:6,returns:"leaf name or String.Empty if fullPath does not contain a leaf"},{signature:"static string GetParentName(Layer layer)",summary:'Get a layer\'s "parent" path name',since:6,returns:"parent name or String.Empty"},{signature:"static string GetParentName(string fullPath)",summary:'Get a layer\'s "parent" path name',since:6,returns:"parent name or String.Empty"},{signature:"static bool IsValidName(string name)",summary:"Determines if a given string is valid for a layer name.",since:5,returns:"True if the name is valid for a layer name; otherwise, false."},{signature:"bool CommitChanges()",since:5},{signature:"void CopyAttributesFrom(Layer otherLayer)",summary:"Copy typical attributes from another layer",since:6},{signature:"void Default()",summary:"Sets layer to default settings.",since:5},{signature:"void DeletePerViewportColor(Guid viewportId)",summary:"Remove any per viewport layer color setting so the layer's overall setting will be used for all viewports.",since:6},{signature:"void DeletePerViewportPlotColor(Guid viewportId)",summary:"Remove any per viewport layer plot color setting so the layer's overall setting will be used for all viewports.",since:6},{signature:"void DeletePerViewportPlotWeight(Guid viewportId)",summary:"Remove any per viewport layer plot weight setting so the layer's overall setting will be used for all viewports.",since:6},{signature:"void DeletePerViewportSettings(Guid viewportId)",summary:"Deletes per viewport layer settings.",since:6},{signature:"void DeletePerViewportVisible(Guid viewportId)",summary:"Remove any per viewport visibility setting so the layer's overall setting will be used for all viewports.",since:6},{signature:"bool Equals(Layer other)",since:6},{signature:"bool Equals(object obj)"},{signature:"Layer[] GetChildren()",summary:"Gets immediate children of this layer. Note that child layers may have their own children.",since:5,returns:"Array of child layers. None if this layer does not have any children."},{signature:"int GetHashCode()"},{signature:"bool GetPersistentLocking()",summary:'The persistent locking setting is used for layers that can be locked by\n     a "parent" object. A common case is when a layer is a child layer\n     (Layer.ParentI is not nil). In this case, when a parent layer is locked,\n     then child layers are also locked. The persistent locking setting\n     determines what happens when the parent is unlocked again.',since:5.5},{signature:"bool GetPersistentVisibility()",summary:'The persistent visbility setting is used for layers whose visibilty can\n     be changed by a "parent" object. A common case is when a layer is a\n     child layer (ParentId is not nil). In this case, when a parent layer is\n     turned off, then child layers are also turned off. The persistent\n     visibility setting determines what happens when the parent is turned on\n     again.',since:5.5},{signature:"string GetUserString(string key)",summary:"Gets user string from this geometry.",since:5,returns:"string associated with the key if successful. None if no key was found."},{signature:"System.Collections.Specialized.NameValueCollection GetUserStrings()",summary:"Gets a copy of all (user key string, user value string) pairs attached to this geometry.",since:5,returns:"A new collection."},{signature:"bool HasPerViewportSettings(Guid viewportId)",summary:"Verifies that a layer has per viewport settings.",since:6,returns:"True if the layer has per viewport settings, False otherwise."},{signature:"bool IsChildOf(Guid otherlayerId)",since:6},{signature:"bool IsChildOf(int layerIndex)",since:5},{signature:"bool IsChildOf(Layer otherLayer)",since:5},{signature:"bool IsParentOf(Guid otherLayer)",since:6},{signature:"bool IsParentOf(int layerIndex)",since:5},{signature:"bool IsParentOf(Layer otherLayer)",since:5},{signature:"System.Drawing.Color PerViewportColor(Guid viewportId)",summary:"Gets the display color for this layer.",since:6,returns:"The display color."},{signature:"bool PerViewportIsVisible(Guid viewportId)",summary:"Gets the per viewport visibility of this layer.",since:6,returns:"Returns True if objects on layer are visible."},{signature:"bool PerViewportPersistentVisibility(Guid viewportId)",summary:"Gets the per layer persistent visibility. The persistent visbility setting is used for layers whose visibilty can be changed by a parent layer. \n     In this case, when a parent layer is turned off, then child layers are also turned off.\n     The persistent visibility setting determines what happens when the parent is turned on again.",since:6,returns:"Return True if this layer's visibility in the specified viewport is controlled by a parent object and the parent is turned on (after being off), \n     then this layer will also be turned on in the specified viewport.\n     Returns False if this layer's visibility in the specified viewport is controlled by a parent object and the parent layer is turned on(after being off),\n     then this layer will continue to be off in the specified viewport."},{signature:"System.Drawing.Color PerViewportPlotColor(Guid viewportId)",summary:"Gets the plot color for this layer.",since:6,returns:"The plot color."},{signature:"double PerViewportPlotWeight(Guid viewportId)",summary:"Gets the plot weight, in millimeters, for this layer.",since:6,returns:"The plot color."},{signature:"void SetPersistentLocking(bool persistentLocking)",summary:"Set the persistent locking setting for this layer",since:5.5},{signature:"void SetPersistentVisibility(bool persistentVisibility)",summary:"Set the persistent visibility setting for this layer",since:5.5},{signature:"void SetPerViewportColor(Guid viewportId,Color color)",summary:"Sets the display color for this layer.",since:6},{signature:"void SetPerViewportPersistentVisibility(Guid viewportId,bool persistentVisibility)",summary:"Sets the per layer persistent visibility. The persistent visbility setting is used for layers whose visibilty can be changed by a parent layer. \n     In this case, when a parent layer is turned off, then child layers are also turned off.\n     The persistent visibility setting determines what happens when the parent is turned on again.",since:6},{signature:"void SetPerViewportPlotColor(Guid viewportId,Color color)",summary:"Sets the plot color for this layer.",since:6},{signature:"void SetPerViewportPlotWeight(Guid viewportId,double plotWeight)",summary:"Sets the plot weight, in millimeters, for this layer.",since:6},{signature:"void SetPerViewportVisible(Guid viewportId,bool visible)",summary:"Controls layer visibility in specific viewports.",since:6},{signature:"bool SetUserString(string key,string value)",summary:"Attach a user string (key,value combination) to this geometry.",since:5,returns:"True on success."},{signature:"string ToString()"},{signature:"void UnsetPersistentLocking()",summary:"Remove any explicity persistent locking settings from this layer",since:5.5},{signature:"void UnsetPersistentVisibility()",summary:"Remove any explicit persistent visibility setting from this layer",since:5.5},{signature:"void UnsetPerViewportPersistentVisibility(Guid viewportId)",summary:"Remove any per viewport persistent visibility setting so the layer's overall setting will be used for all viewports.",since:6}]},{name:"Rhino.DocObjects.LeaderObject",dataType:1,summary:"Rhino Object that represents leader geometry and attributes",properties:[{signature:"Leader LeaderGeometry",summary:"Get the leader geometry for this object.",since:6}]},{name:"Rhino.DocObjects.LightObject",dataType:1,summary:"",properties:[{signature:"ModelComponentType ComponentType",since:6},{signature:"Light LightGeometry",since:5}],methods:[{signature:"Light DuplicateLightGeometry()",since:5}]},{name:"Rhino.DocObjects.LinearDimensionObject",dataType:1,summary:"Rhino Object that represents a linear dimension geometry and attributes",properties:[{signature:"LinearDimension LinearDimensionGeometry",summary:"Get the dimension geometry for this object.",since:6}]},{name:"Rhino.DocObjects.Linetype",dataType:1,summary:"",constructors:[{signature:"Linetype()",since:5}],properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"bool IsDeleted",summary:"Gets a value indicating whether this linetype has been deleted and is \n     currently in the Undo buffer.",since:5},{signature:"bool IsModified",summary:"True if this linetype has been modified by LinetypeTable.ModifyLinetype()\n     and the modifications can be undone.",since:5},{signature:"bool IsReference",summary:"Gets a value indicting whether this linetype is a referenced linetype. \n     Referenced linetypes are part of referenced documents.",since:5},{signature:"int LinetypeIndex",summary:"The index of this linetype.",since:5},{signature:"string Name",summary:"The name of this linetype.",since:5},{signature:"double PatternLength",summary:"Total length of one repeat of the pattern.",since:5},{signature:"int SegmentCount",summary:"Number of segments in the pattern.",since:5}],methods:[{signature:"static Linetype[] ReadFromFile(string path)",summary:"Reads linetypes from either a Rhino .3dm file or an AutoCAD .lin file.",since:6.6,returns:"An array of linetypes if successful, otherwise an empty array."},{signature:"int AppendSegment(double length,bool isSolid)",summary:"Adds a segment to the pattern.",since:5,returns:"Index of the added segment."},{signature:"bool CommitChanges()",since:5},{signature:"void Default()",summary:"Set linetype to default settings.",since:5},{signature:"void GetSegment(int index,double length,bool isSolid)",summary:"Gets the segment information at a index.",since:5},{signature:"bool RemoveSegment(int index)",summary:"Removes a segment in the linetype.",since:5,returns:"True if the segment index was removed."},{signature:"bool SetSegment(int index,double length,bool isSolid)",summary:"Sets the length and type of the segment at index.",since:5,returns:"True if the operation was successful; otherwise false."},{signature:"bool SetSegments(IEnumerable<double> segments)",summary:"Set all segments.",since:6.8,returns:"True if the segments were replaced"}]},{name:"Rhino.DocObjects.Material",dataType:1,summary:"",constructors:[{signature:"Material()",since:5},{signature:"Material(Material other)",since:6}],properties:[{signature:"static Material DefaultMaterial",since:5},{signature:"static double MaxShine",since:5},{signature:"bool AlphaTransparency",since:6},{signature:"Color AmbientColor",since:5},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"Color DiffuseColor",since:5},{signature:"bool DisableLighting",since:6},{signature:"Color EmissionColor",since:5},{signature:"double FresnelIndexOfRefraction",summary:"Gets or sets the Fresnel index of refraction of the material,\n     default is 1.56",since:6},{signature:"bool FresnelReflections",summary:"Gets or sets if fresnel reflections are used.",since:6},{signature:"double IndexOfRefraction",summary:"Gets or sets the index of refraction of the material, generally\n     >= 1.0 (speed of light in vacuum)/(speed of light in material)",since:5.1},{signature:"bool IsDefaultMaterial",summary:"By default Rhino layers and objects are assigned the default rendering material.",since:5},{signature:"bool IsDeleted",summary:"Deleted materials are kept in the runtime material table so that undo\n     will work with materials.  Call IsDeleted to determine to determine if\n     a material is deleted.",since:5},{signature:"bool IsDocumentControlled",summary:'If True this object may not be modified. Any properties or functions that attempt\n     to modify this object when it is set to "IsReadOnly" will throw a NotSupportedException.',since:5.6},{signature:"bool IsReference",summary:'Rhino allows multiple files to be viewed simultaneously. Materials in the\n     document are "normal" or "reference". Reference materials are not saved.',since:5},{signature:"int MaterialIndex",since:5.6},{signature:"string Name",since:5},{signature:"PhysicallyBasedMaterial PhysicallyBased",since:7},{signature:"Color PreviewColor",summary:"Very simple preview color function for GUIs.",since:6.6},{signature:"Color ReflectionColor",since:5},{signature:"double ReflectionGlossiness",summary:"Gets or sets the reflection glossiness.",since:6},{signature:"double Reflectivity",summary:"Gets or sets how reflective a material is, 0f is no reflection\n     1f is 100% reflective.",since:5.7},{signature:"double RefractionGlossiness",summary:"Gets or sets the refraction glossiness.",since:6},{signature:"RenderMaterial RenderMaterial",summary:"Get the RenderMaterial related to this Material.\n     \n     Will create a new RenderMaterial if none exists. This can happen for older\n     documents.",since:6},{signature:"Guid RenderMaterialInstanceId",since:6},{signature:"Guid RenderPlugInId",summary:"The Id of the RenderPlugIn that is associated with this material.",since:5},{signature:"double Shine",summary:"Gets or sets the shine factor of the material.",since:5},{signature:"Color SpecularColor",since:5},{signature:"double Transparency",summary:"Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)",since:5},{signature:"Color TransparentColor",since:5},{signature:"int UseCount",summary:"Number of objects and layers that use this material.",since:5},{signature:"int UserStringCount",since:5}],methods:[{signature:"bool CommitChanges()",since:5},{signature:"void CopyFrom(Material other)",since:6},{signature:"void Default()",summary:"Set material to default settings.",since:5},{signature:"Texture GetBitmapTexture()",since:5},{signature:"Texture GetBumpTexture()",summary:"Gets the bump texture of this material.",since:5,returns:"A texture; or None if no bump texture has been added to this material."},{signature:"Texture GetEnvironmentTexture()",since:5},{signature:"Texture GetTexture(TextureType which)",summary:"Get the texture that corresponds with the specified texture type for this material.",since:7},{signature:"Texture[] GetTextures()",summary:"Get array of textures that this material uses",since:5.7},{signature:"Texture GetTransparencyTexture()",since:5},{signature:"string GetUserString(string key)",summary:"Gets a user string.",since:5,returns:"string associated with the key if successful. None if no key was found."},{signature:"System.Collections.Specialized.NameValueCollection GetUserStrings()",summary:"Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.",since:5,returns:"A collection of key strings and values strings. This"},{signature:"bool SetBitmapTexture(string filename)",since:5},{signature:"bool SetBitmapTexture(Texture texture)",since:5},{signature:"bool SetBumpTexture(string filename)",since:5},{signature:"bool SetBumpTexture(Texture texture)",since:5},{signature:"bool SetEnvironmentTexture(string filename)",since:5},{signature:"bool SetEnvironmentTexture(Texture texture)",since:5},{signature:"bool SetTexture(Texture texture,TextureType which)",summary:"Set the texture that corresponds with the specified texture type for this material.",since:7},{signature:"bool SetTransparencyTexture(string filename)",since:5},{signature:"bool SetTransparencyTexture(Texture texture)",since:5},{signature:"bool SetUserString(string key,string value)",summary:"Attach a user string (key,value combination) to this geometry.",since:5,returns:"True on success."}]},{name:"Rhino.DocObjects.MaterialRef",dataType:1,summary:"",properties:[{signature:"Guid BackFaceMaterialId",summary:"The Id of the Material used to render the back of an object.",since:5.1},{signature:"int BackFaceMaterialIndex",summary:"The index of the material used to render the back of an object",since:5.1},{signature:"Guid FrontFaceMaterialId",summary:"The Id of the Material used to render the front of an object.",since:5.1},{signature:"int FrontFaceMaterialIndex",summary:"The index of the material used to render the front of an object",since:5.1},{signature:"ObjectMaterialSource MaterialSource",summary:"Determines if the simple material should come from the object or from\n     it's layer.",since:5.1},{signature:"Guid PlugInId",summary:"Identifies a rendering plug-in",since:5.1}],methods:[{signature:"void Dispose()",since:5.1}]},{name:"Rhino.DocObjects.MaterialRefCreateParams",dataType:1,summary:"Options passed to MaterialRefs.Create",properties:[{signature:"Guid BackFaceMaterialId",summary:"The Id of the Material used to render the back of an object.",since:5.1},{signature:"int BackFaceMaterialIndex",summary:"The index of the material used to render the back of an object",since:5.1},{signature:"Guid FrontFaceMaterialId",summary:"The Id of the Material used to render the front of an object.",since:5.1},{signature:"int FrontFaceMaterialIndex",summary:"The index of the material used to render the front of an object",since:5.1},{signature:"ObjectMaterialSource MaterialSource",summary:"Determines if the simple material should come from the object or from\n     it's layer.",since:5.1},{signature:"Guid PlugInId",summary:"Identifies a rendering plug-in",since:5.1}]},{name:"Rhino.DocObjects.MaterialRefs",dataType:1,summary:"If you are developing a high quality plug-in renderer, and a user is\n   assigning a custom render material to this object, then add rendering\n   material information to the MaterialRefs dictionary.\n   \n   Note to developers:\n    As soon as the MaterialRefs dictionary contains items rendering\n    material queries slow down.  Do not populate the MaterialRefs\n   dictionary when setting the MaterialIndex will take care of your needs.",properties:[{signature:"int Count",summary:"Gets the number of elements contained in this dictionary",since:5.1},{signature:"bool IsReadOnly",summary:"IDictionary required property, always returns False for this dictionary.",since:5.1},{signature:"ICollection<Guid> Keys",summary:"Gets an ICollection containing the plug-in Id's in this dictionary.",since:5.1},{signature:"ICollection<MaterialRef> Values",summary:"Gets an ICollection containing the MaterialRef objects in this\n     dictionary.",since:5.1}],methods:[{signature:"void Add(Guid key,MaterialRef value)",summary:"Add or replace an element with the provided key and value to this dictionary.",since:5.1},{signature:"void Add(KeyValuePair<Guid, MaterialRef> item)",summary:"Adds an item to this dictionary."},{signature:"void Clear()",summary:"Removes all items from this dictionary.",since:5.1},{signature:"bool Contains(KeyValuePair<Guid, MaterialRef> item)",summary:"Determines whether this dictionary contains a specific value.",returns:"True if item is found in this dictionary; otherwise, false."},{signature:"bool ContainsKey(Guid key)",summary:"Determines whether this dictionary contains an MaterialRef with the\n     specified plug-in id.",since:5.1,returns:"True if this dictionary contains an element with the specified plug-in\n     Id; otherwise, false."},{signature:"void CopyTo(KeyValuePair<Guid, MaterialRef>[] array,int arrayIndex)",summary:"Copies the elements of this dictionary to an System.Array, starting at\n     a particular System.Array index."},{signature:"MaterialRef Create(MaterialRefCreateParams createParams)",summary:"Call this method to create a MaterialRef which can be used when calling\n     one of the Add methods.",since:5.1,returns:"A temporary MaterialRef object, the caller is responsible for disposing\n     of this object."},{signature:"IEnumerator<KeyValuePair<Guid, MaterialRef>> GetEnumerator()",summary:"Returns an enumerator that iterates through this dictionary.",since:5.1,returns:"A IEnumerator that can be used to iterate this dictionary."},{signature:"bool Remove(Guid key)",summary:"Removes the MaterialRef with the specified plug-in Id from this\n     dictionary.",since:5.1,returns:"True if the MaterialRef is successfully removed; otherwise, false. This\n     method also returns False if key was not found in the original dictionary."},{signature:"bool Remove(KeyValuePair<Guid, MaterialRef> item)",summary:"Removes the element with the specified plug-in id from the this dictionary."},{signature:"bool TryGetValue(Guid key,MaterialRef value)",summary:"Gets the value associated with the specified key.",since:5.1,returns:"True if this dictionary contains a MaterialRef with the specified key;\n     otherwise, false."}]},{name:"Rhino.DocObjects.MeshObject",dataType:1,summary:"",properties:[{signature:"bool IsCustomObject",since:6},{signature:"Mesh MeshGeometry",since:5}],methods:[{signature:"static bool CheckMeshes(IEnumerable<MeshObject> meshObjects,TextLog textLog,MeshCheckParameters parameters)",summary:"Examines mesh objects and logs a description of what it finds right or wrong.\n     The various properties the function checks for are described in MeshCheckParameters.",since:7,returns:"True if successful, False otherwise."},{signature:"Mesh DuplicateMeshGeometry()",since:5}]},{name:"Rhino.DocObjects.ModelComponent",dataType:1,summary:"Base class for all components in a model (document) and manages the\n   index, id and other information common to this type of objects.\n   This class parallels the C++ ON_ModelComponent.",properties:[{signature:"ComponentStatus ComponentStatus",summary:"Gets or sets the component status of the model component.",since:6},{signature:"ModelComponentType ComponentType",summary:"Gets the  for this object.\n     Useful in switch statements.",since:6},{signature:"string DeletedName",summary:"Gets the name of a component that is deleted.",since:6.2},{signature:"bool HasId",summary:"Returns a value indicating whether the component has an ID.",since:6},{signature:"bool HasIndex",summary:"Returns a value indicating whether the component has an Index.",since:6},{signature:"bool HasName",summary:"Returns a value indicating whether the component has a Name.",since:6},{signature:"Guid Id",summary:"Gets or sets the ID of the current instance.",since:6},{signature:"bool IdIsLocked",summary:"Returns a value indicating whether the component ID is already locked.",since:6},{signature:"int Index",summary:"Gets or sets the model component index attribute.",since:6},{signature:"bool IndexIsLocked",summary:"Returns a value indicating whether the component Index is already locked.",since:6},{signature:"uint InstanceDefinitionModelSerialNumber",summary:"When a component is in a model as part of the information required for a linked instance definition,\n     this value identifies the the linked instance definition reference model.",since:6.12},{signature:"bool IsComponentStatusLocked",summary:"The component status itself can be locked. This returns an indication.",since:6},{signature:"bool IsSystemComponent",summary:"True if this model component is a system constant.\n     An incomplete list of system constant model components is below:ON_ModelComponent::Unset\n     ON_InstanceDefinition::Empty\n     ON_Linetype::UnsetON_Linetype::ContinuousON_Linetype::ByLayerON_Linetype::ByParent\n     ON_Layer::UnsetON_Layer::Default\n     ON_TextStyle::UnsetON_TextStyle::DefaultON_TextStyle::ByLayerON_TextStyle::ByParent\n     ON_DimStyle::UnsetON_DimStyle::DefaultON_DimStyle::DefaultInchDecimalON_DimStyle::DefaultInchFractionalON_DimStyle::DefaultFootInchArchitectureON_DimStyle::DefaultMillimeterSmallON_DimStyle::DefaultMillimeterLargeON_DimStyle::DefaultMillimeterArchitecture",since:6},{signature:"uint ModelSerialNumber",summary:"A value identifing the model that manages this component.",since:6.12},{signature:"string Name",summary:"Gets or sets the name",since:6},{signature:"bool NameIsLocked",summary:"Returns a value indicating whether the component Name is already locked.",since:6},{signature:"uint ReferenceModelSerialNumber",summary:"When a component is in a model for reference, this value identifies the reference model.",since:6.12}],methods:[{signature:"static bool IsValidComponentName(string name)",summary:"Tests for a valid model component name.",since:6.15,returns:"True if the string is a valid model component name, False otherwise."},{signature:"static bool ModelComponentTypeIgnoresCase(ModelComponentType type)",summary:"Informs the developer if a particular model component type will require case-ignoring searching within a document.\n     This is currently True with groups; False otherwise.",since:6},{signature:"static bool ModelComponentTypeIncludesParent(ModelComponentType type)",summary:"Informs the developer if a particular model component type will include the hash of the parent.",since:6},{signature:"static bool ModelComponentTypeRequiresUniqueName(ModelComponentType type)",summary:"Informs the developer if a particular model component type will require uniqueness within a document.\n     This is currently True with render materials and model geometry; False otherwise.",since:6,returns:"True with render materials and model geometry; False otherwise."},{signature:"void ClearId()",summary:"Resets the HasId property of the model component to false, if possible.",since:6},{signature:"void ClearIndex()",summary:"Resets the HasIndex property of the model component to false, if possible.",since:6},{signature:"void ClearName()",summary:"Resets the HasName property of the model component to false, if possible.",since:6},{signature:"uint DataCRC(uint currentRemainder)",summary:"Increments the Cyclic Redundancy Check value by this instance.",since:6,returns:"The updated remainder value."},{signature:"void LockId()",summary:"Locks the component Id property.",since:6},{signature:"void LockIndex()",summary:"Locks the component Index property.",since:6},{signature:"void LockName()",summary:"Locks the component Name property.",since:6},{signature:"string ToString()",summary:"Returns the name of the model component type, and then its name and index."}]},{name:"Rhino.DocObjects.MorphControlObject",dataType:1,summary:"Represents a MorphControl in a document."},{name:"Rhino.DocObjects.ObjectAttributes",dataType:1,summary:"Attributes (color, material, layer,...) associated with a rhino object",constructors:[{signature:"ObjectAttributes()",since:5}],properties:[{signature:"bool CastsShadows",summary:"Gets or sets an object's casts shadows property, or whether or not an object casts shadows on other objects and a ground plane.",since:6},{signature:"ObjectColorSource ColorSource",summary:"The color used to display an object is specified in one of three ways.\n     If ColorSource is ON::color_from_layer, then the object's layer ON_Layer::Color() is used.\n     If ColorSource is ON::color_from_object, then value of m_color is used.\n     If ColorSource is ON::color_from_material, then the diffuse color of the object's\n     render material is used.  See ON_3dmObjectAttributes::MaterialSource() to\n     determine where to get the definition of the object's render material.",since:5},{signature:"Decals Decals",summary:"Gets all object decals associated with this object.",since:5.1},{signature:"int DisplayOrder",summary:'Display order used to force objects to be drawn on top or behind each other.\n     Larger numbers draw on top of smaller numbers.\n     0  = draw object in standard depth buffered order<0 = draw object behind "normal" draw order objects>0 = draw object on top of "normal" draw order objects',since:5.1},{signature:"int GroupCount",summary:"number of groups object belongs to.",since:5},{signature:"bool HasMapping",summary:"A mapping from any plugin source is associated with these attributes\n     Need to do this here to respond correctly to ModifyObjectAttributes event",since:5.1},{signature:"bool IsDocumentControlled",since:5},{signature:"bool IsInstanceDefinitionObject",summary:"Use this query to determine if an object is part of an instance definition.",since:5},{signature:"int LayerIndex",summary:"Gets or sets an associated layer index.\n     Layer definitions in an OpenNURBS model are stored in a layer table.\n     The layer table is conceptually an array of ON_Layer classes.  Every\n     OpenNURBS object in a model is on some layer.  The object's layer\n     is specified by zero based indicies into the ON_Layer array.",since:5},{signature:"int LinetypeIndex",summary:"Gets or sets the linetype index.\n     Linetype definitions in an OpenNURBS model are stored in a linetype table.\n     The linetype table is conceptually an array of ON_Linetype classes. Every\n     OpenNURBS object in a model references some linetype.  The object's linetype\n     is specified by zero based indicies into the ON_Linetype array.Index 0 is reserved for continuous linetype (no pattern).",since:5},{signature:"ObjectLinetypeSource LinetypeSource",summary:"The Linetype used to display an object is specified in one of two ways.\n     If LinetypeSource is ON::linetype_from_layer, then the object's layer ON_Layer::Linetype() is used.\n     If LinetypeSource is ON::linetype_from_object, then value of m_linetype is used.",since:5},{signature:"int MaterialIndex",summary:"Gets or sets the material index.\n     If you want something simple and fast, set the index of\n     the rendering material.",since:5},{signature:"MaterialRefs MaterialRefs",summary:"If you are developing a high quality plug-in renderer, and a user is\n     assigning a custom render material to this object, then add rendering\n     material information to the MaterialRefs dictionary.\n     \n     Note to developers:\n      As soon as the MaterialRefs dictionary contains items rendering\n      material queries slow down.  Do not populate the MaterialRefs\n     dictionary when setting the MaterialIndex will take care of your needs.",since:5.1},{signature:"ObjectMaterialSource MaterialSource",summary:"Determines if the simple material should come from the object or from it's layer.\n     High quality rendering plug-ins should use m_rendering_attributes.",since:5},{signature:"ObjectMode Mode",summary:"An object must be in one of three modes: normal, locked or hidden.\n     If an object is in normal mode, then the object's layer controls visibility\n     and selectability. If an object is locked, then the object's layer controls\n     visibility by the object cannot be selected. If the object is hidden, it is\n     not visible and it cannot be selected.",since:5},{signature:"string Name",summary:"Gets or sets an object optional text name.\n     More than one object in a model can have the same name and\n     some objects may have no name.",since:5},{signature:"Color ObjectColor",summary:"If ON::color_from_object == ColorSource, then color is the object's display color.",since:5},{signature:"ObjectDecoration ObjectDecoration",summary:"Used to indicate an object has a decoration (like an arrowhead on a curve)",since:5},{signature:"Guid ObjectId",summary:"Every object has a Guid (globally unique identifier, also known as UUID, or universally\n     unique identifier). The default value is Guid.Empty.\n     \n     When an object is added to a model, the value is checked.  If the value is Guid.Empty, a\n     new Guid is created. If the value is not None but it is already used by another object\n     in the model, a new Guid is created. If the value is not Guid.Empty and it is not used by\n     another object in the model, then that value persists. When an object is updated, by\n     a move for example, the value of ObjectId persists.\n     This value is the same as the one returned by object.Id.",since:5},{signature:"Color PlotColor",summary:"If plot_color_from_object == PlotColorSource, then PlotColor is the object's plotting color.",since:5},{signature:"ObjectPlotColorSource PlotColorSource",summary:"The color used to plot an object on paper is specified in one of three ways.\n     If PlotColorSource is ON::plot_color_from_layer, then the object's layer ON_Layer::PlotColor() is used.\n     If PlotColorSource is ON::plot_color_from_object, then value of PlotColor() is used.",since:5},{signature:"double PlotWeight",summary:"Plot weight in millimeters.\n     =0.0 means use the default width\n     <0.0 means don't plot (visible for screen display, but does not show on plot)",since:5},{signature:"ObjectPlotWeightSource PlotWeightSource",since:5},{signature:"bool ReceivesShadows",summary:"Gets or sets an object's receives shadows property, or whether or not an object receives shadows from other objects.",since:6},{signature:"ActiveSpace Space",summary:"Starting with V4, objects can be in either model space or page space.\n     If an object is in page space, then ViewportId is not nil and\n     identifies the page it is on.",since:5},{signature:"string Url",summary:"Objects may have an URL. There are no restrictions on what value this\n     URL may have. As an example, if the object came from a commercial part\n     library, the URL might point to the definition of that part.",since:6.8},{signature:"int UserStringCount",since:5},{signature:"Guid ViewportId",summary:"If ViewportId is nil, the object is active in all viewports. If ViewportId is not nil, then \n     this object is only active in a specific view. This field is primarily used to assign page\n     space objects to a specific page, but it can also be used to restrict model space to a\n     specific view.",since:5},{signature:"bool Visible",summary:"Gets or sets an object's visiblity.",since:5},{signature:"int WireDensity",summary:"When a surface object is displayed in wireframe, this controls\n     how many isoparametric wires are used.\n     value    number of isoparametric wires\n     -1       boundary wires (off)\n     0        boundary and knot wires \n     1        boundary and knot wires and, if there are no interior knots, a single interior wire.\n     N>=2     boundary and knot wires and (N+1) interior wires.",since:5}],methods:[{signature:"bool AddHideInDetailOverride(Guid detailId)",summary:"Make this object hidden in a given detail",since:6.1},{signature:"void AddToGroup(int groupIndex)",summary:"Adds object to the group with specified index by appending index to\n     group list.\n     If the object is already in group, nothing is changed.",since:5},{signature:"System.Drawing.Color ComputedPlotColor(RhinoDoc document)",since:5.6},{signature:"System.Drawing.Color ComputedPlotColor(RhinoDoc document,Guid viewportId)",since:5.6},{signature:"double ComputedPlotWeight(RhinoDoc document)",since:5.6},{signature:"double ComputedPlotWeight(RhinoDoc document,Guid viewportId)",since:5.6},{signature:"void DeleteAllUserStrings()",since:6},{signature:"bool DeleteUserString(string key)",since:6},{signature:"System.Drawing.Color DrawColor(RhinoDoc document)",since:5},{signature:"System.Drawing.Color DrawColor(RhinoDoc document,Guid viewportId)",since:5},{signature:"ObjectAttributes Duplicate()",summary:"Constructs a copy of this  instance.",since:5,returns:"A new instance on success, or None on failure."},{signature:"Guid GetDisplayModeOverride(Guid viewportId)",summary:"Returns the id of the display mode of an objects. Object display modes are view based. Thus, it is possible to have an object display different in different views.",since:6.18,returns:"A display node id if the object has a display mode override for the viewport; otherwise Guid.Empty is returned."},{signature:"int[] GetGroupList()",summary:"Returns an array of GroupCount group indices.  If GroupCount is zero, then GetGroupList() returns null.",since:5,returns:"An array of group indices. None might be returned in place of an empty array."},{signature:"Guid[] GetHideInDetailOverrides()",summary:"Get list of details that this object is supposed to be hidden in",since:6.1},{signature:"string GetUserString(string key)",summary:"Gets a user string.",since:5,returns:"string associated with the key if successful. None if no key was found."},{signature:"System.Collections.Specialized.NameValueCollection GetUserStrings()",summary:"Gets an independent copy of the collection of (user text key, user text value) pairs attached to this object.",since:5,returns:"A collection of key strings and values strings. This"},{signature:"bool HasDisplayModeOverride(Guid viewportId)",summary:"Determines if an object has a display mode override for a given viewport.",since:5,returns:"True if the object has a display mode override for the viewport; otherwise, false."},{signature:"bool HasHideInDetailOverrideSet(Guid detailId)",summary:"Is this object supposed to be hidden in a given detail",since:6.1},{signature:"void RemoveDisplayModeOverride()",summary:"By default, objects are drawn using the display mode of the viewport that\n     the object is being drawn in. Setting a specific display mode, instructs\n     Rhino to always use that display mode, regardless of the viewport's mode.\n     This function resets an object to use the viewport's display mode for all\n     viewports.",since:5},{signature:"void RemoveDisplayModeOverride(Guid rhinoViewportId)",summary:"By default, objects are drawn using the display mode of the viewport that\n     the object is being drawn in. Setting a specific display mode, instructs\n     Rhino to always use that display mode, regardless of the viewport's mode.\n     This function resets an object to use the viewport's display mode.",since:5},{signature:"void RemoveFromAllGroups()",summary:"Removes object from all groups.",since:5},{signature:"void RemoveFromGroup(int groupIndex)",summary:"removes object from the group with specified index.\n     If the object is not in the group, nothing is changed.",since:5},{signature:"bool RemoveHideInDetailOverride(Guid detailId)",summary:"Remove hidden in detail flag for a specific detail",since:6.1},{signature:"bool SetDisplayModeOverride(DisplayModeDescription mode)",summary:"By default, objects are drawn using the display mode of the viewport that\n     the object is being drawn in. Setting a specific display mode, instructs\n     Rhino to always use that display mode, regardless of the viewport's mode.\n     This version affects the object's display mode for all viewports.",since:5,returns:"True if setting was successful."},{signature:"bool SetDisplayModeOverride(DisplayModeDescription mode,Guid rhinoViewportId)",summary:"By default, objects are drawn using the display mode of the viewport that\n     the object is being drawn in. Setting a specific display mode, instructs\n     Rhino to always use that display mode, regardless of the viewport's mode.\n     This version sets a display mode for a specific viewport.",since:5,returns:"True on success."},{signature:"bool SetUserString(string key,string value)",summary:"Attach a user string (key,value combination) to this geometry.",since:5,returns:"True on success."},{signature:"bool Transform(Transform xform)",summary:"Apply a transformation.",since:6,returns:"trueif successful, False otherwise."}]},{name:"Rhino.DocObjects.ObjectColorSource",dataType:3,summary:"Defines enumerated values for the source of display color of single objects."},{name:"Rhino.DocObjects.ObjectDecoration",dataType:3,summary:"Defines bit mask values to represent object decorations."},{name:"Rhino.DocObjects.ObjectEnumeratorSettings",dataType:1,summary:"Settings used for getting an enumerator of objects in a document\n   See Rhino.Collections.ObjectTable.GetEnumerator()",constructors:[{signature:"ObjectEnumeratorSettings()",since:5}],properties:[{signature:"bool ActiveObjects",since:5},{signature:"Type ClassTypeFilter",since:5},{signature:"bool DeletedObjects",since:5},{signature:"bool HiddenObjects",since:5},{signature:"bool IdefObjects",summary:"When true, ONLY Instance Definitions will be returned",since:5},{signature:"bool IncludeGrips",since:5},{signature:"bool IncludeLights",since:5},{signature:"bool IncludePhantoms",since:5},{signature:"int LayerIndexFilter",since:5},{signature:"bool LockedObjects",since:5},{signature:"string NameFilter",since:5},{signature:"bool NormalObjects",since:5},{signature:"ObjectType ObjectTypeFilter",since:5},{signature:"bool ReferenceObjects",since:5},{signature:"bool SelectedObjectsFilter",since:5},{signature:"RhinoViewport ViewportFilter",summary:"Filter on value of object->IsActiveInViewport()",since:5.6},{signature:"bool VisibleFilter",since:5}]},{name:"Rhino.DocObjects.ObjectLinetypeSource",dataType:3,summary:"Defines enumerated values for the source of linetype of single objects."},{name:"Rhino.DocObjects.ObjectMaterialSource",dataType:3,summary:"Defines enumerated values for the source of material of single objects."},{name:"Rhino.DocObjects.ObjectMode",dataType:3,summary:"Defines enumerated values for the display and behavior of single objects."},{name:"Rhino.DocObjects.ObjectPlotColorSource",dataType:3,summary:"Defines enumerated values for the source of plotting/printing color of single objects."},{name:"Rhino.DocObjects.ObjectPlotWeightSource",dataType:3,summary:"Defines enumerated values for the source of plotting/printing weight of single objects."},{name:"Rhino.DocObjects.ObjectType",dataType:3,summary:"Defines binary mask values for each object type that can be found in a document."},{name:"Rhino.DocObjects.ObjRef",dataType:1,summary:"Represents a reference to a Rhino object.",constructors:[{signature:"ObjRef(Guid id)",summary:"Initializes a new object reference from a globally unique identifier ().",since:5},{signature:"ObjRef(Guid id,ComponentIndex ci)",summary:'Initializes a new object reference from a guid and component index. The\n     component index is used to specify a "piece" of the geometry',since:7},{signature:"ObjRef(RhinoObject rhinoObject)",summary:"Initializes a new object reference from a Rhino object.",since:5},{signature:"ObjRef(RhinoObject rhinoObject,PickContext pickContext)",summary:"Initialized a new object reference from a Rhino object and pick context",since:5}],properties:[{signature:"ComponentIndex GeometryComponentIndex",summary:"Gets the component index of the referenced (sub) geometry.\n     Some objects have subobjects that are valid pieces of geometry. For\n     example, breps have edges and faces that are valid curves and surfaces.\n     Each subobject has a component index that is > 0. The parent\n     geometry has a component index = -1.",since:5},{signature:"Guid ObjectId",summary:"Returns the id of the referenced Rhino object.",since:5},{signature:"uint RuntimeSerialNumber",summary:"If > 0, then this is the value of a Rhino object's serial number field.\n     The serial number is used instead of the pointer to prevent crashes in\n     cases when the RhinoObject is deleted but an ObjRef continues to reference\n     the Rhino object. The value of RuntimeSerialNumber is not saved in archives\n     because it generally changes if you save and reload an archive.",since:5}],methods:[{signature:"Brep Brep()",summary:"Gets the brep if this reference geometry is one.",since:5,returns:"A boundary representation; or None on error."},{signature:"ClippingPlaneSurface ClippingPlaneSurface()",summary:"Gets the clipping plane surface if this reference targeted one.",since:5,returns:"A clipping plane surface, or None if this reference targeted something else."},{signature:"Curve Curve()",summary:"Gets the curve if this reference targeted one.",since:5,returns:"A curve, or None if this reference targeted something else."},{signature:"Curve CurveParameter(double parameter)",summary:"If the reference geometry is a curve or edge with a selection\n     point, then this gets the parameter of the selection point.",since:5,returns:"If the selection point was on a curve or edge, then the\n     curve/edge is returned, otherwise null."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"BrepEdge Edge()",summary:"Gets the edge if this reference geometry is one.",since:5,returns:"A boundary representation edge; or None on error."},{signature:"BrepFace Face()",summary:"If the referenced geometry is a brep face, a brep with one face, or\n     a surface, this returns the brep face.",since:5,returns:"A boundary representation face; or None on error."},{signature:"GeometryBase Geometry()",summary:"Gets the geometry linked to the object targeted by this reference.",since:5,returns:"The geometry."},{signature:"Hatch Hatch()",summary:"Gets the hatch if the referenced geometry is one.",since:5,returns:"A hatch; or None if the referenced object is not a hatch"},{signature:"RhinoObject InstanceDefinitionPart()",summary:"If subobject selection is enabled and a piece of an instance reference\n     is selected, this will return the selected piece.",since:6},{signature:"Light Light()",summary:"Gets the light if the referenced geometry is one.",since:5,returns:"A light; or None if the referenced object is not a light, or on error."},{signature:"Mesh Mesh()",summary:"Gets the mesh if the referenced geometry is one.",since:5,returns:"A mesh; or None if the referenced object is not a mesh, or on error."},{signature:"RhinoObject Object()",summary:"Returns the referenced Rhino object.",since:5},{signature:"Point Point()",summary:"Gets the point if the referenced geometry is one.",since:5,returns:"A point; or None if the referenced object is not a point, or on error."},{signature:"PointCloud PointCloud()",summary:"Gets the point cloud if the referenced geometry is one.",since:5,returns:"A point cloud; or None if the referenced object is not a point cloud, or on error."},{signature:"SelectionMethod SelectionMethod()",summary:"Gets the method used to select this object.",since:5,returns:"The method used to select this object."},{signature:"Point3d SelectionPoint()",summary:"If the object was selected by picking a point on it, then\n     SelectionPoint() returns the point where the selection\n     occured, otherwise it returns Point3d.Unset.",since:5,returns:"The point where the selection occured or Point3d.Unset on failure."},{signature:"RhinoView SelectionView()",summary:"If the object was interactively selected in a particular viewport, then\n     SelectionView() returns the view where the object was selected.",since:6.5},{signature:"uint SelectionViewDetailSerialNumber()",summary:"If the object was interactively selected in a page space detail\n     view, then SelectionViewDetailSerialNumber() returns the CRhinoObject\n     serial number of the detail view object.  Use SelectionView()\n     to get the page view that contains the detail view object.\n     If SelectionViewDetailSerialNumber() returns 0, then the selection\n     did not happen in a detail view.",since:6.5},{signature:"void SetSelectionComponent(ComponentIndex componentIndex)",summary:"When an object is selected by picking a sub-object, SetSelectionComponent\n     may be used to identify the sub-object.",since:5},{signature:"SubD SubD()",summary:"Gets the SubD if the referenced geometry is one.",since:7,returns:"A SubD; or None if the referenced object is not a SubD, or on error."},{signature:"Surface Surface()",summary:"Gets the surface if the referenced geometry is one.",since:5,returns:"A surface; or None if the referenced object is not a surface, or on error."},{signature:"Surface SurfaceParameter(double u,double v)",summary:"If the reference geometry is a surface, brep with one face,\n     or surface edge with a selection point, then this gets the \n     surface paramters of the selection point.",since:5,returns:"If the selection point was on a surface, then the surface is returned."},{signature:"TextDot TextDot()",summary:"Gets the text dot if the referenced geometry is one.",since:5,returns:"A text dot; or None if the referenced object is not a text dot, or on error."},{signature:"TextEntity TextEntity()",summary:"Gets the text entity if the referenced geometry is one.",since:5,returns:"A text entity; or None if the referenced object is not a text entity, or on error."},{signature:"BrepTrim Trim()",summary:"If the referenced geometry is an edge of a surface,\n     this returns the associated brep trim.",since:5.8,returns:"A boundary representation trim; or None on error"}]},{name:"Rhino.DocObjects.OrdinateDimensionObject",dataType:1,summary:"Rhino Object that represents an ordinate dimension geometry and attributes",properties:[{signature:"OrdinateDimension OrdinateDimensionGeometry",summary:"Get the dimension geometry for this object.",since:6}]},{name:"Rhino.DocObjects.PointCloudObject",dataType:1,summary:"",properties:[{signature:"PointCloud PointCloudGeometry",since:5}],methods:[{signature:"PointCloud DuplicatePointCloudGeometry()",since:5}]},{name:"Rhino.DocObjects.PointObject",dataType:1,summary:"",properties:[{signature:"Point PointGeometry",since:5}],methods:[{signature:"Point DuplicatePointGeometry()",since:5}]},{name:"Rhino.DocObjects.ProxyObject",dataType:1,summary:"A proxy object (not saved in files)",methods:[{signature:"int CreateMeshes(MeshType meshType,MeshingParameters parameters,bool ignoreCustomParameters)",since:7},{signature:"Mesh[] GetMeshes(MeshType meshType)",since:7}]},{name:"Rhino.DocObjects.RadialDimensionObject",dataType:1,summary:"Rhino Object that represents a radial dimension geometry and attributes",properties:[{signature:"RadialDimension RadialDimensionGeometry",summary:"Get the dimension geometry for this object.",since:6}]},{name:"Rhino.DocObjects.ReplayHistoryData",dataType:1,summary:"Provides history information to commands that will repeat history construction.\n   Generally, a developer using this class will not construct a new instance, but receive one.",properties:[{signature:"RhinoDoc Document",summary:"The document this record belongs to",since:5},{signature:"int HistoryVersion",summary:"ReplayHistory overrides check the version number to ensure the information\n     saved in the history record is compatible with the current implementation\n     of ReplayHistory",since:5},{signature:"Guid RecordId",summary:"Each history record has a unique id that Rhino assigns when it adds the\n     history record to the history record table",since:5},{signature:"ReplayHistoryResult[] Results",summary:"Provides access to BOTH inputs and outputs of the replay history operation.\n     Use this property to then call an appropriate UpdateToX() method and make your\n     custom history support work.",since:5}],methods:[{signature:"void Dispose()",since:5},{signature:"Rhino.DocObjects.ObjRef GetRhinoObjRef(int id)",summary:"In ReplayHistory, use GetRhinoObjRef to convert the information\n     in a history record into the ObjRef that has up to date\n     RhinoObject pointers",since:5,returns:"ObjRef on success, None if not successful"},{signature:"bool TryGetBool(int id,bool value)",since:5},{signature:"bool TryGetColor(int id,Color value)",since:5},{signature:"bool TryGetDouble(int id,double value)",since:5},{signature:"bool TryGetDoubles(int id,double[] values)",since:6.1},{signature:"bool TryGetGuid(int id,Guid value)",since:5},{signature:"bool TryGetInt(int id,int value)",since:5},{signature:"bool TryGetPoint3d(int id,Point3d value)",since:5},{signature:"bool TryGetPoint3dOnObject(int id,Point3d value)",since:6},{signature:"bool TryGetString(int id,string value)",since:5},{signature:"bool TryGetTransform(int id,Transform value)",since:5},{signature:"bool TryGetVector3d(int id,Vector3d value)",since:5}]},{name:"Rhino.DocObjects.ReplayHistoryResult",dataType:1,summary:"",properties:[{signature:"RhinoObject ExistingObject",summary:"The previously existing object.\n     Do not attempt to edit this object. It might have been already deleted by, for example, dragging.",since:5}],methods:[{signature:"bool UpdateToAngularDimension(AngularDimension dimension,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToArc(Arc arc,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToBrep(Brep brep,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToCircle(Circle circle,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToCurve(Curve curve,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToEllipse(Ellipse ellipse,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToExtrusion(Extrusion extrusion,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToHatch(Hatch hatch,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToLeader(Leader leader,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToLine(Point3d from,Point3d to,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToLinearDimension(LinearDimension dimension,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToMesh(Mesh mesh,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToPoint(Point3d point,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToPointCloud(PointCloud cloud,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToRadialDimension(RadialDimension dimension,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToSphere(Sphere sphere,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToSurface(Surface surface,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToText(TextEntity text,ObjectAttributes attributes)",since:5},{signature:"bool UpdateToTextDot(TextDot dot,ObjectAttributes attributes)",since:5}]},{name:"Rhino.DocObjects.RhinoDeselectAllObjectsEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5},{signature:"int ObjectCount",since:5}]},{name:"Rhino.DocObjects.RhinoModifyObjectAttributesEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5},{signature:"ObjectAttributes NewAttributes",since:5},{signature:"ObjectAttributes OldAttributes",since:5},{signature:"RhinoObject RhinoObject",since:5}]},{name:"Rhino.DocObjects.RhinoObject",dataType:1,summary:"Represents an object in the document.\n   RhinoObjects should only ever be creatable by the RhinoDoc.",properties:[{signature:"static uint NextRuntimeSerialNumber",summary:"Gets the runtime serial number that will be assigned to\n     the next Rhino Object that is created.",since:5},{signature:"ObjectAttributes Attributes",summary:"Gets or sets the object attributes.",since:5},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"RhinoDoc Document",summary:"Gets the document that owns this object.",since:5},{signature:"GeometryBase Geometry",summary:"Gets the underlying geometry for this object.\n     All rhino objects are composed of geometry and attributes.",since:5},{signature:"bool GripsOn",summary:"Gets or sets the activation state of object default editing grips.",since:5},{signature:"bool GripsSelected",summary:"True if grips are turned on and at least one is selected.",since:5},{signature:"int GroupCount",summary:"Number of groups object belongs to.",since:5},{signature:"bool HasDynamicTransform",summary:"True if the object has a dynamic transformation",since:5},{signature:"bool HasSubobjectMaterials",summary:"Will be True if the object contains sub object meshes with materials\n     that are different than the top level object.",since:6},{signature:"Guid Id",summary:"Every object has a Guid (globally unique identifier, also known as UUID, or universally\n     unique identifier). The default value is Guid.Empty.\n     \n     When an object is added to a model, the value is checked.  If the value is Guid.Empty, a\n     new Guid is created. If the value is not None but it is already used by another object\n     in the model, a new Guid is created. If the value is not Guid.Empty and it is not used by\n     another object in the model, then that value persists. When an object is updated, by\n     a move for example, the value of ObjectId persists.\n     This value is the same as the one returned by this.Attributes.ObjectId.",since:5},{signature:"uint InstanceDefinitionModelSerialNumber",summary:"When a component is in a model as part of the information required for a linked instance definition,\n     this value identifies the the linked instance definition reference model.",since:6.12},{signature:"bool IsDeletable",summary:"Some objects cannot be deleted, like grips on lights and annotation objects.",since:5},{signature:"bool IsDeleted",summary:"True if the object is deleted. Deleted objects are kept by the document\n     for undo purposes. Call RhinoDoc.UndeleteObject to undelete an object.",since:5},{signature:"bool IsHidden",summary:"An object must be in one of three modes: normal, locked or hidden.\n     If an object is in normal mode, then the object's layer controls visibility\n     and selectability. If an object is locked, then the object's layer controls\n     visibility by the object cannot be selected. If the object is hidden, it is\n     not visible and it cannot be selected.",since:5},{signature:"bool IsInstanceDefinitionGeometry",summary:"True if the object is used as part of an instance definition.",since:5},{signature:"bool IsLocked",summary:"An object must be in one of three modes: normal, locked or hidden.\n     If an object is in normal mode, then the object's layer controls visibility\n     and selectability. If an object is locked, then the object's layer controls\n     visibility by the object cannot be selected. If the object is hidden, it is\n     not visible and it cannot be selected.",since:5},{signature:"bool IsNormal",summary:"An object must be in one of three modes: normal, locked or hidden.\n     If an object is in normal mode, then the object's layer controls visibility\n     and selectability. If an object is locked, then the object's layer controls\n     visibility by the object cannot be selected. If the object is hidden, it is\n     not visible and it cannot be selected.",since:5},{signature:"bool IsReference",summary:"Gets a value indicating if an object is a reference object. An object from a work session\n     reference model is a reference object and cannot be modified. An object is\n     a reference object if, and only if, it is on a reference layer.",since:5},{signature:"string Name",summary:"Rhino objects have optional text names.  More than one object in\n     a model can have the same name and some objects may have no name.",since:5},{signature:"ObjectType ObjectType",summary:"Gets the Rhino-based object type.",since:5},{signature:"uint ReferenceModelSerialNumber",summary:"When a component is in a model for reference, this value identifies the reference model.",since:6.12},{signature:"RenderMaterial RenderMaterial",summary:"Gets the render material associated with this object or None if there\n     is none.  This does not pay attention to the material source and will\n     not check parent objects or layers for a RenderMaterial.",since:5.7},{signature:"uint RuntimeSerialNumber",summary:"Gets the objects runtime serial number.",since:5},{signature:"ComponentIndex[] SubobjectMaterialComponents",since:6},{signature:"bool Visible",summary:"Gets the object visibility.",since:5},{signature:"uint WorksessionReferenceSerialNumber",summary:"Obsolete - use ReferenceModelSerialNumber",since:6.3}],methods:[{signature:"static RhinoObject FromRuntimeSerialNumber(uint serialNumber)",summary:"Get a Rhino object for a unique runtime serial number",since:6},{signature:"static Brep[] GetFillSurfaces(RhinoObject rhinoObject,ClippingPlaneObject clippingPlaneObject)",summary:"Return list of fill surfaces if any for object and clipping plane.",since:6.7},{signature:"static Brep[] GetFillSurfaces(RhinoObject rhinoObject,IEnumerable<ClippingPlaneObject> clippingPlaneObjects)",summary:"Return list of fill surfaces if any for object and clipping plane. Fills are trimmed by\n     clipping planes that did not generate them.",since:6.7,returns:"Array of Brep containing fully trimmed fills if there were any generated."},{signature:"static Brep[] GetFillSurfaces(RhinoObject rhinoObject,IEnumerable<ClippingPlaneObject> clippingPlaneObjects,bool unclippedFills)",summary:"Return list of fill surfaces if any for object and clipping plane.",since:6.7,returns:"Array of Brep containing fills if there were any generated, trimmed if unclippedFills was false"},{signature:"static ObjRef[] GetRenderMeshes(IEnumerable<RhinoObject> rhinoObjects,bool okToCreate,bool returnAllObjects)",summary:"Gets the render meshes of some objects.",since:5,returns:"An array of object references."},{signature:"static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects,MeshingParameters parameters,bool simpleDialog,Mesh[] meshes,ObjectAttributes[] attributes)",summary:"Meshes Rhino objects.",since:5.9,returns:"The results of the calculation."},{signature:"static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects,MeshingParameters parameters,int uiStyle,Transform xform,Mesh[] meshes,ObjectAttributes[] attributes)",summary:"Meshes Rhino objects.",since:6,returns:"The results of the calculation."},{signature:"static Commands.Result MeshObjects(IEnumerable<RhinoObject> rhinoObjects,MeshingParameters parameters,Mesh[] meshes,ObjectAttributes[] attributes)",summary:"Meshes Rhino objects.",since:5.9,returns:"The results of the calculation."},{signature:"bool CommitChanges()",summary:"Moves changes made to this RhinoObject into the RhinoDoc.",since:5,returns:"True if changes were made."},{signature:"int CreateMeshes(MeshType meshType,MeshingParameters parameters,bool ignoreCustomParameters)",summary:"Create meshes used to render and analyze surface and polysrf objects.",since:5,returns:"number of meshes created"},{signature:"void Description(TextLog textLog)",summary:"Get a brief description of a object, including it's attributes and geometry.",since:6},{signature:"GeometryBase DuplicateGeometry()",summary:"Constructs a deep (full) copy of the geometry.",since:5,returns:"A copy of the internal geometry."},{signature:"bool EnableCustomGrips(CustomObjectGrips customGrips)",summary:"Turns on/off the object's editing grips.",since:5,returns:"True if the call succeeded.  If you attempt to add custom grips to an\n     object that does not support custom grips, then False is returned."},{signature:"bool EnableVisualAnalysisMode(VisualAnalysisMode mode,bool enable)",summary:"Used to turn analysis modes on and off.",since:5,returns:"True if this object supports the analysis mode."},{signature:"Display.VisualAnalysisMode[] GetActiveVisualAnalysisModes()",summary:"Gets a list of currently enabled analysis modes for this object.",since:5,returns:"An array of visual analysis modes. The array can be empty, but not null."},{signature:"IConvertible GetCustomRenderMeshParameter(Guid providerId,String parameterName)",summary:"Query the object for the value of a given named custom render mesh parameter.",since:6,returns:"IConvertible. Note that you can't directly cast from object, instead you have to use the Convert mechanism."},{signature:"bool GetDynamicTransform(Transform transform)",summary:"While an object is being dynamically tranformed (dragged, rotated, ...),\n     the current transformation can be retrieved and used for creating\n     dynamic display.",since:5,returns:"True if the object is being edited and its transformation\n     is available.  False if the object is not being edited,\n     in which case the identity xform is returned."},{signature:"GripObject[] GetGrips()",summary:"Returns grips for this object If grips are enabled. If grips are not\n     enabled, returns null.",since:5,returns:"An array of grip objects; or None if there are no grips."},{signature:"int[] GetGroupList()",summary:"Allocates an array of group indices of length GroupCount.\n     If  is 0, then this method returns null.",since:5,returns:"An array of group indices, or None if  is 0."},{signature:"ComponentIndex[] GetHighlightedSubObjects()",summary:"Gets a list of all highlighted subobjects.",since:5,returns:"An array of all highlighted subobjects; or None is there are none."},{signature:"Material GetMaterial(bool frontMaterial)",summary:"Gets material that this object uses based on it's attributes and the document\n     that the object is associated with.  In the rare case that a document is not\n     associated with this object, None will be returned.",since:5},{signature:"Material GetMaterial(ComponentIndex componentIndex)",summary:"Get the Material associated with the sub object\n     identified by componentIndex if the component index is\n     set to ComponentIndex.Unset\n     then the top level material is returned.",since:6,returns:"Returns the Material associated with the sub object\n     identified by componentIndex if the component index is\n     set to ComponentIndex.Unset then the top level material\n     is returned."},{signature:"Material GetMaterial(ComponentIndex componentIndex,Guid plugInId)",summary:"Get the Material associated with the sub object\n     identified by componentIndex if the component index is\n     set to ComponentIndex.Unset\n     then the top level material is returned.",since:6,returns:"Returns the Material associated with the sub object\n     identified by componentIndex if the component index is set to\n     ComponentIndex.Unset\n     then the top level material is returned."},{signature:"Material GetMaterial(ComponentIndex componentIndex,Guid plugInId,ObjectAttributes attributes)",summary:"Get the Material associated with the sub object\n     identified by componentIndex if the component index is\n     set to ComponentIndex.Unset then the top level material\n     is returned.",since:6,returns:"Returns the Material associated with the sub object\n     identified by componentIndex if the component index is set to\n     ComponentIndex.Unset then the top level material is returned."},{signature:"Mesh[] GetMeshes(MeshType meshType)",summary:"Get existing meshes used to render and analyze surface and polysrf objects.",since:5,returns:"An array of meshes."},{signature:"RenderMaterial GetRenderMaterial(bool frontMaterial)",summary:"Gets the RenderMaterial that this object uses based on it's attributes\n     and the document that the object is associated with. If there is no \n     RenderMaterial associated with this object then None is returned.  If\n     None is returned you should call GetMaterial to get the material used\n     to render this object.",since:5.1,returns:"If there is a RenderMaterial associated with this objects' associated\n     Material then it is returned otherwise; None is returned."},{signature:"RenderMaterial GetRenderMaterial(ComponentIndex componentIndex)",summary:"Gets the RenderMaterial associated with this object if there is one. If\n     there is no RenderMaterial associated with this object then None is\n     returned.  If None is returned you should call GetMaterial to get the\n     material used to render this object.",since:6,returns:"Returns the  associated with the sub object\n     identified by componentIndex if the component index is set to\n      then the top level\n     RenderMaterail is returned.  If this method returns None it means there\n     is no RenderMaterial associated with the object or  sub object so you\n     should may GetMaterial get the objects generic material."},{signature:"RenderMaterial GetRenderMaterial(ComponentIndex componentIndex,Guid plugInId)",summary:"Gets the RenderMaterial associated with this object if there is one. If\n     there is no RenderMaterial associated with this object then None is\n     returned.  If None is returned you should call GetMaterial to get the\n     material used to render this object.",since:6,returns:"Returns the  associated with the sub object\n     identified by componentIndex if the component index is set to\n      then the top level\n     RenderMaterail is returned.  If this method returns None it means there\n     is no RenderMaterial associated with the object or sub object so you\n     should may GetMaterial get the objects generic material."},{signature:"RenderMaterial GetRenderMaterial(ComponentIndex componentIndex,Guid plugInId,ObjectAttributes attributes)",summary:"Gets the RenderMaterial associated with this object if there is one. If\n     there is no RenderMaterial associated with this object then None is\n     returned.  If None is returned you should call GetMaterial to get the\n     material used to render this object.",since:6,returns:"Returns the  associated with the sub object\n     identified by componentIndex if the component index is set to\n      then the top level\n     RenderMaterail is returned.  If this method returns None it means there\n     is no RenderMaterial associated with the object or  sub object so you\n     should may GetMaterial get the objects generic material."},{signature:"MeshingParameters GetRenderMeshParameters()",summary:"Meshing parameters that this object uses for generating render meshes. If the\n     object's attributes do not have custom meshing parameters, then the document's\n     meshing parameters are used.",since:5},{signature:"RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport,bool preview)",summary:"Build custom render mesh(es) for this object.",since:5.7,returns:"Returns a RenderPrimitiveList if successful otherwise returns null."},{signature:"RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)",summary:"Build custom render mesh(es) for this object.",since:6,returns:"Returns a RenderPrimitiveList if successful otherwise returns null."},{signature:"ComponentIndex[] GetSelectedSubObjects()",summary:"Get a list of all selected sub-objects.",since:5,returns:"An array of subobject indices, or None if there are none."},{signature:"RhinoObject[] GetSubObjects()",summary:"Gets an array of sub-objects.",since:5,returns:"An array of subobjects, or None if there are none."},{signature:"int[] GetTextureChannels()",summary:"Get a list of the texture mapping channel Id's associated with object.",since:5.7,returns:"Returns an array of channel Id's or an empty list if there are not mappings."},{signature:"TextureMapping GetTextureMapping(int channel)",since:5.7},{signature:"TextureMapping GetTextureMapping(int channel,Transform objectTransform)",summary:"Get objects texture mapping",since:5.7},{signature:"bool HasTextureMapping()",summary:"Returns True if this object has a texture mapping form any source (pluginId)",since:6},{signature:"bool Highlight(bool enable)",summary:"Modifies the highlighting of the object.",since:5,returns:"True if the object is now highlighted."},{signature:"bool HighlightSubObject(ComponentIndex componentIndex,bool highlight)",summary:"Highlights a subobject.",since:5,returns:"True if the subobject is now highlighted."},{signature:"bool InVisualAnalysisMode()",summary:"Reports if any visual analysis mode is currently active for an object.",since:5,returns:"True if an analysis mode is active; otherwise false."},{signature:"bool InVisualAnalysisMode(VisualAnalysisMode mode)",summary:"Reports if a visual analysis mode is currently active for an object.",since:5,returns:"True if the specified analysis mode is active; otherwise false."},{signature:"bool IsActiveInViewport(RhinoViewport viewport)",summary:"Determine if this object is active in a particular viewport.",since:5,returns:"True if the object is active in viewport"},{signature:"int IsHighlighted(bool checkSubObjects)",summary:"Check highlight state.",since:5,returns:"0: object is not highlighted.1: entire object is highlighted.3: one or more proper sub-objects are highlighted."},{signature:"bool IsMeshable(MeshType meshType)",summary:"Returns True if the object is capable of having a mesh of the specified type",since:5},{signature:"bool IsSelectable()",summary:"Reports if an object can be selected.",since:5,returns:"True if object is capable of being selected."},{signature:"bool IsSelectable(bool ignoreSelectionState,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)",summary:"Reports if an object can be selected.",since:5,returns:"True if object is capable of being selected."},{signature:"int IsSelected(bool checkSubObjects)",summary:"Check selection state.",since:5,returns:"0 = object is not selected.\n     1 = object is selected.\n     2 = entire object is selected persistently.\n     3 = one or more proper sub-objects are selected."},{signature:"bool IsSubObjectHighlighted(ComponentIndex componentIndex)",summary:"Determines if a subobject is highlighted.",since:5,returns:"True if the subobject is highlighted."},{signature:"bool IsSubObjectSelectable(ComponentIndex componentIndex,bool ignoreSelectionState)",summary:"Reports if a subobject can be selected.",since:5,returns:"True if the specified subobject can be selected."},{signature:"bool IsSubObjectSelected(ComponentIndex componentIndex)",summary:"Check sub-object selection state.",since:5,returns:"True if the subobject is selected."},{signature:"uint MemoryEstimate()",summary:"Computes an estimate of the number of bytes that this object is using in memory.\n     Note that this is a runtime memory estimate and does not directly compare to the\n     amount of space take up by the object when saved to a file.",since:5,returns:"The estimated number of bytes this object occupies in memory."},{signature:"int MeshCount(MeshType meshType,MeshingParameters parameters)",summary:"RhinoObjects can have several different types of meshes and \n     different numbers of meshes.  A b-rep can have a render and \n     an analysis mesh on each face.  A mesh object has a single \n     render mesh and no analysis mesh. Curve, point, and annotation\n     objects have no meshes.",since:5,returns:"number of meshes"},{signature:"int Select(bool on)",summary:"Selects an object.",since:5,returns:"0: object is not selected.1: object is selected.2: object is selected persistently."},{signature:"int Select(bool on,bool syncHighlight)",summary:"Selects an object.",since:5,returns:"0: object is not selected.1: object is selected.2: object is selected persistently."},{signature:"int Select(bool on,bool syncHighlight,bool persistentSelect,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)",summary:"Selects an object.",since:5,returns:"0: object is not selected.1: object is selected.2: object is selected persistently."},{signature:"int SelectSubObject(ComponentIndex componentIndex,bool select,bool syncHighlight)",summary:"Reports if an object can be selected.",since:5,returns:"0: object is not selected\n     1: object is selected\n     2: object is selected persistently."},{signature:"int SelectSubObject(ComponentIndex componentIndex,bool select,bool syncHighlight,bool persistentSelect)",summary:"Reports if an object can be selected.",since:6,returns:"0: object is not selected1: object is selected2: object is selected persistently."},{signature:"void SetCustomRenderMeshParameter(Guid providerId,String parameterName,object value)",summary:"Set the named custom render mesh parameter value for this object.",since:6},{signature:"int SetTextureMapping(int channel,TextureMapping tm)",since:6},{signature:"string ShortDescription(bool plural)",summary:"Gets a localized short descriptive name of the object.",since:5,returns:"A string with the short localized descriptive name."},{signature:"bool SupportsRenderPrimitiveList(ViewportInfo viewport,bool preview)",summary:"Determines if custom render meshes will be built for a particular object.",since:5.7,returns:"Returns True if custom render mesh(es) will get built for this object."},{signature:"bool SupportsRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)",summary:"Determines if custom render meshes will be built for a particular object.",since:6,returns:"Returns True if custom render mesh(es) will get built for this object."},{signature:"bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport,bool preview,BoundingBox boundingBox)",summary:"Get the bounding box for the custom render meshes associated with this\n     object.",since:5.7,returns:"Returns True if the bounding box was successfully calculated otherwise\n     returns False on error."},{signature:"bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport,DisplayPipelineAttributes attrs,BoundingBox boundingBox)",summary:"Get the bounding box for the custom render meshes associated with this\n     object.",since:6,returns:"Returns True if the bounding box was successfully calculated otherwise\n     returns False on error."},{signature:"int UnhighlightAllSubObjects()",summary:"Removes highlighting from all subobjects.",since:5,returns:"The number of changed subobjects."},{signature:"int UnselectAllSubObjects()",summary:"Removes selection from all subobjects.",since:5,returns:"The number of unselected subobjects."}]},{name:"Rhino.DocObjects.RhinoObjectEventArgs",dataType:1,summary:"",properties:[{signature:"Guid ObjectId",since:5},{signature:"RhinoObject TheObject",since:5}]},{name:"Rhino.DocObjects.RhinoObjectSelectionEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5},{signature:"RhinoObject[] RhinoObjects",since:5},{signature:"bool Selected",summary:"Returns True if objects are being selected.\n       Returns False if objects are being deseleced.",since:5}]},{name:"Rhino.DocObjects.RhinoReplaceObjectEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5},{signature:"RhinoObject NewRhinoObject",since:5},{signature:"Guid ObjectId",since:5},{signature:"RhinoObject OldRhinoObject",since:5}]},{name:"Rhino.DocObjects.RhinoTransformObjectsEventArgs",dataType:1,summary:"EventArgs passed to RhinoDoc.BeforeTransform.",properties:[{signature:"int ObjectCount",since:5.1},{signature:"RhinoObject[] Objects",since:5.1},{signature:"bool ObjectsWillBeCopied",since:5.1},{signature:"Transform Transform",since:5.1}]},{name:"Rhino.DocObjects.SelectionMethod",dataType:3,summary:"Defines enumerated values for several kinds of selection methods."},{name:"Rhino.DocObjects.SnapShots.SnapShotsClient",dataType:1,summary:"This is the abstract interface class for for all Snapshot clients.",constructors:[{signature:"SnapShotsClient()",summary:"SnapShotsClient constructor",since:6}],properties:[{signature:"IntPtr CppPointer",since:6},{signature:"int SerialNumber",since:6}],methods:[{signature:"static string ApplicationCategory()",summary:"Predefined application category",since:6},{signature:"static string DocumentCategory()",summary:"Predefined document category",since:6},{signature:"static string LayersCategory()",summary:"Predefined layers category",since:6},{signature:"static string LightsCategory()",summary:"Predefined lights category",since:6},{signature:"static string ObjectsCategory()",summary:"Predefined objects category",since:6},{signature:"static bool RegisterSnapShotClient(SnapShotsClient client)",summary:"Function used to register snapshots client",since:6},{signature:"static string RenderingCategory()",summary:"Predefined rendering category",since:6},{signature:"static string ViewsCategory()",summary:"Predefined views category",since:6},{signature:"bool AnimateDocument(RhinoDoc doc,double dPos,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)",summary:"Called for each frame. Starting at 0.0.",since:6,returns:"True if successful, otherwise false."},{signature:"bool AnimateObject(RhinoDoc doc,RhinoObject doc_object,Transform transform,double dPos,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)",summary:"Called for each frame. Starting at 0.0.",since:6},{signature:"void AnimationStart(RhinoDoc doc,int iFrames)",summary:"Called once at the start of an animation.",since:6},{signature:"bool AnimationStop(RhinoDoc doc)",summary:"Called once at the end of an animation.",since:6},{signature:"string Category()",summary:"The category of this client. Usually one of the above predefined categories like e.g\n     object, rendering or application category",since:6},{signature:"Guid ClientId()",summary:"The unique id of this client.",since:6,returns:"The unique id of this client."},{signature:"void Dispose()",summary:"SnapShotsClient Dispose",since:6},{signature:"void ExtendBoundingBoxForDocumentAnimation(RhinoDoc doc,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop,BoundingBox bbox)",summary:"Called once at the start of an animation. This can be used to extend the scene bounding box to avoid clipping.",since:6},{signature:"void ExtendBoundingBoxForObjectAnimation(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop,BoundingBox bbox)",summary:"Called once at the start of an animation. This can be used to extend the scene bounding box to avoid clipping.",since:6},{signature:"bool IsCurrentModelStateInAnySnapshot(RhinoDoc doc,BinaryArchiveReader archive,SimpleArrayBinaryArchiveReader archive_array,TextLog text_log)",summary:"Called before restoring a snapshot. Warns the user if the current model state is not already saved.",since:6,returns:"return True if successful, otherwise false."},{signature:"bool IsCurrentModelStateInAnySnapshot(RhinoDoc doc,RhinoObject doc_object,BinaryArchiveReader archive,SimpleArrayBinaryArchiveReader archive_array,TextLog text_log)",summary:"Called before restoring a snapshot. Warns the user if the current model state is not already saved.",since:6,returns:"return True if successful, otherwise false."},{signature:"string Name()",summary:"The client's name.",since:6,returns:"The client's name."},{signature:"bool ObjectTransformNotification(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive)",summary:"Called for every object that is associated with a snapshot and gets transformed in Rhino. This is getting called for each stored snapshot and gives the client the possibility to update the stored data.",since:6,returns:"True if successful, otherwise false."},{signature:"Guid PlugInId()",summary:"The plug-in id that registers this client.",since:6,returns:"The plug-in id that registers this client."},{signature:"bool PrepareForDocumentAnimation(RhinoDoc doc,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)",summary:"Called once at the start of an animation.",since:6,returns:"True if successful, otherwise"},{signature:"bool PrepareForObjectAnimation(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive_start,BinaryArchiveReader archive_stop)",summary:"Called once at the start of an animation.",since:6,returns:"True if successful, otherwise false."},{signature:"bool RestoreDocument(RhinoDoc doc,BinaryArchiveReader archive)",summary:"Called when the user restores a snapshot and SupportDocument() returns true.",since:6,returns:"True if successful, otherwise false"},{signature:"bool RestoreObject(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveReader archive)",summary:"Called when the user restores a snapshot and SupportsObjects() and SupportsObject(Rhino.DocObjects.RhinoObject doc_object) returns true.",since:6,returns:"True if successful, otherwise false."},{signature:"bool SaveDocument(RhinoDoc doc,BinaryArchiveWriter archive)",summary:"Called when the user saves a snapshot and SupportDocument() returns true.",since:6,returns:"True if successful, otherwise false"},{signature:"bool SaveObject(RhinoDoc doc,RhinoObject doc_object,Transform transform,BinaryArchiveWriter archive)",summary:"Called when the user saves a snapshot and SupportsObjects() and SupportsObject(Rhino.DocObjects.RhinoObject doc_object) returns true.",since:6,returns:"True if successful, otherwise false."},{signature:"void SnapshotRestored(RhinoDoc doc)",summary:"Called after all clients restored their data.",since:6},{signature:"bool SupportsAnimation()",summary:"Returns True if the client allows animation.",since:6,returns:"True if the client allows animation."},{signature:"bool SupportsDocument()",summary:"Defines if the client supports document user data or not",since:6,returns:"True if the client saves/restores document user data."},{signature:"bool SupportsObject(RhinoObject doc_object)",summary:"Returns True if the client saves/restores object user data for the given object.",since:6,returns:"True if the client saves/restores object user data for the given object."},{signature:"bool SupportsObjects()",summary:"Returns True if the client saves/restores object user data.",since:6,returns:"True if the client saves/restores object user data."}]},{name:"Rhino.DocObjects.SubDObject",dataType:1,summary:"Rhino object for SubD"},{name:"Rhino.DocObjects.SurfaceObject",dataType:1,summary:"Represents a surface in a document.",properties:[{signature:"Surface SurfaceGeometry",summary:"Gets the surface geometry linked with this object.",since:5}],methods:[{signature:"Surface DuplicateSurfaceGeometry()",summary:"Constructs a new deep copy of the surface geometry.",since:5,returns:"The copy of the geometry."}]},{name:"Rhino.DocObjects.Tables.BitmapTable",dataType:1,summary:"Stores the list of bitmaps in a Rhino document.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"int AddBitmap(string bitmapFilename,bool replaceExisting)",summary:"Adds a new bitmap with specified name to the bitmap table.",since:5,returns:"index of new bitmap in table on success. -1 on error."},{signature:"bool Delete(BitmapEntry item)",summary:"Removes the bitmap from the table.",since:6,returns:"True if the item could be deleted; otherwise, false."},{signature:"bool DeleteBitmap(string bitmapFilename)",summary:"Deletes a bitmap.",since:5,returns:"True if successful. False if the bitmap cannot be deleted because it\n     is the current bitmap or because it bitmap contains active geometry."},{signature:"bool ExportToFile(int index,string path)",summary:"Writes a bitmap to a file.",since:5,returns:"True if successful."},{signature:"int ExportToFiles(string directoryPath,int overwrite)",summary:"Exports all the bitmaps in the table to files.",since:5,returns:"Number of bitmaps written."},{signature:"BitmapEntry Find(string name,bool createFile,string fileName)",summary:'This function first attempts to find the file with "name" on the disk.\n     If it does find it, "fileName" is set to the full path of the file and\n     the BitmapEntry returned will be null, even if there was a BitmapEntry\n     with "name" in the bitmap table.\n     If the function cannot find the file on the disk, it searches the bitmap\n     table.  If it finds it, the returned BitmapEntry entry will be the entry\n     in the table with that name.\n     Additionally, if "createFile" is true, and an entry is found, the file\n     will be written to the disk and it\'s full path will be contained in "fileName".',since:5.1,returns:'Returns None if "name" was found on the disk.  If name was not found on the disk,\n     returns the BitmapEntry with the specified name if it is found in the bitmap table\n     and None if it was not found in the bitmap table.'},{signature:"BitmapEntry FindIndex(int index)",summary:"Retrieves a BitmapEntry object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A BitmapEntry object, or None if none was found."}]},{name:"Rhino.DocObjects.Tables.DimStyleTable",dataType:1,summary:"",properties:[{signature:"DimensionStyle[] BuiltInStyles",summary:"Creates an array of default AnnotationStyle objects",since:6},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"DimensionStyle Current",summary:"Returns an instance of the current .",since:6},{signature:"DimensionStyle CurrentDimensionStyle",summary:"Do not use. Use the  property.",since:5},{signature:"Guid CurrentId",since:6},{signature:"int CurrentIndex",since:6}],methods:[{signature:"int Add(DimensionStyle dimstyle,bool reference)",summary:"Adds a new DimensionStyle to the document.",since:6,returns:"index of new AnnotationStyle."},{signature:"int Add(string name)",summary:"Adds a new AnnotationStyle to the document. The new AnnotationStyle will be initialized\n     with the current default AnnotationStyle properties.",since:5,returns:"index of new AnnotationStyle."},{signature:"int Add(string name,bool reference)",summary:"Adds a new AnnotationStyle to the document. The new AnnotationStyle will be initialized\n     with the current default AnnotationStyle properties.",since:5,returns:"index of new AnnotationStyle."},{signature:"bool Delete(DimensionStyle item)",summary:"Removes an annotation style.",since:6,returns:"True if the item was removed; False otherwise."},{signature:"bool Delete(int index,bool quiet)",since:6},{signature:"DimensionStyle Find(Guid styleId,bool ignoreDeleted)",since:6},{signature:"DimensionStyle Find(string name,bool ignoreDeleted)",since:5},{signature:"DimensionStyle FindIndex(int index)",summary:"Retrieves a DimensionStyle object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A DimensionStyle object, or None if none was found."},{signature:"DimensionStyle FindName(string name)",summary:"Finds the DimensionStyle with a given name and retuns it. None is returned if no DimensionStyle is found.",since:6,returns:"The instance, or null."},{signature:"DimensionStyle FindRoot(Guid styleId,bool ignoreDeleted)",since:6},{signature:"IEnumerator<DimensionStyle> GetEnumerator()",since:5},{signature:"string GetUnusedStyleName()",summary:"Get a unique name for a style that does not already exist in the DimStyle table",since:6},{signature:"string GetUnusedStyleName(string rootName)",summary:"Get a unique name for a dimension style that does not already exist in the DimStyle table",since:6},{signature:"ModifyType Modify(DimensionStyle dimstyle,AnnotationBase annotation)",since:6},{signature:"bool Modify(DimensionStyle newSettings,Guid dimstyleId,bool quiet)",summary:"Modifies dimension style settings.",since:6,returns:"True if successful. False if Id is not already in table"},{signature:"bool Modify(DimensionStyle newSettings,int dimstyleIndex,bool quiet)",summary:"Modifies dimension style settings.",since:6,returns:"True if successful. False if dimstyleIndex is out of range"},{signature:"bool SetCurrent(int index,bool quiet)",summary:"Sets the  property.",since:6,returns:"True if the method achieved its goal; otherwise false."},{signature:"bool SetCurrentDimensionStyleIndex(int index,bool quiet)",summary:"Do not use. Use the  method.",since:5,returns:"Do not use."}]},{name:"Rhino.DocObjects.Tables.DimStyleTableEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:6},{signature:"DimStyleTableEventType EventType",since:6},{signature:"int Index",since:6},{signature:"DimensionStyle NewState",since:6},{signature:"DimensionStyle OldState",since:6}]},{name:"Rhino.DocObjects.Tables.DimStyleTableEventType",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.FontTable",dataType:1,summary:"Font tables store the list of fonts in a Rhino document.\n   The FontTable is now just a wrapper around the DimStyles table.",properties:[{signature:"int Count",summary:"Number of fonts in the table.",since:5},{signature:"int CurrentIndex",summary:'At all times, there is a "current" font.  Unless otherwise specified,\n     new dimension objects are assigned to the current font. The current\n     font is never deleted.\n     Returns: Zero based font index of the current font.',since:5},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:5}],methods:[{signature:"int FindOrCreate(string face,bool bold,bool italic)",summary:"Get a DimensionStyle with the specified characteristics\n     the settings other than face, bold and italic are copied from the current style",since:5},{signature:"int FindOrCreate(string face,bool bold,bool italic,DimensionStyle template_style)",summary:"Get a DimensionStyle with the specified characteristics",since:6},{signature:"IEnumerator<Font> GetEnumerator()",since:5}]},{name:"Rhino.DocObjects.Tables.GroupTable",dataType:1,summary:"Group tables store the list of groups in a Rhino document.",properties:[{signature:"ModelComponentType ComponentType",since:6}],methods:[{signature:"int Add()",summary:"Adds a new empty group to the group table.",since:5,returns:">=0 index of new group. \n       -1 group not added because a group with that name already exists."},{signature:"int Add(IEnumerable<Guid> objectIds)",summary:"Adds a new group to the group table with a set of objects.",since:5,returns:">=0 index of new group.\n       -1 group not added because a group with that name already exists."},{signature:"int Add(string groupName)",summary:"Adds a new empty group to the group table.",since:5,returns:">=0 index of new group. \n       -1 group not added because a group with that name already exists."},{signature:"int Add(string groupName,IEnumerable<Guid> objectIds)",summary:"Adds a new group to the group table with a set of objects.",since:5,returns:">=0 index of new group. \n       -1 group not added because a group with that name already exists."},{signature:"bool AddToGroup(int groupIndex,Guid objectId)",summary:"Adds an object to an existing group.",since:5,returns:"True if the operation was successful."},{signature:"bool AddToGroup(int groupIndex,IEnumerable<Guid> objectIds)",summary:"Adds a list of objects to an existing group.",since:5,returns:"True if at least an operation was successful."},{signature:"bool ChangeGroupName(int groupIndex,string newName)",since:5},{signature:"bool Delete(Group item)",since:6},{signature:"bool Delete(int groupIndex)",summary:"Deletes a group from this table.\n       Deleted groups are kept in the runtime group table so that undo\n       will work with groups.  Call IsDeleted() to determine if a group is deleted.",since:5,returns:"True if the operation was successful."},{signature:"int Find(string groupName)",summary:"Finds a group with a given name.",since:6,returns:">=0 index of the group with the given name.\n       UnsetIntIndex no group found with the given name."},{signature:"int Find(string groupName,bool ignoreDeletedGroups)",summary:"Finds a group with a given name.",since:5,returns:">=0 index of the group with the given name.\n       -1 no group found with the given name."},{signature:"Group FindIndex(int index)",summary:"Retrieves a Group object based on Index. This seach type of search is discouraged.\n       We are moving towards using only IDs for all tables.",since:6,returns:"A Group object, or None if none was found."},{signature:"Group FindName(string name)",summary:"Finds a Linetype given its name. Returns the instance, rather than the index.",since:6,returns:"An Linetype, or None on error."},{signature:"Group FindNameHash(NameHash nameHash)",summary:"Finds a Linetype given its name hash.",since:6,returns:"An Linetype, or None on error."},{signature:"RhinoObject[] GroupMembers(int groupIndex)",summary:"Gets an array of all of the objects in a group.",since:5,returns:"An array with all the objects in the specified group."},{signature:"string GroupName(int groupIndex)",since:5},{signature:"string[] GroupNames(bool ignoreDeletedGroups)",since:5},{signature:"int GroupObjectCount(int groupIndex)",since:5},{signature:"int Hide(int groupIndex)",since:5},{signature:"bool IsDeleted(int groupIndex)",since:5},{signature:"int Lock(int groupIndex)",since:5},{signature:"int Show(int groupIndex)",since:5},{signature:"bool Undelete(int groupIndex)",since:5},{signature:"int Unlock(int groupIndex)",since:5}]},{name:"Rhino.DocObjects.Tables.GroupTableEventArgs",dataType:1,summary:"Contains group table event data.",properties:[{signature:"RhinoDoc Document",summary:"The document in which the event occurred.",since:5},{signature:"GroupTableEventType EventType",summary:"The event type.",since:5},{signature:"int GroupIndex",summary:"The index of the Group that has changed.",since:6.1},{signature:"Group NewState",summary:"The Group that has changed.",since:6.1},{signature:"Group OldState",summary:"If the event is GroupTableEventType.Modified, then the old Group.",since:6.1}]},{name:"Rhino.DocObjects.Tables.GroupTableEventType",dataType:3,summary:"Defines the types of group table events."},{name:"Rhino.DocObjects.Tables.HatchPatternTable",dataType:1,summary:"All of the hatch pattern definitions contained in a rhino document.",properties:[{signature:"ModelComponentType ComponentType",since:6},{signature:"int CurrentHatchPatternIndex",summary:'At all times, there is a "current" hatch pattern.  Unless otherwise\n     specified, new objects are assigned to the current hatch pattern.\n     The current hatch pattern is never locked, hidden, or deleted.',since:5}],methods:[{signature:"int Add(HatchPattern pattern)",summary:"Adds a new hatch pattern with specified definition to the table.",since:5,returns:">=0 index of new hatch pattern\n     -1  not added because a hatch pattern with that name already exists or\n     some other problem occured."},{signature:"bool Delete(HatchPattern item)",since:6},{signature:"bool Delete(HatchPattern item,bool quiet)",since:6},{signature:"int Find(string name,bool ignoreDeleted)",summary:"Finds the hatch pattern with a given name. Search ignores case.",since:5,returns:"Index of the hatch pattern with the given name. -1 if no hatch pattern found."},{signature:"HatchPattern FindIndex(int index)",summary:"Retrieves a HatchPattern object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A HatchPattern object, or None if none was found."},{signature:"HatchPattern FindName(string name)",summary:"Finds the hatch pattern with a given name. Search ignores case.",since:6,returns:"Hatch pattern with the given name. Null if no hatch pattern found."},{signature:"HatchPattern FindNameHash(NameHash nameHash)",summary:"Finds a HatchPattern given its name hash.",since:6,returns:"An Linetype, or None on error."}]},{name:"Rhino.DocObjects.Tables.InstanceDefinitionTable",dataType:1,summary:"",properties:[{signature:"int ActiveCount",summary:"Number of items in the instance definitions table, excluding deleted definitions.",since:5},{signature:"ModelComponentType ComponentType",since:6},{signature:"int Count",summary:"Number of items in the instance definitions table.",since:5},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:5}],methods:[{signature:"int Add(string name,string description,Point3d basePoint,GeometryBase geometry,ObjectAttributes attributes)",summary:"Adds an instance definition to the instance definition table.",since:5,returns:">=0  index of instance definition in the instance definition table. -1 on failure."},{signature:"int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry)",summary:"Adds an instance definition to the instance definition table.",since:5,returns:">=0  index of instance definition in the instance definition table. -1 on failure."},{signature:"int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry,IEnumerable<ObjectAttributes> attributes)",summary:"Adds an instance definition to the instance definition table.",since:5,returns:">=0  index of instance definition in the instance definition table. -1 on failure."},{signature:"void Compact(bool ignoreUndoReferences)",summary:"Purge deleted instance definition information that is not in use.\n     This function is time consuming and should be used in a thoughtful manner.",since:5.9},{signature:"bool Delete(InstanceDefinition item)",summary:"Deletes the instance definition. This deletes all references too.",since:6,returns:"True on success."},{signature:"bool Delete(int idefIndex,bool deleteReferences,bool quiet)",summary:"Deletes the instance definition.",since:5,returns:"True if successful. False if the instance definition has active references and bDeleteReferences is false."},{signature:"bool DestroySourceArchive(InstanceDefinition definition,bool quiet)",summary:"Destroys all source archive information.\n     Specifically:\n     *  is set to the empty string.\n     * SourceRelativePath is set to false\n     * The alternative source archive path is set to the empty string.\n     * Checksum.Zero() is used to private destroy all checksum information.\n     *  is set to .",since:6,returns:"Returns True if the definition was successfully modified otherwise returns false."},{signature:"InstanceDefinition Find(Guid instanceId,bool ignoreDeletedInstanceDefinitions)",summary:"Finds the instance definition with a given id.",since:5,returns:"The specified instance definition, or None if nothing matching was found."},{signature:"InstanceDefinition Find(string instanceDefinitionName)",summary:"Finds the instance definition with a given name.",since:6,returns:"The specified instance definition, or None if nothing matching was found."},{signature:"InstanceDefinition Find(string instanceDefinitionName,bool ignoreDeletedInstanceDefinitions)",summary:"Finds the instance definition with a given name.",since:5,returns:"The specified instance definition, or None if nothing matching was found."},{signature:"IEnumerator<InstanceDefinition> GetEnumerator()",since:5},{signature:"InstanceDefinition[] GetList(bool ignoreDeleted)",summary:"Gets an array of instance definitions.",since:5,returns:"An array of instance definitions. This can be empty, but not null."},{signature:"string GetUnusedInstanceDefinitionName()",summary:"Gets unsed instance definition name used as default when creating\n     new instance definitions.",since:5,returns:"An unused instance definition name string."},{signature:"string GetUnusedInstanceDefinitionName(string root)",summary:"Gets unsed instance definition name used as default when creating\n     new instance definitions.",since:5,returns:"An unused instance definition name string."},{signature:"string GetUnusedInstanceDefinitionName(string root,uint defaultSuffix)",summary:"Gets unsed instance definition name used as default when creating\n     new instance definitions.",since:5,returns:"An unused instance definition name string."},{signature:"int InstanceDefinitionIndex(Guid instanceId,bool ignoreDeletedInstanceDefinitions)",summary:"Get the index of the instance definition with a given id.",since:6,returns:"index > -1 if instance definition was found."},{signature:"bool MakeSourcePathRelative(InstanceDefinition idef,bool relative,bool quiet)",summary:"Obsolete method that always returns false.\n     Marks the source path for a linked instance definition as relative or absolute.",since:5,returns:"True if the instance definition could be modified."},{signature:"bool Modify(InstanceDefinition idef,string newName,string newDescription,bool quiet)",summary:"Modifies the instance definition name and description.\n     Does not change instance definition ID or geometry.",since:5,returns:"True if successful."},{signature:"bool Modify(int idefIndex,string newName,string newDescription,bool quiet)",summary:"Modifies the instance definition name and description.\n     Does not change instance definition ID or geometry.",since:5,returns:"True if successful."},{signature:"bool ModifyGeometry(int idefIndex,GeometryBase newGeometry,ObjectAttributes newAttributes)",since:5},{signature:"bool ModifyGeometry(int idefIndex,IEnumerable<GeometryBase> newGeometry)",since:5},{signature:"bool ModifyGeometry(int idefIndex,IEnumerable<GeometryBase> newGeometry,IEnumerable<ObjectAttributes> newAttributes)",summary:"Modifies the instance definition geometry and replaces all references\n     to the current definition with references to the new definition.",since:5,returns:"True if operation succeeded."},{signature:"bool ModifySourceArchive(int idefIndex,FileReference sourceArchive,InstanceDefinitionUpdateType updateType,bool quiet)",summary:"If the instance definition is linked or embedded, use SetSource to\n     specify the source archive.",since:6,returns:"Returns True if the definition was successfully modified otherwise returns false."},{signature:"bool ModifySourceArchive(int idefIndex,string sourceArchive,InstanceDefinitionUpdateType updateType,bool quiet)",summary:"If the instance definition is linked or embedded, use SetSource to\n     specify the source archive.",since:6,returns:"Returns True if the definition was successfully modified otherwise returns false."},{signature:"bool Purge(int idefIndex)",summary:"Purges an instance definition and its definition geometry.",since:5.9,returns:"True if successful. False if the instance definition cannot be purged\n     because it is in use by reference objects or undo information."},{signature:"bool RefreshLinkedBlock(InstanceDefinition definition)",summary:"Reload linked block definitions and update the Rhino display.",since:6,returns:"Returns True if the linked file was successfully read and updated."},{signature:"bool Undelete(int idefIndex)",summary:"Undeletes an instance definition that has been deleted by Delete()",since:5.9,returns:"True if successful"},{signature:"bool UndoModify(int idefIndex)",summary:"Restores the instance definition to its previous state,\n     if the instance definition has been modified and the modification can be undone.",since:5,returns:"True if operation succeeded."},{signature:"bool UpdateLinkedInstanceDefinition(int idefIndex,string filename,bool updateNestedLinks,bool quiet)",summary:"Read the objects from a file and use them as the instance's definition geometry.",since:5.9}]},{name:"Rhino.DocObjects.Tables.InstanceDefinitionTableEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5.3},{signature:"InstanceDefinitionTableEventType EventType",since:5.3},{signature:"int InstanceDefinitionIndex",since:5.3},{signature:"InstanceDefinition NewState",since:5.3},{signature:"InstanceDefinitionGeometry OldState",since:5.3}]},{name:"Rhino.DocObjects.Tables.InstanceDefinitionTableEventType",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.LayerTable",dataType:1,summary:"",properties:[{signature:"int ActiveCount",summary:"Returns number of layers in the layer table, excluding deleted layers.",since:5},{signature:"ModelComponentType ComponentType",since:6},{signature:"int Count",summary:"Returns number of layers in the layer table, including deleted layers.",since:5},{signature:"Layer CurrentLayer",summary:'At all times, there is a "current" layer. Unless otherwise specified,\n     new objects are assigned to the current layer. The current layer is\n     never locked, hidden, or deleted.\n     \n     Returns reference to the current layer. Note that this reference may\n     become invalid after a call to AddLayer().',since:5},{signature:"int CurrentLayerIndex",summary:'At all times, there is a "current" layer.  Unless otherwise specified, new objects\n     are assigned to the current layer. The current layer is never locked, hidden, or deleted.\n     Resturns: Zero based layer table index of the current layer.',since:5},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:5}],methods:[{signature:"int Add()",summary:"Adds a new layer with default definition to the layer table.",since:5,returns:"index of new layer."},{signature:"int Add(Layer layer)",summary:"Adds a new layer with specified definition to the layer table.",since:5,returns:">=0 index of new layer\n     -1  layer not added because a layer with that name already exists."},{signature:"int Add(string layerName,Color layerColor)",summary:"Adds a new layer with specified definition to the layer table.",since:5,returns:">=0 index of new layer\n     -1  layer not added because a layer with that name already exists."},{signature:"int AddReferenceLayer()",summary:"Adds a new reference layer with default definition to the layer table.\n     Reference layers are not saved in files.",since:5,returns:"index of new layer."},{signature:"int AddReferenceLayer(Layer layer)",summary:"Adds a new reference layer with specified definition to the layer table\n     Reference layers are not saved in files.",since:5,returns:">=0 index of new layer\n     -1  layer not added because a layer with that name already exists."},{signature:"bool Delete(Guid layerId,bool quiet)",summary:"Deletes layer.",since:6,returns:"True if successful. False if layerIndex is out of range or the the layer cannot be\n     deleted because it is the current layer or because it layer contains active geometry."},{signature:"bool Delete(int layerIndex,bool quiet)",summary:"Deletes layer.",since:5,returns:"True if successful. False if layerIndex is out of range or the the layer cannot be\n     deleted because it is the current layer or because it layer contains active geometry."},{signature:"bool Delete(Layer layer)",summary:"Deletes layer.",since:6,returns:"True if successful. False if layerIndex is out of range or the the layer cannot be\n     deleted because it is the current layer or because it layer contains active geometry."},{signature:"bool Delete(Layer layer,bool quiet)",summary:"Deletes layer.",since:6,returns:"True if successful. False if layerIndex is out of range or the the layer cannot be\n     deleted because it is the current layer or because it layer contains active geometry."},{signature:"int[] Duplicate(IEnumerable<int> layerIndices,bool duplicateObjects,bool duplicateSublayers)",summary:"Duplicates, or copies, one or more layers. Duplicated layers are added to the document.",since:6.18,returns:"The indices of the newly added layers if successful, an empty array on failure."},{signature:"int[] Duplicate(int layerIndex,bool duplicateObjects,bool duplicateSublayers)",summary:"Duplicates, or copies, a layer. Duplicated layers are added to the document.",since:6.18,returns:"The indices of the newly added layers if successful, an empty array on failure."},{signature:"int Find(Guid layerId,bool ignoreDeletedLayers)",summary:"Finds a layer with a matching ID.",since:5,returns:">=0 index of the layer with the given name\n     -1  no layer has the given name."},{signature:"int Find(Guid layerId,bool ignoreDeletedLayers,int notFoundReturnValue)",summary:"Finds a layer with a matching ID.",since:6,returns:"The index of the found layer, or notFoundReturnValue."},{signature:"int Find(Guid parentId,string layerName,bool ignoreDeletedLayers)",summary:"Finds a layer with a given name and matching parent ID.",since:6,returns:">=0 index of the layer with the given name\n     -1  no layer has the given name."},{signature:"int Find(Guid parentId,string layerName,int notFoundReturnValue)",summary:"Finds a layer with a given name and matching parent ID.",since:6,returns:"The index of the found layer, or notFoundReturnValue."},{signature:"int Find(string layerName,bool ignoreDeletedLayers)",summary:"Finds the layer with a given name. If multiple layers exist that have the same name, the\n     first match layer index will be returned.\n     Deleted layers have no name.",since:5,returns:"index of the layer with the given name.\n     If no layer is found, the index of the default layer, -1, is returned."},{signature:"int FindByFullPath(string layerPath,bool ignoreDeletedLayers)",since:5},{signature:"int FindByFullPath(string layerPath,int notFoundReturnValue)",summary:"Searches for a layer using the fully qualified name, that includes ancestors.\n     Deleted layers have no name.",since:6,returns:"The index of the found layer, or notFoundReturnValue."},{signature:"Layer FindIndex(int index)",summary:"Retrieves a Layer object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A Layer object, or None if none was found."},{signature:"Layer FindName(string layerName)",summary:"Finds the layer with a given name. If multiple layers exist that have the same name, the\n     first match layer index will be returned.\n     Deleted layers have no name.The default layer is NOT included in the search. If required, use the overload with startIndex input.",since:6,returns:"A layer, or null."},{signature:"Layer FindName(string layerName,int startIndex)",summary:"Finds the next layer that has an index equal or higher than the searched value.\n     Search in case-insensitive.",since:6,returns:"A layer, or null."},{signature:"Layer FindNameHash(NameHash nameHash)",summary:"Finds a Layer given its name hash.",since:6,returns:"An Layer, or None on error."},{signature:"Layer FindNext(int index,string layerName)",summary:"Use FindName(name, index).",since:6,returns:"Do not use."},{signature:"int FindNext(int index,string layerName,bool ignoreDeletedLayers)",since:5},{signature:"bool ForceLayerVisible(Guid layerId)",summary:"Makes a layer and all of its parent layers visible.",since:5,returns:"True if the operation succeeded."},{signature:"bool ForceLayerVisible(int layerIndex)",summary:"Makes a layer and all of its parent layers visible.",since:5,returns:"True if the operation succeeded."},{signature:"IEnumerator<Layer> GetEnumerator()",since:5},{signature:"bool GetSelected(List<int> layerIndices)",summary:"Returns the indices of layers that are selected on the Layer user interface.",returns:"True if the layer user inteface is visible, False otherwise."},{signature:"string GetUnusedLayerName()",summary:"Gets the next unused layer name used as default when creating new layers.",since:6,returns:"An unused layer name string."},{signature:"string GetUnusedLayerName(bool ignoreDeleted)",summary:"Gets the next unused layer name used as default when creating new layers.",since:5,returns:"An unused layer name string."},{signature:"bool Modify(Layer newSettings,Guid layerId,bool quiet)",summary:"Modifies layer settings.",since:6,returns:"True if successful. False if layerIndex is out of range or the settings attempt\n     to lock or hide the current layer."},{signature:"bool Modify(Layer newSettings,int layerIndex,bool quiet)",summary:"Modifies layer settings.",since:5,returns:"True if successful. False if layerIndex is out of range or the settings attempt\n     to lock or hide the current layer."},{signature:"bool Purge(Guid layerId,bool quiet)",summary:"Deletes a layer and all geometry objects on a layer.",since:6,returns:"True if successful. False if layerIndex is out of range or the the layer cannot be\n     deleted because it is the current layer."},{signature:"bool Purge(int layerIndex,bool quiet)",summary:"Deletes a layer and all geometry objects on a layer",since:5.5,returns:"True if successful. False if layerIndex is out of range or the the layer cannot be\n     deleted because it is the current layer."},{signature:"bool Select(IEnumerable<int> layerIndices,bool bDeselect)",summary:"Selects layers in the Layer user interface.",since:6,returns:"True if the layer user inteface is visible, False otherwise."},{signature:"bool SetCurrentLayerIndex(int layerIndex,bool quiet)",summary:'At all times, there is a "current" layer. Unless otherwise specified, new objects\n     are assigned to the current layer. The current layer is never locked, hidden, or deleted.',since:5,returns:"True if current layer index successfully set."},{signature:"bool Undelete(int layerIndex)",summary:"Undeletes a layer that has been deleted by DeleteLayer().",since:5,returns:"True if successful."},{signature:"bool UndoModify(Guid layerId)",summary:"Restores the layer to its previous state,\n     if the layer has been modified and the modification can be undone.",since:6,returns:"True if this layer had been modified and the modifications were undone."},{signature:"bool UndoModify(Guid layerId,uint undoRecordSerialNumber)",summary:"Restores the layer to its previous state,\n     if the layer has been modified and the modification can be undone.",since:6,returns:"True if this layer had been modified and the modifications were undone."},{signature:"bool UndoModify(int layerIndex)",summary:"Restores the layer to its previous state,\n     if the layer has been modified and the modification can be undone.",since:5,returns:"True if this layer had been modified and the modifications were undone."},{signature:"bool UndoModify(int layerIndex,uint undoRecordSerialNumber)",summary:"Restores the layer to its previous state,\n     if the layer has been modified and the modification can be undone.",since:5,returns:"True if this layer had been modified and the modifications were undone."}]},{name:"Rhino.DocObjects.Tables.LayerTableEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5},{signature:"LayerTableEventType EventType",since:5},{signature:"int LayerIndex",since:5},{signature:"Layer NewState",since:5},{signature:"Layer OldState",since:5}]},{name:"Rhino.DocObjects.Tables.LayerTableEventType",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.LightTable",dataType:1,summary:"",properties:[{signature:"ModelComponentType ComponentType",since:6},{signature:"int Count",summary:"Number of lights in the light table.  Does not include Sun or Skylight.",since:5},{signature:"RhinoDoc Document",summary:"Document that owns this light table.",since:5},{signature:"Skylight Skylight",since:6},{signature:"Sun Sun",summary:"Gets the Sun instance that is applied to the document.\n     If the RDK is loaded, an instance is always returned.",since:5}],methods:[{signature:"int Add(Light light)",since:5},{signature:"int Add(Light light,ObjectAttributes attributes)",since:5},{signature:"bool Delete(int index,bool quiet)",since:6},{signature:"bool Delete(LightObject item)",since:6},{signature:"int Find(Guid id,bool ignoreDeleted)",since:5},{signature:"LightObject FindIndex(int index)",summary:"Retrieves a  object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A  object, or None if none was found."},{signature:"LightObject FindName(string name)",summary:"Finds the LightObject with a given name.\n     Deleted lights have no name.",since:6,returns:"A layer. If no layer is found, None is returned."},{signature:"LightObject FindNameHash(NameHash nameHash)",summary:"Finds a LightObject given its name hash.",since:6,returns:"A LightObject, or None on error."},{signature:"IEnumerator<LightObject> GetEnumerator()",since:5},{signature:"bool Modify(Guid id,Light light)",since:5},{signature:"bool Modify(int index,Light light)",since:5}]},{name:"Rhino.DocObjects.Tables.LightTableEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5.3},{signature:"LightTableEventType EventType",since:5.3},{signature:"int LightIndex",since:5.3},{signature:"LightObject NewState",since:5.3},{signature:"Light OldState",since:5.3}]},{name:"Rhino.DocObjects.Tables.LightTableEventType",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.LinetypeTable",dataType:1,summary:"",properties:[{signature:"int ActiveCount",summary:"Returns number of linetypes in the linetypes table, excluding deleted linetypes.",since:5},{signature:"string ByLayerLinetypeName",summary:"Returns the text name of the bylayer linetype.",since:5},{signature:"string ByParentLinetypeName",summary:"Returns the text name of the byparent linetype.",since:6},{signature:"ModelComponentType ComponentType",since:6},{signature:"string ContinuousLinetypeName",summary:"Returns the text name of the continuous linetype.",since:5},{signature:"int Count",summary:"Returns number of linetypes in the linetypes table, including deleted linetypes.",since:5},{signature:"Linetype CurrentLinetype",summary:"Returns reference to the current linetype. Note that this reference may\n     become invalid after a call to AddLinetype().",since:5},{signature:"int CurrentLinetypeIndex",summary:"At all times, there is a \"current\" linetype.  Unless otherwise specified,\n     new objects are assigned to the current linetype. If the current linetype\n     source is LinetypeFromLayer the object's layer's linetype is used instead.",since:5},{signature:"ObjectLinetypeSource CurrentLinetypeSource",summary:"Source used by an object to determine its current linetype to be used by new objects.",since:5},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:5},{signature:"double LinetypeScale",summary:"For display in Rhino viewports, the linetypes are scaled by a single scale\n     factor for all viewports. This is not used for printing, where all linetype\n     patterns are scaled to print in their defined size 1:1 on the paper.",since:5}],methods:[{signature:"int Add(Linetype linetype)",summary:"Adds a new linetype with specified definition to the linetype table.",since:5,returns:"Index of newline type or -1 on error."},{signature:"int Add(string name,IEnumerable<double> segmentLengths)",summary:"Adds a new linetype with specified definition to the linetype table.",since:5,returns:"Index of new linetype or -1 on error."},{signature:"int AddReferenceLinetype(Linetype linetype)",summary:"Adds a reference linetypes that will not be saved in files.",since:5,returns:"Index of new linetype or -1 on error."},{signature:"bool Delete(IEnumerable<int> indices,bool quiet)",summary:"Deletes multiple linetypes.",since:5,returns:"True if operation succeeded."},{signature:"bool Delete(int index,bool quiet)",summary:"Deletes linetype.",since:5,returns:"True if successful. False if linetypeIndex is out of range or the\n     linetype cannot be deleted because it is the current linetype or\n     because it linetype is referenced by active geometry."},{signature:"bool Delete(Linetype item)",since:6},{signature:"int Find(Guid id,bool ignoreDeletedLinetypes)",summary:"Finds a linetype with a matching ID.",since:5,returns:"Zero or a positive value if the index of the linetype with the given ID is found.\n     -1 if no linetype has the given ID."},{signature:"int Find(string name)",summary:"Finds the linetype with a given name.",since:6,returns:">=0 index of the linetype with the given name\n     -1  no linetype has the given name."},{signature:"int Find(string name,bool ignoreDeletedLinetypes)",summary:"Obsolete. Use the other overload.",since:5,returns:">=0 index of the linetype with the given name\n     -1  no linetype has the given name."},{signature:"Linetype FindIndex(int index)",summary:"Retrieves a Linetype object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A Linetype object, or None if none was found."},{signature:"Linetype FindName(string name)",summary:"Finds the linetype with a given name.",since:6,returns:"A linetype, or None if the name does not exist."},{signature:"IEnumerator<Linetype> GetEnumerator()",since:5},{signature:"string GetUnusedLinetypeName()",summary:"Gets unused linetype name used as default when creating new linetypes.",since:6,returns:"The unused linetype name."},{signature:"string GetUnusedLinetypeName(bool ignoreDeleted)",summary:"Obsolete. Use the other overload. Gets unused linetype name used as default when creating new linetypes.",since:5,returns:"The unused linetype name."},{signature:"int LinetypeIndexForObject(RhinoObject rhinoObject)",summary:"Returns the effective linetype index to be used to find the \n     linetype definition to draw an object. If an object's linetype\n     source is LinetypeFromObject, the linetype index in the object's\n     attributes is used. If an object's linetype source is LinetypeFromLayer\n     the linetype index from the object's layer is used.",since:5,returns:"The effective linetype index."},{signature:"int LoadDefaultLinetypes()",summary:"Fills in the linetype table with any default linetypes not already included.",since:6,returns:"The number of default linetypes added to the linetype table."},{signature:"bool Modify(Linetype linetype,int index,bool quiet)",summary:"Modify linetype settings.",since:5,returns:"True if successful. False if linetype_index is out of range or the\n     settings attempt to lock or hide the current linetype."},{signature:"bool SetCurrentLinetypeIndex(int linetypeIndex,bool quiet)",summary:'At all times, there is a "current" linetype. Unless otherwise specified, new objects\n     are assigned to the current linetype. The current linetype is never deleted.',since:5,returns:"True if current linetype index successfully set."},{signature:"bool Undelete(int index)",summary:"Restores a linetype that has been deleted.",since:5,returns:"True if successful."},{signature:"bool UndoModify(int index)",summary:"If the linetype has been modified and the modifcation can be undone,\n     then UndoModify() will restore the linetype to its previous state.",since:5,returns:"True if this linetype had been modified and the modifications were undone."}]},{name:"Rhino.DocObjects.Tables.MaterialTable",dataType:1,summary:"",properties:[{signature:"ModelComponentType ComponentType",since:6},{signature:"int CurrentMaterialIndex",summary:'At all times, there is a "current" material.  Unless otherwise\n     specified, new objects are assigned to the current material.\n     The current material is never locked, hidden, or deleted.',since:5},{signature:"ObjectMaterialSource CurrentMaterialSource",summary:"Gets or sets the current material source.",since:5}],methods:[{signature:"int Add()",summary:"Adds a new material to the table based on the default material.",since:5,returns:"The position of the new material in the table."},{signature:"int Add(Material material)",summary:"Adds a new material to the table based on a given material.",since:5,returns:"The position of the new material in the table."},{signature:"int Add(Material material,bool reference)",summary:"Adds a new material to the table based on a given material.",since:5,returns:"The position of the new material in the table."},{signature:"bool Delete(Material item)",since:6},{signature:"bool DeleteAt(int materialIndex)",summary:"Removes a material at a specific position from this material table.",since:5,returns:"True if successful. False if materialIndex is out of range or the\n     material cannot be deleted because it is the current material or because\n     it material contains active geometry."},{signature:"int Find(Guid materialId,bool ignoreDeletedMaterials)",summary:"Finds a material with a matching id.",since:5,returns:">=0 index of the material with the given name\n     -1  no material has the given name."},{signature:"int Find(string materialName,bool ignoreDeletedMaterials)",summary:"Finds a meterial with a given name.",since:5,returns:">=0 index of the material with the given name\n     -1  no material has the given name."},{signature:"Material FindIndex(int index)",summary:"Retrieves a Material object based on Index. This seach type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A Material object, or None if none was found."},{signature:"bool Modify(Material newSettings,int materialIndex,bool quiet)",summary:"Modify material settings.",since:5,returns:"True if successful. False if materialIndex is out of range or the settings attempt\n     to lock or hide the current material."},{signature:"bool ResetMaterial(int materialIndex)",since:5}]},{name:"Rhino.DocObjects.Tables.MaterialTableEventArgs",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",since:5},{signature:"MaterialTableEventType EventType",since:5},{signature:"int Index",since:5},{signature:"Material OldSettings",since:5}]},{name:"Rhino.DocObjects.Tables.MaterialTableEventType",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.ModifyType",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.NamedConstructionPlaneTable",dataType:1,summary:"Contains all named construction planes in a rhino document.\n   This class cannot be inherited.",properties:[{signature:"int Count",summary:"Number of construction planes in the table.",since:5},{signature:"RhinoDoc Document",summary:"Gets the document that owns this table.",since:5}],methods:[{signature:"int Add(string name,Plane plane)",summary:"Adds named construction plane to document.",since:5,returns:"0 based index of named construction plane.\n     -1 on failure."},{signature:"bool Delete(int index)",summary:"Remove named construction plane from the document.",since:5,returns:"True if successful."},{signature:"bool Delete(string name)",summary:"Remove named construction plane from the document.",since:5,returns:"True if successful."},{signature:"int Find(string name)",summary:"Finds a named construction plane.",since:5,returns:">=0 index of the construction plane with the given name.\n     -1 no construction plane found with the given name."},{signature:"IEnumerator<ConstructionPlane> GetEnumerator()",since:5}]},{name:"Rhino.DocObjects.Tables.NamedLayerStateTable",dataType:1,summary:"All named layer states in a Rhino document.",properties:[{signature:"int Count",summary:"Returns the number of named layers states in the document.",since:6.14},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:6.14},{signature:"string[] Names",summary:"Returns the names of named layer states in the document.",since:6.14}],methods:[{signature:"bool Delete(string name)",summary:"Deletes an exising named layer state.",since:6.14,returns:"True if successful, False otherwise."},{signature:"int FindName(string name)",summary:"Returns the index of an existing named layer state.",since:6.14,returns:">0 if successful, -1 if not found."},{signature:"int Import(string filename)",summary:"Imports named layer states from a 3dm file.",since:6.15,returns:"The number of named layers states imported."},{signature:"bool Rename(string oldName,string newName)",summary:"Renames an existing named layer state.",since:6.14,returns:"True if successful, False otherwise."},{signature:"bool Restore(string name,RestoreLayerProperties properties)",summary:"Restores a named layer state.",since:6.14,returns:"True if successful, False otherwise."},{signature:"bool Restore(string name,RestoreLayerProperties properties,Guid viewportId)",summary:"Restores a named layer state.",since:6.14},{signature:"int Save(string name)",summary:"Saves or updates a named layer state.",since:6.14,returns:"The index of the newly added, or updated, layer state."},{signature:"int Save(string name,Guid viewportId)",summary:"Saves or updates a named layer state.",since:6.14,returns:"The index of the newly added, or updated, layer state."}]},{name:"Rhino.DocObjects.Tables.NamedPositionTable",dataType:1,summary:"All named positions in a rhino document.",properties:[{signature:"int Count",summary:"Number of Named Positions in the table.",since:6},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:6},{signature:"Guid[] Ids",summary:"Array of Named Position guids.",since:6},{signature:"string[] Names",summary:"Array of Named Position names.",since:6}],methods:[{signature:"bool Append(Guid id,IEnumerable<Guid> objectIds)",summary:"Append objects to a Named Position.",since:6,returns:"True or False depending on whether the Append was successful."},{signature:"bool Append(Guid id,IEnumerable<RhinoObject> objects)",summary:"Append objects to a Named Position.",since:6,returns:"True or False depending on whether the Append was successful."},{signature:"bool Append(string name,IEnumerable<Guid> objectIds)",summary:"Append objects to a Named Position.",since:6,returns:"True or False depending on whether the Append was successful."},{signature:"bool Append(string name,IEnumerable<RhinoObject> objects)",summary:"Append objects to a Named Position.",since:6,returns:"True or False depending on whether the Append was successful."},{signature:"bool Delete(Guid id)",summary:"Delete a Named Position.",since:6,returns:"True or False depending on whether the Delete was successful, Null in case the id does not exist as a Named Position."},{signature:"bool Delete(string name)",summary:"Delete a Named Position.",since:6,returns:"True or False depending on whether the Delete was successful, Null in case the id does not exist as a Named Position."},{signature:"Guid Id(string name)",summary:"Guid of a Named Position.",since:6,returns:"The Guid of the Named Position.  If not found, an empty Guid is returned."},{signature:"string Name(Guid id)",summary:"Name of a Named Position.",since:6,returns:"The name of the Named Position as a string."},{signature:"Guid[] ObjectIds(Guid id)",summary:"Array of Rhino Object Guids related to a Named Position.",since:6,returns:"Array of Guid which pertain to the objects tracked by the Named Position."},{signature:"Guid[] ObjectIds(string name)",summary:"Array of Rhino Object Guids related to a Named Position.",since:6,returns:"Array of Guid which pertain to the objects tracked by the Named Position, or None in case no such Named Position is found."},{signature:"RhinoObject[] Objects(Guid id)",summary:"Array of Rhino Objects related to a Named Position.",since:6,returns:"Array of Rhino Objects which are tracked by the Named Position."},{signature:"RhinoObject[] Objects(string name)",summary:"Array of Rhino Objects related to a Named Position.",since:6,returns:"Array of Rhino Objects which are tracked by the Named Position if successful, None if no such Named Position exists."},{signature:"bool ObjectXform(Guid id,Guid objId,Transform xform)",summary:"Retrieve the Transform of a Rhino Object relate dto a Named Position.",since:6,returns:"Transform of the RhinoObject related to the Named Position."},{signature:"bool ObjectXform(Guid id,RhinoObject obj,Transform xform)",summary:"Retrieve the Transform of a Rhino Object relate dto a Named Position.",since:6,returns:"Transform of the RhinoObject related to the Named Position."},{signature:"bool Rename(Guid id,string name)",summary:"Rename a Named Position.",since:6,returns:"True or False depending on whether the Rename was successful.  For example, this method might return False if you attempt to remane the Named Position with the currently assigned name."},{signature:"bool Rename(string oldName,string name)",summary:"Rename a Named Position.",since:6,returns:"True or False depending on whether the Rename was successful.  For example, this method might return False if you attempt to remane the Named Position with the currently assigned name."},{signature:"bool Restore(Guid id)",summary:"Restore a Named Position.",since:6,returns:"True or False based on whether the Named Position was able to be restored."},{signature:"bool Restore(string name)",summary:"Restore a Named Position.",since:6,returns:"True or False based on whether the Named Position was able to be restored."},{signature:"Guid Save(string name,IEnumerable<Guid> objectIds)",summary:"Save a new Named Position.",since:6,returns:"Guid of the newly saved Named Position."},{signature:"Guid Save(string name,IEnumerable<RhinoObject> objects)",summary:"Save a new Named Position.",since:6,returns:"Guid of the newly saved Named Position."},{signature:"bool Update(Guid id)",summary:"Updates a Named Position, effectively storing the current positions of the objects which the Named Position is tracking.",since:6,returns:"True or False depending on whether the Update was successful."},{signature:"bool Update(string name)",summary:"Updates a Named Position, effectively storing the current positions of the objects which the Named Position is tracking.",since:6,returns:"True or False depending on whether the Update was successful."}]},{name:"Rhino.DocObjects.Tables.NamedViewTable",dataType:1,summary:"All named views in a rhino document.",properties:[{signature:"int Count",summary:"Number of named views in the table.",since:5},{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:5}],methods:[{signature:"int Add(string name,Guid viewportId)",summary:"Adds named view to document which is based on an existing viewport.",since:5,returns:"0 based index of named view.\n     -1 on failure."},{signature:"int Add(ViewInfo view)",since:5},{signature:"bool Delete(int index)",summary:"Remove named view from the document.",since:5,returns:"True if successful."},{signature:"bool Delete(string name)",summary:"Remove named view from the document.",since:5,returns:"True if successful."},{signature:"int FindByName(string name)",summary:"Finds a named view.",since:5,returns:">=0 index of the found named view\n     -1 no named view found."},{signature:"IEnumerator<ViewInfo> GetEnumerator()",since:5},{signature:"bool Rename(int index,string newName)",summary:"Renames a named view.",since:7,returns:"True if successful, False otherwise."},{signature:"bool Rename(string oldName,string newName)",summary:"Renames a named view.",since:7,returns:"True if successful, False otherwise."},{signature:"bool Restore(int index,RhinoView view,bool backgroundBitmap)",since:5},{signature:"bool Restore(int index,RhinoViewport viewport)",summary:"Sets the MainViewport of a standard RhinoView to a named views settings",since:6},{signature:"bool Restore(int index,RhinoViewport viewport,bool backgroundBitmap)",since:5.9},{signature:"bool RestoreAnimated(int index,RhinoView view,bool backgroundBitmap)",since:5},{signature:"bool RestoreAnimated(int index,RhinoView view,bool backgroundBitmap,int frames,int frameRate)",since:5},{signature:"bool RestoreAnimated(int index,RhinoViewport viewport,bool backgroundBitmap)",since:5.9},{signature:"bool RestoreAnimated(int index,RhinoViewport viewport,bool backgroundBitmap,int frames,int frameRate)",since:5.9},{signature:"bool RestoreAnimatedConstantSpeed(int index,RhinoViewport viewport,double units_per_frame,int ms_delay)",since:6},{signature:"bool RestoreAnimatedConstantTime(int index,RhinoViewport viewport,int frames,int ms_delay)",since:6},{signature:"bool RestoreWithAspectRatio(int index,RhinoViewport viewport)",since:6}]},{name:"Rhino.DocObjects.Tables.ObjectTable",dataType:1,summary:"",properties:[{signature:"BoundingBox BoundingBox",summary:'Gets the boundingbox for all objects (normal, locked and hidden) in this\n     document that exist in "model" space. This bounding box does not include\n     objects that exist in layout space.',since:5},{signature:"BoundingBox BoundingBoxVisible",summary:'Gets the boundingbox for all visible objects (normal and locked) in this\n     document that exist in "model" space. This bounding box does not include\n     hidden objects or any objects that exist in layout space.',since:5},{signature:"ModelComponentType ComponentType",since:6},{signature:"RhinoDoc Document",summary:"Gets the document that owns this object table.",since:5},{signature:"int HistoryRecordCount",summary:"Returns the amount of history records in this document.",since:6}],methods:[{signature:"Guid Add(GeometryBase geometry)",summary:"Adds geometry that is not further specified.\n     This is meant, for example, to handle addition of sets of different geometrical entities.",since:5,returns:"The new object ID on success."},{signature:"Guid Add(GeometryBase geometry,ObjectAttributes attributes)",summary:"Adds geometry that is not further specified.\n     This is meant, for example, to handle addition of sets of different geometrical entities.",since:5,returns:"The new object ID on success."},{signature:"Guid Add(GeometryBase geometry,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds geometry that is not further specified.\n     This is meant, for example, to handle addition of sets of different geometrical entities.",since:6,returns:"The new object ID on success."},{signature:"Guid AddAngularDimension(AngularDimension dimension)",summary:"Adds a angular dimension object to the document.",since:5,returns:"The Id of the newly added object or Guid.Empty on failure."},{signature:"Guid AddAngularDimension(AngularDimension dimension,ObjectAttributes attributes)",summary:"Adds a angular dimension object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddAngularDimension(AngularDimension dimension,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds an angular dimension object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddArc(Arc arc)",summary:"Adds a curve object to the document representing an arc.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddArc(Arc arc,ObjectAttributes attributes)",summary:"Adds a curve object to the document representing an arc.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddArc(Arc arc,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddBox(Box box)",summary:"Adds a box to the object table.",since:6,returns:"The ID."},{signature:"Guid AddBox(Box box,ObjectAttributes attributes)",summary:"Adds a box to the object table.",since:6,returns:"The ID."},{signature:"Guid AddBox(Box box,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a box to the object table, as an extrusion.",since:6,returns:"The ID."},{signature:"Guid AddBrep(Brep brep)",summary:"Adds a brep object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddBrep(Brep brep,ObjectAttributes attributes)",summary:"Adds a brep object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddBrep(Brep brep,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddBrep(Brep brep,ObjectAttributes attributes,HistoryRecord history,bool reference,bool splitKinkySurfaces)",since:5},{signature:"Guid AddCentermark(Centermark centermark,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds an ordinate dimension object to the document.",since:6,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddCircle(Circle circle)",summary:"Adds a curve object to the document representing a circle.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCircle(Circle circle,ObjectAttributes attributes)",summary:"Adds a curve object to the document representing a circle.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCircle(Circle circle,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId)",summary:"Adds a clipping plane object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds)",summary:"Adds a clipping plane object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes)",summary:"Adds a clipping plane object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddCurve(Curve curve)",summary:"Adds a curve object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCurve(Curve curve,ObjectAttributes attributes)",summary:"Adds a curve object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCurve(Curve curve,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddEllipse(Ellipse ellipse)",summary:"Adds a curve object to the document representing an ellipse.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddEllipse(Ellipse ellipse,ObjectAttributes attributes)",summary:"Adds a curve object to the document representing an ellipse.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddEllipse(Ellipse ellipse,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid[] AddExplodedInstancePieces(InstanceObject instance,bool explodeNestedInstances,bool deleteInstance)",since:5.11},{signature:"Guid AddExtrusion(Extrusion extrusion)",summary:"Adds an extrusion object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddExtrusion(Extrusion extrusion,ObjectAttributes attributes)",summary:"Adds an extrusion object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddExtrusion(Extrusion extrusion,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddHatch(Hatch hatch)",since:5},{signature:"Guid AddHatch(Hatch hatch,ObjectAttributes attributes)",since:5},{signature:"Guid AddHatch(Hatch hatch,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform)",summary:"Adds an instance object to the document.",since:5,returns:"A unique identifier for the object if successful. Guid.Empty it not successful."},{signature:"Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform,ObjectAttributes attributes)",summary:"Adds an instance object to the document.",since:5,returns:"A unique identifier for the object if successful. Guid.Empty it not successful."},{signature:"Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds an instance object to the document.",since:6.24,returns:"A unique identifier for the object if successful. Guid.Empty it not successful."},{signature:"Guid AddLeader(IEnumerable<Point3d> points)",since:5},{signature:"Guid AddLeader(Leader leader)",summary:"Adds a Leader object to the document.",since:6,returns:"The Id of the newly added object or Guid.Empty on failure."},{signature:"Guid AddLeader(Leader leader,ObjectAttributes attributes)",summary:"Addsa Leader object to the document.",since:6,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddLeader(Leader leader,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a Leader object to the document.",since:6,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddLeader(Plane plane,IEnumerable<Point2d> points)",since:5},{signature:"Guid AddLeader(Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)",since:5},{signature:"Guid AddLeader(string text,IEnumerable<Point3d> points)",since:5},{signature:"Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points)",since:5},{signature:"Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)",since:5},{signature:"Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddLine(Line line)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLine(Line line,ObjectAttributes attributes)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLine(Point3d from,Point3d to)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLine(Point3d from,Point3d to,ObjectAttributes attributes)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLine(Point3d from,Point3d to,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddLinearDimension(LinearDimension dimension)",summary:"Adds a linear dimension object to the document.",since:5,returns:"The Id of the newly added object or Guid.Empty on failure."},{signature:"Guid AddLinearDimension(LinearDimension dimension,ObjectAttributes attributes)",summary:"Adds a linear dimension object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddLinearDimension(LinearDimension dimension,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a linear dimension object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddMesh(Mesh mesh)",summary:"Adds a mesh object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddMesh(Mesh mesh,ObjectAttributes attributes)",summary:"Adds a mesh object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddMesh(Mesh mesh,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddMesh(Mesh mesh,ObjectAttributes attributes,HistoryRecord history,bool reference,bool requireValidMesh)",since:6},{signature:"Guid AddMorphControl(MorphControl morphControl)",since:5},{signature:"Guid AddMorphControl(MorphControl morphControl,ObjectAttributes attributes)",since:5},{signature:"Guid AddMorphControl(MorphControl morphControl,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:6},{signature:"Guid AddOrdinateDimension(OrdinateDimension dimordinate,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds an ordinate dimension object to the document.",since:6,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddPictureFrame(Plane plane,string texturePath,bool asMesh,double width,double height,bool selfIllumination,bool embedBitmap)",summary:"Creates a PictureFrame object from a plane and a path to an image file,\n     Note, a PictureFrame object is just a Plane surface or mesh that has a\n     material with a texture assigned to it that displays in all display\n     modes.",since:5.1,returns:"A unique identifier for the object"},{signature:"Guid AddPoint(double x,double y,double z)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object.."},{signature:"Guid AddPoint(Point point,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a point object and its geometry-linked information to the document",since:6,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3d point)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3d point,ObjectAttributes attributes)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3d point,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a point object to the document",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3f point)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3f point,ObjectAttributes attributes)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(IEnumerable<Point3d> points)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(PointCloud cloud)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(PointCloud cloud,ObjectAttributes attributes)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(PointCloud cloud,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"RhinoList<Guid> AddPoints(IEnumerable<Point3d> points)",summary:"Adds multiple points to the document.",since:5,returns:"List of object ids."},{signature:"RhinoList<Guid> AddPoints(IEnumerable<Point3d> points,ObjectAttributes attributes)",summary:"Adds multiple points to the document.",since:5,returns:"List of object ids."},{signature:"RhinoList<Guid> AddPoints(IEnumerable<Point3f> points)",summary:"Adds multiple points to the document.",since:5,returns:"List of object ids."},{signature:"RhinoList<Guid> AddPoints(IEnumerable<Point3f> points,ObjectAttributes attributes)",summary:"Adds multiple points to the document.",since:5,returns:"List of object ids."},{signature:"Guid AddPolyline(IEnumerable<Point3d> points)",summary:"Adds a polyline object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes)",summary:"Adds a polyline object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddRadialDimension(RadialDimension dimension)",since:5},{signature:"Guid AddRadialDimension(RadialDimension dimension,ObjectAttributes attributes)",since:5},{signature:"Guid AddRadialDimension(RadialDimension dimension,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a radial dimension object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddRectangle(Rectangle3d rectangle)",summary:"Adds a rectangle to the object table.",since:6,returns:"The ID."},{signature:"Guid AddRectangle(Rectangle3d rectangle,ObjectAttributes attributes)",summary:"Adds a rectangle to the object table.",since:6,returns:"The ID."},{signature:"Guid AddRectangle(Rectangle3d rectangle,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a rectangle to the object table.",since:6,returns:"The ID."},{signature:"void AddRhinoObject(BrepObject brepObject,Brep brep)",since:5},{signature:"void AddRhinoObject(CurveObject curveObject,Curve curve)",since:5},{signature:"void AddRhinoObject(CustomBrepObject brepObject)",since:5},{signature:"void AddRhinoObject(CustomBrepObject brepObject,HistoryRecord history)",since:6.1},{signature:"void AddRhinoObject(CustomCurveObject curveObject,HistoryRecord history)",since:6.1},{signature:"void AddRhinoObject(CustomMeshObject meshObject)",since:5},{signature:"void AddRhinoObject(CustomMeshObject meshObject,HistoryRecord history)",since:6.1},{signature:"void AddRhinoObject(CustomPointObject pointObject)",since:5.6},{signature:"void AddRhinoObject(CustomPointObject pointObject,HistoryRecord history)",since:6.1},{signature:"void AddRhinoObject(MeshObject meshObject,Mesh mesh)",since:5},{signature:"void AddRhinoObject(PointObject pointObject,Point point)",since:5.6},{signature:"Guid AddSphere(Sphere sphere)",since:5},{signature:"Guid AddSphere(Sphere sphere,ObjectAttributes attributes)",since:5},{signature:"Guid AddSphere(Sphere sphere,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddSubD(SubD subD)",summary:"Adds a SubD object to Rhino.",since:7,returns:"A unique identifier for the object."},{signature:"Guid AddSubD(SubD subD,ObjectAttributes attributes)",summary:"Adds a SubD object to Rhino.",since:7,returns:"A unique identifier for the object."},{signature:"Guid AddSubD(SubD subD,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a SubD object to Rhino.",since:7,returns:"A unique identifier for the object."},{signature:"Guid AddSurface(Surface surface)",summary:"Adds a surface object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddSurface(Surface surface,ObjectAttributes attributes)",summary:"Adds a surface object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddSurface(Surface surface,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,ObjectAttributes attributes)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification)",since:5},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes)",since:5},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"Guid AddText(Text3d text3d)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(Text3d text3d,ObjectAttributes attributes)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(TextEntity text)",summary:"Adds a v6_TextObject to the document.",since:5,returns:"The Id of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(TextEntity text,ObjectAttributes attributes)",summary:"Adds a text object to the document.",since:5,returns:"The Id of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(TextEntity text,ObjectAttributes attributes,HistoryRecord history,bool reference)",summary:"Adds a text object to the document.",since:5,returns:"The Id of the newly added object or Guid.Empty on failure."},{signature:"Guid AddTextDot(string text,Point3d location)",summary:"Adds a text dot object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddTextDot(string text,Point3d location,ObjectAttributes attributes)",summary:"Adds a text dot object to Rhino.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddTextDot(TextDot dot)",summary:"Adds a text dot object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddTextDot(TextDot dot,ObjectAttributes attributes)",summary:"Adds a text dot object to Rhino.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddTextDot(TextDot dot,ObjectAttributes attributes,HistoryRecord history,bool reference)",since:5},{signature:"RhinoObject[] AllObjectsSince(uint runtimeSerialNumber)",summary:"Gets all the objects that have been added to the document since a given runtime serial number.",since:5,returns:"An array of objects or None if no objects were added since the given runtime serial number."},{signature:"bool Delete(Guid objectId,bool quiet)",summary:"Deletes object from document. The deletion can be undone by calling UndeleteObject().",since:5,returns:"True on success, False on failure."},{signature:"int Delete(IEnumerable<Guid> objectIds,bool quiet)",summary:"Deletes a collection of objects from the document.",since:5,returns:"The number of successfully deleted objects."},{signature:"bool Delete(ObjRef objref,bool quiet)",summary:"Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().",since:5,returns:"True on success, False on failure."},{signature:"bool Delete(ObjRef objref,bool quiet,bool ignoreModes)",summary:"Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().",since:6,returns:"True on success, False on failure."},{signature:"bool Delete(RhinoObject item)",summary:"Deletes an object, taking into account modes and not showing error message boxes.",since:6,returns:"True on success."},{signature:"bool Delete(RhinoObject obj,bool quiet)",summary:"Deletes object from document. The deletion can be undone by calling UndeleteObject().",since:5,returns:"True on success, False on failure."},{signature:"bool Delete(RhinoObject obj,bool quiet,bool ignoreModes)",summary:"Deletes object from document. The deletion can be undone by calling UndeleteObject().",since:6,returns:"True on success, False on failure."},{signature:"bool DeleteGrip(GripObject grip)",summary:"Deletes a grip object.",since:6.5,returns:"True on success."},{signature:"bool DeleteGrip(Guid gripId)",summary:"Deletes a grip object.",since:6.5,returns:"True on success."},{signature:"bool DeleteGrip(ObjRef gripRef)",summary:"Deletes a grip object.",since:6.5,returns:"True on success."},{signature:"int DeleteGrips(IEnumerable<GripObject> grips)",summary:"Deletes one or more grip objects.",since:6.5,returns:"The number of successfully deleted grip objects."},{signature:"int DeleteGrips(IEnumerable<Guid> gripIds)",summary:"Deletes one or more grip objects.",since:6.5,returns:"The number of successfully deleted grip objects."},{signature:"int DeleteGrips(IEnumerable<ObjRef> gripRefs)",summary:"Deletes one or more grip objects.",since:6.5,returns:"The number of successfully deleted grip objects."},{signature:"int DeleteGrips(RhinoObject owner,IEnumerable<int> gripIndices)",summary:"Deletes one or more grip objects.",since:6.5,returns:"The number of successfully deleted grip objects."},{signature:"Guid Duplicate(Guid objectId)",summary:"Same as TransformObject(objref, ON_Xform.Identity, false)",since:5,returns:"The new object ID."},{signature:"Guid Duplicate(ObjRef objref)",summary:"Duplicates the object that is referenced by objref.\n     Same as Transform(objref, Transform.Identity, false)",since:5,returns:"The new object ID."},{signature:"Guid Duplicate(RhinoObject obj)",summary:"Duplicates the object that is referenced by obj.\n     Same as TransformObject(obj, Transform.Identityy, false)",since:5,returns:"The new object ID."},{signature:"RhinoObject Find(Guid objectId)",summary:"Please use FindId().",since:5,returns:"Do not use this method."},{signature:"RhinoObject Find(uint runtimeSerialNumber)",summary:"Use the object runtime serial number to find a rhino object in the document. This is the value stored on\n     RhinoObject.RuntimeObjectSerialNumber. The RhinoObject constructor sets the runtime serial number and every\n     instance of a RhinoObject class will have a unique serial number for the duration of the Rhino application.\n     If an object is replaced with a new object, then the new object will have a different runtime serial number.\n     Deleted objects stored in the undo list maintain their runtime serial numbers and this funtion will return\n     pointers to these objects. Call RhinoObject.IsDeleted if you need to determine if the returned object is\n     active or deleted.  The runtime serial number is not saved in files.",since:5,returns:"Reference to the rhino object with the objectId or None if no such object could be found."},{signature:"RhinoObject[] FindByCrossingWindowRegion(RhinoViewport viewport,IEnumerable<Point3d> region,bool inside,ObjectType filter)",summary:"Finds objects bounded by a polyline region",since:5.7,returns:"An array of RhinoObjects that are inside of this region"},{signature:"RhinoObject[] FindByCrossingWindowRegion(RhinoViewport viewport,Point2d screen1,Point2d screen2,bool inside,ObjectType filter)",summary:"Finds objects bounded by a region",since:5.8,returns:"An array of RhinoObjects that are inside of this region"},{signature:"RhinoObject[] FindByDrawColor(Color drawColor,bool includeLights)",summary:"Finds all objects whose draw color matches a given color.",since:5,returns:"An array of Rhino document objects. This array can be empty."},{signature:"RhinoObject[] FindByFilter(ObjectEnumeratorSettings filter)",summary:"Same as GetObjectList but converts the result to an array.",since:5,returns:"A Rhino object array. This array can be emptry but not null."},{signature:"RhinoObject[] FindByGroup(int groupIndex)",summary:"Finds all RhinoObjects that are in a given group.",since:5,returns:"An array of objects that belong to the specified group or None if no objects could be found."},{signature:"RhinoObject[] FindByLayer(Layer layer)",summary:"Finds all RhinoObjects that are in a given layer.",since:5,returns:"Array of objects that belong to the specified group or None if no objects could be found."},{signature:"RhinoObject[] FindByLayer(string layerName)",summary:"Finds all RhinoObjects that are in a given layer.",since:5,returns:"Array of objects that belong to the specified group or None if no objects could be found."},{signature:"RhinoObject[] FindByObjectType(ObjectType typeFilter)",since:5},{signature:"RhinoObject[] FindByUserString(string key,string value,bool caseSensitive)",summary:"Finds all objects whose UserString matches the search patterns.",since:5,returns:"An array of all objects whose UserString matches with the search patterns or None when no such objects could be found."},{signature:"RhinoObject[] FindByUserString(string key,string value,bool caseSensitive,bool searchGeometry,bool searchAttributes,ObjectEnumeratorSettings filter)",summary:"Finds all objects whose UserString matches the search patterns.",since:5,returns:"An array of all objects whose UserString matches with the search patterns or None when no such objects could be found."},{signature:"RhinoObject[] FindByUserString(string key,string value,bool caseSensitive,bool searchGeometry,bool searchAttributes,ObjectType filter)",summary:"Finds all objects whose UserString matches the search patterns.",since:5,returns:"An array of all objects whose UserString matches with the search patterns or None when no such objects could be found."},{signature:"RhinoObject[] FindByWindowRegion(RhinoViewport viewport,IEnumerable<Point3d> region,bool inside,ObjectType filter)",summary:"Finds objects bounded by a polyline region",since:5.7,returns:"An array of RhinoObjects that are inside of this region"},{signature:"RhinoObject[] FindByWindowRegion(RhinoViewport viewport,Point2d screen1,Point2d screen2,bool inside,ObjectType filter)",summary:"Finds objects bounded by a polyline region",since:5.8,returns:"An array of RhinoObjects that are inside of this region"},{signature:"ClippingPlaneObject[] FindClippingPlanesForViewport(RhinoViewport viewport)",summary:"Finds all of the clipping plane objects that actively clip a viewport.",since:5,returns:"An array of clipping plane objects. The array can be emptry but not null."},{signature:"GeometryBase FindGeometry(Guid id)",summary:"Same as FindId, but returns the Geometry property directly, if it exists.",since:6,returns:"Reference to the geometry in the rhino object with the objectId or None if no such object could be found."},{signature:"RhinoObject FindId(Guid id)",summary:"Uses the object guid to find a rhino object. Deleted objects cannot be found by id.\n     The guid is the value that is stored on RhinoObject.Id\n     In a single document, no two active objects have the same guid. If an object is\n     replaced with a new object, then the guid  persists. For example, if the _Move command\n     moves an object, then the moved object inherits it's guid from the starting object.\n     If the Copy command copies an object, then the copy gets a new guid. This guid persists\n     through file saving/openning operations. This function will not find grip objects.",since:6,returns:"Reference to the rhino object with the objectId or None if no such object could be found."},{signature:"IEnumerator<RhinoObject> GetEnumerator()",since:5},{signature:"IEnumerable<RhinoObject> GetObjectList(ObjectEnumeratorSettings settings)",since:5},{signature:"IEnumerable<RhinoObject> GetObjectList(ObjectType typeFilter)",since:5},{signature:"IEnumerable<RhinoObject> GetObjectList(Type typeFilter)",since:5},{signature:"IEnumerable<T> GetObjectsByType()",since:6},{signature:"IEnumerable<T> GetObjectsByType(ObjectEnumeratorSettings settings)",since:6},{signature:"IEnumerable<RhinoObject> GetSelectedObjects(bool includeLights,bool includeGrips)",since:5},{signature:"ObjectType GetSelectedObjectTypes()",since:6},{signature:"RhinoObject GripUpdate(RhinoObject obj,bool deleteOriginal)",summary:"Altered grip positions on a RhinoObject are used to calculate an updated object\n     that is added to the document.",since:5,returns:"new RhinoObject on success; otherwise null."},{signature:"bool Hide(Guid objectId,bool ignoreLayerMode)",summary:"If Object().IsNormal() is true, then the object will be hidden.",since:5,returns:"True if the object was successfully hidden."},{signature:"bool Hide(ObjRef objref,bool ignoreLayerMode)",summary:"If objref.Object().IsNormal() is true, then the object will be hidden.",since:5,returns:"True if the object was successfully hidden."},{signature:"bool Hide(RhinoObject obj,bool ignoreLayerMode)",summary:"If obj.IsNormal() is true, then the object will be hidden.",since:5,returns:"True if the object was successfully hidden."},{signature:"bool Lock(Guid objectId,bool ignoreLayerMode)",summary:"If objref.Object().IsNormal() is true, then the object will be locked.",since:5,returns:"True if the object was successfully locked."},{signature:"bool Lock(ObjRef objref,bool ignoreLayerMode)",summary:"If objref.Object().IsNormal() is true, then the object will be locked.",since:5,returns:"True if the object was successfully locked."},{signature:"bool Lock(RhinoObject obj,bool ignoreLayerMode)",summary:"If obj.IsNormal() is true, then the object will be locked.",since:5,returns:"True if the object was successfully locked."},{signature:"bool ModifyAttributes(Guid objectId,ObjectAttributes newAttributes,bool quiet)",summary:"Modifies an object's attributes.  Cannot be used to change object id.",since:5,returns:"True if successful."},{signature:"bool ModifyAttributes(ObjRef objref,ObjectAttributes newAttributes,bool quiet)",summary:"Modifies an object's attributes.  Cannot be used to change object id.",since:5,returns:"True if successful."},{signature:"bool ModifyAttributes(RhinoObject obj,ObjectAttributes newAttributes,bool quiet)",summary:"Modifies an object's attributes.  Cannot be used to change object id.",since:5,returns:"True if successful."},{signature:"bool ModifyRenderMaterial(Guid objectId,RenderMaterial material)",summary:"Modifies an object's render material assignment, this will set the\n     objects material source to ObjectMaterialSource.MaterialFromObject.",since:5.7,returns:"Returns True on success otherwise returns false."},{signature:"bool ModifyRenderMaterial(ObjRef objRef,RenderMaterial material)",summary:"Modifies an object's render material assignment, this will set the\n     objects material source to ObjectMaterialSource.MaterialFromObject.",since:5.7,returns:"Returns True on success otherwise returns false."},{signature:"bool ModifyRenderMaterial(RhinoObject obj,RenderMaterial material)",summary:"Modifies an object's render material assignment, this will set the\n     objects material source to ObjectMaterialSource.MaterialFromObject.",since:5.7,returns:"Returns True on success otherwise returns false."},{signature:"bool ModifyTextureMapping(Guid objId,int channel,TextureMapping mapping)",since:5.7},{signature:"bool ModifyTextureMapping(ObjRef objRef,int channel,TextureMapping mapping)",since:5.7},{signature:"bool ModifyTextureMapping(RhinoObject obj,int channel,TextureMapping mapping)",since:5.7},{signature:"RhinoObject MostRecentObject()",summary:"Gets the most recently added object that is still in the Document.",since:5,returns:"The most recent (non-deleted) object in the document, or None if no such object exists."},{signature:"int ObjectCount(ObjectEnumeratorSettings filter)",since:5},{signature:"ObjRef[] PickObjects(PickContext pickContext)",summary:"Pick one or more objects based on a given pick context",since:6,returns:"zero or more objects"},{signature:"bool Purge(RhinoObject rhinoObject)",summary:"Removes object from document and deletes the pointer. Typically you will\n     want to call Delete instead in order to keep the object on the undo list.",since:5,returns:"True if the object was purged; otherwise false."},{signature:"bool Purge(uint runtimeSerialNumber)",summary:"Removes object from document and deletes the pointer. Typically you will\n     want to call Delete instead in order to keep the object on the undo list.",since:5,returns:"True if the object was purged; otherwise false."},{signature:"bool Replace(Guid objectId,Arc arc)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Brep brep)",summary:"Replaces one object with new brep object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Brep brep,bool splitKinkySurfaces)",since:6.1},{signature:"bool Replace(Guid objectId,Circle circle)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Curve curve)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Extrusion extrusion)",summary:"Replaces one object with new extrusion object.",since:6,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Hatch hatch)",summary:"Replaces one object with new hatch object.",since:6.1,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Leader leader)",summary:"Replaces one object with new text object.",since:6,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Line line)",summary:"Replaces one object with new line curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Mesh mesh)",summary:"Replaces one object with new mesh object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Point point)",summary:"Replaces one object with new point object.",since:6,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Point3d point)",summary:"Replaces one object with new point object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,PointCloud pointcloud)",summary:"Replaces one object with new pointcloud object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Polyline polyline)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,SubD subD)",summary:"Replaces one object with new subd object.",since:7,returns:"True if successful."},{signature:"bool Replace(Guid objectId,Surface surface)",summary:"Replaces one object with new surface object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,TextDot dot)",summary:"Replaces one object with new textdot object.",since:5,returns:"True if successful."},{signature:"bool Replace(Guid objectId,TextEntity text)",summary:"Replaces one object with new text object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Arc arc)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Brep brep)",summary:"Replaces one object with new brep object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Brep brep,bool splitKinkySurfaces)",since:6.1},{signature:"bool Replace(ObjRef objref,Circle circle)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Curve curve)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Extrusion extrusion)",summary:"Replaces one object with new extrusion object.",since:6,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Hatch hatch)",summary:"Replaces one object with new hatch object.",since:6.1,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Leader leader)",summary:"Replaces one object with new text object.",since:6,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Line line)",summary:"Replaces one object with new line curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Mesh mesh)",summary:"Replaces one object with new mesh object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Point point)",summary:"Replaces one object with new point object.",since:6,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Point3d point)",summary:"Replaces one object with new point object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,PointCloud pointcloud)",summary:"Replaces one object with new pointcloud object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Polyline polyline)",summary:"Replaces one object with new curve object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,RhinoObject newObject)",summary:"Replaces one object with another. Conceptually, this function is the same as calling\n     Setting new_object attributes = old_object attributes\n     DeleteObject(old_object);\n     AddObject(old_object);",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,SubD subD)",summary:"Replaces one object with a new SubD object.",since:7,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,Surface surface)",summary:"Replaces one object with new surface object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,TextDot dot)",summary:"Replaces one object with new textdot object.",since:5,returns:"True if successful."},{signature:"bool Replace(ObjRef objref,TextEntity text)",summary:"Replaces one object with new text object.",since:5,returns:"True if successful."},{signature:"bool ReplaceInstanceObject(Guid objectId,int instanceDefinitionIndex)",summary:"Replaces the underlying instance definition of an instance object.",since:6.8,returns:"True if successful."},{signature:"bool ReplaceInstanceObject(ObjRef objref,int instanceDefinitionIndex)",summary:"Replaces the underlying instance definition of an instance object.",since:6.8,returns:"True if successful."},{signature:"bool Select(Guid objectId)",summary:"Select a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(Guid objectId,bool select)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(Guid objectId,bool select,bool syncHighlight)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(Guid objectId,bool select,bool syncHighlight,bool persistentSelect)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(Guid objectId,bool select,bool syncHighlight,bool persistentSelect,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"int Select(IEnumerable<Guid> objectIds)",summary:"Selects a collection of objects.",since:5,returns:"Number of objects successfully selected."},{signature:"int Select(IEnumerable<Guid> objectIds,bool select)",summary:"Selects or deselects a collection of objects.",since:5,returns:"Number of objects successfully selected or deselected."},{signature:"int Select(IEnumerable<ObjRef> objRefs)",summary:"Selects a collection of objects.",since:5,returns:"Number of objects successfully selected."},{signature:"int Select(IEnumerable<ObjRef> objRefs,bool select)",summary:"Selects or deselects a collection of objects.",since:5,returns:"Number of objects successfully selected or deselected."},{signature:"bool Select(ObjRef objref)",summary:"Select a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(ObjRef objref,bool select)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(ObjRef objref,bool select,bool syncHighlight)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(ObjRef objref,bool select,bool syncHighlight,bool persistentSelect)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Select(ObjRef objref,bool select,bool syncHighlight,bool persistentSelect,bool ignoreGripsState,bool ignoreLayerLocking,bool ignoreLayerVisibility)",summary:"Select or deselects a single object.",since:5,returns:"True on success, False on failure."},{signature:"bool Show(Guid objectId,bool ignoreLayerMode)",summary:"If Object().IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.",since:5,returns:"True if the object was successfully shown."},{signature:"bool Show(ObjRef objref,bool ignoreLayerMode)",summary:"If objref.Object().IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.",since:5,returns:"True if the object was successfully shown."},{signature:"bool Show(RhinoObject obj,bool ignoreLayerMode)",summary:"If obj.IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.",since:5,returns:"True if the object was successfully shown."},{signature:"Guid Transform(Guid objectId,Transform xform,bool deleteOriginal)",summary:"Constructs a new object that is the transformation of the existing object\n     and deletes the existing object if deleteOriginal is true.",since:5,returns:"Id of the new object that is the transformation of the existing_object.\n     The new object has identical attributes."},{signature:"Guid Transform(ObjRef objref,Transform xform,bool deleteOriginal)",summary:"Constructs a new object that is the transformation of the existing object\n     and deletes the existing object if deleteOriginal is true.",since:5,returns:"Id of the new object that is the transformation of the existing_object.\n     The new object has identical attributes."},{signature:"Guid Transform(RhinoObject obj,Transform xform,bool deleteOriginal)",summary:"Constructs a new object that is the transformation of the existing object\n     and deletes the existing object if deleteOriginal is true.",since:5,returns:"Id of the new object that is the transformation of the existing_object.\n     The new object has identical attributes."},{signature:"Guid TransformWithHistory(Guid objectId,Transform xform)",summary:"Constructs a new object that is the transformation of the existing object\n     and records history of the transformation if history recording is turned on.\n     If history recording is not enabled, this function will act the same as\n     Transform(objectId, xform, false)",since:5,returns:"Id of the new object that is the transformation of the existing_object.\n     The new object has identical attributes."},{signature:"Guid TransformWithHistory(ObjRef objref,Transform xform)",summary:"Constructs a new object that is the transformation of the existing object\n     and records history of the transformation if history recording is turned on.\n     If history recording is not enabled, this function will act the same as\n     Transform(objref, xform, false)",since:5,returns:"Id of the new object that is the transformation of the existing_object.\n     The new object has identical attributes."},{signature:"Guid TransformWithHistory(RhinoObject obj,Transform xform)",summary:"Constructs a new object that is the transformation of the existing object\n     and records history of the transformation if history recording is turned on.\n     If history recording is not enabled, this function will act the same as\n     Transform(obj, xform, false)",since:5,returns:"Id of the new object that is the transformation of the existing_object.\n     The new object has identical attributes."},{signature:"bool TryFindPoint(Guid id,Point3d point)",summary:"Finds the location of a point, if a point exists in the document.",since:6,returns:"True on success; False if point was not found, id represented another geometry type, or on error."},{signature:"bool Undelete(RhinoObject rhinoObject)",since:5},{signature:"bool Undelete(uint runtimeSerialNumber)",since:5},{signature:"bool Unlock(Guid objectId,bool ignoreLayerMode)",summary:"If Object().IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.",since:5,returns:"True if the object was successfully unlocked."},{signature:"bool Unlock(ObjRef objref,bool ignoreLayerMode)",summary:"If objref.Object().IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.",since:5,returns:"True if the object was successfully unlocked."},{signature:"bool Unlock(RhinoObject obj,bool ignoreLayerMode)",summary:"If obj.IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.",since:5,returns:"True if the object was successfully unlocked."},{signature:"int UnselectAll()",summary:"Unselect objects.",since:5,returns:"Number of object that were unselected."},{signature:"int UnselectAll(bool ignorePersistentSelections)",summary:"Unselect objects.",since:5,returns:"Number of object that were unselected."}]},{name:"Rhino.DocObjects.Tables.RestoreLayerProperties",dataType:3,summary:""},{name:"Rhino.DocObjects.Tables.RhinoDocCommonTable",dataType:1,summary:"",properties:[{signature:"RhinoDoc Document",summary:"Document that owns this table."}]},{name:"Rhino.DocObjects.Tables.RuntimeDocumentDataTable",dataType:1,summary:"Collection of document runtime data. This is a good place to\n   put non-serialized, per document data.",properties:[{signature:"RhinoDoc Document",since:6.3}],methods:[{signature:"T GetValue(object key,Func<RhinoDoc, T> newT)",summary:"Checks the dictionary for the specified key, if found and the value is not\n     None then then the value is returned.  If the key is not found or its value\n     is None then newT(Document) is called to create a new value instnce which\n     is put in the dictionary and returned.",returns:"Returns the document specific instance of type T using the specified\n     dictionary key."},{signature:"T TryGetValue(object key)",summary:"Check dictionary for value and return it properly cast if\n     found.",since:6.15,returns:"Returns the document specific instance of type T using the specified\n     dictionary key or None if not found."}]},{name:"Rhino.DocObjects.Tables.SnapshotTable",dataType:1,summary:"All snapshots in a rhino document.",properties:[{signature:"RhinoDoc Document",summary:"Document that owns this table.",since:6.7},{signature:"string[] Names",summary:"Array of Snapshot names.",since:6.7}]},{name:"Rhino.DocObjects.Tables.StringTable",dataType:1,summary:"Collection of document user data strings",properties:[{signature:"int Count",summary:"The number of user data strings in the current document.",since:5},{signature:"RhinoDoc Document",summary:"Document that owns this object table.",since:5},{signature:"int DocumentDataCount",since:6},{signature:"int DocumentUserTextCount",since:6}],methods:[{signature:"void Delete(string key)",since:5},{signature:"void Delete(string section,string entry)",summary:"Removes user data strings from the document.",since:5},{signature:"string[] GetEntryNames(string section)",summary:"Return list of all entry names for a given section of user data strings in the document.",since:5,returns:"An array of section names. This can be empty, but not null."},{signature:"string GetKey(int i)",since:5},{signature:"string[] GetSectionNames()",summary:"Returns a list of all the section names for user data strings in the document.\n     By default a section name is a key that is prefixed with a string separated by a backslash.",since:5,returns:"An array of section names. This can be empty, but not null."},{signature:"string GetValue(int i)",since:5},{signature:"string GetValue(string key)",since:5},{signature:"string GetValue(string section,string entry)",summary:"Gets a user data string from the document.",since:5,returns:"The user data."},{signature:"string SetString(string key,string value)",summary:"Adds or sets a user data string to the document.",since:5,returns:"The previous value if successful and a previous value existed."},{signature:"string SetString(string section,string entry,string value)",summary:"Adds or sets a user data string to the document.",since:5,returns:"The previous value if successful and a previous value existed."}]},{name:"Rhino.DocObjects.Tables.ViewTable",dataType:1,summary:"",properties:[{signature:"RhinoView ActiveView",summary:"Gets or Sets the active view.",since:5},{signature:"RhinoDoc Document",summary:"Document that owns this object table.",since:5},{signature:"bool ModelSpaceIsActive",since:5},{signature:"bool RedrawEnabled",summary:"Returns or sets (enable or disables) screen redrawing.",since:5}],methods:[{signature:"RhinoView Add(string title,DefinedViewportProjection projection,Rectangle position,bool floating)",summary:"Constructs a new Rhino view and, at the same time, adds it to the list.",since:5,returns:"The newly constructed Rhino view; or None on error."},{signature:"RhinoPageView AddPageView(string title)",summary:"Constructs a new page view with a given title and, at the same time, adds it to the list.",since:5,returns:"The newly created page view on success; or None on error."},{signature:"RhinoPageView AddPageView(string title,double pageWidth,double pageHeight)",summary:"Constructs a new page view with a given title and size and, at the same time, adds it to the list.",since:5,returns:"The newly created page view on success; or None on error."},{signature:"void DefaultViewLayout()",since:5},{signature:"void EnableCameraIcon(RhinoView view)",summary:"Use to turn camera icon on and off",since:6},{signature:"RhinoView Find(Guid mainViewportId)",summary:"Finds a view in this document with a given main viewport Id.",since:5,returns:"View on success. None if the view could not be found in this document."},{signature:"RhinoView Find(string mainViewportName,bool compareCase)",summary:"Finds a view in this document with a main viewport that has a given name. Note that there\n     may be multiple views in this document that have the same name. This function only returns\n     the first view found. If you want to find all the views with a given name, use the GetViewList\n     function and iterate through the views.",since:5,returns:"A Rhino view on success; None on error."},{signature:"void FlashObjects(IEnumerable<RhinoObject> list,bool useSelectionColor)",summary:"Cause objects selection state to change momentarily so the object\n     appears to flash on the screen.",since:5},{signature:"void FourViewLayout(bool useMatchingViews)",since:5},{signature:"IEnumerator<RhinoView> GetEnumerator()",since:5},{signature:"RhinoPageView[] GetPageViews()",summary:"Gets all page views in the document.",since:5,returns:"An array with all page views. The return value can be an empty array but not null."},{signature:"RhinoView[] GetStandardRhinoViews()",since:5},{signature:"RhinoView[] GetViewList(bool includeStandardViews,bool includePageViews)",summary:"Gets an array of all the views.",since:5,returns:"A array of Rhino views. This array can be emptry, but not null."},{signature:"bool IsCameraIconVisible(RhinoView view)",summary:"Determine if a camera icon is being shown",since:6},{signature:"void Redraw()",summary:"Redraws all views.",since:5},{signature:"void ThreeViewLayout(bool useMatchingViews)",since:5}]},{name:"Rhino.DocObjects.TextDisplayAlignment",dataType:3,summary:"Defines enumerated values for the line alignment of text."},{name:"Rhino.DocObjects.TextDotObject",dataType:1,summary:"Represents a text dot that is a document."},{name:"Rhino.DocObjects.TextObject",dataType:1,summary:"Rhino Object that represents text geometry and attributes",properties:[{signature:"TextEntity TextGeometry",summary:"Get the text geometry for this object.",since:5}]},{name:"Rhino.DocObjects.Texture",dataType:1,summary:"Represents a texture that is mapped on objects.",constructors:[{signature:"Texture()",summary:"Initializes a new texture.",since:5}],properties:[{signature:"bool ApplyUvwTransform",summary:"If True then the UVW transform is applied to the texture\n     otherwise the UVW transform is ignored.",since:5.6},{signature:"bool Enabled",summary:"If the texture is enabled then it will be visible in the rendered\n     display otherwise it will not.",since:5},{signature:"string FileName",summary:"Gets or sets a file name that is used by this texture.\n     NOTE: We are moving away from string-based FileName, and suggest\n     the usage of the new FileReference class.Also, this filename may well not be a path that makes sense\n     on a user's computer because it was a path initially set on\n     a different user's computer. If you want to get a workable path\n     for this user, use the BitmapTable.Find function using this\n     property.",since:5},{signature:"FileReference FileReference",summary:"Gets or sets a copy of the file reference that is used by this texture.\n     After the get or the set method complete,\n     you own the copy you received or passed in, and can Dispose() of it.",since:6},{signature:"Guid Id",summary:"Gets the globally unique identifier of this texture.",since:5},{signature:"int MappingChannelId",since:5.1},{signature:"TextureCombineMode TextureCombineMode",summary:"Determines how this texture is combined with others in a material's\n     texture list.",since:5.6},{signature:"TextureType TextureType",summary:"Controls how the pixels in the bitmap are interpreted",since:5.6},{signature:"Transform UvwTransform",summary:"Transform to be applied to each instance of this texture\n     if ApplyUvw is true",since:5.6},{signature:"TextureUvwWrapping WrapU",summary:"Texture wrapping mode in the U direction",since:5.6},{signature:"TextureUvwWrapping WrapV",summary:"Texture wrapping mode in the V direction",since:5.6},{signature:"TextureUvwWrapping WrapW",summary:"Texture wrapping mode in the W direction",since:5.6}],methods:[{signature:"void GetAlphaBlendValues(double constant,double a0,double a1,double a2,double a3)",summary:"If the TextureCombineMode is Blend, then the blending function\n     for alpha is determined by\n     \n     new alpha = constant\n                 + a0*(current alpha)\n                 + a1*(texture alpha)\n                 + a2*min(current alpha,texture alpha)\n                 + a3*max(current alpha,texture alpha)",since:5.6},{signature:"void SetAlphaBlendValues(double constant,double a0,double a1,double a2,double a3)",summary:"If the TextureCombineMode is Blend, then the blending function\n     for alpha is determined by\n     \n     new alpha = constant\n                 + a0*(current alpha)\n                 + a1*(texture alpha)\n                 + a2*min(current alpha,texture alpha)\n                 + a3*max(current alpha,texture alpha)",since:5.6},{signature:"void SetRGBBlendValues(Color color,double a0,double a1,double a2,double a3)",summary:"If the TextureCombineMode is Blend, then the blending function\n     for RGB is determined by\n     \n     new rgb = colorcolor\n             + a0[0]*(current RGB)\n             + a1[1]*(texture RGB)\n             + a2[2]*min(current RGB,texture RGB)\n             + a3[3]*max(current RGB,texture RGB)",since:6}]},{name:"Rhino.DocObjects.TextureCombineMode",dataType:3,summary:"Determines how this texture is combined with others in a material's\n   texture list."},{name:"Rhino.DocObjects.TextureType",dataType:3,summary:"The TextureType controls how the pixels in the bitmap\n   are interpreted."},{name:"Rhino.DocObjects.TextureUvwWrapping",dataType:3,summary:"Defines Texture UVW wrapping modes"},{name:"Rhino.DocObjects.ViewInfo",dataType:1,summary:"Represents the name and orientation of a View (and named view).\n   views can be thought of as cameras.",constructors:[{signature:"ViewInfo(RhinoViewport rhinoViewPort)",summary:"Access to the ViewInfo for given RhinoViewport",since:6},{signature:"ViewInfo(uint docRuntimeSerialNumber)",summary:"Construct the ViewInfo for active viewport of given doc.",since:6}],properties:[{signature:"double FocalBlurAperture",summary:"Gets or sets the Focal blur aperture of the active viewport",since:6},{signature:"double FocalBlurDistance",summary:"Gets or sets the Focal blur distance of the active viewport",since:6},{signature:"double FocalBlurJitter",summary:"Gets or sets the Focal blur jitter of the active viewport",since:6},{signature:"ViewInfoFocalBlurModes FocalBlurMode",summary:"Gets or sets the Focal blur mode of the active viewport",since:6},{signature:"uint FocalBlurSampleCount",summary:"Gets or sets the Focal blur sample count of the active viewport",since:6},{signature:"string Name",summary:"Gets or sets the name of the view.",since:5},{signature:"bool ShowWallpaperInGrayScale",summary:"True if wallpaper (if any) is to be shown in gray scale in this view.",since:6},{signature:"ViewportInfo Viewport",summary:"Gets the viewport, or viewing frustum, associated with this view.",since:5},{signature:"string WallpaperFilename",summary:"Get filename for wallpaper set to this view, if any.",since:6},{signature:"bool WallpaperHidden",summary:"True if wallpaper (if any) is to be hidden from this view.",since:6}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5}]},{name:"Rhino.DocObjects.ViewInfoFocalBlurModes",dataType:3,summary:"The different focal blur modes of the ViewInfo"},{name:"Rhino.DocObjects.ViewportInfo",dataType:1,summary:"Represents a viewing frustum.",constructors:[{signature:"ViewportInfo()",summary:"Initializes a new instance.",since:5},{signature:"ViewportInfo(RhinoViewport rhinoViewport)",summary:"Copies all of the ViewportInfo data from an existing RhinoViewport.",since:5},{signature:"ViewportInfo(ViewportInfo other)",summary:"Initializes a new instance by copying values from another instance.",since:5}],properties:[{signature:"static Vector3d DefaultCameraDirection",summary:"Default z=up perspective camera direction",since:6},{signature:"double Camera35mmLensLength",summary:"This property assumes the camera is horizontal and crop the\n     film rather than the image when the aspect of the frustum\n     is not 36/24.  (35mm film is 36mm wide and 24mm high.)\n     Setting preserves camera location,\n     changes the frustum, but maintains the frustum's aspect.",since:5},{signature:"double CameraAngle",summary:"Gets or sets the 1/2 smallest angle. See  for more information.",since:5},{signature:"Vector3d CameraDirection",summary:"Gets the direction that the camera faces.",since:5},{signature:"Point3d CameraLocation",summary:"Gets the camera location (position) point.",since:5},{signature:"Vector3d CameraUp",summary:"Gets the camera up vector.",since:5},{signature:"Vector3d CameraX",summary:'Gets the unit "to the right" vector.',since:5},{signature:"Vector3d CameraY",summary:'Gets the unit "up" vector.',since:5},{signature:"Vector3d CameraZ",summary:"Gets the unit vector in -CameraDirection.",since:5},{signature:"double FrustumAspect",summary:"Setting FrustumAspect changes the larger of the frustum's width/height\n     so that the resulting value of width/height matches the requested\n     aspect.  The camera angle is not changed.  If you change the shape\n     of the view port with a call SetScreenPort(), then you generally \n     want to call SetFrustumAspect() with the value returned by \n     GetScreenPortAspect().",since:5},{signature:"double FrustumBottom",summary:"Gets the frustum bottom value. This is -top if the frustum has a horizontal symmetry axis.\n     This number is usually negative.",since:5},{signature:"Plane FrustumBottomPlane",summary:"Gets the frustum bottom plane that separates visibile from off-screen.",since:5},{signature:"Point3d FrustumCenter",summary:"Gets the frustum center point.",since:5},{signature:"double FrustumFar",summary:"Gets the frustum far-cutting value.",since:5},{signature:"Plane FrustumFarPlane",summary:"Gets far clipping plane if camera and frustum\n     are valid.  The plane's frame is the same as the camera's\n     frame.  The origin is located at the intersection of the\n     camera direction ray and the far clipping plane. The plane's\n     normal points into the frustum towards the camera location.",since:5},{signature:"double FrustumHeight",summary:"Gets the frustum height. This is  - .",since:5},{signature:"double FrustumLeft",summary:"Gets the frustum left value. This is -right if the frustum has a vertical symmetry axis.\n     This number is usually negative.",since:5},{signature:"Plane FrustumLeftPlane",summary:"Gets the frustum left plane that separates visibile from off-screen.",since:5},{signature:"double FrustumMaximumDiameter",summary:"Gets the frustum maximum diameter, or the maximum between  and .",since:5},{signature:"double FrustumMinimumDiameter",summary:"Gets the frustum minimum diameter, or the minimum between  and .",since:5},{signature:"double FrustumNear",summary:"Gets the frustum near-cutting value.",since:5},{signature:"Plane FrustumNearPlane",summary:"Gets near clipping plane if camera and frustum\n     are valid.  The plane's frame is the same as the camera's\n     frame.  The origin is located at the intersection of the\n     camera direction ray and the near clipping plane. The plane's\n     normal points out of the frustum towards the camera\n     location.",since:5},{signature:"double FrustumRight",summary:"Gets the frustum right value. This is -left if the frustum has a vertical symmetry axis.\n     This number is usually positive.",since:5},{signature:"Plane FrustumRightPlane",summary:"Gets the frustum right plane that separates visibile from off-screen.",since:5},{signature:"double FrustumTop",summary:"Gets the frustum top value. This is -bottom if the frustum has a horizontal symmetry axis.\n     This number is usually positive.",since:5},{signature:"Plane FrustumTopPlane",summary:"Gets the frustum top plane that separates visibile from off-screen.",since:5},{signature:"double FrustumWidth",summary:"Gets the frustum width. This is  - .",since:5},{signature:"Guid Id",summary:"Sets the viewport's id to the value used to \n     uniquely identify this viewport.\n     There is no approved way to change the viewport \n     id once it is set in order to maintain consistency\n     across multiple viewports and those routines that \n     manage them.",since:5},{signature:"bool IsCameraDirectionLocked",summary:"Gets or sets a value that indicates whether the direction that the camera faces is unmodifiable.",since:5},{signature:"bool IsCameraLocationLocked",summary:"Gets or sets a value that indicates whether the camera location is unmodifiable.",since:5},{signature:"bool IsCameraUpLocked",summary:"Gets or sets a value that indicates whether the camera up vector is unmodifiable.",since:5},{signature:"bool IsFrustumLeftRightSymmetric",summary:"Gets or sets a value that indicates whether the camera frustum has a vertical symmetry axis.",since:5},{signature:"bool IsFrustumTopBottomSymmetric",summary:"Gets or sets a value that indicates whether the camera frustum has a horizontal symmetry axis.",since:5},{signature:"bool IsParallelProjection",summary:"Get or set whether this projection is parallel.",since:5},{signature:"bool IsPerspectiveProjection",summary:"Get or set whether this projection is perspective.",since:5},{signature:"bool IsTwoPointPerspectiveProjection",summary:"Gets a value that indicates whether this projection is a two-point perspective.",since:5},{signature:"bool IsValidCamera",summary:"Gets a value that indicates whether the camera is valid.",since:5},{signature:"bool IsValidFrustum",summary:"Gets a value that indicates whether the frustum is valid.",since:5},{signature:"double PerspectiveMinNearDist",summary:"Expert user function to control the minimum\n     value of near when perspective projections\n     are being used.",since:7},{signature:"double PerspectiveMinNearOverFar",summary:"Expert user function to control the minimum\n     ratio of near/far when perspective projections\n     are begin used.",since:7},{signature:"Rectangle ScreenPort",summary:"Get or set the screen port.  and",since:6},{signature:"double ScreenPortAspect",summary:"Gets the sceen aspect ratio.\n     This is width / height.",since:5},{signature:"Point3d TargetPoint",summary:"The current value of the target point.  This point does not play\n     a role in the view projection calculations.  It can be used as a \n     fixed point when changing the camera so the visible regions of the\n     before and after frustums both contain the region of interest.\n     The default constructor sets this point on ON_3dPoint::UnsetPoint.\n     You must explicitly call one SetTargetPoint() functions to set\n     the target point.",since:5},{signature:"SizeF ViewScale",summary:"Applies scaling factors to parallel projection clipping coordinates\n     by setting the m_clip_mod transformation. \n     If you want to compress the view projection across the viewing\n     plane, then set x = 0.5, y = 1.0, and z = 1.0.",since:5}],methods:[{signature:"static double CalculateCameraRotationAngle(Vector3d direction,Vector3d up)",summary:"Calculates the camera rotation angle.",since:6.8,returns:"The camera rotation angle in radians."},{signature:"static Vector3d CalculateCameraUpDirection(Point3d location,Vector3d direction,double angle)",summary:"Calculates the camera up direction.",since:6.8,returns:"The camera up direction."},{signature:"bool ChangeToParallelProjection(bool symmetricFrustum)",summary:"Use this function to change projections of valid viewports\n     from parallel to perspective.  It will make common additional\n     adjustments to the frustum and camera location so the resulting\n     views are similar.  The camera direction and target point are\n     not be changed.\n     If the current projection is parallel and symmetricFrustum,\n     FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric()\n     are all equal, then no changes are made and True is returned.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool ChangeToPerspectiveProjection(double targetDistance,bool symmetricFrustum,double lensLength)",summary:"Use this function to change projections of valid viewports\n     from parallel to perspective.  It will make common additional\n     adjustments to the frustum and camera location so the resulting\n     views are similar.  The camera direction and target point are\n     not changed.\n     If the current projection is perspective and symmetricFrustum,\n     IsFrustumIsLeftRightSymmetric, and IsFrustumIsTopBottomSymmetric\n     are all equal, then no changes are made and True is returned.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool ChangeToSymmetricFrustum(bool isLeftRightSymmetric,bool isTopBottomSymmetric,double targetDistance)",summary:"If needed, adjusts the current frustum so it has the \n     specified symmetries and adjust the camera location\n     so the target plane remains visible.",since:5,returns:"Returns True if the viewport has now a frustum with the specified symmetries."},{signature:"bool ChangeToTwoPointPerspectiveProjection(double targetDistance,Vector3d up,double lensLength)",summary:"Changes projections of valid viewports\n     to a two point perspective.  It will make common additional\n     adjustments to the frustum and camera location and direction\n     so the resulting views are similar.\n     If the current projection is perspective and\n     IsFrustumIsLeftRightSymmetric is True and\n     IsFrustumIsTopBottomSymmetric is false, then no changes are\n     made and True is returned.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool DollyCamera(Vector3d dollyVector)",summary:"DollyCamera() does not update the frustum's clipping planes.\n     To update the frustum's clipping planes call DollyFrustum(d)\n     with d = dollyVector o cameraFrameZ.  To convert screen locations\n     into a dolly vector, use GetDollyCameraVector().\n     Does not update frustum.  To update frustum use DollyFrustum(d) with d = dollyVector o cameraFrameZ.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool DollyExtents(BoundingBox cameraCoordinateBoundingBox,double border)",summary:"Dolly the camera location and so that the view frustum contains\n     all of the document objects that can be seen in view.\n     If the projection is perspective, the camera angle is not changed.",since:5.6,returns:"True if successful."},{signature:"bool DollyExtents(IEnumerable<GeometryBase> geometry,double border)",summary:"Dolly the camera location and so that the view frustum contains\n     all of the document objects that can be seen in view.\n     If the projection is perspective, the camera angle is not changed.",since:5.6,returns:"True if successful."},{signature:"bool DollyFrustum(double dollyDistance)",summary:"Moves the frustum clipping planes.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool Extents(double halfViewAngleRadians,BoundingBox bbox)",summary:"Extends this viewport view to include a bounding box.\n     Use Extents() as a quick way to set a viewport to so that bounding\n     volume is inside of a viewports frustrum.\n     The view angle is used to determine the position of the camera.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool Extents(double halfViewAngleRadians,Sphere sphere)",summary:"Extends this viewport view to include a sphere.\n     Use Extents() as a quick way to set a viewport to so that bounding\n     volume is inside of a viewports frustrum.\n     The view angle is used to determine the position of the camera.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"Point3d FrustumCenterPoint(double targetDistance)",summary:"Return a point on the central axis of the view frustum.\n     This point is a good choice for a general purpose target point.",since:5,returns:"A point on the frustum's central axis.  If the viewport or input\n     is not valid, then ON_3dPoint::UnsetPoint is returned."},{signature:"bool GetBoundingBoxDepth(BoundingBox bbox,double nearDistance,double farDistance)",summary:"Gets near and far clipping distances of a bounding box.\n     This function ignores the current value of the viewport's \n     near and far settings. If the viewport is a perspective\n     projection, the it intersects the semi infinite frustum\n     volume with the bounding box and returns the near and far\n     distances of the intersection.  If the viewport is a parallel\n     projection, it instersects the infinte view region with the\n     bounding box and returns the near and far distances of the\n     projection.",since:5,returns:"True if the bounding box intersects the view frustum and near_dist/far_dist were set. \n     False if the bounding box does not intesect the view frustum."},{signature:"bool GetCameraAngles(double halfDiagonalAngleRadians,double halfVerticalAngleRadians,double halfHorizontalAngleRadians)",summary:"Gets the field of view angles.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool GetCameraFrame(Point3d location,Vector3d cameraX,Vector3d cameraY,Vector3d cameraZ)",summary:"Gets location and vectors of this camera.",since:5,returns:"True if current camera orientation is valid; otherwise false."},{signature:"Vector3d GetDollyCameraVector(int screenX0,int screenY0,int screenX1,int screenY1,double projectionPlaneDistance)",summary:"Gets a world coordinate dolly vector that can be passed to DollyCamera().",since:5,returns:"The world coordinate dolly vector."},{signature:"Vector3d GetDollyCameraVector(Point screen0,Point screen1,double projectionPlaneDistance)",summary:"Gets a world coordinate dolly vector that can be passed to DollyCamera().",since:5,returns:"The world coordinate dolly vector."},{signature:"Point3d[] GetFarPlaneCorners()",summary:"Gets the corners of far clipping plane rectangle.\n     4 points are returned in the order of bottom left, bottom right,\n     top left, top right.",since:5,returns:"Four corner points on success.\n     Empty array if viewport is not valid."},{signature:"bool GetFrustum(double left,double right,double bottom,double top,double nearDistance,double farDistance)",summary:"Gets the view frustum.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"Line GetFrustumLine(double screenX,double screenY)",summary:"Gets the world coordinate line in the view frustum\n     that projects to a point on the screen.",since:5.1,returns:"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."},{signature:"Line GetFrustumLine(Point screenPoint)",summary:"Gets the world coordinate line in the view frustum\n     that projects to a point on the screen.",since:5.1,returns:"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."},{signature:"Line GetFrustumLine(PointF screenPoint)",summary:"Gets the world coordinate line in the view frustum\n     that projects to a point on the screen.",since:5.1,returns:"3d world coordinate line segment starting on the near clipping plane and ending on the far clipping plane."},{signature:"Point3d[] GetNearPlaneCorners()",summary:"Gets the corners of near clipping plane rectangle.\n     4 points are returned in the order of bottom left, bottom right,\n     top left, top right.",since:5,returns:"Four corner points on success.\n     Empty array if viewport is not valid."},{signature:"bool GetPointDepth(Point3d point,double distance)",summary:"Gets the clipping distance of a point. This function ignores the\n     current value of the viewport's near and far settings. If\n     the viewport is a perspective projection, then it intersects\n     the semi infinite frustum volume with the bounding box and\n     returns the near and far distances of the intersection.\n     If the viewport is a parallel projection, it instersects the\n     infinte view region with the bounding box and returns the\n     near and far distances of the projection.",since:5,returns:"True if the bounding box intersects the view frustum and\n     near_dist/far_dist were set.\n     False if the bounding box does not intesect the view frustum."},{signature:"System.Drawing.Rectangle GetScreenPort()",summary:"Gets the location of viewport in pixels.\n     See documentation for SetScreenPort.",since:5,returns:"The rectangle, or Empty rectangle on error."},{signature:"System.Drawing.Rectangle GetScreenPort(int near,int far)",summary:"Gets the location of viewport in pixels.\n     See value meanings in SetScreenPort.",since:5,returns:"The rectangle, or Empty rectangle on error."},{signature:"void GetScreenPortLocation(int left,int top,int right,int bottom)",summary:"Get the location of viewport in pixels (non System.Drawing version of GetScreenPort)",since:6},{signature:"bool GetSphereDepth(Sphere sphere,double nearDistance,double farDistance)",summary:"Gets near and far clipping distances of a bounding sphere.",since:5,returns:"True if the sphere intersects the view frustum and near_dist/far_dist were set.\n     False if the sphere does not intesect the view frustum."},{signature:"double GetWorldToScreenScale(Point3d pointInFrustum)",summary:"Gets the scale factor from point in frustum to screen scale.",since:5.1,returns:"number of pixels per world unit at the 3d point."},{signature:"Transform GetXform(CoordinateSystem sourceSystem,CoordinateSystem destinationSystem)",summary:"Computes a transform from a coordinate system to another.",since:5,returns:"The 4x4 transformation matrix (acts on the left)."},{signature:"bool RotateCamera(double rotationAngleRadians,Vector3d rotationAxis,Point3d rotationCenter)",summary:"Rotates the view camera.",since:7,returns:"True if rotation is successful, False otherwise."},{signature:"bool SetCameraDirection(Vector3d direction)",summary:"Sets the direction that the camera faces.",since:5,returns:"True if the direction was set; otherwise false."},{signature:"bool SetCameraLocation(Point3d location)",summary:"Sets the camera location (position) point.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool SetCameraUp(Vector3d up)",summary:"Sets the camera up vector.",since:5,returns:"True if the direction was set; otherwise false."},{signature:"bool SetFrustum(double left,double right,double bottom,double top,double nearDistance,double farDistance)",summary:"Sets the view frustum. If FrustumSymmetryIsLocked() is true\n     and left != -right or bottom != -top, then they will be\n     adjusted so the resulting frustum is symmetric.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"bool SetFrustumNearFar(BoundingBox boundingBox)",summary:"Sets the frustum near and far using a bounding box.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"bool SetFrustumNearFar(double nearDistance,double farDistance)",summary:"Sets the frustum near and far distances using two values.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"bool SetFrustumNearFar(double nearDistance,double farDistance,double minNearDistance,double minNearOverFar,double targetDistance)",summary:"Sets near and far clipping distance subject to constraints.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"bool SetFrustumNearFar(Point3d center,double radius)",summary:"Sets the frustum near and far using a center point and radius.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"bool SetScreenPort(int left,int right,int bottom,int top,int near,int far)",summary:"Location of viewport in pixels.\n     These are provided so you can set the port you are using\n     and get the appropriate transformations to and from\n     screen space.\n     // For a Windows window\n     /      int width = width of window client area in pixels;\n     /      int height = height of window client area in pixels;\n     /      port_left = 0;\n     /      port_right = width;\n     /      port_top = 0;\n     /      port_bottom = height;\n     /      port_near = 0;\n     /      port_far = 1;\n     /      SetScreenPort( port_left, port_right, \n     /                     port_bottom, port_top, \n     /                     port_near, port_far );",since:5,returns:"True if input is valid."},{signature:"bool SetScreenPort(Rectangle windowRectangle)",summary:"Gets the location of viewport in pixels.\n     See value meanings in SetScreenPort.",since:5,returns:"True if input is valid."},{signature:"bool SetScreenPort(Rectangle windowRectangle,int near,int far)",summary:"Gets the location of viewport in pixels.\n     See value meanings in SetScreenPort.",since:5,returns:"True if input is valid."},{signature:"double TargetDistance(bool useFrustumCenterFallback)",summary:"Gets the distance from the target point to the camera plane.\n     Note that if the frustum is not symmetric, then this distance\n     is shorter than the distance from the target to the camera location.",since:5,returns:"Shortest signed distance from camera plane to target point.\n     If the target point is on the visible side of the camera,\n     a positive value is returned.  ON_UNSET_VALUE is returned\n     when the input of view is not valid."},{signature:"bool TransformCamera(Transform xform)",summary:"Transforms the view camera location, direction, and up.",since:7,returns:"True if a valid camera was transformed, False if\n     invalid camera, frustum, or transformation."},{signature:"void UnlockCamera()",summary:"Unlocks the camera vectors and location.",since:5},{signature:"void UnlockFrustumSymmetry()",summary:"Unlocks frustum horizontal and vertical symmetries.",since:5},{signature:"bool ZoomToScreenRect(int left,int top,int right,int bottom)",summary:"Zooms to a screen zone.\n     View changing from screen input points. Handy for\n     using a mouse to manipulate a view.\n     ZoomToScreenRect() may change camera and frustum settings.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool ZoomToScreenRect(Rectangle windowRectangle)",summary:"Zooms to a screen zone.\n     View changing from screen input points. Handy for\n     using a mouse to manipulate a view.\n     ZoomToScreenRect() may change camera and frustum settings.",since:5,returns:"True if the operation succeeded; otherwise, false."}]},{name:"Rhino.DocObjects.Worksession",dataType:1,summary:"Manages a list of models that are being used as reference geometry.",properties:[{signature:"RhinoDoc Document",summary:"Gets the document that owns this worksession.",since:6},{signature:"string FileName",summary:"Returns the path to the open worksession, or .rws, file. \n     If there is no worksession file open, or the active worksession\n     has not yet been saved, then None is returned.",since:6},{signature:"int ModelCount",summary:"Returns the number of models in the worksession. The active model will included\n     in this count whether or not it has been saved.",since:6},{signature:"string[] ModelPaths",summary:"Returns the paths to the models used by the worksession. If the active model has\n     not been saved, then it will not be included in the output array.",since:6},{signature:"uint RuntimeSerialNumber",summary:"Unique serial number for the worksession while the application is running.\n     This is not a persistent value.",since:6.3}],methods:[{signature:"static string FileNameFromRuntimeSerialNumber(uint runtimeSerialNumber)",summary:"Returns the path to the open worksession, or .rws, file. \n     If there is no worksession file open, or the active worksession\n     has not yet been saved, then None is returned.",since:6.3},{signature:"string ModelPathFromSerialNumber(uint modelSerialNumber)",summary:"Returns the path to a model, used by the worksession, given a reference model serial number",since:6.12,returns:"The path to the model if successful, None otherwise."}]},{name:"Rhino.DocumentEventArgs",dataType:1,summary:"Provides document information for RhinoDoc events.",properties:[{signature:"RhinoDoc Document",summary:"Gets the document for this event. This field might be null.",since:5},{signature:"int DocumentId",summary:"Gets the document Id of the document for this event.",since:5},{signature:"uint DocumentSerialNumber",summary:"Gets the uniques document serial number for this event",since:6}]},{name:"Rhino.DocumentOpenEventArgs",dataType:1,summary:"Provides document information for RhinoDoc events.",properties:[{signature:"string FileName",summary:"Name of file being opened.",since:5},{signature:"bool Merge",summary:'True if file is being merged into the current document. This\n     occurs during the "Import" command.',since:5},{signature:"bool Reference",summary:"True if file is opened as a reference file.",since:5}]},{name:"Rhino.DocumentSaveEventArgs",dataType:1,summary:"Provides document information for RhinoDoc events.",properties:[{signature:"bool ExportSelected",summary:"True if only selected objects are being written to a file.",since:5},{signature:"string FileName",summary:"Name of file being written.",since:5}]},{name:"Rhino.FileIO.BinaryArchiveException",dataType:1,summary:"Thrown by BinaryArchiveReader and BinaryArchiveWriter classes when\n   an IO error has occured.",constructors:[{signature:"BinaryArchiveException(string message)",summary:"Initializes a new instance of the  class.",since:5}]},{name:"Rhino.FileIO.BinaryArchiveFile",dataType:1,summary:"",constructors:[{signature:"BinaryArchiveFile(string filename,BinaryArchiveMode mode)",since:5.1}],properties:[{signature:"BinaryArchiveReader Reader",since:5.1},{signature:"BinaryArchiveWriter Writer",since:5.1}],methods:[{signature:"void Close()",since:5.1},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.1},{signature:"bool Open()",since:5.1}]},{name:"Rhino.FileIO.BinaryArchiveMode",dataType:3,summary:""},{name:"Rhino.FileIO.BinaryArchiveReader",dataType:1,summary:"Represents an entity that is capable of reading a binary archive and\n   instantiating strongly-typed objects.",properties:[{signature:"int Archive3dmVersion",summary:"If a 3dm archive is being read or written, then this is the\n     version of the 3dm archive format (1, 2, 3, 4 or 5).\n     0     a 3dm archive is not being read/written\n     1     a version 1 3dm archive is being read/written\n     2     a version 2 3dm archive is being read/written\n     3     a version 3 3dm archive is being read/written\n     4     a version 4 3dm archive is being read/written\n     5     an old version 5 3dm archive is being read\n     50    a version 5 3dm archive is being read/written.",since:5},{signature:"ulong CurrentPosition",summary:"current offset (in bytes) into archive ( like ftell() )",since:6},{signature:"bool ReadErrorOccured",summary:"Gets or sets whether en error occurred during reading.",since:5}],methods:[{signature:"bool AtEnd()",summary:"True if at end of a file",since:5.1},{signature:"bool BeginRead3dmChunk(uint expectedTypeCode,int majorVersion,int minorVersion)",summary:"Begins reading a chunk that must be in the archive at this location.",since:6,returns:"True if beginning of the chunk was read.  In this case you must call EndRead3dmChunk(),\n     even if something goes wrong while you attempt to read the interior of the chunk.\n     False if the chunk did not exist at the current location in the file."},{signature:"bool BeginRead3dmChunk(uint typeCode,long value)",summary:"Begins reading a chunk that must be in the archive at this location."},{signature:"uint Dump3dmChunk(TextLog log)",summary:'Fnction for studying contents of a file.  The primary use is as an aid\n     to help dig through files that have been damaged (bad disks, transmission\n     errors, etc.) If an error is found, a line that begins with the word\n     "ERROR" is printed.',since:5.1,returns:"0 if something went wrong, otherwise the typecode of the chunk that\n     was just studied."},{signature:"bool EnableCRCCalculation(bool enable)",summary:"Expert user function to control CRC calculation while reading and writing.\n     Typically this is used when seeking around and reading/writing information\n     in non-serial order.",since:6,returns:"Current state of CRC calculation.  Use the returned value to restore the\n     CRC calculation setting after you are finished doing your fancy pants\n     expert IO."},{signature:"bool EndRead3dmChunk(bool suppressPartiallyReadChunkWarning)",summary:"Calling this will skip rest of stuff in chunk if it was only partially read.",since:6},{signature:"void Read3dmChunkVersion(int major,int minor)",summary:"A chunk version is a single byte that encodes a major.minor\n     version number.  Useful when creating I/O code for 3dm chunks\n     that may change in the future.  Increment the minor version \n     number if new information is added to the end of the chunk. \n     Increment the major version if the format of the chunk changes\n     in some other way.",since:5,returns:"True on successful read."},{signature:"bool Read3dmStartSection(int version,string comment)",since:5.1,returns:"True on success"},{signature:"bool ReadBool()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"bool[] ReadBoolArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"Geometry.BoundingBox ReadBoundingBox()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"byte ReadByte()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"byte[] ReadByteArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"void ReadCheckSum()",summary:"Reads a legacy ON_CheckSum, only provided to read data chunks from old\n     V5 files, the CheckSum read is discarded",since:6},{signature:"System.Drawing.Color ReadColor()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"byte[] ReadCompressedBuffer()",summary:"Reads an array of compressed  information from the archive and uncompresses it.\n     An array is returned even if the input was another enumerable type.",since:5.9,returns:"The array that was read."},{signature:"Rhino.Collections.ArchivableDictionary ReadDictionary()",summary:"Reads a complete  from the archive.",since:5,returns:"The newly instantiated object."},{signature:"double ReadDouble()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"double[] ReadDoubleArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"System.Drawing.Font ReadFont()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.GeometryBase ReadGeometry()",summary:"Reads a -derived object from the archive.\n     The  class is abstract.",since:5,returns:"The element that was read."},{signature:"Geometry.GeometryBase[] ReadGeometryArray()",since:7},{signature:"Guid ReadGuid()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"Guid[] ReadGuidArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"int ReadInt()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"Int64 ReadInt64()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"int[] ReadIntArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"Geometry.Interval ReadInterval()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Line ReadLine()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.MeshingParameters ReadMeshingParameters()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"DocObjects.ObjRef ReadObjRef()",summary:"Reads a  from the archive",since:5.8,returns:"the element that was read"},{signature:"DocObjects.ObjRef[] ReadObjRefArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5.8,returns:"The array that was read."},{signature:"Geometry.Plane ReadPlane()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"System.Drawing.Point ReadPoint()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Point2d ReadPoint2d()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Point3d ReadPoint3d()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Point3f ReadPoint3f()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Point4d ReadPoint4d()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"System.Drawing.PointF ReadPointF()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Ray3d ReadRay3d()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"System.Drawing.Rectangle ReadRectangle()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"System.Drawing.RectangleF ReadRectangleF()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"RenderSettings ReadRenderSettings()",summary:"Reads a -derived object from the archive.",since:6,returns:"The element that was read."},{signature:"sbyte ReadSByte()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"sbyte[] ReadSByteArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"short ReadShort()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"short[] ReadShortArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"float ReadSingle()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"float[] ReadSingleArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"System.Drawing.Size ReadSize()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"System.Drawing.SizeF ReadSizeF()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"string ReadString()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"string[] ReadStringArray()",summary:"Reads an array of  from the archive.\n     An array is returned even if the input was another enumerable type.",since:5,returns:"The array that was read."},{signature:"Geometry.Transform ReadTransform()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"uint ReadUInt()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"ushort ReadUShort()",summary:"Reads a  from the archive.",since:5,returns:"The value that was read."},{signature:"string ReadUtf8String()",summary:"Reads a  from the archive.",since:6,returns:"The value that was read."},{signature:"Geometry.Vector2d ReadVector2d()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Vector3d ReadVector3d()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"Geometry.Vector3f ReadVector3f()",summary:"Reads a  from the archive.",since:5,returns:"The element that was read."},{signature:"bool SeekFromCurrentPosition(long byteOffset)",summary:"seek from current position ( like fseek( ,SEEK_CUR) )"},{signature:"bool SeekFromCurrentPosition(ulong byteOffset,bool forward)",summary:"seek from current position ( like fseek( ,SEEK_CUR) )"},{signature:"bool SeekFromStart(ulong byteOffset)",summary:"seek from start position ( like fseek( ,SEEK_SET) )"}]},{name:"Rhino.FileIO.BinaryArchiveWriter",dataType:1,summary:"Represents an entity that is able to write data to an archive.",properties:[{signature:"int Archive3dmVersion",summary:"If a 3dm archive is being read or written, then this is the\n     version of the 3dm archive format (1, 2, 3, 4 or 5).\n     0     a 3dm archive is not being read/written\n     1     a version 1 3dm archive is being read/written\n     2     a version 2 3dm archive is being read/written\n     3     a version 3 3dm archive is being read/written\n     4     a version 4 3dm archive is being read/written\n     5     an old version 5 3dm archive is being read\n     50    a version 5 3dm archive is being read/written.",since:5},{signature:"bool WriteErrorOccured",summary:"Gets or sets whether an error occurred.",since:5}],methods:[{signature:"bool BeginWrite3dmChunk(uint typecode,int majorVersion,int minorVersion)",summary:"Begins writing a chunk",since:6,returns:"True if input was valid and chunk was started.  In this case you must call\n     EndWrite3dmChunk(), even if something goes wrong while you attempt to write\n     the contents of the chunk.\n     False if input was not valid or the write failed."},{signature:"bool BeginWrite3dmChunk(uint typecode,long value)",summary:"Begins writing a chunk"},{signature:"bool EnableCRCCalculation(bool enable)",summary:"Expert user function to control CRC calculation while reading and writing.\n     Typically this is used when seeking around and reading/writing information\n     in non-serial order.",since:6,returns:"Current state of CRC calculation.  Use the returned value to restore the\n     CRC calculation setting after you are finished doing your fancy pants\n     expert IO."},{signature:"bool EndWrite3dmChunk()",summary:"updates length in chunk header",since:6},{signature:"void Write3dmChunkVersion(int major,int minor)",summary:"A chunk version is a single byte that encodes a major.minor\n     version number.  Useful when creating I/O code for 3dm chunks\n     that may change in the future.  Increment the minor version \n     number if new information is added to the end of the chunk. \n     Increment the major version if the format of the chunk changes\n     in some other way.",since:5,returns:"True on successful read."},{signature:"void WriteBool(bool value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteBoolArray(IEnumerable<bool> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteBoundingBox(BoundingBox value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteByte(byte value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteByteArray(IEnumerable<byte> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteColor(Color value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteCompressedBuffer(IEnumerable<byte> value)",summary:"Writes a list, an array, or any enumerable of  to the archive as a compressed buffer.\n     The return will always be an array.",since:5.9},{signature:"void WriteDictionary(ArchivableDictionary dictionary)",summary:"Delivers the complete content of a dictionary to the archive.",since:5},{signature:"void WriteDouble(double value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteDoubleArray(IEnumerable<double> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteEmptyCheckSum()",summary:"Reads a legacy ON_CheckSum, only provided to read data chunks from old\n     V5 files, the CheckSum read is discarded",since:6},{signature:"void WriteFont(Font value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteGeometry(GeometryBase value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteGeometryArray(IEnumerable<GeometryBase> geometry)",since:7},{signature:"void WriteGuid(Guid value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteGuidArray(IEnumerable<Guid> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteInt(int value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteInt64(Int64 value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteIntArray(IEnumerable<int> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteInterval(Interval value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteLine(Line value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteMeshingParameters(MeshingParameters value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteObjRef(ObjRef objref)",summary:"Writes a  to the archive",since:5.8,returns:"the element that was read"},{signature:"void WriteObjRefArray(IEnumerable<ObjRef> objrefs)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5.8},{signature:"void WritePlane(Plane value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WritePoint(Point value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WritePoint2d(Point2d value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WritePoint3d(Point3d value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WritePoint3f(Point3f value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WritePoint4d(Point4d value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WritePointF(PointF value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteRay3d(Ray3d value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteRectangle(Rectangle value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteRectangleF(RectangleF value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteRenderSettings(RenderSettings value)",summary:"Writes a  value to the archive.",since:6},{signature:"void WriteSByte(sbyte value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteSByteArray(IEnumerable<sbyte> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteShort(short value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteShortArray(IEnumerable<short> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteSingle(float value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteSingleArray(IEnumerable<float> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteSize(Size value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteSizeF(SizeF value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteString(string value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteStringArray(IEnumerable<string> value)",summary:"Writes a list, an array, or any enumerable of  to the archive.\n     The return will always be an array.",since:5},{signature:"void WriteTransform(Transform value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteUInt(uint value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteUShort(ushort value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteUtf8String(string value)",summary:"Writes a  value to the archive.",since:6},{signature:"void WriteVector2d(Vector2d value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteVector3d(Vector3d value)",summary:"Writes a  value to the archive.",since:5},{signature:"void WriteVector3f(Vector3f value)",summary:"Writes a  value to the archive.",since:5}]},{name:"Rhino.FileIO.CommonComponentTable",dataType:1,summary:"Provides a base table type that encompasses all document tables, both in RhinoDoc and File3dm.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns the actual component type of a table."},{signature:"int Count",summary:"Returns the count of all items, including deleted ones."}],methods:[{signature:"void Clear()",summary:"Marks all items as deleted."},{signature:"bool Delete(T item)",summary:"Deletes an item. Items that are deleted are still keeping their space, but the 'IsDeleted' flag is checked.",returns:"True if an items could be deleted (e.g., it was not locked)."},{signature:"T FindId(Guid id)",summary:"Uses the guid to find a model component. Deleted objects cannot be found by id.\n     The guid is the value that is stored in the .Id property.\n     In a single document, no two active objects have the same guid. If an object is\n     replaced with a new object, then the guid  persists. For example, if the _Move command\n     moves an object, then the moved object inherits its guid from the starting object.\n     If the Copy command copies an object, then the copy gets a new guid. This guid persists\n     through file saving/openning operations. This function will not find grip objects.",returns:"Reference to the rhino object with the objectId or None if no such object could be found."},{signature:"IEnumerator<T> GetEnumerator()",summary:"Returns the enumerator that yields all items."}]},{name:"Rhino.FileIO.ContentHash",dataType:1,summary:"Contains information that is useful to uniquly identify an object.\n   This object is immutable.",properties:[{signature:"ulong ByteCount",summary:"Gets the length of the content, in bytes.",since:6},{signature:"DateTime HashTime",summary:"Gets the hash time, rounded to seconds.",since:6},{signature:"byte[] Sha1ContentHash",summary:"Gets the 20-bytes long SHA1 hash of the content.",since:6},{signature:"byte[] Sha1NameHash",summary:"Gets the 20-bytes long SHA1 hash of the name.",since:6}],methods:[{signature:"static ContentHash CreateFromFile(string path)",summary:"Creates a new ContentHash, representing the content of a file.",since:6},{signature:"ContentHash Clone()",summary:"Creates a copy of this content hash.\n     Because content hash is immutable, this can be used as a deep copy.",since:6,returns:"A different instance of the same content hash."},{signature:"bool Equals(ContentHash other)",summary:"Determines if another content hash has the same value.",since:6,returns:"True if the two hashes are equal."},{signature:"bool Equals(object obj)",summary:"Determines if another object is a content hash with same value.",returns:"True if the two hashes are equal."},{signature:"int GetHashCode()",summary:"Gets an hash code for this content hash.\n     Two equal content hashes have equal hash code. The other way around might not be true.",returns:"An hash code value."}]},{name:"Rhino.FileIO.DracoCompression",dataType:1,summary:"Google draco compression for mesh and point cloud data",methods:[{signature:"static DracoCompression Compress(Mesh mesh)",summary:"Compress a mesh using default compression options.",since:7,returns:"instance of class representing the compressed data"},{signature:"static DracoCompression Compress(Mesh mesh,DracoCompressionOptions options)",summary:"Compress a mesh",since:7,returns:"instance of class representing the compressed data"},{signature:"static Rhino.Geometry.GeometryBase DecompressBase64String(string encoded)",summary:"Decompress base64 encoded version of draco data into either a mesh or point cloud",since:7,returns:"Mesh or point cloud on success. None on failure"},{signature:"static Rhino.Geometry.GeometryBase DecompressByteArray(byte[] bytes)",summary:"Decompress data into either a mesh or point cloud.",since:7,returns:"Mesh or point cloud on success. None on failure"},{signature:"static Rhino.Geometry.GeometryBase DecompressFile(string path)",summary:"Read compressed data from disk and decompress to RhinoCommon geometry",since:7,returns:"Mesh or point cloud on success. None on failure"},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"string ToBase64String()",summary:"Convert byte array of draco compressed data into a base64 encoded string",since:7},{signature:"bool Write(string path)",summary:"Write the compressed data to disk",since:7,returns:"True on success"}]},{name:"Rhino.FileIO.DracoCompressionOptions",dataType:1,summary:"Options for applying drac compression",constructors:[{signature:"DracoCompressionOptions()",summary:"Initializes to default options",since:7}],properties:[{signature:"int CompressionLevel",summary:"Compression level. 0 if fastest, but least compression. 10 is slowest, but best compression",since:7},{signature:"int NormalQuantizationBits",summary:"Sets the quantization compression options for normal values. The\n     values will be quantized in a box defined by the maximum extent\n     of the values. I.e., the actual precision of this option depends\n     on the scale of the attribute values.",since:7},{signature:"int PositionQuantizationBits",summary:"Sets the quantization compression options for position values. The\n     values will be quantized in a box defined by the maximum extent\n     of the values. I.e., the actual precision of this option depends\n     on the scale of the attribute values.",since:7},{signature:"int TextureCoordintateQuantizationBits",summary:"Sets the quantization compression options for texture coordinate\n     values. The values will be quantized in a box defined by the maximum\n     extent of the values. I.e., the actual precision of this option depends\n     on the scale of the attribute values.",since:7}]},{name:"Rhino.FileIO.File3dm",dataType:1,summary:"Represents a 3dm file, which is stored using the OpenNURBS file standard.\n   The 3dm format is the main Rhinoceros storage format.Visit http://www.opennurbs.com/ for more details.",constructors:[{signature:"File3dm()",summary:"Initializes a new instance of a 3dm file.",since:5}],properties:[{signature:"File3dmDimStyleTable AllDimStyles",summary:"Dimension Styles in this file.",since:6},{signature:"File3dmGroupTable AllGroups",summary:"Grpups in this file.",since:6.5},{signature:"File3dmHatchPatternTable AllHatchPatterns",summary:"Hatch patterns in this file.",since:6},{signature:"File3dmInstanceDefinitionTable AllInstanceDefinitions",summary:"Instance definitions in this file",since:6},{signature:"File3dmLayerTable AllLayers",summary:"Layers in this file.",since:6},{signature:"File3dmLinetypeTable AllLinetypes",summary:"Linetypes in this file.",since:6},{signature:"File3dmMaterialTable AllMaterials",summary:"Materials in this file.",since:6},{signature:"File3dmNamedConstructionPlanes AllNamedConstructionPlanes",summary:"Named construction planes in this file.",since:6},{signature:"File3dmViewTable AllNamedViews",summary:"Named views in this file.",since:6},{signature:"File3dmViewTable AllViews",summary:"Views that represent the RhinoViews which are displayed when Rhino loads this file.",since:6},{signature:"string ApplicationDetails",summary:"Gets or sets details for the application that wrote this file.",since:5},{signature:"string ApplicationName",summary:"Gets or sets the name of the application that wrote this file.",since:5},{signature:"string ApplicationUrl",summary:"Gets or sets a URL for the application that wrote this file.",since:5},{signature:"DateTime Created",summary:"Get the DateTime that this file was originally created. If the\n     value is not set in the 3dm file, then DateTime.MinValue is returned",since:5.6},{signature:"string CreatedBy",summary:"Gets a string that names the user who created the file.",since:5},{signature:"IList<DimensionStyle> DimStyles",summary:"Dimension Styles in this file.",since:5},{signature:"IList<HatchPattern> HatchPatterns",summary:"Hatch patterns in this file",since:5},{signature:"IList<InstanceDefinitionGeometry> InstanceDefinitions",summary:"Instance definitions in this file.",since:5.6},{signature:"DateTime LastEdited",summary:"Get the DateTime that this file was last edited. If the\n     value is not set in the 3dm file, then DateTime.MinValue is returned",since:5.6},{signature:"string LastEditedBy",summary:"Gets a string that names the user who last edited the file.",since:5},{signature:"IList<Layer> Layers",summary:"Layers in this file.",since:5},{signature:"IList<Linetype> Linetypes",summary:"Linetypes in this file.",since:5},{signature:"ManifestTable Manifest",summary:"Retrieves the manifest with all object descriptions in this file.",since:6},{signature:"IList<Material> Materials",summary:"Materials in this file.",since:5},{signature:"IList<ConstructionPlane> NamedConstructionPlanes",summary:"Named construction planes in this file.",since:6},{signature:"IList<ViewInfo> NamedViews",summary:"Named views in this file.",since:5},{signature:"File3dmNotes Notes",summary:"Gets or sets the model notes.",since:5},{signature:"File3dmObjectTable Objects",summary:"Gets access to the  class associated with this file,\n     which contains all objects.",since:5},{signature:"File3dmPlugInDataTable PlugInData",summary:"Custom plug-in data in this file.  This data is not attached to any geometry or attributes",since:5},{signature:"int Revision",summary:"Gets or sets the revision number.",since:5},{signature:"File3dmSettings Settings",summary:"Settings include tolerance, and unit system, and defaults used\n     for creating views and objects.",since:5},{signature:"string StartSectionComments",summary:"Gets or sets the start section comments, which are the comments with which the 3dm file begins.",since:5},{signature:"File3dmStringTable Strings",summary:"Document user strings in this file",since:6},{signature:"IList<ViewInfo> Views",summary:"Views that represent the RhinoViews which are displayed when Rhino loads this file.",since:5}],methods:[{signature:"static File3dm Read(string path)",summary:"Reads a 3dm file from a specified location.",since:5,returns:"new File3dm on success, None on error."},{signature:"static File3dm Read(string path,TableTypeFilter tableTypeFilterFilter,ObjectTypeFilter objectTypeFilter)",summary:"Reads a 3dm file from a specified location.",since:5.9,returns:"new File3dm on success, None on error."},{signature:"static void ReadApplicationData(string path,string applicationName,string applicationUrl,string applicationDetails)",summary:"Reads only the application information from an existing 3dm file.",since:5},{signature:"static int ReadArchiveVersion(string path)",summary:"Reads only the archive 3dm version from an existing 3dm file.",since:5.1,returns:"The 3dm file archive version."},{signature:"static DimensionStyle[] ReadDimensionStyles(string path)",summary:"Read the dimension styles table out of a 3dm file.",since:6,returns:"Array of dimension styles on success (empty array if file does not contain dimension styles)\n     None on error"},{signature:"static string ReadNotes(string path)",summary:"Reads only the notes from an existing 3dm file.",since:5,returns:"The 3dm file notes."},{signature:"static System.Drawing.Bitmap ReadPreviewImage(string path)",summary:"Attempts to read the preview image out of a 3dm file.",since:5,returns:"A bitmap, or None on failure."},{signature:"static bool ReadRevisionHistory(string path,string createdBy,string lastEditedBy,int revision,DateTime createdOn,DateTime lastEditedOn)",summary:"Quickly check a file for it's revision information.  This function does\n     not read the entire file, just what it needs to get revision information out",since:5.6,returns:"True on success"},{signature:"static File3dm ReadWithLog(string path,string errorLog)",summary:"Read a 3dm file from a specified location and log any archive\n     reading errors.",since:5,returns:"New File3dm on success, None on error."},{signature:"static File3dm ReadWithLog(string path,TableTypeFilter tableTypeFilterFilter,ObjectTypeFilter objectTypeFilter,string errorLog)",summary:"Reads a 3dm file from a specified location.",since:5.9,returns:"new File3dm on success, None on error."},{signature:"int Audit(bool attemptRepair,int repairCount,string errors,int[] warnings)",summary:"This function is only kept for forward assembly compatibility.",since:5,returns:"Returns 0."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"string Dump()",summary:"Prepares a text dump of the entire model.",since:5,returns:"The text dump."},{signature:"string DumpSummary()",summary:"Prepares a text dump of model properties and settings.",since:5,returns:"The text dump."},{signature:"void DumpToTextLog(TextLog log)",summary:"Prepares a text dump of the entire model.",since:5.1},{signature:"System.Drawing.Bitmap GetPreviewImage()",summary:"Preview image used for file explorer",since:6},{signature:"bool IsValid(string errors)",summary:"The File3dm object is kept consistent during its creation.\n     Therefore, this function now returns only true.",since:5,returns:"True in any case."},{signature:"bool IsValid(TextLog errors)",summary:"The File3dm object is kept consistent during its creation.\n     Therefore, this function now returns only true.",since:5.1,returns:">True in any case."},{signature:"void Polish()",summary:"This function is only kept for forward assembly compatibility.",since:5},{signature:"void SetPreviewImage(Bitmap image)",summary:"Preview image used for file explorer",since:6},{signature:"bool Write(string path,File3dmWriteOptions options)",summary:"Writes contents of this model to an openNURBS archive.\n     If the model is not valid, then Write will refuse to write it.",since:5.9,returns:"True if archive is written with no error.\n     False if errors occur."},{signature:"bool Write(string path,int version)",summary:"Writes contents of this model to an openNURBS archive.\n     If the model is not valid, then Write will refuse to write it.",since:5,returns:"True if archive is written with no error.\n     False if errors occur."},{signature:"bool WriteWithLog(string path,File3dmWriteOptions options,string errorLog)",summary:"Writes contents of this model to an openNURBS archive.\n     If the model is not valid, then Write will refuse to write it.",since:6,returns:"True if archive is written with no error.\n     False if errors occur."},{signature:"bool WriteWithLog(string path,int version,string errorLog)",summary:"Writes contents of this model to an openNURBS archive.\n     If the model is not valid, then Write will refuse to write it.",since:5,returns:"True if archive is written with no error.\n     False if errors occur."}]},{name:"Rhino.FileIO.File3dm.ObjectTypeFilter",dataType:3,summary:""},{name:"Rhino.FileIO.File3dm.TableTypeFilter",dataType:3,summary:""},{name:"Rhino.FileIO.File3dmCommonComponentTable",dataType:1,summary:"Provides a base table type that is shared among all File3dm tables.",methods:[{signature:"void Add(T item)",summary:"Adds an item."},{signature:"void Delete(int index)",summary:"Flags a component as deleted.",returns:"True on success."},{signature:"bool Delete(T item)",summary:"Flags a component as deleted.",returns:"True on success."},{signature:"string Dump()",summary:"Prepares a text dump of object table.",returns:"A string containing the dump."}]},{name:"Rhino.FileIO.File3dmDimStyleTable",dataType:1,summary:"Provides access to annotation styles in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"DimensionStyle FindIndex(int index)",summary:"Retrieves a DimensionStyle object based on Index. This search type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A DimensionStyle object, or None if none was found."},{signature:"DimensionStyle FindName(string name)",summary:"Finds a DimensionStyle given its name.",since:6,returns:"An DimensionStyle, or None on error."},{signature:"DimensionStyle FindNameHash(NameHash nameHash)",summary:"Finds a DimensionStyle given its name hash.",since:6,returns:"An DimensionStyle, or None on error."}]},{name:"Rhino.FileIO.File3dmGroupTable",dataType:1,summary:"Provides access to groups in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6.5}],methods:[{signature:"Group FindIndex(int groupIndex)",summary:"Retrieves a Group object based on an index. This search type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6.5,returns:"A Group object, or None if none was found."},{signature:"Group FindName(string name)",summary:"Finds a Group given its name.",since:6.5,returns:"A Group, or None on error."},{signature:"Group FindNameHash(NameHash nameHash)",summary:"Finds a Group given its name hash.",since:6.5,returns:"A Group, or None on error."},{signature:"File3dmObject[] GroupMembers(int groupIndex)",summary:"Gets an array of all of the objects in a group.",since:6.2,returns:"Array of objects that belong to the specified group or empty array if no objects could be found."}]},{name:"Rhino.FileIO.File3dmHatchPatternTable",dataType:1,summary:"Provides access to hatch pattern definitions in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"HatchPattern FindIndex(int index)",summary:"Retrieves a HatchPattern object based on Index. This search type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A HatchPattern object, or None if none was found."},{signature:"HatchPattern FindName(string name)",summary:"Finds a HatchPattern given its name.",since:6,returns:"An HatchPattern, or None on error."},{signature:"HatchPattern FindNameHash(NameHash nameHash)",summary:"Finds a HatchPattern given its name hash.",since:6,returns:"An HatchPattern, or None on error."}]},{name:"Rhino.FileIO.File3dmInstanceDefinitionTable",dataType:1,summary:"Provides access to instance (block) definitions in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"int Add(string name,string description,Point3d basePoint,GeometryBase geometry,ObjectAttributes attributes)",summary:"Adds an instance definition to the instance definition table.",since:6.5,returns:">=0  index of instance definition in the instance definition table. -1 on failure."},{signature:"int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry)",summary:"Adds an instance definition to the instance definition table.",since:6.5,returns:">=0  index of instance definition in the instance definition table. -1 on failure."},{signature:"int Add(string name,string description,Point3d basePoint,IEnumerable<GeometryBase> geometry,IEnumerable<ObjectAttributes> attributes)",summary:"Adds an instance definition to the instance definition table.",since:6.5,returns:">=0  index of instance definition in the instance definition table. -1 on failure."},{signature:"int AddLinked(string filename,string name,string description)",summary:"Adds a linked instance definition to the instance definition table.",since:6.13},{signature:"InstanceDefinitionGeometry FindName(string name)",summary:"Finds an InstanceDefinitionGeometry given its name.",since:6,returns:"An InstanceDefinitionGeometry, or None on error."},{signature:"InstanceDefinitionGeometry FindNameHash(NameHash nameHash)",summary:"Finds a InstanceDefinitionGeometry given its name hash.",since:6,returns:"An InstanceDefinitionGeometry, or None on error."}]},{name:"Rhino.FileIO.File3dmLayerTable",dataType:1,summary:"Provides access to layers in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"Layer FindIndex(int index)",summary:"Retrieves a Layer object based on Index. This search type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A Layer object, or None if none was found."},{signature:"Layer FindName(string name,Guid parentId)",summary:"Finds a Layer given its name.",since:6,returns:"A Layer, or None on error."},{signature:"Layer FindNameHash(NameHash nameHash)",summary:"Finds a Layer given its name hash.",since:6,returns:"An Layer, or None on error."}]},{name:"Rhino.FileIO.File3dmLinetypeTable",dataType:1,summary:"Provides access to Linetypes in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"Linetype FindIndex(int index)",summary:"Retrieves a Linetype object based on Index. This search type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A Linetype, or None if none was found."},{signature:"Linetype FindName(string name)",summary:"Finds a Linetype given its name.",since:6,returns:"A Linetype, or None on error."},{signature:"Linetype FindNameHash(NameHash nameHash)",summary:"Finds a Linetype given its name hash.",since:6,returns:"An Linetype, or None on error."}]},{name:"Rhino.FileIO.File3dmMaterialTable",dataType:1,summary:"Provides access to materials in the 3dm file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6}],methods:[{signature:"DocObjects.Material FindIndex(int index)",summary:"Retrieves a material based on Index. This search type of search is discouraged.\n     We are moving towards using only IDs for all tables.",since:6,returns:"A material, or None if none was found."}]},{name:"Rhino.FileIO.File3dmNamedConstructionPlanes",dataType:1,summary:"Provides access to namned construction planes in the 3dm file.",properties:[{signature:"int Count",summary:"Number of named construction planes in the table.",since:6}],methods:[{signature:"void Add(ConstructionPlane cplane)",summary:"Adds a named construction plane to the table.",since:6},{signature:"int Add(string name,Plane plane)",summary:"Adds a named construction plane to the table.",since:6,returns:"0 based index of the named construction plane.\n     -1 on failure."},{signature:"void Clear()",summary:"Removes all named construction planes from the table.",since:6},{signature:"bool Contains(ConstructionPlane cplane)",summary:"Returns an indication of the presence of a named construction plane in the table.",since:6,returns:"True if the named construction plane is in the table; False otherwise."},{signature:"void CopyTo(ConstructionPlane[] array,int arrayIndex)",summary:"Copies the content of the table to an array.",since:6},{signature:"bool Delete(ConstructionPlane cplane)",summary:"Deletes a named construction plane from the table.",since:6},{signature:"bool Delete(int index)",summary:"Remove a named construction plane from the table.",since:6,returns:"True if successful."},{signature:"ConstructionPlane FindName(string name)",summary:"Finds a named construction plane given its name.",since:6,returns:"A ConstructionPlane, or None if not found."},{signature:"IEnumerator<ConstructionPlane> GetEnumerator()",summary:"Gets an enumerator that yields all construction planes in this collection.",since:6,returns:"The enumerator."},{signature:"int IndexOf(ConstructionPlane cplane)",summary:"Returns the index of a named construction plane.",since:6,returns:"The index of the named construction plane, -1 if not found."}]},{name:"Rhino.FileIO.File3dmNotes",dataType:1,summary:"Represents the notes information stored in a 3dm file.",constructors:[{signature:"File3dmNotes()",summary:"Creates empty default notes",since:5}],properties:[{signature:"bool IsHtml",summary:"Gets or sets the text format. If the format is HTML, true; False otherwise.",since:5},{signature:"bool IsVisible",summary:"Gets or sets the notes visibility. If the notes are visible, true; False otherwise.",since:5},{signature:"string Notes",summary:"Gets or sets the text content of the notes.",since:5},{signature:"Rectangle WindowRectangle",summary:"Gets or sets the position of the Notes when they were saved.",since:5}]},{name:"Rhino.FileIO.File3dmObject",dataType:1,summary:"Used to store geometry table object definition and attributes in a File3dm.",properties:[{signature:"ObjectAttributes Attributes",summary:"Gets the attributes that are linked with this document object.",since:5},{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"GeometryBase Geometry",summary:"Gets the geometry that is linked with this document object.",since:5},{signature:"string Name",summary:"Gets or sets the Name of the object. Equivalent to this.Attributes.Name.",since:5}],methods:[{signature:"bool Equals(File3dmObject other)",summary:"Verified that two File3dmObject items refer to the same object in a document.",since:6,returns:"True is the two objects coincide."},{signature:"bool Equals(object obj)",summary:"Verified that two objects refer to the same object in a document.",returns:"True is the two objects coincide."},{signature:"int GetHashCode()",summary:"Provides an hash code for this item.",returns:"The hash code."}]},{name:"Rhino.FileIO.File3dmObjectTable",dataType:1,summary:"Represents a simple object table for a file that is open externally.\n   This class mimics Rhino.DocObjects.Tables.ObjectTable while providing external eccess to the file.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"int Count",summary:"Returns the total amount of items in the object table, including lights.",since:5}],methods:[{signature:"void Add(File3dmObject item)",summary:"Duplicates the object, then adds a copy of the object to the document.",since:6},{signature:"Guid AddAngularDimension(AngularDimension dimension)",summary:"Adds a angular dimension object to the 3dm file object table.",since:6.5,returns:"A unique identifier for the object."},{signature:"Guid AddAngularDimension(AngularDimension dimension,ObjectAttributes attributes)",summary:"Adds a angular dimension object to the 3dm file object table.",since:6.5,returns:"A unique identifier for the object."},{signature:"Guid AddArc(Arc arc)",summary:"Adds a curve object to the document representing an arc.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddArc(Arc arc,ObjectAttributes attributes)",summary:"Adds a curve object to the document representing an arc.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddBrep(Brep brep)",summary:"Adds a brep object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddBrep(Brep brep,ObjectAttributes attributes)",summary:"Adds a brep object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCircle(Circle circle)",summary:"Adds a curve object to the document representing a circle.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCircle(Circle circle,ObjectAttributes attributes)",summary:"Adds a curve object to the document representing a circle.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,Guid clippedViewportId)",summary:"Adds a clipping plane object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds)",summary:"Adds a clipping plane object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddClippingPlane(Plane plane,double uMagnitude,double vMagnitude,IEnumerable<Guid> clippedViewportIds,ObjectAttributes attributes)",summary:"Adds a clipping plane object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCurve(Curve curve)",summary:"Adds a curve object to the table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddCurve(Curve curve,ObjectAttributes attributes)",summary:"Adds a curve object to the table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddEllipse(Ellipse ellipse)",summary:"Adds a curve object to the document representing an ellipse.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddEllipse(Ellipse ellipse,ObjectAttributes attributes)",summary:"Adds a curve object to the document representing an ellipse.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddExtrusion(Extrusion extrusion)",summary:"Adds an extrusion object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddExtrusion(Extrusion extrusion,ObjectAttributes attributes)",summary:"Adds an extrusion object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddHatch(Hatch hatch)",summary:"Adds a hatch to the document.",since:5,returns:"A unique identifier for the hatch, or  on failure."},{signature:"Guid AddHatch(Hatch hatch,ObjectAttributes attributes)",summary:"Adds a hatch to the document.",since:5,returns:"A unique identifier for the hatch, or  on failure."},{signature:"Guid AddInstanceObject(InstanceReferenceGeometry instanceReference)",summary:"Adds an instance reference geometry object to the table.",since:6.5,returns:"A unique identifier for the object."},{signature:"Guid AddInstanceObject(InstanceReferenceGeometry instanceReference,ObjectAttributes attributes)",summary:"Adds an instance reference geometry object to the table.",since:6.5,returns:"A unique identifier for the object."},{signature:"Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform)",summary:"Adds an instance reference geometry object to the table.",since:6.5,returns:"A unique identifier for the object."},{signature:"Guid AddInstanceObject(int instanceDefinitionIndex,Transform instanceXform,ObjectAttributes attributes)",summary:"Adds an instance reference geometry object to the table.",since:6.5,returns:"A unique identifier for the object."},{signature:"Guid AddLeader(IEnumerable<Point3d> points)",summary:"Adds an annotation leader to the document. This overload is only provided in the Rhino SDK.",since:5,returns:"A unique identifier for the object; or  on failure."},{signature:"Guid AddLeader(Plane plane,IEnumerable<Point2d> points)",summary:"Adds an annotation leader to the document.",since:5,returns:"A unique identifier for the object; or  on failure."},{signature:"Guid AddLeader(Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)",summary:"Adds an annotation leader to the document.",since:5,returns:"A unique identifier for the object; or  on failure."},{signature:"Guid AddLeader(string text,IEnumerable<Point3d> points)",summary:"Adds an annotation leader to the document. This overload is only provided in the Rhino SDK.",since:5,returns:"A unique identifier for the object; or  on failure."},{signature:"Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points)",summary:"Adds an annotation leader to the document.",since:5,returns:"A unique identifier for the object; or  on failure."},{signature:"Guid AddLeader(string text,Plane plane,IEnumerable<Point2d> points,ObjectAttributes attributes)",summary:"Adds an annotation leader to the document.",since:5,returns:"A unique identifier for the object; or  on failure."},{signature:"Guid AddLine(Line line)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLine(Line line,ObjectAttributes attributes)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLine(Point3d from,Point3d to)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier of new rhino object."},{signature:"Guid AddLine(Point3d from,Point3d to,ObjectAttributes attributes)",summary:"Adds a line object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLinearDimension(LinearDimension dimension)",summary:"Adds a linear dimension to the 3dm file object table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddLinearDimension(LinearDimension dimension,ObjectAttributes attributes)",summary:"Adds a linear dimension to the 3dm file object table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddMesh(Mesh mesh)",summary:"Adds a mesh object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddMesh(Mesh mesh,ObjectAttributes attributes)",summary:"Adds a mesh object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(double x,double y,double z)",summary:"Adds a point object to the table.",since:5,returns:"id of new object."},{signature:"Guid AddPoint(Point3d point)",summary:"Adds a point object to the table.",since:5,returns:"Id of new object."},{signature:"Guid AddPoint(Point3d point,ObjectAttributes attributes)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3f point)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPoint(Point3f point,ObjectAttributes attributes)",summary:"Adds a point object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(IEnumerable<Point3d> points)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(IEnumerable<Point3d> points,ObjectAttributes attributes)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(PointCloud cloud)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPointCloud(PointCloud cloud,ObjectAttributes attributes)",summary:"Adds a point cloud object to the document.",since:5,returns:"A unique identifier for the object."},{signature:"Guid[] AddPoints(IEnumerable<Point3d> points)",summary:"Adds multiple points to the document.",since:5,returns:"List of object ids."},{signature:"Guid[] AddPoints(IEnumerable<Point3d> points,ObjectAttributes attributes)",summary:"Adds multiple points to the document.",since:5,returns:"An array of object unique identifiers."},{signature:"Guid[] AddPoints(IEnumerable<Point3f> points)",summary:"Adds multiple points to the document.",since:5,returns:"An array of object unique identifiers."},{signature:"Guid[] AddPoints(IEnumerable<Point3f> points,ObjectAttributes attributes)",summary:"Adds multiple points to the document.",since:5,returns:"An array of object unique identifiers."},{signature:"Guid AddPolyline(IEnumerable<Point3d> points)",summary:"Adds a polyline object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddPolyline(IEnumerable<Point3d> points,ObjectAttributes attributes)",summary:"Adds a polyline object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddSphere(Sphere sphere)",summary:"Adds a surface object to the document representing a sphere.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddSphere(Sphere sphere,ObjectAttributes attributes)",summary:"Adds a surface object to the document representing a sphere.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddSurface(Surface surface)",summary:"Adds a surface object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddSurface(Surface surface,ObjectAttributes attributes)",summary:"Adds a surface object to Rhino.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,ObjectAttributes attributes)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(string text,Plane plane,double height,string fontName,bool bold,bool italic,TextJustification justification,ObjectAttributes attributes)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(Text3d text3d)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddText(Text3d text3d,ObjectAttributes attributes)",summary:"Adds an annotation text object to the document.",since:5,returns:"The Guid of the newly added object or Guid.Empty on failure."},{signature:"Guid AddTextDot(string text,Point3d location)",summary:"Adds a text dot object to the table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddTextDot(string text,Point3d location,ObjectAttributes attributes)",summary:"Adds a text dot object to the table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddTextDot(TextDot dot)",summary:"Adds a text dot object to the table.",since:5,returns:"A unique identifier for the object."},{signature:"Guid AddTextDot(TextDot dot,ObjectAttributes attributes)",summary:"Adds a text dot object to the table.",since:5,returns:"A unique identifier for the object."},{signature:"bool Delete(Guid objectId)",summary:"Deletes object from document.",since:5.2,returns:"True on success, False on failure."},{signature:"int Delete(IEnumerable<Guid> objectIds)",summary:"Deletes a collection of objects from the document.",since:5.2,returns:"The number of successfully deleted objects."},{signature:"File3dmObject[] FindByGroup(Group group)",summary:"Finds all File3dmObject that are in a given group.",since:6.2,returns:"Array of objects that belong to the specified group or empty array if no objects could be found."},{signature:"File3dmObject[] FindByLayer(Layer layer)",summary:"Finds all File3dmObject that are in a given layer.",since:6,returns:"Array of objects that belong to the specified layer or empty array if no objects could be found."},{signature:"File3dmObject[] FindByLayer(string layer)",summary:"Finds all File3dmObject that are in a given layer.",since:5,returns:"Array of objects that belong to the specified layer or empty array if no objects could be found."},{signature:"Rhino.Geometry.BoundingBox GetBoundingBox()",summary:"Gets the bounding box containing every object in this table.",since:5,returns:"The computed bounding box."},{signature:"IEnumerator<File3dmObject> GetEnumerator()",summary:"Returns an enumerator that yields all objects in this document.\n     Like in Rhino, this includes lights. Unlike in Rhino, however, all lights are returned in the end of the list.",since:5,returns:"An enumerator that yields all objects in a document."}]},{name:"Rhino.FileIO.File3dmPlugInData",dataType:1,summary:"Custom data in the file supplied by a plug-in",properties:[{signature:"Guid PlugInId",summary:"Plug-in this data is associated with",since:5}]},{name:"Rhino.FileIO.File3dmPlugInDataTable",dataType:1,summary:"Table of custom data provided by plug-ins",properties:[{signature:"int Count",summary:"Gets the number of File3dmPlugInData in this table.",since:5}],methods:[{signature:"void Clear()",summary:"Remove all entries from this table",since:5},{signature:"string Dump()",summary:"Prepares a text dump of table.",since:5,returns:"A string containing the dump."},{signature:"IEnumerator<File3dmPlugInData> GetEnumerator()",summary:"Gets the enumerator that visits any  in this table.",since:5,returns:"The enumerator."}]},{name:"Rhino.FileIO.File3dmSettings",dataType:1,summary:"General settings in a 3dm file.",properties:[{signature:"double ModelAbsoluteTolerance",summary:"Gets or sets the model space absolute tolerance.",since:5},{signature:"double ModelAngleToleranceDegrees",summary:"Gets or sets the model space angle tolerance.",since:5},{signature:"double ModelAngleToleranceRadians",summary:"Gets or sets the model space angle tolerance.",since:5},{signature:"Point3d ModelBasepoint",summary:"Gets or sets the model basepoint that is used when the file is read as an instance definition.\n     This point is mapped to the origin in the instance definition.",since:5},{signature:"double ModelRelativeTolerance",summary:"Gets or sets the model space relative tolerance.",since:5},{signature:"UnitSystem ModelUnitSystem",summary:"Gets or sets the model unit system, using  enumeration.",since:5},{signature:"string ModelUrl",summary:"Gets or sets a Uniform Resource Locator (URL) direction for the model.",since:5},{signature:"double PageAbsoluteTolerance",summary:"Gets or sets the page space absolute tolerance.",since:5},{signature:"double PageAngleToleranceDegrees",summary:"Gets or sets the page space angle tolerance.",since:5},{signature:"double PageAngleToleranceRadians",summary:"Gets or sets the page space angle tolerance.",since:5},{signature:"double PageRelativeTolerance",summary:"Gets or sets the page space relative tolerance.",since:5},{signature:"UnitSystem PageUnitSystem",summary:"Gets or sets the page unit system, using  enumeration.",since:5}]},{name:"Rhino.FileIO.File3dmStringTable",dataType:1,summary:"Provides access to document strings in the 3dm file.",properties:[{signature:"int Count",summary:"Returns the number of document strings in the 3dm file.",since:6},{signature:"int DocumentUserTextCount",summary:"Returns the number of Section/Entry-style key values.",since:6}],methods:[{signature:"void Delete(string key)",summary:"Removes a document string from the 3dm file.",since:6},{signature:"void Delete(string section,string entry)",summary:"Removes document strings from the 3dm file.",since:6},{signature:"string[] GetEntryNames(string section)",summary:"Return list of all entry names for a given section of document strings in the 3dm file.",since:6,returns:"An array of section names. This can be empty, but not null."},{signature:"string GetKey(int i)",summary:"Returns a key value at a given index.",since:6,returns:"The key if successful."},{signature:"string[] GetSectionNames()",summary:"Returns a list of all the section names for document strings in the 3dm file.\n     By default a section name is a key that is prefixed with a string separated by a backslash.",since:6,returns:"An array of section names. This can be empty, but not null."},{signature:"string GetValue(int i)",summary:"Returns a string value at a given index.",since:6,returns:"The string value if successful."},{signature:"string GetValue(string key)",summary:"Returns a string value at a key.",since:6,returns:"The string value if successful."},{signature:"string GetValue(string section,string entry)",summary:"Returns a string value given a section and entry.",since:6,returns:"The string value if successful."},{signature:"string SetString(string key,string value)",summary:"Adds or sets a a document string in the 3dm file.",since:6,returns:"The previous value if successful."},{signature:"string SetString(string section,string entry,string value)",summary:"Adds or sets a document string in the 3dm file.",since:6,returns:"The previous value if successful."}]},{name:"Rhino.FileIO.File3dmTypeCodes",dataType:1,summary:'Typecode format 4 bytes long\n  \n  x xxxxxxxxxxxxxxx,x xxx xxxx xxxx x x xx\n  | |               | |               | |  |\n  |        |        |                 |\n  |        |        |         |       +---  "stuff" bit\n  |        |        |         |\n  |        |        |         +-- specific codes\n  |        |        |\n  |        |        +-- RESERVED - DO NOT USE (should be 0) (will be used to control CRC on/off)\n  |        |\n  |        +-- category:_000 0000 0000 0001  Legacy geometry    TCODE_LEGACY_GEOMETRY\n  |                     _000 0000 0000 0010  openNURBS object   TCODE_OPENNURBS_OBJECT\n  |                     _000 0000 0000 0100  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- \n  |                     _000 0000 0000 1000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --                     \n  |                     _000 0000 0001 0000  Geometry           TCODE_GEOMETRY\n  |                     _000 0000 0010 0000  Annotation\n  |                     _000 0000 0100 0000  Display Attributes TCODE_DISPLAY\n  |                     _000 0000 1000 0000  Rendering          TCODE_RENDER     \n  |                     _000 0001 0000 0000                         \n  |                     _000 0010 0000 0000  Interface          TCODE_INTERFACE \n  |                     _000 0100 0000 0000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --\n  |                     _000 1000 0000 0000  Tolerances         TCODE_TOLERANCE\n  |                     _001 0000 0000 0000  Tables             TCODE_TABLE    \n  |                     _010 0000 0000 0000  Table record       TCODE_TABLEREC\n  |                     _100 0000 0000 0000  User information   TCODE_USER\n  | \n  +-- format: 0 - data size in header  - data block follows    TCODE_SHORT\n              1 - data in header - no data block follows'},{name:"Rhino.FileIO.File3dmViewTable",dataType:1,summary:"Provides access to views in the 3dm file.",properties:[{signature:"int Count",summary:"Gets the amount of items in the table.",since:6}],methods:[{signature:"void Add(ViewInfo item)",summary:"Adds a",since:6},{signature:"void Clear()",summary:"Removes all items from the table.",since:6},{signature:"bool Contains(ViewInfo item)",summary:"Returns an indication of the presence of a view in the table.",since:6,returns:"True if the item is in the table; False otherwise."},{signature:"void CopyTo(ViewInfo[] array,int arrayIndex)",summary:"Copies the content of teh table to an array.",since:6},{signature:"bool Delete(int index)",summary:"Removes an item.",since:6,returns:"True if the item was removed."},{signature:"bool Delete(ViewInfo item)",summary:"Deletes an item.",since:6},{signature:"ViewInfo FindName(string name)",summary:"Finds a ViewInfo given its name.",since:6,returns:"An ViewInfo, or None on error."},{signature:"IEnumerator<DocObjects.ViewInfo> GetEnumerator()",summary:"Returns an enumerator that yields all views in the table.",since:6,returns:"An enumerator."},{signature:"int IndexOf(ViewInfo item)",summary:"Returns the index of the current ViewInfo.",since:6,returns:"The index of the ViewInfo."}]},{name:"Rhino.FileIO.File3dmWriteOptions",dataType:1,summary:"Options used by File3dm.Write",constructors:[{signature:"File3dmWriteOptions()",summary:"Initializes properties to defaults.",since:5.9}],properties:[{signature:"bool SaveAnalysisMeshes",summary:"Include analysis meshes in the file. Default is true",since:5.9},{signature:"bool SaveRenderMeshes",summary:"Include Render meshes in the file. Default is true",since:5.9},{signature:"bool SaveUserData",summary:"Include custom user data in the file. Default is true",since:5.9},{signature:"int Version",summary:"File version. Default is major version number of this assembly version.Must be in range [2; current version].Alternatively, 0 is a placeholder for the last valid version.Rhino can read its current version, plus earlier file versions except 1.Use latest version when possible.",since:5.9}],methods:[{signature:"void EnableAnalysisMeshes(ObjectType objectType,bool enable)",summary:"Activates saving of analysis meshes for specific types of objects.\n     If you do not specify the state for an object type, its default is used.\n     Currently SubD mesh saving is disabled by default, while Brep and Extrusion is enabled.",since:6},{signature:"void EnableRenderMeshes(ObjectType objectType,bool enable)",summary:"Activates saving of render meshes for specific types of objects.\n     If you do not specify the state for an object type, its default is used.\n     Specifically, currently SubD mesh saving is disabled by default, while Brep and Extrusion is on.",since:6}]},{name:"Rhino.FileIO.FileObj",dataType:1,summary:"Support for obj file format",methods:[{signature:"static bool Read(String filename,RhinoDoc doc,FileObjReadOptions options)",since:6},{signature:"static WriteFileResult Write(StreamWriter stream,RhinoDoc doc,FileObjWriteOptions options)",summary:"Write an obj stream based on the contents of a RhinoDoc",since:7},{signature:"static WriteFileResult Write(String filename,Mesh[] meshes,FileObjWriteOptions options)",summary:"Write an obj file with an array of meshes",since:7},{signature:"static WriteFileResult Write(String filename,RhinoDoc doc,FileObjWriteOptions options)",summary:"Write an obj file based on the contents of a RhinoDoc",since:6}]},{name:"Rhino.FileIO.FileObjReadOptions",dataType:1,summary:"Options used when reading an obj file.",constructors:[{signature:"FileObjReadOptions(FileReadOptions readOptions)",since:6}],properties:[{signature:"bool DisplayColorFromObjMaterial",summary:"Determines whether textures are read from the .mtl file, if it exists.",since:6.5},{signature:"bool IgnoreTextures",summary:"Determines whether textures are read from the .mtl file, if it exists.",since:6},{signature:"bool MapYtoZ",summary:"Setting to transform OBJ's Y axis to Rhino's Z axis",since:6},{signature:"bool MorphTargetOnly",summary:"TODO",since:6},{signature:"bool ReverseGroupOrder",summary:"Determines how groups/layers are nested when reading an obj file.\n     Left to Right (default = false) or Right to Left (true)",since:6},{signature:"bool Split32BitTextures",since:6},{signature:"UseObjGsAs UseObjGroupsAs",since:6},{signature:"bool UseObjObjects",summary:'Determines whether or not "o"s in the obj file\n     will be interpreted as objects in the Rhino model',since:6}],methods:[{signature:"Transform GetTransform()",summary:"Calculates the YToZ transform.",since:6}]},{name:"Rhino.FileIO.FileObjReadOptions.UseObjGsAs",dataType:3,summary:'Determines how "g"s in the obj file will be interpreted\n     on import'},{name:"Rhino.FileIO.FileObjWriteOptions",dataType:1,summary:"",constructors:[{signature:"FileObjWriteOptions(FileWriteOptions writeOptions)",since:6}],properties:[{signature:"string ActualFilePathOnMac",since:6.3},{signature:"bool CreateNgons",summary:"Setting to enable/diable the creation of ngons for the output",since:6},{signature:"bool CullUnnecessaryVertexesInNgons",summary:"Setting to determine whether interior colinear vertexes are part of the \n     ngon.",since:6},{signature:"AsciiEol EolType",since:6},{signature:"ObjGroupNames ExportGroupNameLayerNames",summary:'Setting to determine whether object, group or layer names\n     will become "g"s in the OBJ output file',since:6},{signature:"bool ExportMaterialDefinitions",summary:'Setting to write an .mtl file and "usemtl"s in the obj file',since:6},{signature:"bool ExportNormals",summary:"Enable/disable export of vertex normals, if they exist.",since:6},{signature:"ObjObjectNames ExportObjectNames",summary:"Setting to determine what object names in Rhino \n     will become in the OBJ output file",since:6},{signature:"bool ExportOpenMeshes",summary:"Enable/Disable bailing when an open mesh is encountered.",since:6},{signature:"bool ExportTcs",summary:"Enable/disable export of texture coordinates, if they exist.",since:6},{signature:"bool ExportVcs",summary:"Enable/disable export of vertex colors, if they exist.",since:6},{signature:"bool IncludeUnweldedEdgesInNgons",summary:"Setting to determine whether unwelded edges are ignored in the \n     creation of an ngon.",since:6},{signature:"bool MapZtoY",summary:"Setting to transform Rhino's Z axis to OBJ's Y axis",since:6},{signature:"bool MergeNestedGroupingNames",summary:"Setting to merge nested layer or group names into a single OBJ group name",since:6.7},{signature:"MeshingParameters MeshParameters",summary:"Mesh parameters to use when meshing geometry that is not already a mesh.",since:6},{signature:"VertexWelding MeshType",since:6},{signature:"int MinNgonFaceCount",summary:"Minimum number of faces to consider creation of ngon",since:6},{signature:"GeometryType ObjectType",since:6},{signature:"int SignificantDigits",summary:"Number of significant digits to write out for floating point numbers",since:6},{signature:"bool SortObjGroups",summary:"Setting to enable/disable sorting of OBJ groups",since:6},{signature:"SubDMeshing SubDMeshType",since:7},{signature:"int SubDSurfaceMeshingDensity",summary:"Determines how coarse the mesh output\n     will be when surface meshing subd objects\n     \n     See comments for ON_SubDDisplayParameters in opennurbs_mesh.h\n     for details regarding numbers used.",since:7},{signature:"CurveType TrimCurveType",summary:"trimming curve option",since:6},{signature:"bool UnderbarMaterialNames",summary:"Enable/disable replacing white space with underbars in material names.",since:6},{signature:"bool UseRelativeIndexing",summary:"Determines whether to use relative indexing.\n     \n     TRUE = use relative (negative) indexing\n     FALSE = use absolute (positive) indexing",since:6},{signature:"bool UseSimpleDialog",summary:"Determines whether to use the simple or detailed meshing dialog.",since:6},{signature:"bool WrapLongLines",summary:'Setting to enable/disable line wrapping with "\\"s',since:6}],methods:[{signature:"Transform GetTransform()",summary:"Calculates the transform combination of ZToY and\n     any the translation that might occur in a SavewithOrigin.",since:6}]},{name:"Rhino.FileIO.FileObjWriteOptions.AsciiEol",dataType:3,summary:"End of Line"},{name:"Rhino.FileIO.FileObjWriteOptions.CurveType",dataType:3,summary:"Type of curve used for trimmed surfaces"},{name:"Rhino.FileIO.FileObjWriteOptions.GeometryType",dataType:3,summary:"(trimmed) NURBS surfaces may be exported                              \n     as either NURBS or meshes"},{name:"Rhino.FileIO.FileObjWriteOptions.ObjGroupNames",dataType:3,summary:""},{name:"Rhino.FileIO.FileObjWriteOptions.ObjObjectNames",dataType:3,summary:""},{name:"Rhino.FileIO.FileObjWriteOptions.SubDMeshing",dataType:3,summary:"Determines whether the surface or control net of a SubD object is used to generate a mesh"},{name:"Rhino.FileIO.FileObjWriteOptions.VertexWelding",dataType:3,summary:"Determines how/if vertexes of the mesh in Rhino will be modified in the output"},{name:"Rhino.FileIO.FileObjWriter.ObjGroupComparer",dataType:1,summary:""},{name:"Rhino.FileIO.FileObjWriter.ObjLayerComparer",dataType:1,summary:""},{name:"Rhino.FileIO.FileObjWriter.ObjRhinoObject",dataType:1,summary:""},{name:"Rhino.FileIO.FileObjWriter.RhinoObjectMesh",dataType:1,summary:""},{name:"Rhino.FileIO.FilePdf",dataType:1,summary:"Support for PDF file format",methods:[{signature:"static FilePdf Create()",summary:"Create a new instance of a FilePdf class",since:6},{signature:"int AddPage(int widthInDots,int heightInDots,int dotsPerInch)",summary:"Add a blank page to this document",since:6.5,returns:"page number on success"},{signature:"int AddPage(ViewCaptureSettings settings)",summary:"Add a new page to this document and draw a viewport into it based on\n     provided ViewCaptureSettings",since:6,returns:"page number on success"},{signature:"void DrawBitmap(int pageNumber,Bitmap bitmap,float left,float top,float width,float height,float rotationInDegrees)",summary:"Draw a bitmap",since:6.5},{signature:"void DrawLine(int pageNumber,PointF from,PointF to,Color strokeColor,float strokeWidth)",summary:"Draw a line",since:6.5},{signature:"void DrawPolyline(int pageNumber,PointF[] polyline,Color fillColor,Color strokeColor,float strokeWidth)",summary:"Draw a polyline path",since:6.5},{signature:"void DrawText(int pageNumber,string text,double x,double y,float heightPoints,Font onfont,Color fillColor,Color strokeColor,float strokeWidth,float angleDegrees,TextHorizontalAlignment horizontalAlignment,TextVerticalAlignment verticalAlignment)",summary:"Draw text on a page",since:6.5},{signature:"object PdfDocumentImplementation()",summary:"Get actual implementation of PdfDocument class",since:6},{signature:"void Write(Stream stream)",summary:"Write pdf to a stream",since:6},{signature:"void Write(string filename)",summary:"Write pdf to a file",since:6}]},{name:"Rhino.FileIO.FilePdfEventArgs",dataType:1,summary:"Used for events that are fired while constructing/saving a Pdf",properties:[{signature:"FilePdf Pdf",summary:"The document that is about to be written",since:6}]},{name:"Rhino.FileIO.FilePly",dataType:1,summary:"Support for ply file format",methods:[{signature:"static WriteFileResult Write(String filename,RhinoDoc doc,FilePlyWriteOptions options)",summary:"Write a ply file based on the contents of a RhinoDoc",since:7}]},{name:"Rhino.FileIO.FilePlyWriteOptions",dataType:1,summary:"",constructors:[{signature:"FilePlyWriteOptions(FileWriteOptions writeOptions)",since:7}],properties:[{signature:"bool ExportASCII",summary:"Determines whether to export as Ascii.",since:7},{signature:"bool ExportColors",summary:"Determines whether to export vertex colors.",since:7},{signature:"bool ExportMaterial",summary:"Determines whether to export a material.",since:7},{signature:"bool ExportNormals",summary:"Determines whether to export vertex normals.",since:7},{signature:"MeshingParameters MeshingParameters",since:7},{signature:"bool UseSimpleDialog",summary:"Determines whether to use the simple or detailed meshing dialog.",since:7}]},{name:"Rhino.FileIO.FileReadOptions",dataType:1,summary:"",constructors:[{signature:"FileReadOptions()",since:5}],properties:[{signature:"bool BatchMode",summary:'True means you cannot ask questions during reading. (no dialogs, no "getters", etc.)',since:5},{signature:"bool ImportMode",summary:"True means we are merging whatever is being read into an existing document.\n      This means you need to consider things like:\n     \n     If the information being read is in a different unit system, it should be\n     scaled if UseScaleGeometry is true.\n     \n     There can be existing layers, fonts, materials, dimension styles, hatch\n     patterns, and so on with the same name as items being read from the file.",since:5},{signature:"bool ImportReferenceMode",summary:"True means we are reading information for a work session reference model\n     or a linked instance definition.",since:5},{signature:"bool InsertMode",summary:'True means we are reading information that will be used to create an\n     instance definition or some other type of "inserting" that is supported\n     by Rhino\'s "Insert" command.',since:5},{signature:"bool NewMode",summary:"True means we are reading template information in something like\n     a OnFileNew event.",since:5},{signature:"bool OpenMode",summary:"True means we are reading the information into an empty document.  This\n     means you need to consider things like:\n     Setting the unit system (if the file has a unit system)Creating a default layer if one is not there.Setting up appropriate views when you're finished reading.",since:5},{signature:"bool ScaleGeometry",summary:"true: If ImportMode is True and the geometry in the file being read has\n     a unit system different from the model's unit system, then apply the unit\n     conversion scale to the file's geometry before adding it to the model.\n     \n     false: Do not scale. Once case where this happens is when an instance\n     definition is read from a file and the model space instance references\n     have been scaled. In case the instance definition geometry cannot be\n     scaled or the net result is that the size of the instance reference\n     object is scaled by the square of the scale factor.",since:5},{signature:"bool UseScaleGeometry",summary:"If this parameter is true, then no questions are asked when unit conversion\n     scaling is optional and the setting specified by ScaleGeometry is used.",since:5}],methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.FileIO.FileReference",dataType:1,summary:"Manages a reference to an existing or nonexisting file,\n   using either or both absolute or relative paths.\n   Once constructed, this class is immutable.",constructors:[{signature:"FileReference(string fullPath,string relativePath,ContentHash hash,FileReferenceStatus status)",summary:"Constructs a new instance of the FileReference class,\n     given a fullPath, a relativePath a content hash and a status value.",since:6}],properties:[{signature:"ContentHash ContentHash",summary:"Gets the content hash.",since:6},{signature:"string FullPath",summary:"Gets the absolute path of this file reference.",since:6},{signature:"FileReferenceStatus FullPathStatus",summary:"Gets the file reference status.",since:6},{signature:"bool IsSet",summary:"Returns an indication of the fact that the reference is actually set to a non-None value.",since:6},{signature:"string RelativePath",summary:"Gets the relative path of this file reference.",since:6}],methods:[{signature:"static FileReference CreateFromFullAndRelativePaths(string fullPath,string relativePath)",summary:"Returns a new file reference. This returns a new instance even if the path does not exist.",since:6,returns:"A file reference to the specified paths."},{signature:"static FileReference CreateFromFullPath(string fullPath)",summary:"Returns a new file reference. This returns a new instance even if the path does not exist.",since:6,returns:"A file reference to the specified path."},{signature:"void Dispose()",summary:"Reclaims unmanaged resources used by this object.",since:6}]},{name:"Rhino.FileIO.FileSlc",dataType:1,summary:"Support for writing slice (slc) file format",methods:[{signature:"static bool Write(string filename,RhinoDoc doc,FileSlcWriteOptions options)",summary:"Write a slc file based on the contents of a RhinoDoc",since:7,returns:"True on success"}]},{name:"Rhino.FileIO.FileSlcWriteOptions",dataType:1,summary:"Options used when writing a slc file",properties:[{signature:"double AngleBetweenSegmentsDegrees",summary:"The angle that determines how smooth the polylines of the slice curves\n     will be. When the number is small you will get a smooth final output\n     but it will take more time to export and a larger file.",since:7},{signature:"Point3d EndPoint",summary:"End of the slicing normal",since:7},{signature:"double SliceDistance",summary:"The distance between the slices or layers of curves that your final\n     output will contain. The distance should be based on the slice\n     thickness of your final output device",since:7},{signature:"Point3d StartPoint",summary:"Start of the slicing normal",since:7},{signature:"bool UseMeshes",summary:"Use meshes to generate slices. The curves for each slice are generated\n     by intersecting the object mesh with a plane. the Angle between\n     polyline segments data is not used when this value is true",since:7}]},{name:"Rhino.FileIO.FileStp",dataType:1,summary:"Support for writing step (stp) file format",methods:[{signature:"static bool Write(string filename,RhinoDoc doc,FileStpWriteOptions options)",summary:"Write a stp file based on the contents of a RhinoDoc",since:7,returns:"True on success"}]},{name:"Rhino.FileIO.FileStpWriteOptions",dataType:1,summary:"Options used when writing a stp file",properties:[{signature:"bool Export2dCurves",summary:"Some (not most, and not Rhino) importing applications can make use of\n     the 2-D trimming curves to get a more accurate and faster import. The\n     size of the step file will be larger",since:7},{signature:"bool ExportBlack",summary:"Let importing application set color for black objects. If a Rhino\n     object has color black, no color is assigned to the object in the step\n     file.This will cause the importing application to give the object its\n     default color.This is desirable because black objects look like\n     ink blots in some applications.This option is grayed out if the schema\n     option is AP203ControConfigDesign since that schema does not include\n     color entities.",since:7},{signature:"bool SplitClosedSurfaces",summary:"Splits closed surfaces, for example, the interior surfaces of drilled\n     holes.",since:7}]},{name:"Rhino.FileIO.FileType",dataType:1,summary:"",constructors:[{signature:"FileType(string extension,string description)",since:5}],properties:[{signature:"string Description",since:5},{signature:"string Extension",since:5}]},{name:"Rhino.FileIO.FileWriteOptions",dataType:1,summary:"",constructors:[{signature:"FileWriteOptions()",since:5}],properties:[{signature:"string DestinationFileName",summary:"For use on Apple frameworks only.\n     Retrns the final destination file name.",since:6.3},{signature:"int FileVersion",since:5},{signature:"bool IncludeBitmapTable",summary:"The file written should include the bitmap table if your File Writing Plug-in supports it.",since:5},{signature:"bool IncludeHistory",summary:"The file written should include history information if your File Writing Plug-In supports it.",since:5},{signature:"bool IncludePreviewImage",summary:"The file written should include a preview image if your File Writing Plug-in supports it.",since:5},{signature:"bool IncludeRenderMeshes",summary:"The file written should include the render meshes if your File Writing Plug-in supports it.",since:5},{signature:"bool SuppressAllInput",since:7},{signature:"bool SuppressDialogBoxes",summary:"If true, it means the command has been run with a '-', meaning you should not ask questions during writing. (no dialogs, no \"getters\", etc.)",since:5},{signature:"bool UpdateDocumentPath",summary:"If a complete, current version, 3dm file is successfully saved, then\n     the name of the file will be used to update the document's default file\n     path and title and document will be marked as not modified.",since:6.7},{signature:"bool WriteAsTemplate",summary:"Write as template",since:5},{signature:"bool WriteGeometryOnly",summary:"If true, the file written should include only geometry File Writing Plug-in supports it.",since:5},{signature:"bool WriteSelectedObjectsOnly",summary:"If true, this command should export only the objects currently selected in the Rhino model.",since:5},{signature:"bool WriteUserData",summary:"If true, the file written should include User Data if your File Writing Plug-in supports it.",since:5},{signature:"Transform Xform",since:5}],methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.FileIO.ICommonComponentTable",dataType:4,summary:"Provides methods to use all File3dm and RhinoDoc tables under the same contract.\n   Do not derive from this interface. This is to ensure all tables can be used with the same method list."},{name:"Rhino.FileIO.ImageFile",dataType:1,summary:"Support functions for image files",methods:[{signature:"static bool SupportsAlphaChannel(string filename)",summary:"Returns True if file at given path is an image file and that file format supports\n     an alpha channel",since:6}]},{name:"Rhino.FileIO.ManifestTable",dataType:1,summary:'Maintains an index to every model component that is in the 3dm file.\n   This is the "more comprehensive" table that contains all objects in all other tables.',properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"int Count",summary:"Total number of items in the manifest, including deleted items.",since:6},{signature:"long LongCount",summary:"Total number of items in the manifest, including deleted items.",since:6},{signature:"object Parent",summary:"Returns the parent object. This is the RhinoDoc, or the File3md file.",since:6}],methods:[{signature:"static ModelComponentType GetModelComponentTypeFromGenericType()",summary:"Returns the result of the ComponentType property of a ModelComponent.",since:6,returns:"A ."},{signature:"int ActiveObjectCount(ModelComponentType type)",summary:"Total number of items in the manifest, including deleted items.",since:6},{signature:"void Clear()",summary:"Marks all items as deleted.",since:6},{signature:"bool Contains(ModelComponent item)",summary:"Determines if an items is contained in this table.",since:6,returns:"True if the item is contained; otherwise, false."},{signature:"void CopyTo(ModelComponent[] array,int arrayIndex)",summary:"Copies the content of this table to an array.",since:6},{signature:"T FindId(Guid id)",summary:"Uses the guid to find a model component. Deleted objects cannot be found by id.\n     The guid is the value that is stored in the .Id property.\n     In a single document, no two active objects have the same guid. If an object is\n     replaced with a new object, then the guid  persists. For example, if the _Move command\n     moves an object, then the moved object inherits its guid from the starting object.\n     If the Copy command copies an object, then the copy gets a new guid. This guid persists\n     through file saving/openning operations. This function will not find grip objects.",since:6,returns:"Reference to the rhino object or None if no such object could be found."},{signature:"ModelComponent FindId(Guid id)",summary:"Uses the guid to find a model component. Deleted objects cannot be found by id.\n     The guid is the value that is stored in the .Id property.\n     In a single document, no two active objects have the same guid. If an object is\n     replaced with a new object, then the guid  persists. For example, if the _Move command\n     moves an object, then the moved object inherits its guid from the starting object.\n     If the Copy command copies an object, then the copy gets a new guid. This guid persists\n     through file saving/openning operations. This function will not find grip objects.",since:6,returns:"Reference to the rhino object with the objectId or None if no such object could be found."},{signature:"ModelComponent FindId(Guid id,ModelComponentType type)",summary:"Uses the guid to find a model component. Deleted objects cannot be found by id.\n     The guid is the value that is stored in the .Id property.\n     In a single document, no two active objects have the same guid. If an object is\n     replaced with a new object, then the guid  persists. For example, if the _Move command\n     moves an object, then the moved object inherits its guid from the starting object.\n     If the Copy command copies an object, then the copy gets a new guid. This guid persists\n     through file saving/openning operations. This function will not find grip objects.",since:6,returns:"Reference to the rhino object with the objectId or None if no such object could be found."},{signature:"T FindIndex(int index)",summary:"Uses the index to find a model component.\n     The index is the value that is stored in the .Index property.",since:6,returns:"Reference to the rhino object or None if no such object could be found."},{signature:"ModelComponent FindIndex(int index,ModelComponentType type)",summary:"Uses the index to find a model component.\n     The index is the value that is stored in the .Index property.",since:6,returns:"Reference to the rhino object or None if no such object could be found."},{signature:"T FindName(string name,Guid parent)",summary:"Uses the name to find a model component.\n     The name is the value that is stored in the .Name property.\n     Deleted objects have no name.",since:6,returns:"Reference to the rhino object or None if no such object could be found."},{signature:"ModelComponent FindName(string name,ModelComponentType type,Guid parent)",summary:"Uses the name to find a model component.\n     The name is the value that is stored in the .Name property.\n     Deleted objects have no name.",since:6,returns:"Reference to the rhino object or None if no such object could be found."},{signature:"T FindNameHash(NameHash nameHash)",summary:"Uses the hash of the name to find a model component.\n     Deleted objects have no name.",since:6},{signature:"ModelComponent FindNameHash(NameHash nameHash,ModelComponentType type)",summary:"Uses the hash of the name to find a model component.\n     Deleted objects have no name.",since:6,returns:"Reference to the rhino object or None if no such object could be found."},{signature:"IEnumerator<T> GetEnumerator()",summary:"Visits all model components in the document, including default ones.",since:6,returns:"An enumerator."},{signature:"IEnumerator<ModelComponent> GetEnumerator()",summary:"Visits all model components in the document, including default ones.",since:6,returns:"An enumerator."},{signature:"IEnumerator<ModelComponent> GetEnumerator(ModelComponentType type)",summary:"Returns an enumerators that yields all model components, including default ones,\n     relating to a particular type.",since:6,returns:"An enumerator."}]},{name:"Rhino.FileIO.NameHash",dataType:1,summary:"Contains information that is useful to uniquly identify an object name.\n   This object is immutable.",constructors:[{signature:"NameHash(string name)",summary:"Creates a new NameHash, representing a piece of text.",since:6},{signature:"NameHash(string name,Guid parentId)",summary:"Creates a new NameHash, representing a piece of text.",since:6},{signature:"NameHash(string name,Guid parentId,bool ignoreCase)",summary:"Creates a new NameHash, representing a piece of text.",since:6},{signature:"NameHash(string name,Guid parentId,ModelComponentType type)",summary:"Creates a new NameHash, representing a piece of text.",since:6}],properties:[{signature:"uint MappedCodePoints",summary:"Gets the NameHash flags. In some cases = number of mapped code points.",since:6},{signature:"Guid ParentId",summary:"Only useful if this participates in a tree structure, as with layers.",since:6},{signature:"byte[] Sha1Hash",summary:"Gets the 20-bytes long SHA-1 hash of ordinal minimum mapped unicode (UTF-32) code points.",since:6}],methods:[{signature:"static NameHash CreateFilePathHash(string path)",summary:"Creates a new NameHash, representing the name of a file.",since:6},{signature:"NameHash Clone()",summary:"Creates a copy of this name hash.\n     Because content hash is immutable, this can be used as a deep copy.",since:6,returns:"A different instance of the same name hash."},{signature:"bool Equals(NameHash other)",summary:"Determines if another name hash has the same value.",since:6,returns:"True if the two hashes are equal."},{signature:"bool Equals(object obj)",summary:"Determines if another object is a name hash with same value.",returns:"True if the two hashes are equal."},{signature:"int GetHashCode()",summary:"Gets an hash code for this name hash.\n     Two equal content hashes have equal hash code. The other way around might not be true.",returns:"An hash code value."}]},{name:"Rhino.FileIO.SerializationOptions",dataType:1,summary:"Contains options for serializing -or storing- data,\n   such as Rhino version and user data.",constructors:[{signature:"SerializationOptions()",summary:"Initializes a new instance of the  class.",since:5}],properties:[{signature:"int RhinoVersion",summary:"Gets or sets a value indicating the Rhino version.",since:5},{signature:"bool WriteUserData",summary:"Gets or sets a value indicating whether to write user data.",since:5}]},{name:"Rhino.FileIO.SHA1OpenNURBS",dataType:1,summary:"Provides the OpenNURBS implementation of SHA1.\n   \n   This class is provided only with the purpose of hashing. It is not meant to be\n   used for any cryptographic purpose.",constructors:[{signature:"SHA1OpenNURBS()",summary:"Constructs a new instance of the SHA1 algorithm.",since:6}],methods:[{signature:"static byte[] FileSystemPathHash(string path,bool? ignoreCase)",summary:"Computes the SHA1 hash of a file system path, converted to UTF8.\n         These file system paths have identical values of FileSystemPathHash():/x/y/z/name.ext\\x\\y\\z\\name.ext/x//y//z/name.ext/x/y/a/b/c/../../../z/name.ext/X/Y/Z/NAME.EXT (When ignoreCase is true)",returns:"A 20-byte long SHA1 hash."},{signature:"static byte[] StringHash(string input)",summary:"Computes the SHA1 hash of a string, converted to UTF8.",since:6,returns:"A 20-byte long SHA1 hash."},{signature:"void Initialize()",summary:"Resets this instance of the algorithm, so that it can be used again.\n     It is not required to call this method after creation.",since:6}]},{name:"Rhino.FileIO.TextLog",dataType:1,summary:"Used for collecting text data",constructors:[{signature:"TextLog()",summary:"Creates a text log that stores all text in memory.  Use ToString on this\n     version of the TextLog to get the text that we written",since:5.1},{signature:"TextLog(IntPtr ptr)",since:6},{signature:"TextLog(string filename)",summary:"Creates a text log that writes all text to a file. If no filename is\n     provided, then text is written to StdOut",since:5.1}],properties:[{signature:"int IndentSize",summary:"0: one tab per indent. >0: number of spaces per indent",since:5.1}],methods:[{signature:"static TextLog NewCommandLine()",summary:"Returns a reference to a TextLog that prints to the Rhino command line.\n     Each new command line reference holds its own indents.",since:7},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.1},{signature:"void PopIndent()",summary:"Decrease the indentation level",since:5.1},{signature:"void Print(string text)",summary:"Send text to the textlog",since:5.1},{signature:"void Print(string format,object arg0)",summary:"Send formatted text to the textlog",since:5.1},{signature:"void Print(string format,object arg0,object arg1)",summary:"Send formatted text to the textlog",since:5.1},{signature:"void PrintWrappedText(string text,int lineLength)",summary:"Send text wrapped at a set line length",since:5.1},{signature:"void PushIndent()",summary:"Increase the indentation level",since:5.1},{signature:"string ToString()",summary:"If the TextLog was constructed using the empty constructor, then the text\n     information is stored in a runtime string.  The contents of this string\n     is retrieved using ToString for this case"}]},{name:"Rhino.Geometry.AngularDimension",dataType:1,summary:"Represents a dimension of an entity that can be measured with an angle.",constructors:[{signature:"AngularDimension()",since:6},{signature:"AngularDimension(Arc arc,double offset)",summary:"Create an angular dimension from a given arc",since:5}],properties:[{signature:"AngleDisplayFormat AngleFormat",since:6},{signature:"int AngleResolution",since:6},{signature:"double AngleRoundoff",since:6},{signature:"ZeroSuppression AngleZeroSuppression",since:6},{signature:"Point2d ArrowPoint1",since:6},{signature:"Point2d ArrowPoint2",since:6},{signature:"Point2d CenterPoint",since:6},{signature:"Point2d DefPoint1",since:6},{signature:"Point2d DefPoint2",since:6},{signature:"Point2d DimlinePoint",since:6}],methods:[{signature:"static AngularDimension Create(DimensionStyle dimStyle,Plane plane,Vector3d horizontal,Point3d centerpoint,Point3d defpoint1,Point3d defpoint2,Point3d dimlinepoint)",summary:"Initialize Dimension parameters",since:6},{signature:"static AngularDimension Create(Guid styleId,Plane plane,Point3d extpoint1,Point3d extpoint2,Point3d dirpoint1,Point3d dirpoint2,Point3d dimlinepoint)",summary:"Initialize Dimension parameters",since:6},{signature:"bool AdjustFromPoints(Plane plane,Point3d centerpoint,Point3d defpoint1,Point3d defpoint2,Point3d dimlinepoint)",summary:"Update Dimension geometry from point locations",since:6},{signature:"bool AdjustFromPoints(Plane plane,Point3d extpoint1,Point3d extpoint2,Point3d dirpoint1,Point3d dirpoint2,Point3d dimlinepoint)",summary:"Update Dimension geometry from point locations",since:6},{signature:"bool Get3dPoints(Point3d centerpoint,Point3d defpoint1,Point3d defpoint2,Point3d arrowpoint1,Point3d arrowpoint2,Point3d dimlinepoint,Point3d textpoint)",summary:"Get locations of dimension's 3d points",since:6},{signature:"string GetAngleDisplayText(DimensionStyle style)",since:6},{signature:"bool GetDisplayLines(DimensionStyle style,double scale,Line[] lines,Arc[] arcs)",since:6},{signature:"bool GetTextRectangle(Point3d[] corners)",since:6}]},{name:"Rhino.Geometry.AnnotationBase",dataType:1,summary:"Provides a common base class to all annotation geometry.\n   This class refers to the geometric element that is independent from the document.",properties:[{signature:"LengthDisplay AlternateDimensionLengthDisplay",summary:"Alternate length display units and format",since:6},{signature:"AnnotationType AnnotationType",summary:"Type of annotation",since:6},{signature:"char DecimalSeparator",summary:"Set or get the decimal separator c",since:7},{signature:"LengthDisplay DimensionLengthDisplay",summary:"Length display units and format",since:6},{signature:"double DimensionScale",summary:"Gets or sets the dimension scale",since:6},{signature:"DimensionStyle DimensionStyle",summary:"If there are no overrides then the parent style is returned otherwise the dimension style saved with the annotation is returned.",since:6},{signature:"Guid DimensionStyleId",summary:"Id of this annotation's parent dimstyle\n     If this annotation has overrides to dimstyle properties, \n     those overrides will be represented in the DimensionStyle\n     returned by DimensionStyle(ParentStyle)",since:6},{signature:"bool DrawForward",summary:"Gets or sets whether the text is oriented towards the reader when viewed from behind",since:6},{signature:"bool DrawTextFrame",summary:"Gets or sets whether to draw a frame around a text mask",since:7},{signature:"Font FirstCharFont",summary:"Returns the font used by the first run of text in an annotation",since:6.5},{signature:"Font Font",summary:"The base Font for the text of the annotation.  The text string is rich text and therefore a different font that the base font can be associated with sub strings of the text",since:6},{signature:"int FontIndex",summary:"Obsolete; use Font property instead",since:6.1},{signature:"double FormatWidth",summary:"Text format width (Wrapping rectangle)",since:6},{signature:"bool HasPropertyOverrides",since:6},{signature:"Color MaskColor",summary:"Color to use for drawing a text mask when it is enabled. If the mask is\n     enabled and MaskColor is System.Drawing.Color.Transparent, then the\n     viewport's color will be used for the MaskColor",since:6},{signature:"MaskType MaskColorSource",summary:"Gets or sets whether the mask background color is from the background or from a color",since:6},{signature:"bool MaskEnabled",summary:"Determines whether or not to draw a Text Mask",since:6},{signature:"MaskFrame MaskFrame",summary:"Gets or sets whether to draw a frame around a text mask",since:7},{signature:"double MaskOffset",summary:"Offset for the border around text of the rectangle used to draw the mask.  This \n     value multiplied by TextHeight is the offset on each side of the tight rectangle \n     around the text characters to the mask rectangle. The default value is 0.1.",since:6},{signature:"bool MaskUsesViewportColor",summary:"If true, the viewport's color is used for the mask color. If\n     false, the color defined by MaskColor is used",since:6},{signature:"DimensionStyle ParentDimensionStyle",summary:"The parent dimension style associated with this annotation",since:6},{signature:"string PlainText",summary:"Text stripped of RTF formatting information",since:6},{signature:"string PlainTextWithFields",summary:"Text stripped of RTF formatting information and with field expressions intact",since:6.19},{signature:"Plane Plane",summary:"Plane that this annotation lies on",since:5},{signature:"string RichText",summary:"Text including additional RTF formatting information",since:6},{signature:"string Text",summary:"Text including additional RTF formatting information",since:5},{signature:"string TextFormula",summary:"See RichText",since:5},{signature:"bool TextHasRtfFormatting",since:6},{signature:"double TextHeight",summary:"AnnotationBase.TextHeight\n     Gets the parent dimstyle for the annotation and \n     gets or sets the text height in the dimstyle",since:5},{signature:"bool TextIsWrapped",summary:"Is text wrapping on",since:6},{signature:"double TextModelWidth",summary:"Width of text in the model",since:6},{signature:"double TextRotationDegrees",summary:"Rotation of text in degrees",since:6},{signature:"double TextRotationRadians",summary:"Rotation of text in radians",since:6}],methods:[{signature:"static bool FirstCharProperties(string rtf_str,bool bold,bool italic,bool underline,string facename)",since:6},{signature:"static string FormatRtfString(string rtf_in,bool clear_bold,bool set_bold,bool clear_italic,bool set_italic,bool clear_underline,bool set_underline,bool clear_facename,bool set_facename,string facename)",since:6},{signature:"static double GetDimensionScale(RhinoDoc doc,DimensionStyle dimstyle,RhinoViewport vport)",summary:"Get view dependent dimension scale",since:6},{signature:"static string PlainTextToRtf(string str)",since:6},{signature:"bool ClearPropertyOverrides()",summary:"Clears all overriden properties for this annotation",since:6},{signature:"BoundingBox GetBoundingBox(Transform xform)",summary:"Aligned Boundingbox solver. Gets the world axis aligned boundingbox for the transformed geometry.",since:6.1,returns:"The boundingbox of the transformed geometry in world coordinates \n     or BoundingBox.Empty if not bounding box could be found."},{signature:"DimensionStyle GetDimensionStyle(DimensionStyle parentDimStyle)",summary:"Return the proper dimension style from which to get properties\n     for this annotation object\n     If this object has style overrides, those will be included in the \n     returned dimension style and the style will be updated to include\n     the current state of the parent style for non-overridden fields",since:6},{signature:"string GetPlainTextWithRunMap(int[] map)",summary:"Return plain text string for this annotation with field expressions unevaluated \n     intrunmap is an array of ints in groups of 3: run index, char pos start, length",since:7},{signature:"bool IsAllBold()",summary:"Returns True if all of the text in the annotation is Bold, otherwise returns false",since:6.22},{signature:"bool IsAllItalic()",summary:"Returns True if all of the text in the annotation is Italic, otherwise returns false",since:6.22},{signature:"bool IsAllUnderlined()",summary:"Returns True if all of the text in the annotation is Underlined, otherwise returns false",since:6.22},{signature:"bool IsPropertyOverridden(Field field)",summary:"Returns True if a property is overridden",since:6},{signature:"bool RunReplace(string repl_string,int start_run_idx,int start_run_pos,int end_run_idx,int end_run_pos)",summary:"Replace text within a formatted string",since:7},{signature:"bool SetBold(bool set_on)",since:6},{signature:"bool SetFacename(bool set_on,string facename)",since:6},{signature:"bool SetItalic(bool set_on)",since:6},{signature:"bool SetOverrideDimStyle(DimensionStyle OverrideStyle)",summary:"Set a style including overrides for this annotation object.\n     The DimensionStyle OverrideStyle must have the override fields marked \n     as overridden and must have it's Id set to nil.\n     Use DimensinoStyle.SetFieldOverride(Field field) and related functions\n     to manage override settings. To override a field, the field value must be set\n     and the field must be marked as an override. \n     The DimensionStyle passed in here must not be in the dimstyle table",since:6},{signature:"void SetRichText(string rtfText,DimensionStyle dimstyle)",since:6},{signature:"bool SetUnderline(bool set_on)",since:6},{signature:"void WrapText()",summary:"Wrap text",since:6}]},{name:"Rhino.Geometry.Arc",dataType:2,summary:"Represents the value of a plane, two angles and a radius in\n   a subcurve of a three-dimensional circle.\n   \n   The curve is parameterized by an angle expressed in radians. For an IsValid arc\n   the total subtended angle AngleRadians() = Domain()(1) - Domain()(0) must satisfy\n   0 < AngleRadians() < 2*PiThe parameterization of the Arc is inherited from the Circle it is derived from.\n   In particulart -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxiswhere xaxis and yaxis, (part of Circle.Plane) form an othonormal frame of the plane\n   containing the circle.",constructors:[{signature:"Arc(Circle circle,double angleRadians)",summary:"Initializes a new instance of an arc from a base circle and an angle.",since:5},{signature:"Arc(Circle circle,Interval angleIntervalRadians)",summary:"Initializes a new instance of an arc from a base circle and an interval of angles.",since:5},{signature:"Arc(Plane plane,double radius,double angleRadians)",summary:"Initializes a new arc from a base plane, a radius value and an angle.",since:5},{signature:"Arc(Plane plane,Point3d center,double radius,double angleRadians)",summary:"Initializes a new aligned arc at the given center point, with a custom radius and angle.",since:5},{signature:"Arc(Point3d center,double radius,double angleRadians)",summary:"Initializes a new horizontal arc at the given center point, with a custom radius and angle.",since:5},{signature:"Arc(Point3d startPoint,Point3d pointOnInterior,Point3d endPoint)",summary:"Initializes a new arc through three points. If the points are coincident \n     or colinear, this will result in an Invalid arc.",since:5},{signature:"Arc(Point3d pointA,Vector3d tangentA,Point3d pointB)",summary:"Initializes a new arc from end points and a tangent vector. \n     If the tangent is parallel with the endpoints this will result in an Invalid arc.",since:5}],properties:[{signature:"static Arc Unset",summary:"Gets an Arc with Unset components.",since:5},{signature:"double Angle",summary:"Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.",since:5},{signature:"double AngleDegrees",summary:"Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.",since:5},{signature:"Interval AngleDomain",summary:"Gets or sets the angle domain (in Radians) of this arc.",since:5},{signature:"Point3d Center",summary:"Gets or sets the center point for this arc.",since:5},{signature:"double Circumference",summary:"Gets the circumference of the circle that is coincident with this arc.",since:5},{signature:"double Diameter",summary:"Gets or sets the Diameter of this arc.",since:5},{signature:"double EndAngle",summary:"Gets or sets the end angle (in Radians) for this arc segment.",since:5},{signature:"double EndAngleDegrees",summary:"Gets or sets the end angle (in Radians) for this arc segment.",since:5},{signature:"Point3d EndPoint",summary:"Gets the end point of the arc.",since:5},{signature:"bool IsCircle",summary:"Gets a value indicating whether or not this arc is a complete circle.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether or not this arc is valid.\n     Detail:\n      Radius>0 and 0<AngleRadians()<=2*Math.Pi.",since:5},{signature:"double Length",summary:"Gets the length of the arc. (Length = Radius * (subtended angle in radians)).",since:5},{signature:"Point3d MidPoint",summary:"Gets the mid-point of the arc.",since:5},{signature:"Plane Plane",summary:"Gets or sets the plane in which this arc lies.",since:5},{signature:"double Radius",summary:"Gets or sets the radius of this arc.",since:5},{signature:"double StartAngle",summary:"Gets or sets the start angle (in Radians) for this arc segment.",since:5},{signature:"double StartAngleDegrees",summary:"Gets or sets the start angle (in Radians) for this arc segment.",since:5},{signature:"Point3d StartPoint",summary:"Gets the start point of the arc.",since:5}],methods:[{signature:"BoundingBox BoundingBox()",summary:"Computes the 3D axis aligned bounding box for this arc.",since:5,returns:"Bounding box of arc."},{signature:"double ClosestParameter(Point3d testPoint)",summary:"Gets parameter on the arc closest to a test point.",since:5,returns:"Parameter (in radians) of the point on the arc that\n     is closest to the test point. If testPoint is the center\n     of the arc, then the starting point of the arc is\n     (arc.Domain()[0]) returned. If no parameter could be found, \n     RhinoMath.UnsetValue is returned."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Computes the point on an arc that is closest to a test point.",since:5,returns:"The point on the arc that is closest to testPoint. If testPoint is\n     the center of the arc, then the starting point of the arc is returned.\n     UnsetPoint on failure."},{signature:"bool EpsilonEquals(Arc other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(Arc other)",summary:"Determines whether another arc has the same value as this arc.",since:5,returns:"True if obj is equal to this arc; otherwise false."},{signature:"bool Equals(object obj)",summary:"Determines whether another object is an arc and has the same value as this arc.",returns:"True if obj is an arc and is exactly equal to this arc; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash code for the present arc.",returns:"A non-unique integer that represents this arc."},{signature:"Point3d PointAt(double t)",summary:"Gets the point at the given arc parameter.",since:5,returns:"The point at the given parameter."},{signature:"void Reverse()",summary:"Reverses the orientation of the arc. Changes the domain from [a,b]\n     to [-b,-a].",since:5},{signature:"Vector3d TangentAt(double t)",summary:"Gets the tangent at the given parameter.",since:5,returns:"The tangent at the arc at the given parameter."},{signature:"NurbsCurve ToNurbsCurve()",summary:"Initializes a nurbs curve representation of this arc. \n     This amounts to the same as calling NurbsCurve.CreateFromArc().",since:5,returns:"A nurbs curve representation of this arc or None if no such representation could be made."},{signature:"NurbsCurve ToNurbsCurve(int degree,int cvCount)",summary:"Create a uniform non-ratonal cubic NURBS approximation of an arc.",since:6,returns:"NURBS curve approximation of an arc on success"},{signature:"bool Transform(Transform xform)",summary:"Transforms the arc using a Transformation matrix.",since:5,returns:"True on success, False on failure."},{signature:"bool Trim(Interval domain)",summary:"Sets arc's angle domain (in radians) as a subdomain of the circle.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.ArcCurve",dataType:1,summary:"Represent arcs and circles.\n   ArcCurve.IsCircle returns True if the curve is a complete circle.",constructors:[{signature:"ArcCurve()",summary:"Initializes a new  instance.\n     Radius is set to 1, position to Origin and Domain to full span (circle).",since:5},{signature:"ArcCurve(Arc arc)",summary:"Initializes a new  instance,\n     copying values from another .",since:5},{signature:"ArcCurve(Arc arc,double t0,double t1)",summary:"Initializes a new  instance,\n     copying values from another  and specifying the \n     needed parametrization of the arc.\n     Arc will not be cut again at these parameterizations.",since:5},{signature:"ArcCurve(ArcCurve other)",summary:"Initializes a new  instance,\n     copying values from another .",since:5},{signature:"ArcCurve(Circle circle)",summary:"Initializes a new  instance,\n     copying the shape of a .\n     Parameterization will be [0;circle.Circumference]",since:5},{signature:"ArcCurve(Circle circle,double t0,double t1)",summary:"Initializes a new  instance,\n     copying values from a  and specifying the \n     needed parametrization of the arc.\n     Circle will not be newly cut at these parameterizations.",since:5}],properties:[{signature:"double AngleDegrees",summary:"Gets the angles of this arc in degrees.",since:5},{signature:"double AngleRadians",summary:"Gets the angles of this arc in radians.",since:5},{signature:"Arc Arc",summary:"Gets the arc that is contained within this ArcCurve.",since:5},{signature:"bool IsCompleteCircle",summary:"Gets a value indicating whether or not this curve can be represented by a complete circle.",since:5},{signature:"double Radius",summary:"Gets the radius of this ArcCurve.",since:5}]},{name:"Rhino.Geometry.AreaMassProperties",dataType:1,summary:"Contains static initialization methods and allows access to the computed\n   metrics of area, area centroid and area moments in closed\n   planar curves, in meshes, in surfaces, in hatches and in boundary representations.",properties:[{signature:"double Area",summary:"Gets the area solution.",since:5},{signature:"double AreaError",summary:"Gets the uncertainty in the area calculation.",since:5},{signature:"Point3d Centroid",summary:"Gets the area centroid in the world coordinate system.",since:5},{signature:"Vector3d CentroidCoordinatesMomentsOfInertia",summary:"Moments of inertia with respect to centroid coordinate system.\n     X = integral of ((y-y0)^2 + (z-z0)^2) dm\n     Y = integral of ((z-z0)^2 + (x-x0)^2) dm\n     Z = integral of ((z-z0)^2 + (y-y0)^2) dm\n     where (x0,y0,z0) = centroid.",since:5},{signature:"Vector3d CentroidCoordinatesMomentsOfInertiaError",summary:"Uncertainty in centroid coordinates moments of inertia calculation.",since:5},{signature:"Vector3d CentroidCoordinatesRadiiOfGyration",summary:"Radii of gyration with respect to centroid coordinate system.\n     X = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)\n     Y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)\n     Z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)\n     where (x0,y0,z0) = centroid.",since:5},{signature:"Vector3d CentroidCoordinatesSecondMoments",summary:"Second moments with respect to centroid coordinate system.\n     X = integral of (x-x0)^2 dm\n     Y = integral of (y-y0)^2 dm\n     Z = integral of (z-z0)^2 dm\n     where (x0,y0,z0) = centroid.",since:5},{signature:"Vector3d CentroidCoordinatesSecondMomentsError",summary:"Uncertainty in centroid coordinates second moments calculation.",since:5},{signature:"Vector3d CentroidError",summary:"Gets the uncertainty in the centroid calculation.",since:5},{signature:"Vector3d WorldCoordinatesFirstMoments",summary:'Returns the world coordinate first moments if they were able to be calculated.\n     X is integral of "x dm" over the area\n     Y is integral of "y dm" over the area\n     Z is integral of "z dm" over the area.',since:5},{signature:"Vector3d WorldCoordinatesFirstMomentsError",summary:"Uncertainty in world coordinates first moments calculation.",since:5},{signature:"Vector3d WorldCoordinatesMomentsOfInertia",summary:"The moments of inertia about the world coordinate axes.\n     X = integral of (y^2 + z^2) dm\n     Y = integral of (z^2 + x^2) dm\n     Z = integral of (z^2 + y^2) dm.",since:5},{signature:"Vector3d WorldCoordinatesMomentsOfInertiaError",summary:"Uncertainty in world coordinates moments of inertia calculation.",since:5},{signature:"Vector3d WorldCoordinatesProductMoments",summary:'Returns the world coordinate product moments if they were able to be calculated.\n     X is integral of "xy dm" over the area\n     Y is integral of "yz dm" over the area\n     Z is integral of "zx dm" over the area.',since:5},{signature:"Vector3d WorldCoordinatesProductMomentsError",summary:"Uncertainty in world coordinates second moments calculation.",since:5},{signature:"Vector3d WorldCoordinatesRadiiOfGyration",summary:"Radii of gyration with respect to world coordinate system.\n     X = sqrt(integral of (y^2 + z^2) dm/M)\n     Y = sqrt(integral of (z^2 + x^2) dm/M)\n     Z = sqrt(integral of (z^2 + y^2) dm/M)",since:5},{signature:"Vector3d WorldCoordinatesSecondMoments",summary:'Returns the world coordinate first moments if they were able to be calculated.\n     X is integral of "xx dm" over the area\n     Y is integral of "yy dm" over the area\n     Z is integral of "zz dm" over the area.',since:5},{signature:"Vector3d WorldCoordinatesSecondMomentsError",summary:"Uncertainty in world coordinates second moments calculation.",since:5}],methods:[{signature:"static AreaMassProperties Compute(Brep brep)",summary:"Computes an AreaMassProperties for a brep.",since:5,returns:"The AreaMassProperties for the given Brep or None on failure."},{signature:"static AreaMassProperties Compute(Brep brep,bool area,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Compute the AreaMassProperties for a single Brep.",since:6.3,returns:"The AreaMassProperties for the given Brep or None on failure."},{signature:"static AreaMassProperties Compute(Curve closedPlanarCurve)",summary:"Computes an AreaMassProperties for a closed planar curve.",since:5,returns:"The AreaMassProperties for the given curve or None on failure."},{signature:"static AreaMassProperties Compute(Curve closedPlanarCurve,double planarTolerance)",summary:"Computes an AreaMassProperties for a closed planar curve.",since:5,returns:"The AreaMassProperties for the given curve or None on failure."},{signature:"static AreaMassProperties Compute(Hatch hatch)",summary:"Computes an AreaMassProperties for a hatch.",since:5,returns:"The AreaMassProperties for the given hatch or None on failure."},{signature:"static AreaMassProperties Compute(IEnumerable<GeometryBase> geometry)",summary:"Computes the Area properties for a collection of geometric objects. \n     At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.",since:5.1,returns:"The Area properties for the entire collection or None on failure."},{signature:"static AreaMassProperties Compute(IEnumerable<GeometryBase> geometry,bool area,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Computes the AreaMassProperties for a collection of geometric objects. \n     At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.",since:6.3,returns:"The AreaMassProperties for the entire collection or None on failure."},{signature:"static AreaMassProperties Compute(Mesh mesh)",summary:"Computes an AreaMassProperties for a mesh.",since:5,returns:"The AreaMassProperties for the given Mesh or None on failure."},{signature:"static AreaMassProperties Compute(Mesh mesh,bool area,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Compute the AreaMassProperties for a single Mesh.",since:6.3,returns:"The AreaMassProperties for the given Mesh or None on failure."},{signature:"static AreaMassProperties Compute(Surface surface)",summary:"Computes an AreaMassProperties for a surface.",since:5,returns:"The AreaMassProperties for the given Surface or None on failure."},{signature:"static AreaMassProperties Compute(Surface surface,bool area,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Compute the AreaMassProperties for a single Surface.",since:6.3,returns:"The AreaMassProperties for the given Surface or None on failure."},{signature:"bool CentroidCoordinatesPrincipalMoments(double x,Vector3d xaxis,double y,Vector3d yaxis,double z,Vector3d zaxis)",summary:"Calculates the principal moments and principal axes with repect to centroid coordinates. \n     These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.",since:6.9,returns:"True if successful."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"bool WorldCoordinatesPrincipalMoments(double x,Vector3d xaxis,double y,Vector3d yaxis,double z,Vector3d zaxis)",summary:"Calculates the principal moments and principal axes with repect to world coordinates. \n     These are simply the eigenvalues and eigenvectors of the world coordinate inertia matrix.",since:6.9,returns:"True if successful."}]},{name:"Rhino.Geometry.Arrowhead",dataType:1,summary:"Arrowhead used by annotation",constructors:[{signature:"Arrowhead()",summary:"Constructor",since:6},{signature:"Arrowhead(ArrowType arrowType,Guid blockId)",summary:"Constructor",since:6}],properties:[{signature:"ArrowType ArrowType",summary:"Type of arrowhead used by annotation",since:6},{signature:"Guid BlockId",summary:"Id of block used for user-defined arrowhead",since:6}]},{name:"Rhino.Geometry.BezierCurve",dataType:1,summary:"Represents a Bezier curve.\n   Note: as an exception, the bezier curve is not derived from .",constructors:[{signature:"BezierCurve(IEnumerable<Point2d> controlPoints)",summary:"Create bezier curve with controls defined by a list of 2d points",since:5},{signature:"BezierCurve(IEnumerable<Point3d> controlPoints)",summary:"Create bezier curve with controls defined by a list of 3d points",since:5},{signature:"BezierCurve(IEnumerable<Point4d> controlPoints)",summary:"Create bezier curve with controls defined by a list of 4d points",since:5}],properties:[{signature:"int ControlVertexCount",summary:"Number of control vertices in this curve",since:5},{signature:"int Dimension",summary:"Dimension of Bezier",since:6.3},{signature:"bool IsRational",summary:"Gets a value indicating whether or not the curve is rational. \n     Rational curves have control-points with custom weights.",since:5},{signature:"bool IsValid",summary:"Tests an object to see if it is valid.",since:5}],methods:[{signature:"static BezierCurve[] CreateBeziers(Curve sourceCurve)",summary:"Create an array of Bezier curves that fit to an existing curve. Please note, these\n     Beziers can be of any order and may be rational.",since:6,returns:"A new array of Bezier curves"},{signature:"static BezierCurve[] CreateCubicBeziers(Curve sourceCurve,double distanceTolerance,double kinkTolerance)",summary:"Constructs an array of cubic, non-rational beziers that fit a curve to a tolerance.",since:5,returns:"A new array of bezier curves. The array can be empty and might contain None items."},{signature:"static BezierCurve CreateLoftedBezier(IEnumerable<Point2d> points)",summary:"Loft a bezier through a list of points",since:5,returns:"new bezier curve if successful"},{signature:"static BezierCurve CreateLoftedBezier(IEnumerable<Point3d> points)",summary:"Loft a bezier through a list of points",since:5,returns:"new bezier curve if successful"},{signature:"bool ChangeDimension(int desiredDimension)",summary:"Change dimension of bezier.",since:5,returns:"True if successful.  False if desired_dimension < 1"},{signature:"Vector3d CurvatureAt(double t)",summary:"Evaluate the curvature vector at a curve parameter.",since:5,returns:"Curvature vector of the curve at the parameter t."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"BoundingBox GetBoundingBox(bool accurate)",summary:"Boundingbox solver. Gets the world axis aligned boundingbox for the curve.",since:5,returns:"The boundingbox of the geometry in world coordinates or BoundingBox.Empty \n     if not bounding box could be found."},{signature:"Point2d GetControlVertex2d(int index)",summary:"Get location of a control vertex.",since:5,returns:"If the bezier is rational, the euclidean location is returned."},{signature:"Point3d GetControlVertex3d(int index)",summary:"Get location of a control vertex.",since:5,returns:"If the bezier is rational, the euclidean location is returned."},{signature:"Point4d GetControlVertex4d(int index)",summary:"Get location of a control vertex.",since:5,returns:"Homogenous value of control vertex. If the bezier is not\n     rational, the weight is 1."},{signature:"void GetObjectData(SerializationInfo info,StreamingContext context)",summary:"Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.",since:6.3},{signature:"bool IncreaseDegree(int desiredDegree)",summary:"Increase degree of bezier",since:5,returns:"True if successful.  False if desiredDegree < current degree."},{signature:"bool MakeNonRational()",summary:"Make bezier non-rational",since:5,returns:"treu if successful"},{signature:"bool MakeRational()",summary:"Make bezier rational",since:5,returns:"True if successful"},{signature:"Point3d PointAt(double t)",summary:"Evaluates point at a curve parameter.",since:5,returns:"Point (location of curve at the parameter t)."},{signature:"bool Split(double t,BezierCurve left,BezierCurve right)",summary:"Divides the Bezier curve at the specified parameter.",since:6,returns:"True on success"},{signature:"Vector3d TangentAt(double t)",summary:"Evaluates the unit tangent vector at a curve parameter.",since:5,returns:"Unit tangent vector of the curve at the parameter t."},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a NURBS curve representation of this curve.",since:5,returns:"NURBS representation of the curve on success, None on failure."}]},{name:"Rhino.Geometry.BlendContinuity",dataType:3,summary:"Used in curve and surface blending functions"},{name:"Rhino.Geometry.BlendType",dataType:3,summary:"Blend types used for creating filleted Brep edges"},{name:"Rhino.Geometry.BoundingBox",dataType:2,summary:"Represents the value of two points in a bounding box \n   defined by the two extreme corner points.\n   This box is therefore aligned to the world X, Y and Z axes.",constructors:[{signature:"BoundingBox(double minX,double minY,double minZ,double maxX,double maxY,double maxZ)",summary:"Constructs a boundingbox from numeric extremes.",since:5},{signature:"BoundingBox(IEnumerable<Point3d> points)",summary:"Constructs a boundingbox from a collection of points.",since:5},{signature:"BoundingBox(IEnumerable<Point3d> points,Transform xform)",summary:"Constructs a boundingbox from a collection of points.",since:6},{signature:"BoundingBox(Point3d min,Point3d max)",summary:"Constructs a new boundingbox from two corner points.",since:5}],properties:[{signature:"static BoundingBox Empty",summary:"Gets an [Empty] boundingbox. An Empty box is an invalid structure that has negative width.",since:5},{signature:"static BoundingBox Unset",summary:"Gets a boundingbox that has Unset coordinates for Min and Max.",since:5},{signature:"double Area",summary:"Gets the area of this BoundingBox.",since:6},{signature:"Point3d Center",summary:"Gets the point in the center of the boundingbox.",since:5},{signature:"Vector3d Diagonal",summary:"Gets the diagonal vector of this BoundingBox. \n     The diagonal connects the Min and Max points.",since:5},{signature:"bool IsValid",summary:"Gets a value that indicates whether or not this boundingbox is valid. \n     Empty boxes are not valid, and neither are boxes with unset points.",since:5},{signature:"Point3d Max",summary:"Gets or sets the point in the maximal corner.",since:5},{signature:"Point3d Min",summary:"Gets or sets the point in the minimal corner.",since:5},{signature:"double Volume",summary:"Gets the volume of this BoundingBox.",since:6}],methods:[{signature:"static BoundingBox Intersection(BoundingBox a,BoundingBox b)",summary:"Computes the intersection of two bounding boxes.",since:5,returns:"The intersection bounding box."},{signature:"static BoundingBox Union(BoundingBox a,BoundingBox b)",summary:"Returns a new BoundingBox that represents the union of boxes a and b.",since:5,returns:"The BoundingBox that contains both a and b."},{signature:"static BoundingBox Union(BoundingBox box,Point3d point)",summary:"Returns a new BoundingBox that represents the union of a bounding box and a point.",since:5,returns:"The BoundingBox that contains both the box and the point."},{signature:"Point3d ClosestPoint(Point3d point)",summary:"Finds the closest point on or in the boundingbox.",since:5,returns:"The point on or in the box that is closest to the sample point."},{signature:"Point3d ClosestPoint(Point3d point,bool includeInterior)",summary:"Finds the closest point on or in the boundingbox.",since:5,returns:"The point on or in the box that is closest to the sample point."},{signature:"bool Contains(BoundingBox box)",summary:"Determines whether this boundingbox contains another boundingbox.\n     This is the same as calling Contains(box,false).",since:5,returns:"True if the box is on the inside of this boundingbox, or is coincident with the surface of it."},{signature:"bool Contains(BoundingBox box,bool strict)",summary:"Determines whether this boundingbox contains another boundingbox.\n     The user can choose how to treat boundingboxes with coincidents surfaces.",since:5,returns:"True if the box is (strictly) on the inside of this BoundingBox."},{signature:"bool Contains(Point3d point)",summary:"Tests a point for boundingbox inclusion. This is the same as calling Contains(point, false)",since:5,returns:"True if the point is on the inside of or coincident with this boundingbox; otherwise false."},{signature:"bool Contains(Point3d point,bool strict)",summary:"Tests a point for BoundingBox inclusion.",since:5,returns:"If 'strict' is affirmative, True if the point is inside this boundingbox; False if it is on the surface or outside.If 'strict' is negative, True if the point is on the surface or on the inside of the boundingbox; otherwise false."},{signature:"Point3d Corner(bool minX,bool minY,bool minZ)",summary:"Gets one of the eight corners of the box.",since:5,returns:"The requested point."},{signature:"Point3d FurthestPoint(Point3d point)",summary:"Finds the furthest point on the Box.",since:5,returns:"The point on the box that is furthest from the sample point."},{signature:"Point3d[] GetCorners()",summary:"Gets an array filled with the 8 corner points of this box.\n     See remarks for the return order.",since:5,returns:"An array of 8 corners."},{signature:"Line[] GetEdges()",summary:"Gets an array of the 12 edges of this box.",since:5,returns:"If the boundingbox IsValid, the 12 edges; otherwise, null."},{signature:"void Inflate(double amount)",summary:"Inflates the box with equal amounts in all directions. \n     Inflating with negative amounts may result in decreasing boxes. \n     Invalid boxes can not be inflated.",since:5},{signature:"void Inflate(double xAmount,double yAmount,double zAmount)",summary:"Inflate the box with custom amounts in all directions. \n     Inflating with negative amounts may result in decreasing boxes. \n     InValid boxes can not be inflated.",since:5},{signature:"int IsDegenerate(double tolerance)",summary:"Determines whether a bounding box is degenerate (flat) in one or more directions.",since:5,returns:"0 = box is not degenerate\n     1 = box is a rectangle (degenerate in one direction).\n     2 = box is a line (degenerate in two directions).\n     3 = box is a point (degenerate in three directions)\n     4 = box is not valid."},{signature:"bool MakeValid()",summary:"Ensures that the box is defined in an increasing fashion along X, Y and Z axes.\n     If the Min or Max points are unset, this function will not change the box.",since:5,returns:"True if the box was made valid, False if the box could not be made valid."},{signature:"Point3d PointAt(double tx,double ty,double tz)",summary:"Evaluates the boundingbox with normalized parameters.\n     The box has idealized side length of 1x1x1.",since:5,returns:"The point at the {tx, ty, tz} parameters."},{signature:"Brep ToBrep()",summary:"Constructs a  representation of this boundingbox.",since:5,returns:"If this operation is sucessfull, a Brep representation of this box; otherwise null."},{signature:"string ToString()",summary:"Constructs the string representation of this aligned boundingbox.",returns:"Text."},{signature:"bool Transform(Transform xform)",summary:"Updates this boundingbox to be the smallest axis aligned\n     boundingbox that contains the transformed result of its 8 original corner\n     points.",since:5,returns:"True if this operation is sucessfull; otherwise false."},{signature:"void Union(BoundingBox other)",summary:"Updates this BoundingBox to represent the union of itself and another box.",since:5},{signature:"void Union(Point3d point)",summary:"Updates this BoundingBox to represent the union of itself and a point.",since:5}]},{name:"Rhino.Geometry.Box",dataType:2,summary:"Represents the value of a plane and three intervals in\n   an orthogonal, oriented box that is not necessarily parallel to the world Y, X, Z axes.",constructors:[{signature:"Box(BoundingBox bbox)",summary:"Initializes a new Box that mimics a BoundingBox struct. \n     The orientation plane of the Box is coincident with the \n     World XY plane.",since:5},{signature:"Box(Plane basePlane,BoundingBox boundingbox)",summary:"Initializes a world aligned box from a base plane and a boundingbox.",since:5},{signature:"Box(Plane basePlane,GeometryBase geometry)",summary:"Initializes a box that contains a generic piece of geometry.\n     This box will be aligned with an arbitrary plane.",since:5},{signature:"Box(Plane basePlane,IEnumerable<Point3d> points)",summary:"Initializes the smallest box that contains a set of points.",since:5},{signature:"Box(Plane basePlane,Interval xSize,Interval ySize,Interval zSize)",summary:"Initializes a new box from a base Plane and three Intervals.",since:5}],properties:[{signature:"static Box Empty",summary:"Empty Box. Empty boxes are considered to be invalid.",since:5},{signature:"static Box Unset",summary:"Gets a Box whose base plane and axis dimensions are all Unset.",since:5},{signature:"double Area",summary:"Gets the total surface area of this box.",since:5},{signature:"BoundingBox BoundingBox",summary:"Gets the world axis aligned Bounding box for this oriented box.",since:5},{signature:"Point3d Center",summary:"Gets the point that is in the center of the box.",since:5},{signature:"bool IsValid",summary:"Gets the validity of this Box. Boxes are invalid when the base plane or any of \n     the dimension intervals are invalid or decreasing.",since:5},{signature:"Plane Plane",summary:"Gets or sets the orientation plane for this Box.",since:5},{signature:"double Volume",summary:"Gets the total volume of this box.",since:5},{signature:"Interval X",summary:"Gets or sets the Interval that describes the dimension of the \n     Box along the orientation plane X-Axis. Otherwise known as the Width of the Box.",since:5},{signature:"Interval Y",summary:"Gets or sets the Interval that describes the dimension of the \n     Box along the orientation plane Y-Axis. Otherwise known as the Depth of the Box.",since:5},{signature:"Interval Z",summary:"Gets or sets the Interval that describes the dimension of the \n     Box along the orientation plane Z-Axis. Otherwise known as the Height of the Box.",since:5}],methods:[{signature:"Point3d ClosestPoint(Point3d point)",summary:"Finds the closest point on or in the Box. The box should be Valid for this to work.",since:5,returns:"The point on or in the box that is closest to the sample point."},{signature:"bool Contains(BoundingBox box)",summary:"Test a boundingbox for Box inclusion. This is the same as calling Contains(box,false)",since:5,returns:"True if the box is on the inside of or coincident with this Box."},{signature:"bool Contains(BoundingBox box,bool strict)",summary:"Test a boundingbox for Box inclusion.",since:5,returns:"True if the box is (strictly) on the inside of this Box."},{signature:"bool Contains(Box box)",summary:"Test a box for Box inclusion. This is the same as calling Contains(box,false)",since:5,returns:"True if the box is on the inside of or coincident with this Box."},{signature:"bool Contains(Box box,bool strict)",summary:"Test a box for Box inclusion.",since:5,returns:"True if the box is (strictly) on the inside of this Box."},{signature:"bool Contains(Point3d point)",summary:"Determines whether a point is included in this box. This is the same as calling Contains(point,false)",since:5,returns:"True if the point is on the inside of or coincident with this Box."},{signature:"bool Contains(Point3d point,bool strict)",summary:"Determines whether a point is included in this box.",since:5,returns:"True if the point is (strictly) on the inside of this Box."},{signature:"bool EpsilonEquals(Box other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"Point3d FurthestPoint(Point3d point)",summary:"Finds the furthest point on the Box. The Box should be Valid for this to work properly.",since:5,returns:"The point on the box that is furthest from the sample point."},{signature:"Point3d[] GetCorners()",summary:"Gets an array of the 8 corner points of this box.",since:5,returns:"An array of 8 corners."},{signature:"void Inflate(double amount)",summary:"Inflates the box by a given offset in each direction.\n     Inflating with negative amounts may result in decreasing boxes. \n     InValid boxes cannot be inflated.",since:5},{signature:"void Inflate(double xAmount,double yAmount,double zAmount)",summary:"Inflates the box by a given offset in each direction.\n     Inflating with negative amounts may result in decreasing boxes.\n     InValid boxes cannot be inflated.",since:5},{signature:"bool MakeValid()",summary:"Attempts to make the Box valid. This is not always possible.",since:5,returns:"True if the box was made valid, or if it was valid to begin with. \n     False if the box remains in a differently abled state."},{signature:"Point3d PointAt(double x,double y,double z)",summary:"Evaluates the box volume at the given unitized parameters.\n     The box has idealized side length of 1x1x1.",since:5,returns:"The point at (x,y,z)."},{signature:"void RepositionBasePlane(Point3d origin)",summary:"Repositions the origin of the Base plane for this box without affecting \n     the physical dimensions.",since:5},{signature:"Brep ToBrep()",summary:"Constructs a brep representation of this box.",since:5,returns:"A Brep representation of this box or null."},{signature:"Extrusion ToExtrusion()",summary:"Constructs an extrusion representation of this box.",since:6,returns:"An Extrusion representation of this box or null."},{signature:"bool Transform(Transform xform)",summary:"Transforms this Box using a Transformation matrix. If the Transform does not preserve \n     Similarity, the dimensions of the resulting box cannot be trusted.",since:5,returns:"True if the Box was successfully transformed, False if otherwise."},{signature:"void Union(Point3d point)",summary:"Constructs a union between this Box and the given point. \n     This grows the box in directions so it contains the point.",since:5}]},{name:"Rhino.Geometry.Brep",dataType:1,summary:"Boundary Representation. A surface or polysurface along with trim curve information.",constructors:[{signature:"Brep()",summary:"Initializes a new empty brep",since:5.4}],properties:[{signature:"BrepCurveList Curves2D",summary:"Parameter space trimming curves (used by trims)",since:5.6},{signature:"BrepCurveList Curves3D",summary:"Pointers to 3d curves (used by edges)",since:5.6},{signature:"BrepEdgeList Edges",summary:"Gets the brep edges list accessor.",since:5},{signature:"BrepFaceList Faces",summary:"Gets the brep faces list accessor.",since:5},{signature:"bool IsManifold",summary:"Gets a value indicating whether or not the Brep is manifold. \n     Non-Manifold breps have at least one edge that is shared among three or more faces.",since:5},{signature:"bool IsSolid",summary:"Determines whether this brep is a solid, or a closed oriented manifold.",since:5},{signature:"bool IsSurface",summary:"Returns True if the Brep has a single face and that face is geometrically the same\n     as the underlying surface.  I.e., the face has trivial trimming.\n     In this case, the surface is the first face surface. The flag\n     Brep.Faces[0].OrientationIsReversed records the correspondence between the surface's\n     natural parametric orientation and the orientation of the Brep.trivial trimming here means that there is only one loop curve in the brep\n     and that loop curve is the same as the underlying surface boundary.",since:5},{signature:"BrepLoopList Loops",summary:"Gets the brep loop list accessor.",since:5},{signature:"BrepSolidOrientation SolidOrientation",summary:"Gets the solid orientation state of this Brep.",since:5},{signature:"BrepSurfaceList Surfaces",summary:"Parametric surfaces used by faces",since:5.4},{signature:"BrepTrimList Trims",summary:"Gets the brep trims list accessor.",since:5.1},{signature:"BrepVertexList Vertices",summary:"Gets the brep vertices list accessor.",since:5.5}],methods:[{signature:"static Brep ChangeSeam(BrepFace face,int direction,double parameter,double tolerance)",summary:"Change the seam of a closed trimmed surface.",since:6.4,returns:"A new Brep that has the same geoemtry as the face with a relocated seam if successful, or None on failure."},{signature:"static Brep CopyTrimCurves(BrepFace trimSource,Surface surfaceSource,double tolerance)",summary:"Copy all trims from a Brep face onto a surface.",since:5,returns:"A brep with the shape of surfaceSource and the trims of trimSource or None on failure."},{signature:"static Brep CreateBaseballSphere(Point3d center,double radius,double tolerance)",summary:"Creates a brep representation of the sphere with two similar trimmed NURBS surfaces, and no singularities.",since:6,returns:"A new brep, or None on error."},{signature:"static Curve CreateBlendShape(BrepFace face0,BrepEdge edge0,double t0,bool rev0,BlendContinuity continuity0,BrepFace face1,BrepEdge edge1,double t1,bool rev1,BlendContinuity continuity1)",summary:"Makes a curve blend between points on two surface edges. The blend will be tangent to the surfaces and perpendicular to the edges.",since:6,returns:"The blend curve on success. None on failure"},{signature:"static Brep[] CreateBlendSurface(BrepFace face0,BrepEdge edge0,Interval domain0,bool rev0,BlendContinuity continuity0,BrepFace face1,BrepEdge edge1,Interval domain1,bool rev1,BlendContinuity continuity1)",summary:"Makes a surface blend between two surface edges.",since:6,returns:"Array of Breps if successful."},{signature:"static Brep[] CreateBooleanDifference(Brep firstBrep,Brep secondBrep,double tolerance)",summary:"Compute the Solid Difference of two Breps.",since:5,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanDifference(Brep firstBrep,Brep secondBrep,double tolerance,bool manifoldOnly)",summary:"Compute the Solid Difference of two Breps.",since:6,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance)",summary:"Compute the Solid Difference of two sets of Breps.",since:5,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanDifference(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance,bool manifoldOnly)",summary:"Compute the Solid Difference of two sets of Breps.",since:6,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanIntersection(Brep firstBrep,Brep secondBrep,double tolerance)",summary:"Compute the Solid Intersection of two Breps.",since:5,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanIntersection(Brep firstBrep,Brep secondBrep,double tolerance,bool manifoldOnly)",summary:"Compute the Solid Intersection of two Breps.",since:6,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanIntersection(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance)",summary:"Compute the Solid Intersection of two sets of Breps.",since:5,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanIntersection(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance,bool manifoldOnly)",summary:"Compute the Solid Intersection of two sets of Breps.",since:6,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanSplit(Brep firstBrep,Brep secondBrep,double tolerance)",summary:"Splits shared areas of Breps and creates separate Breps from the shared and unshared parts.",since:6.16,returns:"An array of Brep if successful, an empty array on failure."},{signature:"static Brep[] CreateBooleanSplit(IEnumerable<Brep> firstSet,IEnumerable<Brep> secondSet,double tolerance)",summary:"Splits shared areas of Breps and creates separate Breps from the shared and unshared parts.",since:6.16,returns:"An array of Brep if successful, an empty array on failure."},{signature:"static Brep[] CreateBooleanUnion(IEnumerable<Brep> breps,double tolerance)",summary:"Compute the Boolean Union of a set of Breps.",since:5,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateBooleanUnion(IEnumerable<Brep> breps,double tolerance,bool manifoldOnly)",summary:"Compute the Boolean Union of a set of Breps.",since:6,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateChamferSurface(BrepFace face0,Point2d uv0,double radius0,BrepFace face1,Point2d uv1,double radius1,bool trim,bool extend,double tolerance,Brep[] outBreps0,Brep[] outBreps1)",summary:"Creates a ruled surface as a bevel between two input surface edges.",since:6,returns:"Array of Breps if successful."},{signature:"static Brep[] CreateChamferSurface(BrepFace face0,Point2d uv0,double radius0,BrepFace face1,Point2d uv1,double radius1,bool extend,double tolerance)",summary:"Creates a ruled surface as a bevel between two input surface edges.",since:6,returns:"Array of Breps if successful."},{signature:"static Curve[] CreateContourCurves(Brep brepToContour,Plane sectionPlane)",summary:"Constructs the contour curves for a brep, using a slicing plane.",since:5,returns:"An array with intersected curves. This array can be empty."},{signature:"static Curve[] CreateContourCurves(Brep brepToContour,Point3d contourStart,Point3d contourEnd,double interval)",summary:"Constructs the contour curves for a brep at a specified interval.",since:5,returns:"An array with intersected curves. This array can be empty."},{signature:"static Mesh[] CreateCurvatureAnalysisMesh(Brep brep,CurvatureAnalysisSettingsState state)",summary:"Create an array of analysis meshes for the brep using the specified settings.\n     Meshes aren't set on the brep.",since:6,returns:"True if meshes were created"},{signature:"static Brep[] CreateDevelopableLoft(Curve crv0,Curve crv1,bool reverse0,bool reverse1,int density)",summary:"Creates a single developable surface between two curves.",since:6.1,returns:"The output Breps if successful, otherwise an empty array."},{signature:"static Brep[] CreateDevelopableLoft(NurbsCurve rail0,NurbsCurve rail1,IEnumerable<Point2d> fixedRulings)",summary:"Creates a single developable surface between two curves.",since:6.1,returns:"The output Breps if successful, otherwise an empty array."},{signature:"static Brep CreateEdgeSurface(IEnumerable<Curve> curves)",summary:"Constructs a coons patch from 2, 3, or 4 curves.",since:5,returns:"resulting brep or None on failure."},{signature:"static Brep[] CreateFilletEdges(Brep brep,IEnumerable<int> edgeIndices,IEnumerable<double> startRadii,IEnumerable<double> endRadii,BlendType blendType,RailType railType,double tolerance)",summary:"Fillets, chamfers, or blends the edges of a brep.",since:6,returns:"Array of Breps if successful."},{signature:"static Brep[] CreateFilletSurface(BrepFace face0,Point2d uv0,BrepFace face1,Point2d uv1,double radius,bool trim,bool extend,double tolerance,Brep[] outBreps0,Brep[] outBreps1)",summary:"Creates a constant-radius round surface between two surfaces.",since:6,returns:"Array of Breps if successful."},{signature:"static Brep[] CreateFilletSurface(BrepFace face0,Point2d uv0,BrepFace face1,Point2d uv1,double radius,bool extend,double tolerance)",summary:"Creates a constant-radius round surface between two surfaces.",since:6,returns:"Array of Breps if successful."},{signature:"static Brep CreateFromBox(BoundingBox box)",summary:"Constructs new brep that matches a bounding box.",since:5,returns:"A new brep; or None on failure."},{signature:"static Brep CreateFromBox(Box box)",summary:"Constructs new brep that matches an aligned box.",since:5,returns:"A Brep with 6 faces that is similar to the Box."},{signature:"static Brep CreateFromBox(IEnumerable<Point3d> corners)",summary:"Constructs new brep from 8 corner points.",since:5,returns:"A new brep, or None on error."},{signature:"static Brep CreateFromCone(Cone cone,bool capBottom)",summary:"Constructs a Brep representation of the cone with a single\n     face for the cone, an edge along the cone seam, \n     and vertices at the base and apex ends of this seam edge.\n     The optional cap is a single face with one circular edge \n     starting and ending at the base vertex.",since:5,returns:"A Brep if successful, None on error."},{signature:"static Brep CreateFromCornerPoints(Point3d corner1,Point3d corner2,Point3d corner3,double tolerance)",summary:"Makes a brep with one face.",since:5,returns:"A boundary representation, or None on error."},{signature:"static Brep CreateFromCornerPoints(Point3d corner1,Point3d corner2,Point3d corner3,Point3d corner4,double tolerance)",summary:"make a Brep with one face.",since:5,returns:"A boundary representation, or None on error."},{signature:"static Brep CreateFromCylinder(Cylinder cylinder,bool capBottom,bool capTop)",summary:"Constructs a Brep definition of a cylinder.",since:5,returns:"A Brep representation of the cylinder with a single face for the cylinder,\n     an edge along the cylinder seam, and vertices at the bottom and top ends of this\n     seam edge. The optional bottom/top caps are single faces with one circular edge\n     starting and ending at the bottom/top vertex."},{signature:"static Brep CreateFromJoinedEdges(Brep brep0,int edgeIndex0,Brep brep1,int edgeIndex1,double joinTolerance)",summary:"Joins two naked edges, or edges that are coincident or close together, from two Breps.",since:6,returns:"The resulting Brep if successful, None on failure."},{signature:"static Brep[] CreateFromLoft(IEnumerable<Curve> curves,Point3d start,Point3d end,LoftType loftType,bool closed)",summary:"Constructs one or more Breps by lofting through a set of curves.",since:5,returns:"Constructs a closed surface, continuing the surface past the last curve around to the\n     first curve. Available when you have selected three shape curves."},{signature:"static Brep[] CreateFromLoftRebuild(IEnumerable<Curve> curves,Point3d start,Point3d end,LoftType loftType,bool closed,int rebuildPointCount)",summary:"Constructs one or more Breps by lofting through a set of curves. Input for the loft is simplified by\n     rebuilding to a specified number of control points.",since:5,returns:"Constructs a closed surface, continuing the surface past the last curve around to the\n     first curve. Available when you have selected three shape curves."},{signature:"static Brep[] CreateFromLoftRefit(IEnumerable<Curve> curves,Point3d start,Point3d end,LoftType loftType,bool closed,double refitTolerance)",summary:"Constructs one or more Breps by lofting through a set of curves. Input for the loft is simplified by\n     refitting to a specified tolerance.",since:5,returns:"Constructs a closed surface, continuing the surface past the last curve around to the\n     first curve. Available when you have selected three shape curves."},{signature:"static Brep CreateFromMesh(Mesh mesh,bool trimmedTriangles)",summary:"Create a brep representation of a mesh",since:5.1},{signature:"static Brep CreateFromOffsetFace(BrepFace face,double offsetDistance,double offsetTolerance,bool bothSides,bool createSolid)",summary:"Offsets a face including trim information to create a new brep.",since:5,returns:"A new brep if successful. The brep can be disjoint if bothSides is True and createSolid is false,\n     or if createSolid is True and connecting the offsets with side surfaces fails.\n     None if unsuccessful."},{signature:"static Brep CreateFromRevSurface(RevSurface surface,bool capStart,bool capEnd)",summary:"Constructs a brep form of a surface of revolution.",since:5,returns:"A Brep if successful, None on error."},{signature:"static Brep CreateFromSphere(Sphere sphere)",summary:"Constructs a Brep definition of a sphere.",since:5,returns:"A Brep if successful, None on error."},{signature:"static Brep CreateFromSurface(Surface surface)",summary:"Constructs a Brep from a surface. The resulting Brep has an outer boundary made\n     from four trims. The trims are ordered so that they run along the south, east,\n     north, and then west side of the surface's parameter space.",since:5,returns:"Resulting brep or None on failure."},{signature:"static Brep[] CreateFromSweep(Curve rail,Curve shape,bool closed,double tolerance)",summary:"Sweep1 function that fits a surface through a profile curve that define the surface cross-sections\n     and one curve that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweep(Curve rail1,Curve rail2,Curve shape,bool closed,double tolerance)",summary:"General 2 rail sweep. If you are not producing the sweep results that you are after, then\n     use the SweepTwoRail class with options to generate the swept geometry.",since:5,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweep(Curve rail1,Curve rail2,IEnumerable<Curve> shapes,bool closed,double tolerance)",summary:"General 2 rail sweep. If you are not producing the sweep results that you are after, then\n     use the SweepTwoRail class with options to generate the swept geometry.",since:5,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweep(Curve rail1,Curve rail2,IEnumerable<Curve> shapes,Point3d start,Point3d end,bool closed,double tolerance,SweepRebuild rebuild,int rebuildPointCount,double refitTolerance,bool preserveHeight)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:6.16,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweep(Curve rail,IEnumerable<Curve> shapes,bool closed,double tolerance)",summary:"Sweep1 function that fits a surface through profile curves that define the surface cross-sections\n     and one curve that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweepInParts(Curve rail1,Curve rail2,IEnumerable<Curve> shapes,IEnumerable<Point2d> rail_params,bool closed,double tolerance)",summary:"Makes a 2 rail sweep. Like CreateFromSweep but the result is split where parameterization along a rail changes abruptly.",since:6,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweepSegmented(Curve rail,Curve shape,bool closed,double tolerance)",summary:"Sweep1 function that fits a surface through a profile curve that define the surface cross-sections\n     and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks\n     and sweeps each piece separately, then put the results together into a Brep.",since:6.14,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromSweepSegmented(Curve rail,IEnumerable<Curve> shapes,bool closed,double tolerance)",summary:"Sweep1 function that fits a surface through a series of profile curves that define the surface cross-sections\n     and one curve that defines a surface edge. The Segmented version breaks the rail at curvature kinks\n     and sweeps each piece separately, then put the results together into a Brep.",since:6.14,returns:"Array of Brep sweep results"},{signature:"static Brep[] CreateFromTaperedExtrude(Curve curveToExtrude,double distance,Vector3d direction,Point3d basePoint,double draftAngleRadians,ExtrudeCornerType cornerType)",summary:"Extrude a curve to a taper making a brep (potentially more than 1)",since:5.1,returns:"array of breps on success"},{signature:"static Brep[] CreateFromTaperedExtrude(Curve curveToExtrude,double distance,Vector3d direction,Point3d basePoint,double draftAngleRadians,ExtrudeCornerType cornerType,double tolerance,double angleToleranceRadians)",summary:"Extrude a curve to a taper making a brep (potentially more than 1)",since:6,returns:"array of breps on success"},{signature:"static Brep[] CreateFromTaperedExtrudeWithRef(Curve curve,Vector3d direction,double distance,double draftAngle,Plane plane,double tolerance)",summary:"Creates one or more Breps by extruding a curve a distance along an axis with draft angle.",since:6.14,returns:"An array of Breps if successful."},{signature:"static Brep[] CreateOffsetBrep(Brep brep,double distance,bool solid,bool extend,double tolerance,Brep[] outBlends,Brep[] outWalls)",summary:"Offsets a Brep.",since:6,returns:"Array of Breps if successful. If the function succeeds in offsetting, a\n     single Brep will be returned. Otherwise, the array will contain the \n     offset surfaces, outBlends will contain the set of blends used to fill\n     in gaps (if extend is false), and outWalls will contain the set of wall\n     surfaces that was supposed to join the offset to the original (if solid\n     is true)."},{signature:"static Brep CreatePatch(IEnumerable<GeometryBase> geometry,int uSpans,int vSpans,double tolerance)",summary:"Constructs a brep patch.\n     This is the simple version of fit that uses a plane with u x v spans.\n     It makes a plane by fitting to the points from the input geometry to use as the starting surface.\n     The surface has the specified u and v span count.",since:5,returns:"A brep fit through input on success, or None on error."},{signature:"static Brep CreatePatch(IEnumerable<GeometryBase> geometry,Surface startingSurface,double tolerance)",summary:"Constructs a brep patch.\n     This is the simple version of fit that uses a specified starting surface.",since:5,returns:"Brep fit through input on success, or None on error."},{signature:"static Brep CreatePatch(IEnumerable<GeometryBase> geometry,Surface startingSurface,int uSpans,int vSpans,bool trim,bool tangency,double pointSpacing,double flexibility,double surfacePull,bool[] fixEdges,double tolerance)",summary:"Constructs a brep patch using all controls",since:5,returns:"A brep fit through input on success, or None on error."},{signature:"static Brep[] CreatePipe(Curve rail,double radius,bool localBlending,PipeCapMode cap,bool fitRail,double absoluteTolerance,double angleToleranceRadians)",summary:"Creates a single walled pipe",since:5,returns:"Array of created pipes on success"},{signature:"static Brep[] CreatePipe(Curve rail,IEnumerable<double> railRadiiParameters,IEnumerable<double> radii,bool localBlending,PipeCapMode cap,bool fitRail,double absoluteTolerance,double angleToleranceRadians)",summary:"Creates a single walled pipe",since:5,returns:"Array of created pipes on success"},{signature:"static Brep[] CreatePlanarBreps(Curve inputLoop)",summary:"Constructs a set of planar breps as outlines by the loops.",since:5,returns:"An array of Planar Breps."},{signature:"static Brep[] CreatePlanarBreps(Curve inputLoop,double tolerance)",summary:"Constructs a set of planar breps as outlines by the loops.",since:6,returns:"An array of Planar Breps."},{signature:"static Brep[] CreatePlanarBreps(CurveList inputLoops)",summary:"Constructs a set of planar Breps as outlines by the loops.",since:5,returns:"An array of Planar Breps or None on error."},{signature:"static Brep[] CreatePlanarBreps(CurveList inputLoops,double tolerance)",summary:"Constructs a set of planar Breps as outlines by the loops.",since:6,returns:"An array of Planar Breps."},{signature:"static Brep[] CreatePlanarBreps(IEnumerable<Curve> inputLoops)",summary:"Constructs a set of planar breps as outlines by the loops.",since:5,returns:"An array of Planar Breps."},{signature:"static Brep[] CreatePlanarBreps(IEnumerable<Curve> inputLoops,double tolerance)",summary:"Constructs a set of planar breps as outlines by the loops.",since:6,returns:"An array of Planar Breps."},{signature:"static Brep CreateQuadSphere(Sphere sphere)",summary:"Constructs a Brep definition of a quad sphere.",since:6,returns:"A Brep if successful, None on error."},{signature:"static Brep[] CreateShell(Brep brep,IEnumerable<int> facesToRemove,double distance,double tolerance)",summary:"Creates a hollowed out shell from a solid Brep. Function only operates on simple, solid, manifold Breps.",since:5.4,returns:"An array of Brep results or None on failure."},{signature:"static Brep[] CreateSolid(IEnumerable<Brep> breps,double tolerance)",summary:"Constructs closed polysurfaces from surfaces and polysurfaces that bound a region in space.",since:5,returns:"The resulting polysurfaces on success or None on failure."},{signature:"static Brep CreateTrimmedPlane(Plane plane,Curve curve)",summary:"Create a Brep trimmed plane.",since:6,returns:"Resulting brep or None on failure."},{signature:"static Brep CreateTrimmedPlane(Plane plane,IEnumerable<Curve> curves)",summary:"Create a Brep trimmed plane.",since:6,returns:"Resulting brep or None on failure."},{signature:"static Brep CreateTrimmedSurface(BrepFace trimSource,Surface surfaceSource)",summary:"Constructs a Brep using the trimming information of a brep face and a surface. \n     Surface must be roughly the same shape and in the same location as the trimming brep face.",since:5,returns:"A brep with the shape of surfaceSource and the trims of trimSource or None on failure."},{signature:"static Brep CreateTrimmedSurface(BrepFace trimSource,Surface surfaceSource,double tolerance)",summary:"Constructs a Brep using the trimming information of a brep face and a surface. \n     Surface must be roughly the same shape and in the same location as the trimming brep face.",since:6,returns:"A brep with the shape of surfaceSource and the trims of trimSource or None on failure."},{signature:"static Brep[] JoinBreps(IEnumerable<Brep> brepsToJoin,double tolerance)",summary:"Joins the breps in the input array at any overlapping edges to form\n     as few as possible resulting breps. There may be more than one brep in the result array.",since:5,returns:"new joined breps on success, None on failure."},{signature:"static Brep MergeBreps(IEnumerable<Brep> brepsToMerge,double tolerance)",summary:"Combines two or more breps into one. A merge is like a boolean union that keeps the inside pieces. This\n     function creates non-manifold Breps which in general are unusual in Rhino. You may want to consider using\n     JoinBreps or CreateBooleanUnion functions instead.",since:5,returns:"Single merged Brep on success. Null on error."},{signature:"static Brep MergeSurfaces(Brep brep0,Brep brep1,double tolerance,double angleToleranceRadians)",summary:"Merges two surfaces into one surface at untrimmed edges. Both surfaces must be untrimmed and share an edge.",since:6,returns:"The merged Brep if successful, None if not successful."},{signature:"static Brep MergeSurfaces(Brep brep0,Brep brep1,double tolerance,double angleToleranceRadians,Point2d point0,Point2d point1,double roundness,bool smooth)",summary:"Merges two surfaces into one surface at untrimmed edges. Both surfaces must be untrimmed and share an edge.",since:6,returns:"The merged Brep if successful, None if not successful."},{signature:"static Brep MergeSurfaces(Surface surface0,Surface surface1,double tolerance,double angleToleranceRadians)",summary:"Merges two surfaces into one surface at untrimmed edges.",since:6,returns:"The merged surfaces as a Brep if successful, None if not successful."},{signature:"static Brep TryConvertBrep(GeometryBase geometry)",summary:"Attempts to convert a generic Geometry object into a Brep.",since:5,returns:"Brep if a brep form could be created or None if this is not possible. If geometry was of type Brep to \n     begin with, the same object is returned, i.e. it is not duplicated."},{signature:"int AddEdgeCurve(Curve curve)",summary:"Add a 3d curve used by the brep edges",since:5.4,returns:"Index used to reference this geometry in the edge curve list"},{signature:"int AddSurface(Surface surface)",summary:"Adds a 3D surface used by BrepFace.",since:5,returns:"Index that should be used to reference the geometry.\n     -1 is returned if the input is not acceptable."},{signature:"int AddTrimCurve(Curve curve)",summary:"Add a 2d curve used by the brep trims",since:5.4,returns:"Index used to reference this geometry in the trimming curve list"},{signature:"void Append(Brep other)",summary:"Appends a copy of another brep to this and updates indices of appended\n     brep parts.  Duplicates are not removed",since:5.4},{signature:"Brep CapPlanarHoles(double tolerance)",summary:"Returns a new Brep that is equivalent to this Brep with all planar holes capped.",since:5,returns:"New brep on success. None on error."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Finds a point on the brep that is closest to testPoint.",since:5,returns:"The point on the Brep closest to testPoint or Point3d.Unset if the operation failed."},{signature:"bool ClosestPoint(Point3d testPoint,Point3d closestPoint,ComponentIndex ci,double s,double t,double maximumDistance,Vector3d normal)",summary:"Finds a point on a Brep that is closest to testPoint.\n     The method searches all Brep faces looking for the one closest to testPoint.\n     When found, if the closest point falls on the inactive region of the face, then \n     the method finds the face's edge that is closest to testPoint.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"void Compact()",summary:"Deletes any unreferenced objects from arrays, reindexes as needed, and\n     shrinks arrays to minimum required size. Uses CUllUnused* members to\n     delete any unreferenced objects from arrays.",since:5},{signature:"bool CullUnused2dCurves()",summary:"Culls 3d curves not referenced by an edge.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnused3dCurves()",summary:"Culls 2d curves not referenced by a trim.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnusedEdges()",summary:"Culls edges with m_edge_index == -1.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnusedFaces()",summary:"Culls faces with m_face_index == -1.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnusedLoops()",summary:"Culls loops with m_loop_index == -1.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnusedSurfaces()",summary:"Culls surfaces not referenced by a face.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnusedTrims()",summary:"Culls trims with m_trim_index == -1.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"bool CullUnusedVertices()",summary:"Culls vertices with m_vertex_index == -1.",since:5,returns:"True if operation succeeded; False otherwise."},{signature:"GeometryBase Duplicate()",summary:"Copies this brep.",since:5,returns:"A brep."},{signature:"Brep DuplicateBrep()",summary:"Same as , but already performs a cast to a brep.\n     This cast always succeeds.",since:5,returns:"A brep."},{signature:"Curve[] DuplicateEdgeCurves()",summary:"Duplicate all the edges of this Brep.",since:5,returns:"An array of edge curves."},{signature:"Curve[] DuplicateEdgeCurves(bool nakedOnly)",summary:"Duplicate edges of this Brep.",since:5,returns:"Array of edge curves on success."},{signature:"Curve[] DuplicateNakedEdgeCurves(bool outer,bool inner)",summary:"Duplicate naked edges of this Brep",since:5.7},{signature:"Brep DuplicateSubBrep(IEnumerable<int> faceIndices)",summary:"Copy a subset of this Brep into another Brep.",since:5,returns:"A brep, or None on error."},{signature:"Point3d[] DuplicateVertices()",summary:"Duplicate all the corner vertices of this Brep.",since:5,returns:"An array or corner vertices."},{signature:"void FindCoincidentBrepComponents(Point3d point,double tolerance,int[] faces,int[] edges,int[] vertices)",summary:"Find the indices of all brep faces, edges and vertices that are within tolerance of a test-point.",since:6.2},{signature:"void Flip()",summary:"Reverses entire brep orientation of all faces.",since:5},{signature:"double GetArea()",summary:"Compute the Area of the Brep. If you want proper Area data with moments \n     and error information, use the AreaMassProperties class.",since:5,returns:"The area of the Brep."},{signature:"double GetArea(double relativeTolerance,double absoluteTolerance)",summary:"Compute the Area of the Brep. If you want proper Area data with moments \n     and error information, use the AreaMassProperties class.",since:5,returns:"The area of the Brep."},{signature:"bool GetPointInside(double tolerance,Point3d point)",summary:"Finds a point inside of a solid Brep.",since:6.19,returns:"Returns False if the input is not solid and manifold, if the Brep's bounding box is less than 2.0 * tolerance wide, \n     or if no point could be found due to ray shooting or other errors. Otherwise, True is returned."},{signature:"BrepRegion[] GetRegions()",summary:"Gets an array containing all regions in this brep.",since:5,returns:"An array of regions in this brep. This array can be empty, but not null."},{signature:"double GetVolume()",summary:"Compute the Volume of the Brep. If you want proper Volume data with moments \n     and error information, use the VolumeMassProperties class.",since:5,returns:"The volume of the Brep."},{signature:"double GetVolume(double relativeTolerance,double absoluteTolerance)",summary:"Compute the Volume of the Brep. If you want proper Volume data with moments \n     and error information, use the VolumeMassProperties class.",since:5,returns:"The volume of the Brep."},{signature:"Curve[] GetWireframe(int density)",summary:"Constructs all the Wireframe curves for this Brep.",since:5,returns:"An array of Wireframe curves or None on failure."},{signature:"bool IsDuplicate(Brep other,double tolerance)",summary:"See if this and other are same brep geometry.",since:5,returns:"True if breps are the same."},{signature:"bool IsPointInside(Point3d point,double tolerance,bool strictlyIn)",summary:"Determines if point is inside a Brep.  This question only makes sense when\n     the brep is a closed and manifold.  This function does not not check for\n     closed or manifold, so result is not valid in those cases.  Intersects\n     a line through point with brep, finds the intersection point Q closest\n     to point, and looks at face normal at Q.  If the point Q is on an edge\n     or the intersection is not transverse at Q, then another line is used.",since:5,returns:"True if point is in, False if not."},{signature:"bool IsValidGeometry(string log)",summary:"Expert user function that tests the brep to see if its geometry information is valid.\n     The value of brep.IsValidTopology() must be True before brep.IsValidGeometry() can be\n     safely called.",since:5,returns:"A value that indicates whether the geometry is valid."},{signature:"bool IsValidTolerancesAndFlags(string log)",summary:"Expert user function that tests the brep to see if its tolerances and\n     flags are valid.  The values of brep.IsValidTopology() and\n     brep.IsValidGeometry() must be True before brep.IsValidTolerancesAndFlags()\n     can be safely called.",since:5,returns:"A value that indicates"},{signature:"bool IsValidTopology(string log)",summary:"Tests the brep to see if its topology information is valid.",since:5,returns:"True if the topology is valid; False otherwise."},{signature:"bool Join(Brep otherBrep,double tolerance,bool compact)",summary:"If any edges of this brep overlap edges of otherBrep, merge a copy of otherBrep into this\n     brep joining all edges that overlap within tolerance.",since:5,returns:"True if any edges were joined."},{signature:"bool JoinEdges(int edgeIndex0,int edgeIndex1,double joinTolerance,bool compact)",summary:"Joins two naked edges, or edges that are coincident or close together.",since:6,returns:"True if successful, False otherwise."},{signature:"int JoinNakedEdges(double tolerance)",summary:"Joins naked edge pairs within the same brep that overlap within tolerance.",since:5,returns:"number of joins made."},{signature:"bool MakeValidForV2()",summary:"No support is available for this function.\n     Expert user function that converts all geometry in brep to nurbs form.",since:6},{signature:"bool MergeCoplanarFaces(double tolerance)",summary:"Merges adjacent coplanar faces into single faces.",since:5,returns:"True if faces were merged, False if no faces were merged."},{signature:"bool MergeCoplanarFaces(double tolerance,double angleTolerance)",summary:"Merges adjacent coplanar faces into single faces.",since:6.1,returns:"True if faces were merged, False if no faces were merged."},{signature:"void RebuildTrimsForV2(BrepFace face,NurbsSurface nurbsSurface)",summary:"No support is available for this function.\n     Expert user function used by MakeValidForV2 to convert trim\n     curves from one surface to its NURBS form. After calling this function,\n     you need to change the surface of the face to a NurbsSurface.",since:5},{signature:"bool RemoveFins()",summary:"Recursively removes any Brep face with a naked edge. This function is only useful for non-manifold Breps.",since:7,returns:"True if successful, False if everything is removed or if the result has any Brep edges with more than two Brep trims."},{signature:"Brep RemoveHoles(double tolerance)",summary:"Remove all inner loops, or holes, in a Brep.",since:6,returns:"The Brep without holes if successful, None otherwise."},{signature:"Brep RemoveHoles(IEnumerable<ComponentIndex> loops,double tolerance)",summary:"Removes inner loops, or holes, in a Brep.",since:6.8,returns:"The Brep without holes if successful, None otherwise."},{signature:"bool Repair(double tolerance)",summary:"Fills in missing or fixes incorrect component information from a Brep. \n     Useful when reading Brep information from other file formats that do not \n     provide as complete of a Brep definition as requried by Rhino.",since:6,returns:"True on success."},{signature:"void SetTolerancesBoxesAndFlags()",summary:"Set tolerances and flags in a Brep.",since:6},{signature:"void SetTolerancesBoxesAndFlags(bool bLazy,bool bSetVertexTolerances,bool bSetEdgeTolerances,bool bSetTrimTolerances,bool bSetTrimIsoFlags,bool bSetTrimTypeFlags,bool bSetLoopTypeFlags,bool bSetTrimBoxes)",summary:"Set tolerances and flags in a Brep.",since:6},{signature:"void SetTrimIsoFlags()",summary:"This function can be used to set the BrepTrim::m_iso\n     flag. It is intended to be used when creating a Brep from\n     a definition that does not include compatible parameter space\n     type information.",since:5.4},{signature:"void SetVertices()",summary:"This function can be used to compute vertex information for a\n     b-rep when everything but the Vertices array is properly filled in.\n     It is intended to be used when creating a Brep from a \n     definition that does not include explicit vertex information.",since:5.4},{signature:"Brep[] Split(Brep cutter,double intersectionTolerance)",summary:"Splits a Brep into pieces using a Brep as a cutter.",since:5,returns:"A new array of Breps. This array can be empty."},{signature:"Brep[] Split(Brep cutter,double intersectionTolerance,bool toleranceWasRaised)",summary:"Splits a Brep into pieces using a Brep as a cutter.",since:5,returns:"A new array of Breps. This array can be empty."},{signature:"Brep[] Split(IEnumerable<Brep> cutters,double intersectionTolerance)",summary:"Splits a Brep into pieces using Breps as cutters.",since:6.13,returns:"A new array of Breps. This array can be empty."},{signature:"Brep[] Split(IEnumerable<Curve> cutters,double intersectionTolerance)",summary:"Splits a Brep into pieces using curves, at least partially on the Brep, as cutters.",since:6.13,returns:"A new array of Breps. This array can be empty."},{signature:"Brep[] Split(IEnumerable<GeometryBase> cutters,Vector3d normal,bool planView,double intersectionTolerance)",summary:"Splits a Brep into pieces using a combination of curves, to be extruded, and Breps as cutters.",since:6.13,returns:"A new array of Breps. This array can be empty."},{signature:"void Standardize()",summary:"Standardizes all trims, edges, and faces in the brep.\n     After standardizing, there may be unused curves and surfaces in the\n     brep.  Call Brep.Compact to remove these unused curves and surfaces.",since:5},{signature:"bool TransformComponent(IEnumerable<ComponentIndex> components,Transform xform,double tolerance,double timeLimit,bool useMultipleThreads)",summary:"Transform an array of Brep components, bend neighbors to match, and leave the rest fixed.",since:6,returns:"True if successful, False otherwise."},{signature:"Brep[] Trim(Brep cutter,double intersectionTolerance)",summary:"Trims a brep with an oriented cutter. The parts of the brep that lie inside\n     (opposite the normal) of the cutter are retained while the parts to the\n     outside (in the direction of the normal) are discarded.  If the Cutter is\n     closed, then a connected component of the Brep that does not intersect the\n     cutter is kept if and only if it is contained in the inside of cutter.\n     That is the region bounded by cutter opposite from the normal of cutter,\n     If cutter is not closed all these components are kept.",since:5,returns:"This Brep is not modified, the trim results are returned in an array."},{signature:"Brep[] Trim(Plane cutter,double intersectionTolerance)",summary:"Trims a Brep with an oriented cutter.  The parts of Brep that lie inside\n     (opposite the normal) of the cutter are retained while the parts to the\n     outside ( in the direction of the normal ) are discarded. A connected\n     component of Brep that does not intersect the cutter is kept if and only\n     if it is contained in the inside of Cutter.  That is the region bounded by\n     cutter opposite from the normal of cutter, or in the case of a Plane cutter\n     the halfspace opposite from the plane normal.",since:5,returns:"This Brep is not modified, the trim results are returned in an array."},{signature:"Brep[] UnjoinEdges(IEnumerable<int> edgesToUnjoin)",summary:"Unjoins, or separates, edges within the Brep. Note, seams in closed surfaces will not separate.",since:6,returns:"This Brep is not modified, the trim results are returned in an array."}]},{name:"Rhino.Geometry.BrepEdge",dataType:1,summary:"Represents a single edge curve in a Brep object.",properties:[{signature:"Brep Brep",summary:"Gets the Brep that owns this edge.",since:5},{signature:"Curve EdgeCurve",summary:"Get the brep.Curves3D[] 3d curve geometry used by this edge or null.",since:6},{signature:"int EdgeCurveIndex",summary:"Get the brep.Curves3D[] index of the 3d curve geometry used by this edge or -1.",since:6},{signature:"int EdgeIndex",summary:"Gets the index of this edge in the Brep.Edges collection.",since:5},{signature:"BrepVertex EndVertex",summary:"BrepVertex at end of edge",since:5.1},{signature:"BrepVertex StartVertex",summary:"BrepVertex at start of edge",since:5.1},{signature:"double Tolerance",summary:"Gets or sets the accuracy of the edge curve (>=0.0 or RhinoMath.UnsetValue)\n     A value of UnsetValue indicates that the tolerance should be computed.\n    \n     The maximum distance from the edge's 3d curve to any surface of a face\n     that has this edge as a portion of its boundary must be <= this tolerance.",since:5},{signature:"int TrimCount",summary:"Gets the number of trim-curves that use this edge.",since:5},{signature:"EdgeAdjacency Valence",summary:"Gets the topological valency of this edge. The topological valency \n     is defined by how many adjacent faces share this edge.",since:5}],methods:[{signature:"int[] AdjacentFaces()",summary:"Gets the indices of all the BrepFaces that use this edge.",since:5},{signature:"Concavity ConcavityAt(double t,double tolerance)",summary:"Determine the concavity of this edge at a specific parameter.",since:6.2,returns:"Concavity measure at parameter."},{signature:"bool GetEdgeParameter(int trimIndex,double trimParameter,double edgeParameter)",summary:"Get corresponding edge parameter for given trim at given trim parameter.",since:5.12,returns:"True on success"},{signature:"bool IsSmoothManifoldEdge(double angleToleranceRadians)",summary:"For a manifold, non-boundary edge, decides whether or not the two surfaces\n     on either side meet smoothly.",since:5,returns:"True if edge is manifold, has exactly 2 trims, and surface normals on either\n     side agree to within angle_tolerance."},{signature:"bool SetEdgeCurve(int curve3dIndex)",summary:"Set 3d curve geometry used by a b-rep edge.",since:5.4,returns:"True if successful"},{signature:"bool SetEdgeCurve(int curve3dIndex,Interval subDomain)",summary:"Set 3d curve geometry used by a b-rep edge.",since:5.4,returns:"True if successful"},{signature:"int[] TrimIndices()",summary:"Gets the indices of all trims associated with this edge.",since:5.12,returns:"Empty array on failure."}]},{name:"Rhino.Geometry.BrepFace",dataType:1,summary:"Provides strongly-typed access to brep faces.\n   A Brep face is composed of one surface and trimming curves.",properties:[{signature:"Brep Brep",summary:"Gets the Brep that owns this face.",since:6.9},{signature:"int FaceIndex",summary:"Index of face in Brep.Faces array.",since:5},{signature:"bool IsSurface",summary:"Gets a value indicating whether the face is synonymous with the underlying surface. \n     If a Face has no trimming curves then it is considered a Surface.",since:5},{signature:"BrepLoopList Loops",summary:"Loops in this face.",since:5},{signature:"bool OrientationIsReversed",summary:"True if face orientation is opposite of natural surface orientation.",since:5},{signature:"BrepLoop OuterLoop",summary:"Every face has a single outer loop.",since:5},{signature:"int SurfaceIndex",summary:"Surface index of the 3d surface geometry used by this face or -1",since:5.6}],methods:[{signature:"int[] AdjacentEdges()",summary:"Gets the indices of all the BrepEdges that delineate this Face.",since:5},{signature:"int[] AdjacentFaces()",summary:"Gets the indices of all the BrepFaces that surround (are adjacent to) this face.",since:5},{signature:"bool ChangeSurface(int surfaceIndex)",summary:"Expert user tool that replaces the 3d surface geometry use by the face.",since:5,returns:"True if successful."},{signature:"Brep CreateExtrusion(Curve pathCurve,bool cap)",summary:"Extrude a face in a Brep.",since:5.3,returns:"A Brep on success or None on failure."},{signature:"bool DraftAnglePoint(Point2d testPoint,double testAngle,Vector3d pullDirection,bool edge,Point3d draftPoint,double draftAngle)",summary:"Returns the surface draft angle and point at a parameter.",since:6,returns:"True if successful, False otherwise."},{signature:"Brep DuplicateFace(bool duplicateMeshes)",summary:"Duplicate a face from the brep to create new single face brep.",since:5,returns:"A new single-face brep synonymous with the current Face."},{signature:"Surface DuplicateSurface()",summary:"Gets a copy to the untrimmed surface that this face is based on.",since:5,returns:"A copy of this face's underlying surface."},{signature:"Mesh GetMesh(MeshType meshType)",summary:"Obtains a reference to a specified type of mesh for this brep face.",since:5,returns:"A mesh."},{signature:"PointFaceRelation IsPointOnFace(double u,double v)",summary:"Tests if a parameter space point is on the interior of a trimmed face.",since:5,returns:"A value describing the spatial relationship between the point and the face."},{signature:"Point3d[] PullPointsToFace(IEnumerable<Point3d> points,double tolerance)",summary:"Pulls one or more points to a brep face.",since:5,returns:"An array of pulled points."},{signature:"bool RebuildEdges(double tolerance,bool rebuildSharedEdges,bool rebuildVertices)",summary:"Rebuild the edges used by a face so they lie on the surface.",since:5,returns:"True on success."},{signature:"Brep RemoveHoles(double tolerance)",summary:"Remove all inner loops, or holes, from a Brep face.",since:6},{signature:"bool SetDomain(int direction,Interval domain)",summary:"Sets the surface domain of this face.",since:5,returns:"True on success, False on failure."},{signature:"bool SetMesh(MeshType meshType,Mesh mesh)",summary:"Sets a reference to a specified type of mesh for this brep face.",since:5,returns:"True if the operation succeeded; otherwise false."},{signature:"bool ShrinkFace(ShrinkDisableSide disableSide)",summary:"Shrinks the underlying untrimmed surface of this Brep face close to trimming boundaries.\n     Shrinking a surface is like extending smoothly, only backwards. knot of full multiplicity\n     are added where you want the surface to be cut off. Then the remaining control points are\n     thrown away.",since:6,returns:"True on success, False on failure."},{signature:"bool ShrinkSurfaceToEdge()",summary:"Shrinks the underlying untrimmed surface of this Brep face right to the trimming boundaries.\n     Note, shrinking the trimmed surface can sometimes cause problems later since having\n     the edges so close to the trimming boundaries can cause commands that use the surface\n     edges as input to fail.",since:6.16,returns:"True on success, False on failure."},{signature:"Brep Split(IEnumerable<Curve> curves,double tolerance)",summary:"Split this face using 3D trimming curves.",since:5,returns:"A brep consisting of all the split fragments, or None on failure."},{signature:"Curve[] TrimAwareIsoCurve(int direction,double constantParameter)",summary:"Similar to IsoCurve function, except this function pays attention to trims on faces \n     and may return multiple curves.",since:5,returns:"Isoparametric curves connecting all points with the constantParameter value."},{signature:"Interval[] TrimAwareIsoIntervals(int direction,double constantParameter)",summary:"Gets intervals where the iso curve exists on a BrepFace (trimmed surface)",since:5,returns:"If direction = 0, the parameter space iso interval connects the 2d points\n     (intervals[i][0],iso_constant) and (intervals[i][1],iso_constant).\n     If direction = 1, the parameter space iso interval connects the 2d points\n     (iso_constant,intervals[i][0]) and (iso_constant,intervals[i][1])."},{signature:"Surface UnderlyingSurface()",summary:"Gets the untrimmed surface that is the base of this face.",since:5,returns:"A surface, or None on error."}]},{name:"Rhino.Geometry.BrepFace.ShrinkDisableSide",dataType:3,summary:"Defines bitwise mask flags indicating what side of a surface to not shrink."},{name:"Rhino.Geometry.BrepLoop",dataType:1,summary:"Represent a single loop in a Brep object. A loop is composed\n   of a list of trim curves.",properties:[{signature:"Brep Brep",summary:"Gets the Brep that owns this loop.",since:5},{signature:"BrepFace Face",summary:"BrepFace this loop belongs to.",since:5},{signature:"int LoopIndex",summary:"Gets the index of this loop in the Brep.Loops collection.",since:5},{signature:"BrepLoopType LoopType",summary:"type of loop.",since:5},{signature:"BrepTrimList Trims",summary:"List of trims for this loop",since:5.1}],methods:[{signature:"Curve To2dCurve()",summary:"Create a 2d curve that traces the entire loop",since:5.1},{signature:"Curve To3dCurve()",summary:"Create a 3D curve that approximates the loop geometry.",since:5,returns:"A 3D curve that approximates the loop or None on failure."}]},{name:"Rhino.Geometry.BrepLoopType",dataType:3,summary:"Each brep loop has a defined type, e.g. outer, inner or point on surface."},{name:"Rhino.Geometry.BrepRegion",dataType:1,summary:"Represents a brep topological region that has sides.",properties:[{signature:"BoundingBox BoundingBox",summary:"Gets the region bounding box.",since:5},{signature:"Brep Brep",summary:"Gets a reference to the Brep this region belongs to.",since:5},{signature:"int Index",summary:"Gets the index of region in the RegionTopology array.",since:5},{signature:"bool IsFinite",summary:"Gets a value indicating whether this region is finite.",since:5}],methods:[{signature:"Brep BoundaryBrep()",summary:"Gets the boundary of a region as a brep object. If the region is finite,\n     the boundary will be a closed  manifold brep. The boundary may have more than one\n     connected component.",since:5,returns:"A brep or None on error."},{signature:"BrepRegionFaceSide[] GetFaceSides()",summary:"Gets an array of  entities delimiting this region.",since:5,returns:"An array of region face sides. This array might be empty on failure."}]},{name:"Rhino.Geometry.BrepRegionFaceSide",dataType:1,summary:"Represents a side of a  entity.",properties:[{signature:"Brep Brep",summary:"The brep this side belongs to.",since:5},{signature:"BrepFace Face",summary:"Gets the face this side belongs to.",since:5},{signature:"BrepRegion Region",summary:"The region this side belongs to.",since:5},{signature:"bool SurfaceNormalPointsIntoRegion",summary:"Gets True if BrepFace's surface normal points into region; False otherwise.",since:5}]},{name:"Rhino.Geometry.BrepSolidOrientation",dataType:3,summary:"Enumerates all possible Solid Orientations for a Brep."},{name:"Rhino.Geometry.BrepTrim",dataType:1,summary:"Brep trim information is stored in BrepTrim classes. Brep.Trims is an\n   array of all the trims in the brep. A BrepTrim is derived from CurveProxy\n   so the trim can supply easy to use evaluation tools via the Curve virtual\n   member functions.\n   Note well that the domains and orientations of the curve m_C2[trim.m_c2i]\n   and the trim as a curve may not agree.",properties:[{signature:"Brep Brep",summary:"Gets the Brep that owns this trim.",since:5.1},{signature:"BrepEdge Edge",summary:"Brep edge this trim belongs to. This will be None for singular trims",since:5.1},{signature:"BrepVertex EndVertex",summary:"BrepVertex at end of trim",since:6},{signature:"BrepFace Face",summary:"Brep face this trim belongs to",since:5.1},{signature:"IsoStatus IsoStatus",since:5.6},{signature:"BrepLoop Loop",summary:"Loop that this trim belongs to",since:5.1},{signature:"BrepVertex StartVertex",summary:"BrepVertex at start of trim",since:6},{signature:"Curve TrimCurve",summary:"Gets the Brep.Curves2D 2d curve geometry used by this trim, or null.",since:6},{signature:"int TrimCurveIndex",summary:"Gets the Brep.Curves2D 2d curve index of the 2d curve geometry used by this trim, or -1.",since:6},{signature:"int TrimIndex",summary:"Gets the index of this trim in the Brep.Trims collection.",since:5.1},{signature:"BrepTrimType TrimType",summary:"Type of trim",since:5.1}],methods:[{signature:"void GetTolerances(double toleranceU,double toleranceV)",summary:"The values in tolerance[] record the accuracy of the parameter space\n     trimming curves.",since:5.6},{signature:"bool GetTrimParameter(double edgeParameter,double trimParameter)",summary:"Get corresponding trim parameter at given edge parameter.",since:5.12,returns:"True on success"},{signature:"bool IsReversed()",summary:"Get orientation of trim with respect to it's corresponding edge.",since:5.12,returns:"True if the 2d trim and 3d edge have opposite orientations"},{signature:"void SetTolerances(double toleranceU,double toleranceV)",summary:"The values in tolerance[] record the accuracy of the parameter space\n     trimming curves.",since:5.6},{signature:"bool SetTrimCurve(int curve2dIndex)",summary:"Set 2d curve geometry used by a b-rep trim.",since:5.4,returns:"True if successful"},{signature:"bool SetTrimCurve(int curve2dIndex,Interval subDomain)",summary:"Set 2d curve geometry used by a b-rep trim.",since:5.4,returns:"True if successful"}]},{name:"Rhino.Geometry.BrepTrimType",dataType:3,summary:"Each brep trim has a defined type."},{name:"Rhino.Geometry.BrepVertex",dataType:1,summary:"Brep vertex information",properties:[{signature:"Brep Brep",summary:"Gets the Brep that owns this vertex.",since:5.4},{signature:"int VertexIndex",summary:"Gets the index of this vertex in the Brep.Vertices collection.",since:5.4}],methods:[{signature:"int[] EdgeIndices()",summary:"Gets the indices of all edges associated with this vertex.",since:5.12,returns:"Empty array on failure."}]},{name:"Rhino.Geometry.Centermark",dataType:1,summary:"Represents a centermark",constructors:[{signature:"Centermark()",since:6}],methods:[{signature:"static Centermark Create(DimensionStyle dimStyle,Plane plane,Point3d centerpoint,double radius)",summary:"Create a new centermark",since:6}]},{name:"Rhino.Geometry.Circle",dataType:2,summary:"Represents a circle in 3D.\n   The values used are a radius and an orthonormal frame of the plane containing the circle,\n   with origin at the center.The circle is parameterized by radians from 0 to 2 Pi given byt -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxiswhere center, xaxis and yaxis define the orthonormal frame of the circle plane.",constructors:[{signature:"Circle(Arc arc)",summary:"Initializes a circle from an arc.",since:5},{signature:"Circle(double radius)",summary:"Initializes a circle with center (0,0,0) in the world XY plane.",since:5},{signature:"Circle(Plane plane,double radius)",summary:"Initializes a circle on a plane with a given radius.",since:5},{signature:"Circle(Plane plane,Point3d center,double radius)",summary:"Initializes a circle parallel to a given plane with given center and radius.",since:5},{signature:"Circle(Point3d center,double radius)",summary:"Initializes a circle parallel to the world XY plane with given center and radius.",since:5},{signature:"Circle(Point3d point1,Point3d point2,Point3d point3)",summary:"Initializes a circle through three 3d points.",since:5},{signature:"Circle(Point3d startPoint,Vector3d tangentAtP,Point3d pointOnCircle)",summary:'Initializes a circle from two 3d points and a tangent at the first point.\n     The start/end of the circle is at point "startPoint".',since:5}],properties:[{signature:"static Circle Unset",summary:"Gets a circle with Unset components.",since:5},{signature:"BoundingBox BoundingBox",summary:"Gets the circle's 3d axis aligned bounding box.",since:5},{signature:"Point3d Center",summary:"Gets or sets the center point of this circle.",since:5},{signature:"double Circumference",summary:"Gets or sets the circumference of this circle.",since:5},{signature:"double Diameter",summary:"Gets or sets the diameter (radius * 2.0) of this circle. \n     Diameters should be positive values.",since:5},{signature:"bool IsValid",summary:"A valid circle has radius larger than 0.0 and a base plane which is must also be valid.",since:5},{signature:"Vector3d Normal",summary:"Gets the normal vector for this circle.",since:5},{signature:"Plane Plane",summary:"Gets or sets the plane of the circle.",since:5},{signature:"double Radius",summary:"Gets or sets the radius of this circle. \n     Radii should be positive values.",since:5}],methods:[{signature:"static bool TryFitCircleToPoints(IEnumerable<Point3d> points,Circle circle)",summary:"Attempt to fit a circle through a set of points.",since:6.2,returns:"True on success, False on failure."},{signature:"static Circle TryFitCircleTT(Curve c1,Curve c2,double t1,double t2)",summary:"Try to fit a circle to two curves using tangent relationships.",since:5,returns:"Valid circle on success, Circle.Unset on failure."},{signature:"static Circle TryFitCircleTTT(Curve c1,Curve c2,Curve c3,double t1,double t2,double t3)",summary:"Try to fit a circle to three curves using tangent relationships.",since:5,returns:"Valid circle on success, Circle.Unset on failure."},{signature:"bool ClosestParameter(Point3d testPoint,double t)",summary:"Gets the parameter on the circle which is closest to a test point.",since:5,returns:"True on success, False on failure."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Gets the point on the circle which is closest to a test point.",since:5,returns:"The point on the circle that is closest to testPoint or\n     Point3d.Unset on failure."},{signature:"Vector3d DerivativeAt(int derivative,double t)",summary:"Determines the value of the Nth derivative at a parameter.",since:5,returns:"The derivative of the circle at the given parameter."},{signature:"bool EpsilonEquals(Circle other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool IsInPlane(Plane plane,double tolerance)",summary:"Evaluates whether or not this circle is co-planar with a given plane.",since:5,returns:"True if the circle plane is co-planar with the given plane within tolerance."},{signature:"Point3d PointAt(double t)",summary:"Circles use trigonometric parameterization: \n     t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.",since:5,returns:"The point on the circle at the given parameter."},{signature:"void Reverse()",summary:"Reverse the orientation of the circle. Changes the domain from [a,b]\n     to [-b,-a].",since:5},{signature:"bool Rotate(double sinAngle,double cosAngle,Vector3d axis)",summary:"Rotates the circle around an axis that starts at the base plane origin.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double sinAngle,double cosAngle,Vector3d axis,Point3d point)",summary:"Rotates the circle around an axis that starts at the provided point.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double angle,Vector3d axis)",summary:"Rotates the circle through a given angle.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double angle,Vector3d axis,Point3d point)",summary:"Rotates the circle through a given angle.",since:5,returns:"True on success, False on failure."},{signature:"Vector3d TangentAt(double t)",summary:"Circles use trigonometric parameterization: \n     t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.",since:5,returns:"The tangent at the circle at the given parameter."},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a nurbs curve representation of this circle. \n     This amounts to the same as calling NurbsCurve.CreateFromCircle().",since:5,returns:"A nurbs curve representation of this circle or None if no such representation could be made."},{signature:"NurbsCurve ToNurbsCurve(int degree,int cvCount)",summary:"Create a uniform non-ratonal cubic NURBS approximation of a circle.",since:6,returns:"NURBS curve approximation of a circle on success"},{signature:"bool Transform(Transform xform)",summary:"Transforms this circle using an xform matrix.",since:5,returns:"True on success, False on failure."},{signature:"bool Translate(Vector3d delta)",summary:"Moves the circle.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.ClippingPlaneSurface",dataType:1,summary:"Represents a planar surface that is used as clipping plane in viewports.\n   A clipping plane object maintains a list of viewports that it clips against.",properties:[{signature:"Plane Plane",summary:"Gets or sets the clipping plane.",since:5}],methods:[{signature:"bool AddClipViewportId(Guid viewportId)",summary:"Adds a viewport id to the list of viewports that this clipping plane clips.",since:6.1,returns:"True if the viewport was added, False if the viewport is already in the list."},{signature:"bool RemoveClipViewportId(Guid viewportId)",summary:"Removes a viewport id that this being clipped by this clipping plane.",since:6.1,returns:"True if the viewport was removed, False if the viewport was not in the list."},{signature:"Guid[] ViewportIds()",summary:"Returns the ids of RhinoViewport objects that are clipped by this clipping plane.",since:5,returns:"The ids of RhinoViewport objects."}]},{name:"Rhino.Geometry.Collections.BrepCurveList",dataType:1,summary:"Provides access to all the underlying curves in a Brep object.",properties:[{signature:"int Count",summary:"Gets the number of curves in this list.",since:5.6}],methods:[{signature:"int Add(Curve curve)",summary:"Adds a curve",since:5.6,returns:"Index that should be used to reference the geometry.\n     -1 is returned if the input is not acceptable."},{signature:"IEnumerator<Curve> GetEnumerator()",summary:"Get an enumerator that visits all curves.",since:5.6,returns:"The enumerator."}]},{name:"Rhino.Geometry.Collections.BrepEdgeList",dataType:1,summary:"Provides access to all the Edges in a Brep object.",properties:[{signature:"int Count",summary:"Gets the number of brep edges.",since:5}],methods:[{signature:"BrepEdge Add(BrepVertex startVertex,BrepVertex endVertex,int curve3dIndex,double edgeTolerance)",summary:"Create and add a new edge to this list",since:5.4},{signature:"BrepEdge Add(BrepVertex startVertex,BrepVertex endVertex,int curve3dIndex,Interval subDomain,double edgeTolerance)",summary:"Create and add a new edge to this list",since:5.4},{signature:"BrepEdge Add(int curve3dIndex)",summary:"Create and add a new edge to this list",since:5.4},{signature:"BrepEdge Add(int startVertexIndex,int endVertexIndex,int curve3dIndex,double edgeTolerance)",summary:"Create and add a new edge to this list",since:5.6},{signature:"BrepEdge Add(int startVertexIndex,int endVertexIndex,int curve3dIndex,Interval subDomain,double edgeTolerance)",summary:"Create and add a new edge to this list",since:5.6},{signature:"IEnumerator<BrepEdge> GetEnumerator()",summary:"Gets an enumerator that visits all edges.",since:5,returns:"The enumerator."},{signature:"int MergeAllEdges(double angleTolerance)",summary:"Merges all possible Brep edges. Edges across kinks cannot be merged.\n     A pair of adjacent edges in a Brep  are mergable if the angle between them is less than tolerance and the valence of the shared vertex is 2.",since:6.23,returns:"The number of edges merged."},{signature:"int MergeEdge(int edgeIndex,double angleTolerance)",summary:"Merge adjacent edges to a specified edge recursively.\n     A pair of adjacent edges in a Brep  are mergable if the angle between them is less than tolerance and the valence of the shared vertex is 2.",since:6.23,returns:"The number of edges merged."},{signature:"int SplitEdgeAtParameters(int edgeIndex,IEnumerable<double> edgeParameters)",summary:"Splits an edge at the specified parameters.",since:5,returns:"Number of splits applied to the edge."},{signature:"bool SplitKinkyEdge(int edgeIndex,double kinkToleranceRadians)",summary:"Splits the edge into G1 pieces.",since:5,returns:"True if successful."}]},{name:"Rhino.Geometry.Collections.BrepFaceList",dataType:1,summary:"Provides access to all the Faces in a Brep object.",properties:[{signature:"int Count",summary:"Gets the number of brep faces.",since:5}],methods:[{signature:"BrepFace Add(int surfaceIndex)",summary:"Create and add a new face to this list. An incomplete face is added.\n     The caller must create and fill in the loops used by the face.",since:5.4},{signature:"BrepFace Add(Surface surface)",summary:"Add a new face to a brep.  This creates a complete face with\n     new vertices at the surface corners, new edges along the surface\n     boundary, etc.  The loop of the returned face has four trims that\n     correspond to the south, east, north, and west side of the \n     surface in that order.  If you use this version of Add to\n     add an exiting brep, then you are responsible for using a tool\n     like JoinEdges() to hook the new face to its neighbors.",since:5.4},{signature:"BrepFace AddConeFace(BrepVertex vertex,BrepEdge edge,bool revEdge)",summary:"Add a new face to the brep whose surface geometry is a \n     ruled cone with the edge as the base and the vertex as\n     the apex point.",since:5.4},{signature:"BrepFace AddRuledFace(BrepEdge edgeA,bool revEdgeA,BrepEdge edgeB,bool revEdgeB)",summary:"Add a new face to the brep whose surface geometry is a \n     ruled surface between two edges.",since:5.4},{signature:"Brep ExtractFace(int faceIndex)",summary:"Extracts a face from a Brep.",since:5,returns:"A brep. This can be null."},{signature:"void Flip(bool onlyReversedFaces)",summary:"Flips the orientation of faces.",since:5},{signature:"IEnumerator<BrepFace> GetEnumerator()",summary:"Gets an enumerators that yields  objects.",since:5,returns:"The enumerator."},{signature:"void RemoveAt(int faceIndex)",summary:"Deletes a face at a specified index.",since:5},{signature:"bool RemoveSlits()",summary:"Remove slit trims and slit boundaries from each face.",since:5.1,returns:"True if any slits were removed"},{signature:"bool ShrinkFaces()",summary:"Shrinks all the underlying surfaces in this Brep. \n     Sometimes the surfaces extend far beyond the trimming boundaries of the Brep Face. \n     This function will remove those portions of the surfaces that are not used.",since:5,returns:"True on success, False on failure."},{signature:"bool SplitBipolarFaces()",summary:"Splits surfaces with two singularities, like spheres, so the results\n     have at most one singularity.",since:5,returns:"True if successful."},{signature:"bool SplitClosedFaces(int minimumDegree)",summary:"Splits closed surfaces so they are not closed.",since:5,returns:"True if successful."},{signature:"bool SplitFaceAtTangents(int faceIndex)",summary:"Splits the face of a Brep at tangent locations.",since:6,returns:"True if successful, False otherwise."},{signature:"bool SplitFacesAtTangents()",summary:"Splits all of the faces of a Brep at tangent locations.",since:6,returns:"True if successful, False otherwise."},{signature:"bool SplitKinkyFace(int faceIndex,double kinkTolerance)",summary:"Splits a single face into G1 pieces.",since:5,returns:"True on success, False on failure."},{signature:"bool SplitKinkyFaces()",summary:"Splits any faces with creases into G1 pieces.",since:5,returns:"True on success, False on failure."},{signature:"bool SplitKinkyFaces(double kinkTolerance)",summary:"Splits any faces with creases into G1 pieces.",since:5,returns:"True on success, False on failure."},{signature:"bool SplitKinkyFaces(double kinkTolerance,bool compact)",summary:"Splits any faces with creases into G1 pieces.",since:5,returns:"True on success, False on failure."},{signature:"bool StandardizeFaceSurface(int faceIndex)",summary:"Standardizes the relationship between a BrepFace and the 3d surface it\n     uses.  When done, the face will be the only face that references its 3d\n     surface, and the orientations of the face and 3d surface will be the same.",since:5,returns:"True if successful."},{signature:"void StandardizeFaceSurfaces()",summary:"Standardize all faces in the brep.",since:5}]},{name:"Rhino.Geometry.Collections.BrepLoopList",dataType:1,summary:"Provides access to all the Loops in a Brep object.",properties:[{signature:"int Count",summary:"Gets the number of brep loops.",since:5}],methods:[{signature:"BrepLoop Add(BrepLoopType loopType)",summary:"Create a new empty boundary loop. The new loop will not be part of a face and\n     will not include any trim curves.",since:5.4},{signature:"BrepLoop Add(BrepLoopType loopType,BrepFace face)",summary:"Create a new boundary loop on a face.  After you get this\n     BrepLoop, you still need to create the vertices, edges, \n     and trims that define the loop.",since:5.4,returns:"New loop that needs to be filled in"},{signature:"BrepLoop AddOuterLoop(int faceIndex)",summary:"Create a new outer boundary loop that runs along the sides\n     of the face's surface.  All the necessary trims, edges,\n     and vertices are created and added to the brep.",since:5.4,returns:"New outer boundary loop that is complete."},{signature:"BrepLoop AddPlanarFaceLoop(int faceIndex,BrepLoopType loopType,IEnumerable<Curve> boundaryCurves)",summary:"Add a planar trimming loop to a planar face",since:5.4,returns:"new loop if successful"},{signature:"IEnumerator<BrepLoop> GetEnumerator()",summary:"Gets an enumerator that visits all edges.",since:5,returns:"The enumerator."}]},{name:"Rhino.Geometry.Collections.BrepSurfaceList",dataType:1,summary:"Provides access to all the underlying surfaces in a Brep object.",properties:[{signature:"int Count",summary:"Gets the number of surfaces in a brep.",since:5.4}],methods:[{signature:"IEnumerator<Surface> GetEnumerator()",summary:"Gets an enumerator that visits all surfaces.",since:5.4,returns:"The enumerator."}]},{name:"Rhino.Geometry.Collections.BrepTrimList",dataType:1,summary:"Provides access to all the Trims in a Brep object",properties:[{signature:"int Count",summary:"Gets the number of brep trims.",since:5.1}],methods:[{signature:"BrepTrim Add(bool rev3d,BrepEdge edge,int curve2dIndex)",summary:"Add a new trim that will be part of an inner, outer, or slit loop\n     to the brep",since:5.4,returns:"new trim"},{signature:"BrepTrim Add(bool rev3d,BrepLoop loop,int curve2dIndex)",summary:"Add a new trim that will be part of an inner, outer, or slit loop\n     to the brep",since:5.4,returns:"new trim"},{signature:"BrepTrim Add(BrepEdge edge,bool rev3d,BrepLoop loop,int curve2dIndex)",summary:"Add a new trim that will be part of an inner, outer, or slit loop\n     to the brep.",since:5.4,returns:"new trim"},{signature:"BrepTrim Add(int curve2dIndex)",summary:"Add a new trim that will be part of an inner, outer, or slit loop\n     to the brep.",since:5.4,returns:"New Trim"},{signature:"BrepTrim AddCurveOnFace(BrepFace face,BrepEdge edge,bool rev3d,int curve2dIndex)",summary:"Add a new curve on face to the brep",since:5.4,returns:"new trim that represents the curve on surface"},{signature:"BrepTrim AddSingularTrim(BrepVertex vertex,BrepLoop loop,IsoStatus iso,int curve2dIndex)",summary:"Add a new singular trim to the brep.",since:5.4,returns:"new trim"},{signature:"IEnumerator<BrepTrim> GetEnumerator()",summary:"Gets an enumerator that visits all edges.",since:5.1,returns:"The enumerator."},{signature:"bool MatchEnds()",summary:"Matches the endpoints of all trims in the Brep.",since:6.19,returns:"True if any trim's 2d curve is changed, False otherwise."},{signature:"bool MatchEnds(BrepLoop loop)",summary:"Match the endpoints of all trims in a loop.",since:6.19,returns:"True if any trim's 2d curve is changed, False otherwise."},{signature:"bool MatchEnds(BrepTrim trim0,BrepTrim trim1)",summary:"Match the end of a trim to the start of the next trim.",since:6.19,returns:"True if either trim's 2d curve is changed, False otherwise."},{signature:"bool MatchEnds(int trimIndex)",summary:"Match the endpoints of a trim to the next and previous trim.",since:6.19,returns:"True if any trim's 2d curve is changed, False otherwise."}]},{name:"Rhino.Geometry.Collections.BrepVertexList",dataType:1,summary:"Provides access to all the Vertices in a Brep object",properties:[{signature:"int Count",summary:"Gets the number of brep vertices.",since:5.4}],methods:[{signature:"BrepVertex Add()",summary:"Create and add a new vertex to this list",since:5.4},{signature:"BrepVertex Add(Point3d point,double vertexTolerance)",summary:"Create and add a new vertex to this list",since:5.4},{signature:"BrepVertex AddPointOnFace(BrepFace face,double s,double t)",summary:"Adds a new point on face to the brep",since:5.4,returns:"new vertex that represents the point on face"},{signature:"IEnumerator<BrepVertex> GetEnumerator()",summary:"Gets an enumerator that visits all surfaces.",since:5.4,returns:"The enumerator."}]},{name:"Rhino.Geometry.Collections.MeshFaceList",dataType:1,summary:"Provides access to the faces and Face related functionality of a Mesh.",properties:[{signature:"int Capacity",summary:"Gets or sets the total number of mesh triangles and quads the internal data structure can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of mesh faces. When getting this can includes invalid faces.",since:5},{signature:"int QuadCount",summary:"Gets the number of faces that are valid quads (4 corners).",since:5},{signature:"int TriangleCount",summary:"Gets the number of faces that are valid triangles (3 corners).",since:5}],methods:[{signature:"int AddFace(int vertex1,int vertex2,int vertex3)",summary:"Appends a new triangular face to the end of the mesh face list.",since:5,returns:"The index of the newly added triangle."},{signature:"int AddFace(int vertex1,int vertex2,int vertex3,int vertex4)",summary:"Appends a new quadragular face to the end of the mesh face list.",since:5,returns:"The index of the newly added quad."},{signature:"int AddFace(MeshFace face)",summary:"Appends a new mesh face to the end of the mesh face list.",since:5,returns:"The index of the newly added face."},{signature:"int[] AddFaces(IEnumerable<MeshFace> faces)",summary:"Appends a list of faces to the end of the mesh face list.",since:5,returns:"Indices of the newly created faces"},{signature:"int[] AdjacentFaces(int faceIndex)",summary:"Gets all faces that share a topological edge with a given face.",since:5,returns:"All indices that share an edge."},{signature:"void Clear()",summary:"Clears the Face list on the mesh.",since:5},{signature:"int ConvertNonPlanarQuadsToTriangles(double planarTolerance,double angleToleranceRadians,int splitMethod)",summary:"Splits non-planar quads into two triangles based on given params.",since:6,returns:"Number of quads that were converted to triangles."},{signature:"bool ConvertQuadsToTriangles()",summary:"Splits all quads along the short diagonal.",since:5,returns:"True on success, False on failure."},{signature:"bool ConvertTrianglesToQuads(double angleToleranceRadians,double minimumDiagonalLengthRatio)",summary:"Joins adjacent triangles into quads if the resulting quad is 'nice'.",since:5,returns:"True on success, False on failure."},{signature:"int CullDegenerateFaces()",summary:"Attempts to removes degenerate faces from the mesh.\n     Degenerate faces are faces that contains such a combination of indices,\n     that their final shape collapsed in a line or point.Before returning, this method also attempts to repair faces by juggling\n     vertex indices.",since:5,returns:"The number of degenerate faces that were removed."},{signature:"int DeleteFaces(IEnumerable<int> faceIndexes)",summary:"Removes a collection of faces from the mesh without affecting the remaining geometry.",since:5,returns:"The number of faces deleted on success."},{signature:"int DeleteFaces(IEnumerable<int> faceIndexes,bool compact)",summary:"Removes a collection of faces from the mesh without affecting the remaining geometry.",since:6.6,returns:"The number of faces deleted on success."},{signature:"void Destroy()",summary:"Releases all memory allocated to store faces. The list capacity will be 0 after this call.\n     Subsequent calls can add new items.",since:6},{signature:"Mesh ExtractDuplicateFaces()",summary:"Extracts, or removes, duplicate faces.",since:6,returns:"A mesh containing the extracted duplicate faces if successful, None otherwise."},{signature:"Mesh ExtractFaces(IEnumerable<int> faceIndices)",summary:"Extracts, or removes, faces.",since:6,returns:"A mesh containing the extracted faces if successful, None otherwise."},{signature:"IndexPair[] GetClashingFacePairs(int maxPairCount)",summary:"Gets an array of pairs of mesh faces that clash.",since:6,returns:"Array of pairs of mesh face indices."},{signature:"int[] GetConnectedFaces(int faceIndex,double angleRadians,bool greaterThanAngle)",summary:"Find all connected face indices where adjacent face normals meet\n     the criteria of angleRadians and greaterThanAngle",since:5.6,returns:"list of connected face indices"},{signature:"int[] GetConnectedFacesToEdges(int startFaceIndex,bool treatNonmanifoldLikeUnwelded)",summary:"Uses startFaceIndex and finds all connected face indexes up to unwelded\n     or naked edges. If treatNonmanifoldLikeUnwelded is True then non-manifold\n     edges will be considered as unwelded or naked",since:5.6,returns:"Array of connected face indexes"},{signature:"int[] GetDuplicateFaces()",summary:"Finds all of the duplicate faces.",since:6,returns:"The indexes that are duplicates of other indexes if successful. \n     If there are no duplicate, then an empty array is returned."},{signature:"IEnumerator<MeshFace> GetEnumerator()",summary:"Gets an enumerator that yields all faces in this collection.",since:5,returns:"The enumerator."},{signature:"MeshFace GetFace(int index)",summary:"Returns the mesh face at the given index.",since:5,returns:"The mesh face at the given index on success or MeshFace.Unset if the index is out of range."},{signature:"double GetFaceAspectRatio(int index)",summary:"Returns the mesh face at the given index.",since:6,returns:"The mesh face at the given index on success or MeshFace.Unset if the index is out of range."},{signature:"BoundingBox GetFaceBoundingBox(int faceIndex)",summary:"Gets the bounding box of a face.",since:5,returns:"A new bounding box, or  on error."},{signature:"Point3d GetFaceCenter(int faceIndex)",summary:"Gets the center point of a face.\n     For a triangular face, this is the centroid or barycenter.For a quad, this is the avarage of four coner points.",since:5,returns:"The center point."},{signature:"bool GetFaceVertices(int faceIndex,Point3f a,Point3f b,Point3f c,Point3f d)",summary:"Gets the 3D location of the vertices forming a face.",since:5,returns:"True if the operation succeeded, otherwise false."},{signature:"int[] GetTopologicalVertices(int faceIndex)",summary:"Gets the topology vertex indices of a face.",since:5,returns:"An array of integers."},{signature:"bool GetZeroAreaFaces(int[] whollyDegenerateFaces,int[] partiallyDegenerateFaces)",summary:"Examines and adds face indexes to whollyDegenerateFaces if the face is a triangle with zero area or a quad both triangles have zero area.\n     Face indexes are added to partiallyDegenerateFaces when a quad has one triangle with zero area.",since:6,returns:"Returns True if the mesh has wholly or partially degenerate faces, False otherwise."},{signature:"bool HasNakedEdges(int faceIndex)",summary:"Returns True if at least one of the face edges are not topologically\n     connected to any other faces.",since:5,returns:"True if that face makes the mesh open, otherwise false."},{signature:"void Insert(int index,MeshFace face)",summary:"Inserts a mesh face at a defined index in this list.",since:5},{signature:"bool IsHidden(int faceIndex)",summary:"Gets a value indicating whether a face is hidden.\n     A face is hidden if, and only if, at least one of its vertices is hidden.",since:5,returns:"True if hidden, False if fully visible."},{signature:"void RemoveAt(int index)",summary:"Removes a face from the mesh.",since:5},{signature:"void RemoveAt(int index,bool compact)",summary:"Removes a face from the mesh.",since:6.6},{signature:"int RemoveZeroAreaFaces(int fixedFaceCount)",summary:"Deletes or fixes mesh faces that have zero area.",since:6,returns:"Number of removed wholly degenerate faces."},{signature:"bool SetFace(int index,int vertex1,int vertex2,int vertex3)",summary:"Sets a triangular face at a specific index of the mesh.",since:5,returns:"True if the operation succeeded, otherwise false."},{signature:"bool SetFace(int index,int vertex1,int vertex2,int vertex3,int vertex4)",summary:"Sets a quadrangular face at a specific index of the mesh.",since:5,returns:"True if the operation succeeded, otherwise false."},{signature:"bool SetFace(int index,MeshFace face)",summary:"Sets a face at a specific index of the mesh.",since:5,returns:"True if the operation succeeded, otherwise false."},{signature:"int[] ToIntArray(bool asTriangles)",summary:"Copies all of the face indices to a linear array of indices per face.\n     \n     Note that this includes indices from invalid faces too.",since:5.9,returns:"The int array. This method never returns null."},{signature:"int[] ToIntArray(bool asTriangles,List<int> replacedIndices)",summary:"Copies all of the faces to a linear array of indices.\n     \n     Clean-up of vertex indices if replacedIndices is a valid List<int>",returns:"The int array. This method never returns null."}]},{name:"Rhino.Geometry.Collections.MeshFaceNormalList",dataType:1,summary:"Provides access to the Face normals of a Mesh.",properties:[{signature:"int Capacity",summary:"Gets or sets the total number of face normals the internal data structure can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of mesh face normals.",since:5}],methods:[{signature:"int AddFaceNormal(double x,double y,double z)",summary:"Appends a face normal to the list of mesh face normals.",since:5,returns:"The index of the newly added face normal."},{signature:"int AddFaceNormal(float x,float y,float z)",summary:"Appends a face normal to the list of mesh face normals.",since:5,returns:"The index of the newly added face normal."},{signature:"int AddFaceNormal(Vector3d normal)",summary:"Appends a face normal to the list of mesh face normals.",since:5,returns:"The index of the newly added face normal."},{signature:"int AddFaceNormal(Vector3f normal)",summary:"Appends a face normal to the list of mesh face normals.",since:5,returns:"The index of the newly added face normal."},{signature:"void Clear()",summary:"Clears the Face Normal list on the mesh.",since:5},{signature:"bool ComputeFaceNormals()",summary:"Computes all the face normals for this mesh based on the physical shape of the mesh.",since:5,returns:"True on success, False on failure."},{signature:"void Destroy()",summary:"Releases all memory allocated to store face normals. The list capacity will be 0 after this call.\n     Subsequent calls can add new items.",since:6},{signature:"IEnumerator<Vector3f> GetEnumerator()",summary:"Gets an enumerator that yields all normals (vectors) in this collection.",since:5,returns:"The enumerator."},{signature:"bool SetFaceNormal(int index,double x,double y,double z)",summary:"Sets a face normal vector at an index using three double-precision numbers.",since:5,returns:"True on success; False on error."},{signature:"bool SetFaceNormal(int index,float x,float y,float z)",summary:"Sets a face normal vector at an index using three single-precision numbers.",since:5,returns:"True on success; False on error."},{signature:"bool SetFaceNormal(int index,Vector3d normal)",summary:"Sets a face normal vector at an index using a single-precision vector.",since:5,returns:"True on success; False on error."},{signature:"bool SetFaceNormal(int index,Vector3f normal)",summary:"Sets a face normal vector at an index using a single-precision vector.",since:5,returns:"True on success; False on error."},{signature:"bool UnitizeFaceNormals()",summary:"Unitizes all the existing face normals.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.Collections.MeshNgonList",dataType:1,summary:"Provides access to the ngons and n-gon related functionality of a Mesh.\n   See also the  property for Ngon functionality details.",properties:[{signature:"int Count",summary:"Gets or sets the number of mesh ngons.",since:6},{signature:"uint UnsignedCount",summary:"Gets or sets the number of mesh ngons.",since:6}],methods:[{signature:"int AddNgon(MeshNgon ngon)",summary:"Appends a new ngon to the end of the mesh ngon list.",since:6,returns:"The index of the newly added ngon."},{signature:"int[] AddNgons(IEnumerable<MeshNgon> ngons)",summary:"Appends a list of ngons to the end of the mesh ngon list.",since:6,returns:"Indices of the newly created ngons"},{signature:"int AddPlanarNgons(double planarTolerance)",summary:"Add an ngon for each group of connected coplanar faces.",since:6,returns:"Number of ngons added to the mesh."},{signature:"int AddPlanarNgons(double planarTolerance,int minimumNgonVertexCount,int minimumNgonFaceCount,bool allowHoles)",summary:"Add an ngon for each group of connected coplanar faces.",since:6,returns:"Number of ngons added to the mesh."},{signature:"void Clear()",summary:"Clears the Ngon list on the mesh.",since:6},{signature:"IEnumerator<MeshNgon> GetEnumerator()",summary:"Gets an enumerator that yields all ngons in this collection.",since:6,returns:"The enumerator."},{signature:"MeshNgon GetNgon(int index)",summary:"Returns the mesh ngon at the given index.",since:6,returns:"The mesh ngon at the given index.  This ngon can be MeshNgon.Empty."},{signature:"int[] GetNgonBoundary(IEnumerable<int> ngonFaceIndexList)",summary:"Get a list of vertices that form the boundary of a face set. This is often use to get n-gon boundaries.",since:6,returns:"List of mesh vertex indices that form the boundary of the face set."},{signature:"BoundingBox GetNgonBoundingBox(int index)",summary:"Gets the bounding box of an ngon.",since:6,returns:"A new bounding box, or  on error."},{signature:"BoundingBox GetNgonBoundingBox(MeshNgon ngon)",summary:"Gets the bounding box of an ngon.",since:6,returns:"A new bounding box, or  on error."},{signature:"Point3d GetNgonCenter(int index)",summary:"Gets the center point of an ngon.\n     This the avarage of the corner points.",since:6,returns:"The center point."},{signature:"Point3d GetNgonCenter(MeshNgon ngon)",summary:"Gets the center point of an ngon.\n     This the avarage of the corner points.",since:6,returns:"The center point."},{signature:"int GetNgonEdgeCount(int index)",summary:"Gets the complete edge count of an ngon.",since:6,returns:"Complete edge count or zero on error."},{signature:"int GetNgonOuterEdgeCount(int index)",summary:"Gets the outer edge count of an ngon.",since:6,returns:"Outer edge count or zero on error."},{signature:"void Insert(int index,MeshNgon ngon)",summary:"Inserts a mesh ngon at a defined index in this list.",since:6},{signature:"uint IsValid(int index)",summary:"Tests an ngon to see if the vertex and face references are valid and pass partial boundary validity checks.",since:6,returns:"0 if the ngon is not valid, otherwise the number of boundary edges."},{signature:"uint IsValid(int index,TextLog textLog)",summary:"Tests an ngon to see if the vertex and face references are valid and pass partial boundary validity checks.",since:6,returns:"0 if the ngon is not valid, otherwise the number of boundary edges."},{signature:"Point3d[] NgonBoundaryVertexList(MeshNgon ngon,bool bAppendStartPoint)",summary:"Get an ngon's boundary points.",since:6,returns:"A list of ngon boundary points."},{signature:"bool NgonHasHoles(int index)",summary:"Determines whether a ngon has holes.",since:6,returns:"True for holes (or malformed ngon, see remarks), False for no holes."},{signature:"int NgonIndexFromFaceIndex(int meshFaceIndex)",summary:"Returns the index of a mesh ngon the face belongs to.",since:6,returns:"The index of the mesh ngon the face belongs to or -1 if the face does not belong to an ngon."},{signature:"int Orientation(int index,bool permitHoles)",summary:"Determine if the ngon's boundary orientation matches that of the set of faces it is made from.",since:7,returns:"1: The ngon does not have holes, the ngon's faces are compatibly oriented, \n     and the ngon's outer boundary orientation matches the faces' orientation.\n     -1: The ngon does not have holes, the ngon's faces are compatibly oriented,\n     and the ngon's outer boundary orientation is opposite the faces' orientation.\n     0: Otherwise.The ngon may be invalid, have holes, the ngon's faces may not be\n     compatibly oriented, the ngons edges may not have a consistent orientation\n     with respect to the faces, or some other issue."},{signature:"void RemoveAt(int index)",summary:"Removes an ngon from the mesh.",since:6},{signature:"int RemoveNgons(IEnumerable<int> indices)",summary:"Remove one or more ngons from the mesh.",since:6,returns:"The number of deleted ngons."},{signature:"void ReverseOuterBoundary(int index)",summary:"Reverse the order of the m_vi[] array for an ngon",since:7},{signature:"void SetNgon(int index,MeshNgon ngon)",summary:"Set an ngon in this list.",since:6}]},{name:"Rhino.Geometry.Collections.MeshTextureCoordinateList",dataType:1,summary:"Provides access to the Vertex Texture coordinates of a Mesh.",properties:[{signature:"int Capacity",summary:"Gets or sets the total number of texture coordinates the internal data structure can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of texture coordinates.",since:5}],methods:[{signature:"int Add(double s,double t)",summary:"Adds a new texture coordinate to the end of the Texture list.",since:5,returns:"The index of the newly added texture coordinate."},{signature:"int Add(float s,float t)",summary:"Adds a new texture coordinate to the end of the Texture list.",since:5,returns:"The index of the newly added texture coordinate."},{signature:"int Add(Point2f tc)",summary:"Adds a new texture coordinate to the end of the Texture list.",since:5,returns:"The index of the newly added texture coordinate."},{signature:"int Add(Point3d tc)",summary:"Adds a new texture coordinate to the end of the Texture list.",since:5,returns:"The index of the newly added texture coordinate."},{signature:"bool AddRange(Point2f[] textureCoordinates)",summary:"Appends an array of texture coordinates.",since:5,returns:"True on success, False on failure."},{signature:"void Clear()",summary:"Clears the Texture Coordinate list on the mesh.",since:5},{signature:"void Destroy()",summary:"Releases all memory allocated to store texture coordinates. The list capacity will be 0 after this call.\n     Subsequent calls can add new items.",since:6},{signature:"IEnumerator<Point2f> GetEnumerator()",summary:"Gets an enumerator that yields all texture coordinates in this collection.",since:5,returns:"The enumerator."},{signature:"bool NormalizeTextureCoordinates()",summary:"Scales the texture coordinates so the texture domains are [0,1] \n     and eliminate any texture rotations.",since:5,returns:"True on success, False on failure."},{signature:"bool ReverseTextureCoordinates(int direction)",summary:"Reverses one coordinate direction of the texture coordinates.\n     The region of the bitmap the texture uses does not change.\n     Either Us or Vs direction is flipped.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"bool SetTextureCoordinate(int index,double s,double t)",summary:"Sets or adds a texture coordinate to the Texture Coordinate List.\n     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetTextureCoordinate(int index,float s,float t)",summary:"Sets or adds a texture coordinate to the Texture Coordinate List.\n     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetTextureCoordinate(int index,Point2f tc)",summary:"Sets or adds a texture coordinate to the Texture Coordinate List.\n     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetTextureCoordinate(int index,Point3f tc)",summary:"Sets or adds a texture coordinate to the Texture Coordinate List.\n     If [index] is less than [Count], the existing coordinate at [index] will be modified.If [index] equals [Count], a new coordinate is appended to the end of the coordinate list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetTextureCoordinates(Point2f[] textureCoordinates)",summary:"Sets all texture coordinates in one go.",since:5,returns:"True on success, False on failure."},{signature:"bool SetTextureCoordinates(TextureMapping mapping)",summary:"Set all texture coordinates based on a texture mapping function",since:5,returns:"True on success, False on failure."},{signature:"float[] ToFloatArray()",summary:"Copies all vertices to a linear array of float in u,v order",since:6,returns:"The float array."},{signature:"bool TransposeTextureCoordinates()",summary:"Transposes texture coordinates.\n     The region of the bitmap the texture uses does not change.\n     All texture coordinates rows (Us) become columns (Vs), and vice versa.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.Collections.MeshTopologyEdgeList",dataType:1,summary:"Represents an entry point to the list of edges in a mesh topology.",properties:[{signature:"int Count",summary:"Gets the amount of edges in this list.",since:5}],methods:[{signature:"bool CollapseEdge(int topologyEdgeIndex)",summary:"Replaces a mesh edge with a vertex at its center and update adjacent faces as needed.",since:5,returns:"True if successful."},{signature:"Line EdgeLine(int topologyEdgeIndex)",summary:"Gets the 3d line along an edge.",since:5,returns:"Line along edge. If input is not valid, an Invalid Line is returned."},{signature:"int[] GetConnectedFaces(int topologyEdgeIndex)",summary:"Gets indices of faces connected to an edge.",since:5,returns:"An array of face indices the edge borders. This might be empty on error."},{signature:"int[] GetConnectedFaces(int topologyEdgeIndex,bool[] faceOrientationMatchesEdgeDirection)",summary:"Gets indices of faces connected to an edge.",since:5,returns:"An array of face indices the edge borders. This might be empty on error."},{signature:"int GetEdgeIndex(int topologyVertex1,int topologyVertex2)",summary:"Returns index of edge that connects topological vertices. \n     returns -1 if no edge is found.",since:5,returns:"The edge index."},{signature:"int[] GetEdgesForFace(int faceIndex)",summary:"Gets indices of edges that surround a given face.",since:5,returns:"A new array of indices to the topological edges that are connected with the specified face."},{signature:"int[] GetEdgesForFace(int faceIndex,bool[] sameOrientation)",summary:"Gets indices of edges that surround a given face.",since:5,returns:"A new array of indices to the topological edges that are connected with the specified face."},{signature:"IndexPair GetTopologyVertices(int topologyEdgeIndex)",summary:"Gets the two topology vertices for a given topology edge.",since:5,returns:"The pair of vertex indices the edge connects."},{signature:"bool IsEdgeUnwelded(int topologyEdgeIndex)",summary:"Determines if the mesh edge is unwelded, or if the mesh faces that share the edge have unique vertex indices.",since:6.13,returns:"True if the edge is unwelded, False if the edge is welded."},{signature:"bool IsHidden(int topologyEdgeIndex)",summary:"Returns True if the topological edge is hidden. The mesh topology\n     edge is hidden only if either of its mesh topology vertices is hidden.",since:5,returns:"True if mesh topology edge is hidden."},{signature:"bool IsNgonInterior(int topologyEdgeIndex)",summary:"Returns True if the topological edge is an interior ngon edge",since:6,returns:"True if mesh topology edge is an interior ngon edge."},{signature:"bool IsSwappableEdge(int topologyEdgeIndex)",summary:"Determines if a mesh edge index is valid input for .",since:5,returns:"True if edge can be swapped."},{signature:"bool SplitEdge(int topologyEdgeIndex,double t)",summary:"Divides a mesh edge to create two or more triangles",since:5,returns:"True if successful"},{signature:"bool SplitEdge(int topologyEdgeIndex,Point3d point)",summary:"Divides a mesh edge to create two or more triangles",since:5,returns:"True if successful"},{signature:"bool SwapEdge(int topologyEdgeIndex)",summary:"If the edge is shared by two triangular face, then the edge is swapped.",since:5,returns:"True if successful."}]},{name:"Rhino.Geometry.Collections.MeshTopologyVertexList",dataType:1,summary:"Provides access to the mesh topology vertices of a mesh. Topology vertices are\n   sets of vertices in the MeshVertexList that can topologically be considered the\n   same vertex.",properties:[{signature:"int Count",summary:"Gets or sets the number of mesh topology vertices.",since:5}],methods:[{signature:"int ConnectedEdge(int topologyVertexIndex,int edgeAtVertexIndex)",summary:"Gets a particular edge that is connected to a topological vertex.\n     Call TopologyVertices.SortVertices before this if you are interested in ordered edges.",since:6,returns:"The index of the connected edge."},{signature:"int[] ConnectedEdges(int topologyVertexIndex)",summary:"Gets all edges that are connected to a given vertex.\n     Call TopologyVertices.SortVertices before this if you are interested in ordered edges.",since:6,returns:"Indices of all edges around vertex that are connected to this topological vertex.\n     None if no faces are connected to this vertex."},{signature:"int ConnectedEdgesCount(int topologyVertexIndex)",summary:"Gets the count of edges that are connected to a given vertex.",since:6,returns:"The amount of edges at this vertex. This can be 0."},{signature:"int[] ConnectedFaces(int topologyVertexIndex)",summary:"Gets all faces that are connected to a given vertex.",since:5,returns:"Indices of all faces in Mesh.Faces that are connected to this topological vertex.\n     None if no faces are connected to this vertex."},{signature:"int[] ConnectedTopologyVertices(int topologyVertexIndex)",summary:"Gets all topological vertices that are connected to a given vertex.",since:5,returns:"Indices of all topological vertices that are connected to this topological vertex.\n     None if no vertices are connected to this vertex."},{signature:"int[] ConnectedTopologyVertices(int topologyVertexIndex,bool sorted)",summary:"Gets all topological vertices that are connected to a given vertex.",since:5,returns:"Indices of all topological vertices that are connected to this topological vertex.\n     None if no vertices are connected to this vertex."},{signature:"IEnumerator<Point3f> GetEnumerator()",summary:"Gets an enumerator that yields all topology vertices in this collection.",since:5,returns:"The enumerator."},{signature:"int[] IndicesFromFace(int faceIndex)",summary:"Returns TopologyVertexIndices for a given mesh face index.",since:5,returns:"An array of vertex indices."},{signature:"bool IsHidden(int topologyVertexIndex)",summary:"Returns True if the topological vertex is hidden. The mesh topology\n     vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.",since:5,returns:"True if mesh topology vertex is hidden."},{signature:"int[] MeshVertexIndices(int topologyVertexIndex)",summary:"Gets all indices of the mesh vertices that a given topology vertex represents.",since:5,returns:"Indices of all vertices that in Mesh.Vertices that a topology vertex represents."},{signature:"bool SortEdges()",summary:"Sorts the edge list for the mesh topology vertex list so that\n     the edges are in radial order when you call ConnectedTopologyVertices.\n     A nonmanifold edge is treated as a boundary edge with respect\n     to sorting.  If any boundary or nonmanifold edges end at the\n     vertex, then the first edge will be a boundary or nonmanifold edge.",since:5,returns:"True on success."},{signature:"bool SortEdges(int topologyVertexIndex)",summary:"Sorts the edge list for as single mesh topology vertex so that\n     the edges are in radial order when you call ConnectedTopologyVertices.\n     A nonmanifold edge is treated as a boundary edge with respect\n     to sorting.  If any boundary or nonmanifold edges end at the\n     vertex, then the first edge will be a boundary or nonmanifold edge.",since:5,returns:"True on success."},{signature:"int TopologyVertexIndex(int vertexIndex)",summary:"Gets the topology vertex index for an existing mesh vertex in the mesh's\n     VertexList.",since:5,returns:"Index of a topology vertex in the Mesh.TopologyVertices."}]},{name:"Rhino.Geometry.Collections.MeshVertexColorList",dataType:1,summary:"Provides access to the vertex colors of a mesh object.",properties:[{signature:"int Capacity",summary:"Gets or sets the total number of vertex colors the internal data structure can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of mesh colors.",since:5},{signature:"MappingTag Tag",summary:"Gets or sets a mapping information for the mesh associated with these vertex colors.",since:5}],methods:[{signature:"int Add(Color color)",summary:"Adds a new vertex color to the end of the color list.",since:5,returns:"The index of the newly added color."},{signature:"int Add(int red,int green,int blue)",summary:"Adds a new vertex color to the end of the color list.",since:5,returns:"The index of the newly added color."},{signature:"bool AppendColors(Color[] colors)",summary:"Appends a collection of colors to the vertex color list. \n     For the Mesh to be valid, the number of colors must match the number of vertices.",since:5,returns:"True on success, False on failure."},{signature:"void Clear()",summary:"Clears the vertex color list on the mesh.",since:5},{signature:"bool CreateMonotoneMesh(Color baseColor)",summary:"Constructs a valid vertex color list consisting of a single color.",since:5,returns:"True on success, False on failure."},{signature:"void Destroy()",summary:"Releases all memory allocated to store vertex colors. The list capacity will be 0 after this call.\n     Subsequent calls can add new items.",since:6},{signature:"IEnumerator<Color> GetEnumerator()",summary:"Gets an enumerator that yields all colors in this collection.",since:5,returns:"The enumerator."},{signature:"bool SetColor(int index,Color color)",summary:"Sets or adds a vertex to the Vertex List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetColor(int index,int red,int green,int blue)",summary:"Sets or adds a vertex color to the color List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetColor(MeshFace face,Color color)",summary:"Sets a color at the three or four vertex indices of a specified face.",since:5,returns:"True on success; False on error."},{signature:"bool SetColors(Color[] colors)",summary:"Sets all the vertex colors in one go. For the Mesh to be valid, the number \n     of colors must match the number of vertices.",since:5,returns:"True on success, False on failure."},{signature:"int[] ToARGBArray()",summary:"Return colors as an array of integers with packed ARGB values",since:7}]},{name:"Rhino.Geometry.Collections.MeshVertexList",dataType:1,summary:"Provides access to the vertices and vertex-related functionality of a mesh.",properties:[{signature:"int Capacity",summary:"Gets or sets the total number of vertices the internal data structure can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of mesh vertices.",since:5},{signature:"bool UseDoublePrecisionVertices",summary:"Set to True if the vertices should be stored in double precision",since:6.4}],methods:[{signature:"static int Align(IEnumerable<Mesh> meshes,double distance,IEnumerable<IEnumerable<bool>> whichVertices)",summary:"Moves mesh vertices that belong to naked edges to neighboring vertices, within the specified distance.\n     This forces unaligned mesh vertices to the same location and is helpful to clean meshes for 3D printing.See the _AlignMeshVertices Rhino command for more information.",returns:"If the operation succeeded, the number of moved vertices, or -1 on error."},{signature:"int Add(double x,double y,double z)",summary:"Adds a new vertex to the end of the Vertex list.",since:5,returns:"The index of the newly added vertex."},{signature:"int Add(float x,float y,float z)",summary:"Adds a new vertex to the end of the Vertex list.",since:5,returns:"The index of the newly added vertex."},{signature:"int Add(Point3d vertex)",summary:"Adds a new vertex to the end of the Vertex list.",since:5,returns:"The index of the newly added vertex."},{signature:"int Add(Point3f vertex)",summary:"Adds a new vertex to the end of the Vertex list.",since:5,returns:"The index of the newly added vertex."},{signature:"void AddVertices(IEnumerable<Point3d> vertices)",summary:"Adds a series of new vertices to the end of the vertex list.\n     This overload accepts double-precision points.",since:5},{signature:"void AddVertices(IEnumerable<Point3f> vertices)",summary:"Adds a series of new vertices to the end of the vertex list.\n     This overload accepts single-precision points.",since:5},{signature:"int Align(double distance,IEnumerable<bool> whichVertices)",summary:"Moves mesh vertices that belong to naked edges to neighboring vertices, within the specified distance.\n     This forces unaligned mesh vertices to the same location and is helpful to clean meshes for 3D printing.See the _AlignMeshVertices Rhino command for more information.",since:6,returns:"If the operation succeeded, the number of moved vertices, or -1 on error."},{signature:"void Clear()",summary:"Clears the Vertex list on the mesh.",since:5},{signature:"bool CombineIdentical(bool ignoreNormals,bool ignoreAdditional)",summary:"Merges identical vertices.",since:5,returns:"True if the mesh is changed, in which case the mesh will have fewer vertices than before."},{signature:"int CullUnused()",summary:"Removes all vertices that are currently not used by the Face list.",since:5,returns:"The number of unused vertices that were removed."},{signature:"void Destroy()",summary:"Releases all memory allocated to store faces. The list capacity will be 0 after this call.\n     Subsequent calls can add new items.",since:6},{signature:"int[] GetConnectedVertices(int vertexIndex)",summary:'Gets indices of all vertices that form "edges" with a given vertex index.',since:5,returns:"An array of vertex indices that are connected with the specified vertex."},{signature:"IEnumerator<Point3f> GetEnumerator()",summary:"Gets an enumerator that yields all mesh vertices (points) in this collection.",since:5,returns:"The enumerator."},{signature:"int[] GetTopologicalIndenticalVertices(int vertexIndex)",summary:'Gets a list of other vertices which are "topologically" identical\n     to this vertex.',since:5,returns:"Array of indices of vertices that are topoligically the same as this vertex. The\n     array includes vertexIndex. Returns None on failure."},{signature:"int[] GetVertexFaces(int vertexIndex)",summary:"Gets a list of all of the faces that share a given vertex.",since:5,returns:"An array of indices of faces on success, None on failure."},{signature:"void Hide(int vertexIndex)",summary:"Hides the vertex at the given index.",since:5},{signature:"void HideAll()",summary:"Hides all vertices in the mesh.",since:5},{signature:"bool IsHidden(int vertexIndex)",summary:"Gets a value indicating whether or not a vertex is hidden.",since:5,returns:"True if the vertex is hidden, False if it is not."},{signature:"Point3d Point3dAt(int index)",summary:"Get double precision location at a given index",since:6.4},{signature:"bool Remove(IEnumerable<int> indices,bool shrinkFaces)",summary:"Removes the vertices at the given indices and all faces that reference those vertices.",since:5,returns:"True on success, False on failure."},{signature:"bool Remove(int index,bool shrinkFaces)",summary:"Removes the vertex at the given index and all faces that reference that index.",since:5,returns:"True on success, False on failure."},{signature:"bool SetVertex(int index,double x,double y,double z)",summary:"Sets or adds a vertex to the Vertex List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetVertex(int index,double x,double y,double z,bool updateNormals)",summary:"Sets or adds a vertex to the Vertex List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:6.6,returns:"True on success, False on failure."},{signature:"bool SetVertex(int index,float x,float y,float z)",summary:"Sets or adds a vertex to the Vertex List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetVertex(int index,Point3d vertex)",summary:"Sets or adds a vertex to the Vertex List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetVertex(int index,Point3f vertex)",summary:"Sets or adds a vertex to the Vertex List.\n     If [index] is less than [Count], the existing vertex at [index] will be modified.If [index] equals [Count], a new vertex is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"void Show(int vertexIndex)",summary:"Shows the vertex at the given index.",since:5},{signature:"void ShowAll()",summary:"Shows all vertices in the mesh.",since:5},{signature:"float[] ToFloatArray()",summary:"Copies all vertices to a linear array of float in x,y,z order",since:5.9,returns:"The float array."},{signature:"Point3d[] ToPoint3dArray()",summary:"Copies all vertices to a new array of .",since:5,returns:"A new array."},{signature:"Point3f[] ToPoint3fArray()",summary:"Copies all vertices to a new array of .",since:5,returns:"A new array."}]},{name:"Rhino.Geometry.Collections.MeshVertexNormalList",dataType:1,summary:"Provides access to the Vertex Normals of a Mesh.",properties:[{signature:"int Capacity",summary:"Gets or sets the amount of vertex normals that the list can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of mesh vertex normals.",since:5}],methods:[{signature:"int Add(double x,double y,double z)",summary:"Adds a new vertex normal at the end of the list.",since:5,returns:"The index of the newly added vertex normal."},{signature:"int Add(float x,float y,float z)",summary:"Adds a new vertex normal at the end of the list.",since:5,returns:"The index of the newly added vertex normal."},{signature:"int Add(Vector3d normal)",summary:"Adds a new vertex normal at the end of the list.",since:5,returns:"The index of the newly added vertex normal."},{signature:"int Add(Vector3f normal)",summary:"Adds a new vertex normal at the end of the list.",since:5,returns:"The index of the newly added vertex normal."},{signature:"bool AddRange(Vector3f[] normals)",summary:"Appends a collection of normal vectors.",since:5,returns:"True on success, False on failure."},{signature:"void Clear()",summary:"Clears the vertex normal collection on the mesh.",since:5},{signature:"bool ComputeNormals()",summary:"Computes the vertex normals based on the physical shape of the mesh.",since:5,returns:"True on success, False on failure."},{signature:"void Destroy()",summary:"Releases all memory allocated to store vertex normals. The list capacity will be 0 after this call.\n     Subsequent calls can add new items.",since:6},{signature:"void Flip()",summary:"Reverses direction of all vertex normals\n     This is the same as Mesh.Flip(true, false, false)",since:5},{signature:"IEnumerator<Vector3f> GetEnumerator()",summary:"Gets an enumerator that yields all normals (vectors) in this collection.",since:5,returns:"The enumerator."},{signature:"bool SetNormal(int index,double x,double y,double z)",summary:"Sets or adds a vertex normal to the list.\n     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetNormal(int index,float x,float y,float z)",summary:"Sets or adds a normal to the list.\n     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetNormal(int index,Vector3d normal)",summary:"Sets or adds a vertex normal to the list.\n     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetNormal(int index,Vector3f normal)",summary:"Sets or adds a vertex normal to the list.\n     If [index] is less than [Count], the existing vertex normal at [index] will be modified.If [index] equals [Count], a new vertex normal is appended to the end of the vertex list.If [index] is larger than [Count], the function will return false.",since:5,returns:"True on success, False on failure."},{signature:"bool SetNormals(Vector3f[] normals)",summary:"Sets all normal vectors in one go. This method destroys the current normal array if it exists.",since:5,returns:"True on success, False on failure."},{signature:"float[] ToFloatArray()",summary:"Copies all vertex normals to a linear array of float in x,y,z order",since:6,returns:"The float array."},{signature:"bool UnitizeNormals()",summary:"Unitizes all vertex normals.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.Collections.MeshVertexStatusList",dataType:1,summary:"Provides access to status information relative to components of a mesh.",properties:[{signature:"int Capacity",summary:"Gets or sets the total number of hidden vertex information the internal data structure can hold without resizing.",since:6},{signature:"int Count",summary:"Gets or sets the number of hidden vertices. For this to be a valid part of a mesh, this count should be the same as the one of mesh vertices.",since:6},{signature:"int HiddenCount",summary:"Gets a value indicating how many vertices have been set to hidden.",since:6}],methods:[{signature:"void Add(bool hidden)",summary:"Adds a new flag at the end of the list.",since:6,returns:"The index of the newly added hidden vertex."},{signature:"void AddRange(IEnumerable<bool> values)",summary:"Appends an array, a list or any enumerable of flags to the end of the list.",since:6,returns:"True on success, False on failure."},{signature:"void Clear()",summary:"Clears the hidden vertex list on the mesh. This results in a fully visible mesh.",since:6},{signature:"bool Contains(bool hidden)",summary:"Determines if some vertices are hidden or some are shown.",since:6,returns:"True if the array contains the specified value."},{signature:"void CopyTo(bool[] array,int arrayIndex)",summary:"Copies to an array, starting at an index.",since:6},{signature:"void Destroy()",summary:"Releases all memory allocated to store hidden vertices. The list capacity will be 0 after this call.\n     Vertices will be immediately considered visible.Subsequent calls can add new items.",since:6},{signature:"IEnumerator<bool> GetEnumerator()",summary:"Gets an enumerator that yields all flags in this collection.",since:6,returns:"The enumerator."}]},{name:"Rhino.Geometry.Collections.NurbsCurveKnotList",dataType:1,summary:"Provides access to the knot vector of a nurbs curve.",properties:[{signature:"int Count",summary:"Total number of knots in this curve.",since:5},{signature:"bool IsClampedEnd",summary:"Gets a value indicating whether or not the knot vector is clamped at the end of the curve. \n     Clamped curves are coincident with the first and last control-point. This requires fully multiple knots.",since:5},{signature:"bool IsClampedStart",summary:"Gets a value indicating whether or not the knot vector is clamped at the start of the curve. \n     Clamped curves start at the first control-point. This requires fully multiple knots.",since:5}],methods:[{signature:"bool ClampEnd(CurveEnd end)",summary:"Clamp end knots. Does not modify control point locations.",since:5,returns:"True on success, False on failure."},{signature:"bool Contains(double item)",summary:"Returns an indication of the presence of a value in the knot list.",since:6,returns:"True if present, False otherwise."},{signature:"void CopyTo(double[] array,int arrayIndex)",summary:"Copies the list to an array.",since:6},{signature:"bool CreatePeriodicKnots(double knotSpacing)",summary:"Compute a clamped, uniform, periodic knot vector based on the current\n     degree and control point count. Does not change values of control\n     vertices.",since:5,returns:"True on success, False on failure."},{signature:"bool CreateUniformKnots(double knotSpacing)",summary:"Compute a clamped, uniform knot vector based on the current\n     degree and control point count. Does not change values of control\n     vertices.",since:5,returns:"True on success, False on failure."},{signature:"void EnsurePrivateCopy()",summary:"If you want to keep a copy of this class around by holding onto it in a variable after a command\n     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can\n     call this function as many times as you want.",since:5},{signature:"bool EpsilonEquals(NurbsCurveKnotList other,double epsilon)",summary:"Checks that all values in the other list are sequentially equal within epsilon to the values in this list.",since:5.4,returns:"True if values are, orderly, equal within epsilon. False otherwise."},{signature:"int IndexOf(double item)",summary:"Returns the first item in the list.",since:6,returns:"The index, or -1 if no index is found."},{signature:"bool InsertKnot(double value)",summary:"Inserts a knot and update control point locations.\n     Does not change parameterization or locus of curve.",since:5,returns:"True on success, False on failure."},{signature:"bool InsertKnot(double value,int multiplicity)",summary:"Inserts a knot and update control point locations.\n     Does not change parameterization or locus of curve.",since:5,returns:"True on success, False on failure."},{signature:"int KnotMultiplicity(int index)",summary:"Get knot multiplicity.",since:5,returns:"The multiplicity (valence) of the knot."},{signature:"bool RemoveKnotAt(double t)",summary:"Remove a knot from a curve and adjusts the remaining control points to maintain curve position as closely as possible.",since:6,returns:"True if successful, False on failure."},{signature:"bool RemoveKnots(int index0,int index1)",summary:"Remove knots from a curve and adjusts the remaining control points to maintain curve position as closely as possible.\n     The knots from Knots[index0] through Knots[index1 - 1] will be removed.",since:6,returns:"True if successful, False on failure."},{signature:"int RemoveMultipleKnots(int minimumMultiplicity,int maximumMultiplicity,double tolerance)",summary:"Remove multiple knots from this curve.",since:6,returns:"number of knots removed on success. 0 if no knots were removed"},{signature:"double SuperfluousKnot(bool start)",summary:"Computes the knots that are superfluous because they are not used in NURBs evaluation.\n     These make it appear so that the first and last curve spans are different from interior spans.\n     http://wiki.mcneel.com/developer/onsuperfluousknot",since:5,returns:"A component."}]},{name:"Rhino.Geometry.Collections.NurbsCurvePointList",dataType:1,summary:"Provides access to the control points of a nurbs curve.",properties:[{signature:"double ControlPolygonLength",summary:"Gets the length of the polyline connecting all control points.",since:5},{signature:"int Count",summary:"Gets the number of control points in this curve.",since:5},{signature:"int PointSize",summary:"Returns the control point size, or the number of doubles per control point. \n     For rational curves, PointSize = Curve.Dimension + 1. \n     For non-rational curves, PointSize = Curve.Dimension.",since:6.9}],methods:[{signature:"bool ChangeEndWeights(double w0,double w1)",summary:"Use a combination of scaling and reparameterization to change the end weights to the specified values.",since:5,returns:"True on success, False on failure."},{signature:"bool Contains(ControlPoint item)",summary:"Determines if this list contains an item.",since:6,returns:"A boolean value."},{signature:"Polyline ControlPolygon()",summary:"Constructs a polyline through all the control points. \n     Note that periodic curves generate a closed polyline with fewer \n     points than control-points.",since:5,returns:"A polyline connecting all control points."},{signature:"void CopyTo(ControlPoint[] array,int arrayIndex)",summary:"Copied the list to an array.",since:6},{signature:"void EnsurePrivateCopy()",summary:"If you want to keep a copy of this class around by holding onto it in a variable after a command\n     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can\n     call this function as many times as you want.",since:5},{signature:"bool EpsilonEquals(NurbsCurvePointList other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool GetPoint(int index,Point3d point)",summary:"Gets a world 3-D, or Euclidean, control point at the given index.\n     The 4-D representation is (x, y, z, 1.0).",since:6,returns:"True on success, False on failure."},{signature:"bool GetPoint(int index,Point4d point)",summary:"Gets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:6,returns:"True on success, False on failure."},{signature:"double GetWeight(int index)",summary:"Gets the weight of a control point at the given index.\n     Note, if the curve is non-rational, the weight will be 1.0.",since:6,returns:"The control point weight if successful, Rhino.Math.UnsetValue otherwise."},{signature:"int IndexOf(ControlPoint item)",summary:"Gets the index of a control point, or -1.",since:6,returns:"The index."},{signature:"bool MakeNonRational()",summary:"Converts the curve to a Non-rational NURBS curve. Non-rational curves have unweighted control points.",since:5,returns:"True on success, False on failure."},{signature:"bool MakeRational()",summary:"Converts the curve to a Rational NURBS curve. Rational NURBS curves have weighted control points.",since:5,returns:"True on success, False on failure."},{signature:"bool SetPoint(int index,double x,double y,double z)",summary:"Sets a world 3-D, or Euclidean, control point at the given index.\n     The 4-D representation is (x, y, z, 1.0).",since:6,returns:"True on success, False on failure."},{signature:"bool SetPoint(int index,double x,double y,double z,double weight)",summary:"Sets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:5,returns:"True on success, False on failure."},{signature:"bool SetPoint(int index,Point3d point)",summary:"Sets a world 3-D, or Euclidean, control point at the given index.\n     The 4-D representation is (x, y, z, 1.0).",since:5,returns:"True on success, False on failure."},{signature:"bool SetPoint(int index,Point3d point,double weight)",summary:"Sets a world 3-D, or Euclidean, control point and weight at a given index.\n     The 4-D representation is (x*w, y*w, z*w, w).",since:6,returns:"True on success, False on failure."},{signature:"bool SetPoint(int index,Point4d point)",summary:"Sets a homogeneous control point at the given index, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:5,returns:"True on success, False on failure."},{signature:"bool SetWeight(int index,double weight)",summary:"Sets the weight of a control point at the given index\n     Note, if the curve is non-rational, it will be converted to rational.",since:6,returns:"True if successful, False otherwise."},{signature:"bool UVNDirectionsAt(int index,Vector3d uDir,Vector3d vDir,Vector3d nDir)",summary:"Calculates the U, V, and N directions of a NURBS curve control point similar to the method used by Rhino's MoveUVN command.",since:7,returns:"True if successful, False otherwise."},{signature:"bool ValidateSpacing(double closeTolerance,double stackTolerance,int[] closeIndices,int[] stackedIndices)",summary:"Simple check of distance between adjacent control points",since:6,returns:"True if close or stacked indices are found"}]},{name:"Rhino.Geometry.Collections.NurbsSurfaceKnotList",dataType:1,summary:"Provides access to the knot vector of a nurbs surface.",properties:[{signature:"bool ClampedAtEnd",summary:"Determines if a knot vector is clamped.",since:5},{signature:"bool ClampedAtStart",summary:"Determines if a knot vector is clamped.",since:5},{signature:"int Count",summary:"Gets the total number of knots in this curve.",since:5}],methods:[{signature:"bool CreatePeriodicKnots(double knotSpacing)",summary:"Compute a clamped, uniform, periodic knot vector based on the current\n     degree and control point count. Does not change values of control\n     vertices.",since:5,returns:"True on success, False on failure."},{signature:"bool CreateUniformKnots(double knotSpacing)",summary:"Compute a clamped, uniform knot vector based on the current\n     degree and control point count. Does not change values of control\n     vertices.",since:5,returns:"True on success, False on failure."},{signature:"void EnsurePrivateCopy()",summary:"If you want to keep a copy of this class around by holding onto it in a variable after a command\n     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can\n     call this function as many times as you want.",since:5},{signature:"bool EpsilonEquals(NurbsSurfaceKnotList other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool InsertKnot(double value)",summary:"Inserts a knot and update control point locations.\n     Does not change parameterization or locus of curve.",since:5,returns:"True on success, False on failure."},{signature:"bool InsertKnot(double value,int multiplicity)",summary:"Inserts a knot and update control point locations.\n     Does not change parameterization or locus of curve.",since:5,returns:"True on success, False on failure."},{signature:"int KnotMultiplicity(int index)",summary:"Get knot multiplicity.",since:5,returns:"The multiplicity (valence) of the knot."},{signature:"bool RemoveKnots(int index0,int index1)",summary:"Remove knots from the knot vector and adjusts the remaining control points to maintain surface position as closely as possible.\n     The knots from Knots[index0] through Knots[index1 - 1] will be removed.",since:6,returns:"True if successful, False on failure."},{signature:"bool RemoveKnotsAt(double u,double v)",summary:"Remove knots from the surface and adjusts the remaining control points to maintain surface position as closely as possible.",since:6,returns:"True if successful, False on failure."},{signature:"int RemoveMultipleKnots(int minimumMultiplicity,int maximumMultiplicity,double tolerance)",summary:"Remove multiple knots from this surface",since:6,returns:"number of knots removed on success. 0 if no knots were removed"},{signature:"double SuperfluousKnot(bool start)",summary:"Computes the knots that are superfluous because they are not used in NURBs evaluation.\n     These make it appear so that the first and last surface spans are different from interior spans.\n     http://wiki.mcneel.com/developer/onsuperfluousknot",since:5,returns:"A component."}]},{name:"Rhino.Geometry.Collections.NurbsSurfacePointList",dataType:1,summary:"Provides access to the control points of a nurbs surface.",properties:[{signature:"int CountU",summary:"Gets the number of control points in the U direction of this surface.",since:5},{signature:"int CountV",summary:"Gets the number of control points in the V direction of this surface.",since:5},{signature:"int PointSize",summary:"Returns the control point size, or the number of doubles per control point. \n     For rational curves, PointSize = Surface.Dimension + 1. \n     For non-rational curves, PointSize = Surface.Dimension.",since:6.9}],methods:[{signature:"void EnsurePrivateCopy()",summary:"If you want to keep a copy of this class around by holding onto it in a variable after a command\n     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can\n     call this function as many times as you want.",since:5},{signature:"bool EpsilonEquals(NurbsSurfacePointList other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"ControlPoint GetControlPoint(int u,int v)",summary:"Gets the control point at the given (u, v) index.",since:5,returns:"The control point at the given (u, v) index."},{signature:"Point2d GetGrevillePoint(int u,int v)",summary:"Gets the 2-D Greville point associated with the control point at the given (u, v) index.",since:5,returns:"A Surface UV coordinate on success, Point2d.Unset on failure."},{signature:"bool GetPoint(int u,int v,Point3d point)",summary:"Gets a world 3-D, or Euclidean, control point at the given (u, v) index.\n     The 4-D representation is (x, y, z, 1.0).",since:6,returns:"True on success, False on failure."},{signature:"bool GetPoint(int u,int v,Point4d point)",summary:"Gets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:6,returns:"True on success, False on failure."},{signature:"double GetWeight(int u,int v)",summary:"Gets the weight of a control point at the given (u, v) index.\n     Note, if the surface is non-rational, the weight will be 1.0.",since:6,returns:"The control point weight if successful, Rhino.Math.UnsetValue otherwise."},{signature:"bool SetControlPoint(int u,int v,ControlPoint cp)",summary:"Sets the control point at the given (u, v) index.",since:5,returns:"True on success, False on failure."},{signature:"bool SetControlPoint(int u,int v,Point3d cp)",summary:"Sets the control point at the given (u, v) index.",since:5,returns:"True on success, False on failure."},{signature:"bool SetPoint(int u,int v,double x,double y,double z)",summary:"Sets a world 3-D, or Euclidean, control point at the given (u, v) index.\n     The 4-D representation is (x, y, z, 1.0).",since:6,returns:"True on success, False on failure."},{signature:"bool SetPoint(int u,int v,double x,double y,double z,double weight)",summary:"Sets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:6,returns:"True on success, False on failure."},{signature:"bool SetPoint(int u,int v,Point3d point)",summary:"Sets a world 3-D, or Euclidean, control point at the given (u, v) index.\n     The 4-D representation is (x, y, z, 1.0).",since:6,returns:"True on success, False on failure."},{signature:"bool SetPoint(int u,int v,Point3d point,double weight)",summary:"Sets a world 3-D, or Euclidean, control point and weight at a given index.\n     The 4-D representation is (x*w, y*w, z*w, w).",since:6,returns:"True on success, False on failure."},{signature:"bool SetPoint(int u,int v,Point4d point)",summary:"Sets a homogeneous control point at the given (u, v) index, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:6,returns:"True on success, False on failure."},{signature:"bool SetWeight(int u,int v,double weight)",summary:"Sets the weight of a control point at the given (u, v) index.\n     Note, if the surface is non-rational, it will be converted to rational.",since:6,returns:"True if successful, False otherwise."},{signature:"bool UVNDirectionsAt(int u,int v,Vector3d uDir,Vector3d vDir,Vector3d nDir)",summary:"Calculates the U, V, and N directions of a NURBS surface control point similar to the method used by Rhino's MoveUVN command.",since:7,returns:"True if successful, False otherwise."},{signature:"bool ValidateSpacing(double closeTolerance,double stackTolerance,IndexPair[] closeIndices,IndexPair[] stackedIndices)",summary:"Simple check of distance between adjacent control points",since:6}]},{name:"Rhino.Geometry.Collections.SubDEdgeList",dataType:1,summary:"All edges in a SubD",properties:[{signature:"int Count",summary:"Gets the number of SubD edges.",since:7}],methods:[{signature:"SubDEdge Add(SubDEdgeTag tag,SubDVertex v0,SubDVertex v1)",summary:"Add a new edge to the list.",since:7},{signature:"SubDEdge Find(int id)",summary:"Find an edge in this SubD with a given id",since:7},{signature:"SubDEdge Find(uint id)",summary:"Find an edge in this SubD with a given id",since:7},{signature:"IEnumerator<SubDEdge> GetEnumerator()",summary:"Implementation of IEnumerable",since:7}]},{name:"Rhino.Geometry.Collections.SubDFaceList",dataType:1,summary:"All faces in a SubD",properties:[{signature:"int Count",summary:"Gets the number of SubD faces.",since:7}],methods:[{signature:"SubDFace Find(int id)",summary:"Find a face in this SubD with a given id",since:7},{signature:"SubDFace Find(uint id)",summary:"Find a face in this SubD with a given id",since:7},{signature:"IEnumerator<SubDFace> GetEnumerator()",summary:"Implementation of IEnumerable",since:7}]},{name:"Rhino.Geometry.Collections.SubDVertexList",dataType:1,summary:"Provides access to the vertices and vertex-related functionality of a SubD",properties:[{signature:"int Count",summary:"Gets the number of SubD vertices.",since:7},{signature:"SubDVertex First",summary:"First vertex in this linked list of vertices",since:7}],methods:[{signature:"SubDVertex Add(SubDVertexTag tag,Point3d vertex)",summary:"Add a new vertex to the end of the Vertex list.",since:7,returns:"The newly added vertex."},{signature:"SubDVertex Find(int id)",summary:"Find a vertex in this SubD with a given id",since:7},{signature:"SubDVertex Find(uint id)",summary:"Find a vertex in this SubD with a given id",since:7}]},{name:"Rhino.Geometry.ComponentIndex",dataType:2,summary:"Represents an index of an element contained in another object.",constructors:[{signature:"ComponentIndex(ComponentIndexType type,int index)",summary:"Construct component index with a specific type/index combination",since:5}],properties:[{signature:"static ComponentIndex Unset",summary:"The unset value of component index.",since:5},{signature:"ComponentIndexType ComponentIndexType",summary:"The interpretation of Index depends on the Type value.\n     Type             m_index interpretation (0 based indices)\n     no_type            used when context makes it clear what array is being index\n     brep_vertex        Brep.m_V[] array index\n     brep_edge          Brep.m_E[] array index\n     brep_face          Brep.m_F[] array index\n     brep_trim          Brep.m_T[] array index\n     brep_loop          Brep.m_L[] array index\n     mesh_vertex        Mesh.m_V[] array index\n     meshtop_vertex     MeshTopology.m_topv[] array index\n     meshtop_edge       MeshTopology.m_tope[] array index\n     mesh_face          Mesh.m_F[] array index\n     idef_part          InstanceDefinition.m_object_uuid[] array index\n     polycurve_segment  PolyCurve::m_segment[] array index\n     dim_linear_point   LinearDimension2::POINT_INDEX\n     dim_radial_point   RadialDimension2::POINT_INDEX\n     dim_angular_point  AngularDimension2::POINT_INDEX\n     dim_ordinate_point OrdinateDimension2::POINT_INDEX\n     dim_text_point     TextEntity2 origin point.",since:5},{signature:"int Index",summary:"The interpretation of m_index depends on the m_type value.\n     m_type             m_index interpretation (0 based indices)\n     no_type            used when context makes it clear what array is being index\n     brep_vertex        Brep.m_V[] array index\n     brep_edge          Brep.m_E[] array index\n     brep_face          Brep.m_F[] array index\n     brep_trim          Brep.m_T[] array index\n     brep_loop          Brep.m_L[] array index\n     mesh_vertex        Mesh.m_V[] array index\n     meshtop_vertex     MeshTopology.m_topv[] array index\n     meshtop_edge       MeshTopology.m_tope[] array index\n     mesh_face          Mesh.m_F[] array index\n     idef_part          InstanceDefinition.m_object_uuid[] array index\n     polycurve_segment  PolyCurve::m_segment[] array index\n     dim_linear_point   LinearDimension2::POINT_INDEX\n     dim_radial_point   RadialDimension2::POINT_INDEX\n     dim_angular_point  AngularDimension2::POINT_INDEX\n     dim_ordinate_point OrdinateDimension2::POINT_INDEX\n     dim_text_point     TextEntity2 origin point.",since:5}],methods:[{signature:"bool IsUnset()",summary:"Return True is this component index is the same as the Unset component index",since:7}]},{name:"Rhino.Geometry.ComponentIndexType",dataType:3,summary:"Defines enumerated values to represent component index types."},{name:"Rhino.Geometry.ComponentStatus",dataType:2,summary:"Provides information about selection, highlighting, visibility, editability and integrity states of a component.\n   This structure is immutable.",properties:[{signature:"static ComponentStatus AllSet",summary:"All flags are checked.",since:6},{signature:"static ComponentStatus Clear",summary:"This is the default value and equal to undefined.",since:6},{signature:"static ComponentStatus Damaged",summary:"The damaged flag is checked.",since:6},{signature:"static ComponentStatus Hidden",summary:"The hidden flag is checked.",since:6},{signature:"static ComponentStatus Highlighted",summary:"The highlight selection flag is checked.",since:6},{signature:"static ComponentStatus Locked",summary:"The locked flag is checked.",since:6},{signature:"static ComponentStatus Selected",summary:"The selection flag is checked.",since:6},{signature:"static ComponentStatus SelectedPersistent",summary:"The persistent selection flag is checked.",since:6},{signature:"bool IsClear",summary:"True if every setting is 0 or false.",since:6},{signature:"bool IsDamaged",summary:"Returns False if component is not damaged. True otherwise.",since:6},{signature:"bool IsHidden",summary:"Returns True if hidden. False otherwise.",since:6},{signature:"bool IsHighlighted",summary:"Returns True if highlighted. False otherwise.",since:6},{signature:"bool IsLocked",summary:"Returns True if locked. False otherwise.",since:6},{signature:"bool IsSelected",summary:"Returns True if selected or selected persistent. False otherwise.",since:6},{signature:"bool IsSelectedPersistent",summary:"Returns True if selected persistent. False otherwise.",since:6}],methods:[{signature:"bool Equals(ComponentStatus other)",summary:"Determines if another ComponentStatus and this are equal.",since:6,returns:"True if equal in value. False otherwise"},{signature:"bool Equals(object obj)",summary:"Determines if an object and this are equal.",returns:"True if equal in value. False otherwise"},{signature:"int GetHashCode()",summary:"Serves as a special hash function. The inner value is used for the purpose.",returns:"An integer deriving from a bit mask."},{signature:"bool HasAllEqualStates(ComponentStatus statesFilter,ComponentStatus comparand)",summary:"For the purposes of this test, Selected and SelectedPersistent are considered equal.",since:6,returns:'True if at all tested states in "this" and comparand are identical.'},{signature:"bool HasNoEqualStates(ComponentStatus statesFilter,ComponentStatus comparand)",summary:"For the purposes of this test, Selected and SelectedPersistent are considered equal.",since:6,returns:'True if at all tested states in "this" and comparand are identical.'},{signature:"bool HasSomeEqualStates(ComponentStatus statesFilter,ComponentStatus comparand)",summary:"For the purposes of this test, Selected and SelectedPersistent are considered equal.",since:6,returns:'True if at least one tested state in "this" and comparand are identical.'},{signature:"string ToString()",summary:"Provides a string representation of this ComponentStatus.",returns:"The representation in English."},{signature:"ComponentStatus WithStates(ComponentStatus additionalStatus)",summary:"Activates any information flag described in any of the two input component statuses\n     and returns a new ComponentStatus with those flags checked.",since:6}]},{name:"Rhino.Geometry.Concavity",dataType:3,summary:"Enumerates the possible types of edge concavity types."},{name:"Rhino.Geometry.Cone",dataType:2,summary:"Represents the center plane, radius and height values in a right circular cone.",constructors:[{signature:"Cone(Plane plane,double height,double radius)",summary:"Initializes a new cone with a specified base plane, height and radius.",since:5}],properties:[{signature:"static Cone Unset",summary:"Gets an invalid Cone.",since:5},{signature:"Point3d ApexPoint",summary:"Point at tip of the cone.",since:5},{signature:"Vector3d Axis",summary:"Unit vector axis of cone.",since:5},{signature:"Point3d BasePoint",summary:"Center of base circle.",since:5},{signature:"double Height",summary:"Gets or sets the height of the circular right cone.",since:5},{signature:"bool IsValid",summary:"True if plane is valid, height is not zero and radius is not zero.",since:5},{signature:"Plane Plane",summary:"Gets or sets the base plane of the cone.  The apex of the cone is at the plane's origin.",since:5},{signature:"double Radius",summary:"Gets or sets the radius of the cone.",since:5}],methods:[{signature:"double AngleInDegrees()",summary:"Computes the angle (in degrees) between the axis and the \n     side of the cone.\n     The angle and the height have the same sign.",since:5,returns:"An angle in degrees."},{signature:"double AngleInRadians()",summary:"Computes the angle (in radians) between the axis and the \n     side of the cone.\n     The angle and the height have the same sign.",since:5,returns:"Math.Atan(Radius / Height) if the height is not 0; 0 if the radius is 0; Math.PI otherwise."},{signature:"bool EpsilonEquals(Cone other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"Brep ToBrep(bool capBottom)",summary:"Gets a Brep representation of the cone with a single\n     face for the cone, an edge along the cone seam, \n     and vertices at the base and apex ends of this seam edge.\n     The optional cap is a single face with one circular edge \n     starting and ending at the base vertex.",since:5,returns:"A brep (polysurface) representation of this cone values."},{signature:"NurbsSurface ToNurbsSurface()",summary:"Constructs a Nurbs surface representation of this Cone. \n     This is synonymous with calling NurbsSurface.CreateFromCone().",since:5,returns:"A Nurbs surface representation of the cone or null."},{signature:"RevSurface ToRevSurface()",summary:"Constructs a RevSurface representation of this Cone. \n     This is synonymous with calling RevSurface.CreateFromCone().",since:5,returns:"A RevSurface representation of the cone or null."}]},{name:"Rhino.Geometry.ConicSectionType",dataType:3,summary:"Defines enumerated values for types of conic sections."},{name:"Rhino.Geometry.Continuity",dataType:3,summary:"Provides enumerated values for continuity along geometry,\n     such as continuous first derivative or continuous unit tangent and curvature."},{name:"Rhino.Geometry.ControlPoint",dataType:2,summary:"Represents control point geometry with three-dimensional position and weight.",constructors:[{signature:"ControlPoint(double x,double y,double z)",summary:"Constructs a new world 3-D, or Euclidean, control point.\n     The 4-D representation is (x, y, z, 1.0).",since:5},{signature:"ControlPoint(double x,double y,double z,double weight)",summary:"Constructs a new homogeneous control point, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:5},{signature:"ControlPoint(Point3d pt)",summary:"Constructs a new world 3-D, or Euclidean, control point.\n     The 4-D representation of this is (x, y, z, 1.0).",since:5},{signature:"ControlPoint(Point3d euclideanPt,double weight)",summary:"Constructs a control point from a world 3-D, or Euclidean, location and a weight.\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:5},{signature:"ControlPoint(Point4d pt)",summary:"Constructs a new homogeneous control point, where the 4-D representation is (x, y, z, w).\n     The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).",since:5}],properties:[{signature:"static ControlPoint Unset",summary:"Gets the predefined, unset control point.",since:5},{signature:"Point3d Location",summary:"Gets or sets world 3-D, or Euclidean location of the control point.",since:5},{signature:"double Weight",summary:"Gets or sets the weight of this control point.",since:5},{signature:"double X",summary:"Gets or sets the X coordinate of the control point.",since:6},{signature:"double Y",summary:"Gets or sets the Y coordinate of the control point.",since:6},{signature:"double Z",summary:"Gets or sets the Z coordinate of the control point.",since:6}],methods:[{signature:"bool EpsilonEquals(ControlPoint other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(ControlPoint other)",summary:"Determines if two points exactly match.",since:6,returns:"True if the other control point exactly matches this one."}]},{name:"Rhino.Geometry.Curve",dataType:1,summary:"Represents a base class that is common to most RhinoCommon curve types.\n   A curve represents an entity that can be all visited by providing\n   a single parameter, usually called t.",properties:[{signature:"int Degree",summary:"Gets the maximum algebraic degree of any span\n     or a good estimate if curve spans are not algebraic.",since:5},{signature:"int Dimension",summary:"Gets the dimension of the object.\n     The dimension is typically three. For parameter space trimming\n     curves the dimension is two. In rare cases the dimension can\n     be one or greater than three.",since:5},{signature:"Interval Domain",summary:"Gets or sets the domain of the curve.",since:5},{signature:"bool IsClosed",summary:"Gets a value indicating whether or not this curve is a closed curve.",since:5},{signature:"bool IsPeriodic",summary:"Gets a value indicating whether or not this curve is considered to be Periodic.",since:5},{signature:"Point3d PointAtEnd",summary:"Evaluates point at the end of the curve.",since:5},{signature:"Point3d PointAtStart",summary:"Evaluates point at the start of the curve.",since:5},{signature:"int SpanCount",summary:"Gets the number of non-empty smooth (c-infinity) spans in the curve.",since:5},{signature:"Vector3d TangentAtEnd",summary:"Evaluate unit tangent vector at the end of the curve.",since:5},{signature:"Vector3d TangentAtStart",summary:"Evaluates the unit tangent vector at the start of the curve.",since:5}],methods:[{signature:"static Curve CreateArcBlend(Point3d startPt,Vector3d startDir,Point3d endPt,Vector3d endDir,double controlPointLengthRatio)",summary:"Creates a polycurve consisting of two tangent arc segments that connect two points and two directions.",since:6.1,returns:"The arc blend curve, or None on error."},{signature:"static Curve CreateBlendCurve(Curve curveA,Curve curveB,BlendContinuity continuity)",summary:"Create a Blend curve between two existing curves.",since:5,returns:"A curve representing the blend between A and B or None on failure."},{signature:"static Curve CreateBlendCurve(Curve curveA,Curve curveB,BlendContinuity continuity,double bulgeA,double bulgeB)",summary:"Create a Blend curve between two existing curves.",since:5,returns:"A curve representing the blend between A and B or None on failure."},{signature:"static Curve CreateBlendCurve(Curve curve0,double t0,bool reverse0,BlendContinuity continuity0,Curve curve1,double t1,bool reverse1,BlendContinuity continuity1)",summary:"Makes a curve blend between 2 curves at the parameters specified\n     with the directions and continuities specified",since:5,returns:"The blend curve on success. None on failure"},{signature:"static Curve[] CreateBooleanDifference(Curve curveA,Curve curveB)",summary:"Calculates the boolean difference between two closed, planar curves. \n     Note, curves must be co-planar.",since:5,returns:"Result curves on success, empty array if no difference could be calculated."},{signature:"static Curve[] CreateBooleanDifference(Curve curveA,Curve curveB,double tolerance)",summary:"Calculates the boolean difference between two closed, planar curves. \n     Note, curves must be co-planar.",since:6,returns:"Result curves on success, empty array if no difference could be calculated."},{signature:"static Curve[] CreateBooleanDifference(Curve curveA,IEnumerable<Curve> subtractors)",summary:"Calculates the boolean difference between a closed planar curve, and a list of closed planar curves. \n     Note, curves must be co-planar.",since:5,returns:"Result curves on success, empty array if no difference could be calculated."},{signature:"static Curve[] CreateBooleanDifference(Curve curveA,IEnumerable<Curve> subtractors,double tolerance)",summary:"Calculates the boolean difference between a closed planar curve, and a list of closed planar curves. \n     Note, curves must be co-planar.",since:6,returns:"Result curves on success, empty array if no difference could be calculated."},{signature:"static Curve[] CreateBooleanIntersection(Curve curveA,Curve curveB)",summary:"Calculates the boolean intersection of two closed, planar curves. \n     Note, curves must be co-planar.",since:5,returns:"Result curves on success, empty array if no intersection could be calculated."},{signature:"static Curve[] CreateBooleanIntersection(Curve curveA,Curve curveB,double tolerance)",summary:"Calculates the boolean intersection of two closed, planar curves. \n     Note, curves must be co-planar.",since:6,returns:"Result curves on success, empty array if no intersection could be calculated."},{signature:"static CurveBooleanRegions CreateBooleanRegions(IEnumerable<Curve> curves,Plane plane,bool combineRegions,double tolerance)",summary:"Calculates curve Boolean regions, which trims and splits curves based on their overlapping regions.",since:7,returns:"The curve Boolean regions if successful, None of no successful."},{signature:"static CurveBooleanRegions CreateBooleanRegions(IEnumerable<Curve> curves,Plane plane,IEnumerable<Point3d> points,bool combineRegions,double tolerance)",summary:"Curve Boolean method, which trims and splits curves based on their overlapping regions.",since:7,returns:"The curve Boolean regions if successful, None of no successful."},{signature:"static Curve[] CreateBooleanUnion(IEnumerable<Curve> curves)",summary:"Calculates the boolean union of two or more closed, planar curves. \n     Note, curves must be co-planar.",since:5,returns:"Result curves on success, empty array if no union could be calculated."},{signature:"static Curve[] CreateBooleanUnion(IEnumerable<Curve> curves,double tolerance)",summary:"Calculates the boolean union of two or more closed, planar curves. \n     Note, curves must be co-planar.",since:6,returns:"Result curves on success, empty array if no union could be calculated."},{signature:"static Curve CreateControlPointCurve(IEnumerable<Point3d> points)",summary:"Constructs a control-point of degree=3 (or less).",since:5},{signature:"static Curve CreateControlPointCurve(IEnumerable<Point3d> points,int degree)",summary:"Constructs a curve from a set of control-point locations.",since:5},{signature:"static Curve[] CreateCurve2View(Curve curveA,Curve curveB,Vector3d vectorA,Vector3d vectorB,double tolerance,double angleTolerance)",summary:"Creates a third curve from two curves that are planar in different construction planes. \n     The new curve looks the same as each of the original curves when viewed in each plane.",since:6,returns:"An array containing one or more curves if successful."},{signature:"static Arc CreateFillet(Curve curve0,Curve curve1,double radius,double t0Base,double t1Base)",summary:"Computes the fillet arc for a curve filleting operation.",since:5,returns:"The fillet arc on success, or Arc.Unset on failure."},{signature:"static Curve CreateFilletCornersCurve(Curve curve,double radius,double tolerance,double angleTolerance)",summary:"Rounds the corners of a kinked curve with arcs of a single, specified radius.",since:6,returns:"The filleted curve if successful. None on failure."},{signature:"static Curve[] CreateFilletCurves(Curve curve0,Point3d point0,Curve curve1,Point3d point1,double radius,bool join,bool trim,bool arcExtension,double tolerance,double angleTolerance)",summary:"Creates a tangent arc between two curves and trims or extends the curves to the arc.",since:5.1,returns:"The results of the fillet operation. The number of output curves depends\n     on the input curves and the values of the parameters that were used\n     during the fillet operation. In most cases, the output array will contain\n     either one or three curves, although two curves can be returned if the\n     radius is zero and join = false.\n     For example, if both join and trim = true, then the output curve\n     will be a polycurve containing the fillet curve joined with trimmed copies\n     of the input curves. If join = False and trim = true, then three curves,\n     the fillet curve and trimmed copies of the input curves, will be returned.\n     If both join and trim = false, then just the fillet curve is returned."},{signature:"static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points,int degree)",summary:"Interpolates a sequence of points. Used by InterpCurve Command\n     This routine works best when degree=3.",since:5,returns:"interpolated curve on success. None on failure."},{signature:"static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points,int degree,CurveKnotStyle knots)",summary:"Interpolates a sequence of points. Used by InterpCurve Command\n     This routine works best when degree=3.",since:5,returns:"interpolated curve on success. None on failure."},{signature:"static Curve CreateInterpolatedCurve(IEnumerable<Point3d> points,int degree,CurveKnotStyle knots,Vector3d startTangent,Vector3d endTangent)",summary:"Interpolates a sequence of points. Used by InterpCurve Command\n     This routine works best when degree=3.",since:5,returns:"interpolated curve on success. None on failure."},{signature:"static Curve CreateMeanCurve(Curve curveA,Curve curveB)",summary:"Constructs a mean, or average, curve from two curves.",since:5,returns:"The average curve, or None on error."},{signature:"static Curve CreateMeanCurve(Curve curveA,Curve curveB,double angleToleranceRadians)",summary:"Constructs a mean, or average, curve from two curves.",since:5,returns:"The average curve, or None on error."},{signature:"static Curve CreatePeriodicCurve(Curve curve)",summary:"Removes kinks from a curve. Periodic curves deform smoothly without kinks.",since:6,returns:"The resulting curve if successful, None otherwise."},{signature:"static Curve CreatePeriodicCurve(Curve curve,bool smooth)",summary:"Removes kinks from a curve. Periodic curves deform smoothly without kinks.",since:6,returns:"The resulting curve if successful, None otherwise."},{signature:"static Curve CreateSoftEditCurve(Curve curve,double t,Vector3d delta,double length,bool fixEnds)",summary:"Creates a soft edited curve from an exising curve using a smooth field of influence.",since:6,returns:"The soft edited curve if successful. None on failure."},{signature:"static Curve[] CreateTextOutlines(string text,string font,double textHeight,int textStyle,bool closeLoops,Plane plane,double smallCapsScale,double tolerance)",summary:"Creates outline curves created from a text string. The functionality is similar to what you find in Rhino's TextObject command or TextEntity.Explode() in RhinoCommon.",since:6,returns:"An array containing one or more curves if successful."},{signature:"static Curve[] CreateTweenCurves(Curve curve0,Curve curve1,int numCurves)",summary:"Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n     That means the first control point of first curve is matched to first control point of the second curve and so on.\n     There is no matching of curves direction. Caller must match input curves direction before calling the function.",since:5.2,returns:"An array of joint curves. This array can be empty."},{signature:"static Curve[] CreateTweenCurves(Curve curve0,Curve curve1,int numCurves,double tolerance)",summary:"Creates curves between two open or closed input curves. Uses the control points of the curves for finding tween curves.\n     That means the first control point of first curve is matched to first control point of the second curve and so on.\n     There is no matching of curves direction. Caller must match input curves direction before calling the function.",since:6,returns:"An array of joint curves. This array can be empty."},{signature:"static Curve[] CreateTweenCurvesWithMatching(Curve curve0,Curve curve1,int numCurves)",summary:"Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n     Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n     input curves are compatible and no refit is needed. There is no matching of curves direction.\n     Caller must match input curves direction before calling the function.",since:5.2,returns:"An array of joint curves. This array can be empty."},{signature:"static Curve[] CreateTweenCurvesWithMatching(Curve curve0,Curve curve1,int numCurves,double tolerance)",summary:"Creates curves between two open or closed input curves. Make the structure of input curves compatible if needed.\n     Refits the input curves to have the same structure. The resulting curves are usually more complex than input unless\n     input curves are compatible and no refit is needed. There is no matching of curves direction.\n     Caller must match input curves direction before calling the function.",since:6,returns:"An array of joint curves. This array can be empty."},{signature:"static Curve[] CreateTweenCurvesWithSampling(Curve curve0,Curve curve1,int numCurves,int numSamples)",summary:"Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n     This is how the algorithm workd: Divides the two curves into an equal number of points, finds the midpoint between the \n     corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n     direction. Caller must match input curves direction before calling the function.",since:5.2,returns:">An array of joint curves. This array can be empty."},{signature:"static Curve[] CreateTweenCurvesWithSampling(Curve curve0,Curve curve1,int numCurves,int numSamples,double tolerance)",summary:"Creates curves between two open or closed input curves. Use sample points method to make curves compatible.\n     This is how the algorithm workd: Divides the two curves into an equal number of points, finds the midpoint between the \n     corresponding points on the curves and interpolates the tween curve through those points. There is no matching of curves\n     direction. Caller must match input curves direction before calling the function.",since:6,returns:">An array of joint curves. This array can be empty."},{signature:"static bool DoDirectionsMatch(Curve curveA,Curve curveB)",summary:"Determines whether two curves travel more or less in the same direction.",since:5,returns:"True if both curves more or less point in the same direction, \n     False if they point in the opposite directions."},{signature:"static bool GetDistancesBetweenCurves(Curve curveA,Curve curveB,double tolerance,double maxDistance,double maxDistanceParameterA,double maxDistanceParameterB,double minDistance,double minDistanceParameterA,double minDistanceParameterB)",summary:"Computes the distances between two arbitrary curves that overlap.",since:5,returns:"True if the operation succeeded; otherwise false."},{signature:"static bool GetFilletPoints(Curve curve0,Curve curve1,double radius,double t0Base,double t1Base,double t0,double t1,Plane filletPlane)",summary:"Finds points at which to cut a pair of curves so that a fillet of given radius can be inserted.",since:5,returns:"True on success, False on failure."},{signature:"static Curve[] JoinCurves(IEnumerable<Curve> inputCurves)",summary:"Joins a collection of curve segments together.",since:5,returns:"An array of curves which contains."},{signature:"static Curve[] JoinCurves(IEnumerable<Curve> inputCurves,double joinTolerance)",summary:"Joins a collection of curve segments together.",since:5,returns:"An array of joint curves. This array can be empty."},{signature:"static Curve[] JoinCurves(IEnumerable<Curve> inputCurves,double joinTolerance,bool preserveDirection)",summary:"Joins a collection of curve segments together.",since:5,returns:"An array of joint curves. This array can be empty."},{signature:"static bool MakeEndsMeet(Curve curveA,bool adjustStartCurveA,Curve curveB,bool adjustStartCurveB)",summary:"Makes adjustments to the ends of one or both input curves so that they meet at a point.",since:5,returns:"True on success."},{signature:"static RegionContainment PlanarClosedCurveRelationship(Curve curveA,Curve curveB,Plane testPlane,double tolerance)",summary:"Determines whether two coplanar simple closed curves are disjoint or intersect;\n     otherwise, if the regions have a containment relationship, discovers\n     which curve encloses the other.",since:5,returns:"A value indicating the relationship between the first and the second curve."},{signature:"static bool PlanarCurveCollision(Curve curveA,Curve curveB,Plane testPlane,double tolerance)",summary:"Determines if two coplanar curves collide (intersect).",since:5,returns:"True if the curves intersect, otherwise false"},{signature:"static Curve[] ProjectToBrep(Curve curve,Brep brep,Vector3d direction,double tolerance)",summary:"Projects a Curve onto a Brep along a given direction.",since:5,returns:"An array of projected curves or empty array if the projection set is empty."},{signature:"static Curve[] ProjectToBrep(Curve curve,IEnumerable<Brep> breps,Vector3d direction,double tolerance)",summary:"Projects a Curve onto a collection of Breps along a given direction.",since:5,returns:"An array of projected curves or empty array if the projection set is empty."},{signature:"static Curve[] ProjectToBrep(Curve curve,IEnumerable<Brep> breps,Vector3d direction,double tolerance,int[] brepIndices)",summary:"Projects a Curve onto a collection of Breps along a given direction.",since:5,returns:"An array of projected curves or None if the projection set is empty."},{signature:"static Curve[] ProjectToBrep(IEnumerable<Curve> curves,IEnumerable<Brep> breps,Vector3d direction,double tolerance)",summary:"Projects a collection of Curves onto a collection of Breps along a given direction.",since:5,returns:"An array of projected curves or empty array if the projection set is empty."},{signature:"static Curve[] ProjectToBrep(IEnumerable<Curve> curves,IEnumerable<Brep> breps,Vector3d direction,double tolerance,int[] curveIndices,int[] brepIndices)",summary:"Projects a collection of Curves onto a collection of Breps along a given direction.",since:5,returns:"An array of projected curves. Array is empty if the projection set is empty."},{signature:"static Curve[] ProjectToMesh(Curve curve,IEnumerable<Mesh> meshes,Vector3d direction,double tolerance)",summary:"Projects a curve to a set of meshes using a direction and tolerance.",since:5,returns:"A curve array."},{signature:"static Curve[] ProjectToMesh(Curve curve,Mesh mesh,Vector3d direction,double tolerance)",summary:"Projects a curve to a mesh using a direction and tolerance.",since:5,returns:"A curve array."},{signature:"static Curve[] ProjectToMesh(IEnumerable<Curve> curves,IEnumerable<Mesh> meshes,Vector3d direction,double tolerance)",summary:"Projects a curve to a set of meshes using a direction and tolerance.",since:5,returns:"A curve array."},{signature:"static Curve ProjectToPlane(Curve curve,Plane plane)",summary:"Constructs a curve by projecting an existing curve to a plane.",since:5,returns:"The projected curve on success; None on failure."},{signature:"static Curve[] PullToBrepFace(Curve curve,BrepFace face,double tolerance)",summary:"Pull a curve to a BrepFace using closest point projection.",since:5,returns:"An array of pulled curves, or an empty array on failure."},{signature:"bool ChangeClosedCurveSeam(double t)",summary:"If this curve is closed, then modify it so that the start/end point is at curve parameter t.",since:5,returns:"True on success, False on failure."},{signature:"bool ChangeDimension(int desiredDimension)",summary:"Changes the dimension of a curve.",since:5,returns:"True if the curve's dimension was already desiredDimension\n     or if the curve's dimension was successfully changed to desiredDimension;\n     otherwise false."},{signature:"CurveOrientation ClosedCurveOrientation()",summary:"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in the world xy plane.\n     Only works with simple (no self intersections) closed, planar curves.",since:6,returns:"The orientation of this curve with respect to world xy plane."},{signature:"CurveOrientation ClosedCurveOrientation(Plane plane)",summary:"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in a given plane.\n     Only works with simple (no self intersections) closed, planar curves.",since:5,returns:"The orientation of this curve in the given plane."},{signature:"CurveOrientation ClosedCurveOrientation(Transform xform)",summary:"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve.\n     Only works with simple (no self intersections) closed, planar curves.",since:5,returns:"The orientation of this curve in the world xy-plane."},{signature:"CurveOrientation ClosedCurveOrientation(Vector3d upDirection)",summary:"Determines the orientation (counterclockwise or clockwise) of a closed, planar curve in a given plane.\n     Only works with simple (no self intersections) closed, planar curves.",since:5,returns:"The orientation of this curve with respect to a defined up direction."},{signature:"bool ClosestPoint(Point3d testPoint,double t)",summary:"Finds parameter of the point on a curve that is closest to testPoint.\n     If the maximumDistance parameter is > 0, then only points whose distance\n     to the given point is <= maximumDistance will be returned.  Using a \n     positive value of maximumDistance can substantially speed up the search.",since:5,returns:"True on success, False on failure."},{signature:"bool ClosestPoint(Point3d testPoint,double t,double maximumDistance)",summary:"Finds the parameter of the point on a curve that is closest to testPoint.\n     If the maximumDistance parameter is > 0, then only points whose distance\n     to the given point is <= maximumDistance will be returned.  Using a \n     positive value of maximumDistance can substantially speed up the search.",since:5,returns:"True on success, False on failure."},{signature:"bool ClosestPoints(Curve otherCurve,Point3d pointOnThisCurve,Point3d pointOnOtherCurve)",summary:"Gets closest points between this and another curves.",since:5,returns:"True on success; False on error."},{signature:"bool ClosestPoints(IEnumerable<GeometryBase> geometry,Point3d pointOnCurve,Point3d pointOnObject,int whichGeometry)",summary:"Finds the object (and the closest point in that object) that is closest to\n     this curve. Breps, surfaces,\n     curves and point clouds are examples of\n     objects that can be passed to this function.",since:5,returns:"True on success; False if no object was found or selected."},{signature:"bool ClosestPoints(IEnumerable<GeometryBase> geometry,Point3d pointOnCurve,Point3d pointOnObject,int whichGeometry,double maximumDistance)",summary:"Finds the object (and the closest point in that object) that is closest to\n     this curve. Breps, surfaces,\n     curves and point clouds are examples of\n     objects that can be passed to this function.",since:5,returns:"True on success; False if no object was found or selected."},{signature:"PointContainment Contains(Point3d testPoint)",summary:"Computes the relationship between a point and a closed curve region. \n     This curve must be closed or the return value will be Unset.\n     Both curve and point are projected to the World XY plane.",since:5,returns:"Relationship between point and curve region."},{signature:"PointContainment Contains(Point3d testPoint,Plane plane)",summary:"Computes the relationship between a point and a closed curve region. \n     This curve must be closed or the return value will be Unset.",since:5,returns:"Relationship between point and curve region."},{signature:"PointContainment Contains(Point3d testPoint,Plane plane,double tolerance)",summary:"Computes the relationship between a point and a closed curve region. \n     This curve must be closed or the return value will be Unset.",since:5,returns:"Relationship between point and curve region."},{signature:"Vector3d CurvatureAt(double t)",summary:"Evaluate the curvature vector at a curve parameter.",since:5,returns:"Curvature vector of the curve at the parameter t."},{signature:"Vector3d[] DerivativeAt(double t,int derivativeCount)",summary:"Evaluate the derivatives at the specified curve parameter.",since:5,returns:"An array of vectors that represents all the derivatives starting at zero."},{signature:"Vector3d[] DerivativeAt(double t,int derivativeCount,CurveEvaluationSide side)",summary:"Evaluate the derivatives at the specified curve parameter.",since:5,returns:"An array of vectors that represents all the derivatives starting at zero."},{signature:"Point3d[] DivideAsContour(Point3d contourStart,Point3d contourEnd,double interval)",summary:"Divides this curve at fixed steps along a defined contour line.",since:5,returns:"An array of points; or None on error."},{signature:"double[] DivideByCount(int segmentCount,bool includeEnds)",summary:"Divide the curve into a number of equal-length segments.",since:5,returns:"List of curve parameters at the division points on success, None on failure."},{signature:"double[] DivideByCount(int segmentCount,bool includeEnds,Point3d[] points)",summary:"Divide the curve into a number of equal-length segments.",since:5,returns:"Array containing division curve parameters on success, None on failure."},{signature:"double[] DivideByLength(double segmentLength,bool includeEnds)",summary:"Divide the curve into specific length segments.",since:5,returns:"Array containing division curve parameters if successful, None on failure."},{signature:"double[] DivideByLength(double segmentLength,bool includeEnds,bool reverse)",summary:"Divide the curve into specific length segments.",since:6,returns:"Array containing division curve parameters if successful, None on failure."},{signature:"double[] DivideByLength(double segmentLength,bool includeEnds,bool reverse,Point3d[] points)",summary:"Divide the curve into specific length segments.",since:6,returns:"Array containing division curve parameters if successful, None on failure."},{signature:"double[] DivideByLength(double segmentLength,bool includeEnds,Point3d[] points)",summary:"Divide the curve into specific length segments.",since:5,returns:"Array containing division curve parameters if successful, None on failure."},{signature:"Point3d[] DivideEquidistant(double distance)",summary:"Calculates 3d points on a curve where the linear distance between the points is equal.",since:5,returns:"An array of equidistant points, or None on error."},{signature:"GeometryBase Duplicate()",summary:"Constructs an exact duplicate of this Curve.",since:5},{signature:"Curve DuplicateCurve()",summary:"Constructs an exact duplicate of this curve.",since:5,returns:"An exact copy of this curve."},{signature:"Curve[] DuplicateSegments()",summary:"Polylines will be exploded into line segments. ExplodeCurves will\n     return the curves in topological order.",since:5,returns:"An array of all the segments that make up this curve."},{signature:"Curve Extend(CurveEnd side,CurveExtensionStyle style,IEnumerable<GeometryBase> geometry)",summary:"Extends a curve until it intersects a collection of objects.",since:5,returns:"New extended curve result on success, None on failure."},{signature:"Curve Extend(CurveEnd side,CurveExtensionStyle style,Point3d endPoint)",summary:"Extends a curve to a point.",since:5,returns:"New extended curve result on success, None on failure."},{signature:"Curve Extend(CurveEnd side,double length,CurveExtensionStyle style)",summary:"Extends a curve by a specific length.",since:5,returns:"A curve with extended ends or None on failure."},{signature:"Curve Extend(double t0,double t1)",summary:"Where possible, analytically extends curve to include the given domain. \n     This will not work on closed curves. The original curve will be identical to the \n     restriction of the resulting curve to the original curve domain.",since:5,returns:"Extended curve on success, None on failure."},{signature:"Curve Extend(Interval domain)",summary:"Where possible, analytically extends curve to include the given domain. \n     This will not work on closed curves. The original curve will be identical to the \n     restriction of the resulting curve to the original curve domain.",since:5,returns:"Extended curve on success, None on failure."},{signature:"Curve ExtendByArc(CurveEnd side,IEnumerable<GeometryBase> geometry)",summary:"Extends a curve by an Arc until it intersects a collection of objects.",since:5,returns:"New extended curve result on success, None on failure."},{signature:"Curve ExtendByLine(CurveEnd side,IEnumerable<GeometryBase> geometry)",summary:"Extends a curve by a line until it intersects a collection of objects.",since:5,returns:"New extended curve result on success, None on failure."},{signature:"Curve ExtendOnSurface(CurveEnd side,BrepFace face)",summary:"Extends a curve on a surface.",since:5,returns:"New extended curve result on success, None on failure."},{signature:"Curve ExtendOnSurface(CurveEnd side,Surface surface)",summary:"Extends a curve on a surface.",since:5,returns:"New extended curve result on success, None on failure."},{signature:"double[] ExtremeParameters(Vector3d direction)",summary:"Returns the parameter values of all local extrema. \n     Parameter values are in increasing order so consecutive extrema \n     define an interval on which each component of the curve is monotone. \n     Note, non-periodic curves always return the end points.",since:6,returns:"The parameter values of all local extrema."},{signature:"Curve Fair(double distanceTolerance,double angleTolerance,int clampStart,int clampEnd,int iterations)",summary:"Fairs a curve object. Fair works best on degree 3 (cubic) curves. Attempts to \n     remove large curvature variations while limiting the geometry changes to be no \n     more than the specified tolerance.",since:5,returns:"Returns new faired Curve on success, None on failure."},{signature:"Curve Fit(int degree,double fitTolerance,double angleTolerance)",summary:"Fits a new curve through an existing curve.",since:5,returns:"Returns a new fitted Curve if successful, None on failure."},{signature:"bool FrameAt(double t,Plane plane)",summary:"Returns a 3d frame at a parameter.",since:5,returns:"True on success, False on failure."},{signature:"ConicSectionType GetConicSectionType()",summary:"Returns the type of conic section based on the curve's shape.",since:6},{signature:"ConicSectionType GetConicSectionType(Point3d focus1,Point3d focus2,Point3d center)",summary:"Returns the type of conic section based on the curve's shape.",since:6},{signature:"bool GetCurveParameterFromNurbsFormParameter(double nurbsParameter,double curveParameter)",summary:"Convert a NURBS curve parameter to a curve parameter.",since:5,returns:"True on success, False on failure."},{signature:"double GetLength()",summary:"Gets the length of the curve with a fractional tolerance of 1.0e-8.",since:5,returns:"The length of the curve on success, or zero on failure."},{signature:"double GetLength(double fractionalTolerance)",summary:"Get the length of the curve.",since:5,returns:"The length of the curve on success, or zero on failure."},{signature:"double GetLength(double fractionalTolerance,Interval subdomain)",summary:"Get the length of a sub-section of the curve.",since:5,returns:"The length of the sub-curve on success, or zero on failure."},{signature:"double GetLength(Interval subdomain)",summary:"Get the length of a sub-section of the curve with a fractional tolerance of 1e-8.",since:5,returns:"The length of the sub-curve on success, or zero on failure."},{signature:"bool GetLocalPerpPoint(Point3d testPoint,double seedParmameter,double curveParameter)",summary:"Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.",since:6,returns:"True if a solution is found, False otherwise."},{signature:"bool GetLocalPerpPoint(Point3d testPoint,double seedParmameter,Interval subDomain,double curveParameter)",summary:"Search for a location on the curve, near seedParmameter, that is perpendicular to a test point.",since:6,returns:"True if a solution is found, False otherwise."},{signature:"bool GetLocalTangentPoint(Point3d testPoint,double seedParmameter,double curveParameter)",summary:"Search for a location on the curve, near seedParmameter, that is tangent to a test point.",since:6,returns:"True if a solution is found, False otherwise."},{signature:"bool GetLocalTangentPoint(Point3d testPoint,double seedParmameter,Interval subDomain,double curveParameter)",summary:"Search for a location on the curve, near seedParmameter, that is tangent to a test point.",since:6,returns:"True if a solution is found, False otherwise."},{signature:"bool GetNextDiscontinuity(Continuity continuityType,double t0,double t1,double t)",summary:"Searches for a derivative, tangent, or curvature discontinuity.",since:5,returns:"Parametric continuity tests c = (C0_continuous, ..., G2_continuous):\n      True if a parametric discontinuity was found strictly between t0 and t1. Note well that\n      all curves are parametrically continuous at the ends of their domains.\n     \n     Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):\n      True if a locus discontinuity was found strictly between t0 and t1 or at t1 is the at the end\n      of a curve. Note well that all open curves (IsClosed()=false) are locus discontinuous at the\n      ends of their domains.  All closed curves (IsClosed()=true) are at least C0_locus_continuous at \n      the ends of their domains."},{signature:"bool GetNurbsFormParameterFromCurveParameter(double curveParameter,double nurbsParameter)",summary:"Convert a curve parameter to a NURBS curve parameter.",since:5,returns:"True on success, False on failure."},{signature:"Plane[] GetPerpendicularFrames(IEnumerable<double> parameters)",summary:"Gets a collection of perpendicular frames along the curve. Perpendicular frames \n     are also known as 'Zero-twisting frames' and they minimize rotation from one frame to the next.",since:5,returns:"An array of perpendicular frames on success or None on failure."},{signature:"int HasNurbsForm()",summary:"Does a NURBS curve representation of this curve exist?",since:5,returns:"0   unable to create NURBS representation with desired accuracy.\n     1   success - NURBS parameterization matches the curve's to the desired accuracy\n     2   success - NURBS point locus matches the curve's and the domain of the NURBS\n                   curve is correct. However, This curve's parameterization and the\n                   NURBS curve parameterization may not match. This situation happens\n                   when getting NURBS representations of curves that have a\n                   transendental parameterization like circles."},{signature:"Point3d[] InflectionPoints()",summary:"Returns a curve's inflection points. An inflection point is a location on\n     a curve at which the sign of the curvature (i.e., the concavity) changes. \n     The curvature at these locations is always 0.",since:7,returns:"An array of points if successful, None if not successful or on error."},{signature:"bool IsArc()",summary:"Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.",since:5,returns:"True if the curve can be represented by an arc or a circle within tolerance."},{signature:"bool IsArc(double tolerance)",summary:"Test a curve to see if it can be represented by an arc or circle within the given tolerance.",since:5,returns:"True if the curve can be represented by an arc or a circle within tolerance."},{signature:"bool IsCircle()",summary:"Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.",since:5,returns:"True if the Curve can be represented by a circle within tolerance."},{signature:"bool IsCircle(double tolerance)",summary:"Test a curve to see if it can be represented by a circle within the given tolerance.",since:5,returns:"True if the curve can be represented by a circle to within tolerance."},{signature:"bool IsClosable(double tolerance)",summary:"Decide if it makes sense to close off this curve by moving the endpoint \n     to the start based on start-end gap size and length of curve as \n     approximated by chord defined by 6 points.",since:5,returns:"True if start and end points are close enough based on above conditions."},{signature:"bool IsClosable(double tolerance,double minimumAbsoluteSize,double minimumRelativeSize)",summary:"Decide if it makes sense to close off this curve by moving the endpoint\n     to the start based on start-end gap size and length of curve as\n     approximated by chord defined by 6 points.",since:5,returns:"True if start and end points are close enough based on above conditions."},{signature:"bool IsContinuous(Continuity continuityType,double t)",summary:"Test continuity at a curve parameter value.",since:5,returns:"True if the curve has at least the c type continuity at the parameter t."},{signature:"bool IsEllipse()",summary:"Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.",since:5,returns:"True if the Curve can be represented by an ellipse within tolerance."},{signature:"bool IsEllipse(double tolerance)",summary:"Test a curve to see if it can be represented by an ellipse within a given tolerance.",since:5,returns:"True if the Curve can be represented by an ellipse within tolerance."},{signature:"bool IsInPlane(Plane testPlane)",summary:"Test a curve to see if it lies in a specific plane.",since:5,returns:"True if the maximum distance from the curve to the testPlane is <= RhinoMath.ZeroTolerance."},{signature:"bool IsInPlane(Plane testPlane,double tolerance)",summary:"Test a curve to see if it lies in a specific plane.",since:5,returns:"True if the maximum distance from the curve to the testPlane is <= tolerance."},{signature:"bool IsLinear()",summary:"Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).",since:5,returns:"True if the curve is linear."},{signature:"bool IsLinear(double tolerance)",summary:"Test a curve to see if it is linear to within the custom tolerance.",since:5,returns:"True if the ends of the curve are farther than tolerance apart\n     and the maximum distance from any point on the curve to\n     the line segment connecting the curve ends is <= tolerance."},{signature:"bool IsPlanar()",summary:"Test a curve for planarity.",since:5,returns:"True if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12)."},{signature:"bool IsPlanar(double tolerance)",summary:"Test a curve for planarity.",since:5,returns:"True if there is a plane such that the maximum distance from the curve to the plane is <= tolerance."},{signature:"bool IsPolyline()",summary:"Several types of Curve can have the form of a polyline\n     including a degree 1 NurbsCurve, a PolylineCurve,\n     and a PolyCurve all of whose segments are some form of\n     polyline. IsPolyline tests a curve to see if it can be\n     represented as a polyline.",since:5,returns:"True if this curve can be represented as a polyline; otherwise, false."},{signature:"bool IsShort(double tolerance)",summary:"Used to quickly find short curves.",since:5,returns:"True if the length of the curve is <= tolerance."},{signature:"bool IsShort(double tolerance,Interval subdomain)",summary:"Used to quickly find short curves.",since:5,returns:"True if the length of the curve is <= tolerance."},{signature:"bool LcoalClosestPoint(Point3d testPoint,double seed,double t)",summary:"Find parameter of the point on a curve that is locally closest to \n     the testPoint.  The search for a local close point starts at\n     a seed parameter.",since:6.3,returns:"True if the search is successful, False if the search fails."},{signature:"bool LengthParameter(double segmentLength,double t)",summary:"Gets the parameter along the curve which coincides with a given length along the curve. \n     A fractional tolerance of 1e-8 is used in this version of the function.",since:5,returns:"True on success, False on failure."},{signature:"bool LengthParameter(double segmentLength,double t,double fractionalTolerance)",summary:"Gets the parameter along the curve which coincides with a given length along the curve.",since:5,returns:"True on success, False on failure."},{signature:"bool LengthParameter(double segmentLength,double t,double fractionalTolerance,Interval subdomain)",summary:"Gets the parameter along the curve which coincides with a given length along the curve.",since:5,returns:"True on success, False on failure."},{signature:"bool LengthParameter(double segmentLength,double t,Interval subdomain)",summary:"Gets the parameter along the curve which coincides with a given length along the curve. \n     A fractional tolerance of 1e-8 is used in this version of the function.",since:5,returns:"True on success, False on failure."},{signature:"bool LocalClosestPoint(Point3d testPoint,double seed,double t)",summary:"Find parameter of the point on a curve that is locally closest to \n     the testPoint.  The search for a local close point starts at\n     a seed parameter.",since:6.18,returns:"True if the search is successful, False if the search fails."},{signature:"bool MakeClosed(double tolerance)",summary:"If IsClosed, just return true. Otherwise, decide if curve can be closed as \n     follows: Linear curves polylinear curves with 2 segments, Nurbs with 3 or less \n     control points cannot be made closed. Also, if tolerance > 0 and the gap between \n     start and end is larger than tolerance, curve cannot be made closed. \n     Adjust the curve's endpoint to match its start point.",since:5,returns:"True on success, False on failure."},{signature:"Point3d[] MaxCurvaturePoints()",summary:"Returns a curve's maximum curvature points. The maximum curvature points identify\n     where the curvature starts to decrease in both directions from the points.",since:7,returns:"An array of points if successful, None if not successful or on error."},{signature:"bool NormalizedLengthParameter(double s,double t)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. \n     A fractional tolerance of 1e-8 is used in this version of the function.",since:5,returns:"True on success, False on failure."},{signature:"bool NormalizedLengthParameter(double s,double t,double fractionalTolerance)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.",since:5,returns:"True on success, False on failure."},{signature:"bool NormalizedLengthParameter(double s,double t,double fractionalTolerance,Interval subdomain)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.",since:5,returns:"True on success, False on failure."},{signature:"bool NormalizedLengthParameter(double s,double t,Interval subdomain)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. \n     A fractional tolerance of 1e-8 is used in this version of the function.",since:5,returns:"True on success, False on failure."},{signature:"double[] NormalizedLengthParameters(double[] s,double absoluteTolerance)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. \n     A fractional tolerance of 1e-8 is used in this version of the function.",since:5,returns:"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. \n     Null on failure."},{signature:"double[] NormalizedLengthParameters(double[] s,double absoluteTolerance,double fractionalTolerance)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.",since:5,returns:"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. \n     Null on failure."},{signature:"double[] NormalizedLengthParameters(double[] s,double absoluteTolerance,double fractionalTolerance,Interval subdomain)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve.",since:5,returns:"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. \n     Null on failure."},{signature:"double[] NormalizedLengthParameters(double[] s,double absoluteTolerance,Interval subdomain)",summary:"Input the parameter of the point on the curve that is a prescribed arc length from the start of the curve. \n     A fractional tolerance of 1e-8 is used in this version of the function.",since:5,returns:"If successful, array of curve parameters such that the length of the curve from its start to t[i] is s[i]*curve_length. \n     Null on failure."},{signature:"Curve[] Offset(Plane plane,double distance,double tolerance,CurveOffsetCornerStyle cornerStyle)",summary:"Offsets this curve. If you have a nice offset, then there will be one entry in \n     the array. If the original curve had kinks or the offset curve had self \n     intersections, you will get multiple segments in the offset_curves[] array.",since:5,returns:"Offset curves on success, None on failure."},{signature:"Curve[] Offset(Point3d directionPoint,Vector3d normal,double distance,double tolerance,CurveOffsetCornerStyle cornerStyle)",summary:"Offsets this curve. If you have a nice offset, then there will be one entry in \n     the array. If the original curve had kinks or the offset curve had self \n     intersections, you will get multiple segments in the offset_curves[] array.",since:5,returns:"Offset curves on success, None on failure."},{signature:"Curve OffsetNormalToSurface(Surface surface,double height)",summary:"Finds a curve by offsetting an existing curve normal to a surface.\n     The caller is responsible for ensuring that the curve lies on the input surface.",since:5,returns:"Offset curve at distance height from the surface.  The offset curve is\n     interpolated through a small number of points so if the surface is irregular\n     or complicated, the result will not be a very accurate offset."},{signature:"Curve[] OffsetOnSurface(BrepFace face,double distance,double fittingTolerance)",summary:"Offset this curve on a brep face surface. This curve must lie on the surface.",since:5,returns:"Offset curves on success, or None on failure."},{signature:"Curve[] OffsetOnSurface(BrepFace face,double[] curveParameters,double[] offsetDistances,double fittingTolerance)",summary:"Offset a curve on a brep face surface. This curve must lie on the surface.\n     This overload allows to specify different offsets for different curve parameters.",since:5,returns:"Offset curves on success, or None on failure."},{signature:"Curve[] OffsetOnSurface(BrepFace face,Point2d throughPoint,double fittingTolerance)",summary:"Offset a curve on a brep face surface. This curve must lie on the surface.\n     This overload allows to specify a surface point at which the offset will pass.",since:5,returns:"Offset curves on success, or None on failure."},{signature:"Curve[] OffsetOnSurface(Surface surface,double distance,double fittingTolerance)",summary:"Offset a curve on a surface. This curve must lie on the surface.",since:5,returns:"Offset curves on success, or None on failure."},{signature:"Curve[] OffsetOnSurface(Surface surface,double[] curveParameters,double[] offsetDistances,double fittingTolerance)",summary:"Offset this curve on a surface. This curve must lie on the surface.\n     This overload allows to specify different offsets for different curve parameters.",since:5,returns:"Offset curves on success, or None on failure."},{signature:"Curve[] OffsetOnSurface(Surface surface,Point2d throughPoint,double fittingTolerance)",summary:"Offset a curve on a surface. This curve must lie on the surface.\n     This overload allows to specify a surface point at which the offset will pass.",since:5,returns:"Offset curves on success, or None on failure."},{signature:"bool PerpendicularFrameAt(double t,Plane plane)",summary:"Return a 3d frame at a parameter. This is slightly different than FrameAt in\n     that the frame is computed in a way so there is minimal rotation from one\n     frame to the next.",since:5,returns:"True on success, False on failure."},{signature:"Point3d PointAt(double t)",summary:"Evaluates point at a curve parameter.",since:5,returns:"Point (location of curve at the parameter t)."},{signature:"Point3d PointAtLength(double length)",summary:"Gets a point at a certain length along the curve. The length must be \n     non-negative and less than or equal to the length of the curve. \n     Lengths will not be wrapped when the curve is closed or periodic.",since:5,returns:"Point on the curve at the specified length from the start point or Poin3d.Unset on failure."},{signature:"Point3d PointAtNormalizedLength(double length)",summary:"Gets a point at a certain normalized length along the curve. The length must be \n     between or including 0.0 and 1.0, where 0.0 equals the start of the curve and \n     1.0 equals the end of the curve.",since:5,returns:"Point on the curve at the specified normalized length from the start point or Poin3d.Unset on failure."},{signature:"Curve[] PullToBrepFace(BrepFace face,double tolerance)",summary:"Pulls this curve to a brep face and returns the result of that operation.",since:5,returns:"An array containing the resulting curves after pulling. This array could be empty."},{signature:"PolylineCurve PullToMesh(Mesh mesh,double tolerance)",summary:'Makes a polyline approximation of the curve and gets the closest point on the mesh for each point on the curve. \n     Then it "connects the points" so that you have a polyline on the mesh.',since:5,returns:"A polyline curve on success, None on failure."},{signature:"NurbsCurve Rebuild(int pointCount,int degree,bool preserveTangents)",summary:"Rebuild a curve with a specific point count.",since:5,returns:"A Nurbs curve on success or None on failure."},{signature:"bool RemoveShortSegments(double tolerance)",summary:"Looks for segments that are shorter than tolerance that can be removed. \n     Does not change the domain, but it will change the relative parameterization.",since:5,returns:"True if removable short segments were found. \n     False if no removable short segments were found."},{signature:"bool Reverse()",summary:"Reverses the direction of the curve.",since:5,returns:"True on success, False on failure."},{signature:"Curve RibbonOffset(double distance,double blendRadius,Point3d directionPoint,Vector3d normal,double tolerance)",summary:"Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\n     Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\n     THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\n     Finally, use the elevations of the input curve to get the correct elevations of the result.",since:7,returns:"The offset curve if successful."},{signature:"Curve RibbonOffset(double distance,double blendRadius,Point3d directionPoint,Vector3d normal,double tolerance,Curve[] crossSections,Surface[] ruledSurfaces)",summary:"Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\n     Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\n     THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\n     Finally, use the elevations of the input curve to get the correct elevations of the result.",since:7,returns:"The offset curve if successful."},{signature:"Curve RibbonOffset(double distance,double blendRadius,Point3d directionPoint,Vector3d normal,double tolerance,double[] outputParameters,double[] curveParameters)",summary:"Offsets a closed curve in the following way: pProject the curve to a plane with given normal.\n     Then, loose Offset the projection by distance + blend_radius and trim off self-intersection.\n     THen, Offset the remaining curve back in the opposite direction by blend_radius, filling gaps with blends.\n     Finally, use the elevations of the input curve to get the correct elevations of the result.",since:7,returns:"The offset curve if successful."},{signature:"bool SetEndPoint(Point3d point)",summary:"Forces the curve to end at a specified point. \n     Not all curve types support this operation.",since:5,returns:"True on success, False on failure."},{signature:"bool SetStartPoint(Point3d point)",summary:"Forces the curve to start at a specified point. \n     Not all curve types support this operation.",since:5,returns:"True on success, False on failure."},{signature:"Curve Simplify(CurveSimplifyOptions options,double distanceTolerance,double angleToleranceRadians)",summary:"Returns a geometrically equivalent PolyCurve.\n     The PolyCurve has the following properties\n     1. All the PolyCurve segments are LineCurve, PolylineCurve, ArcCurve, or NurbsCurve.\n     \n     2. The Nurbs Curves segments do not have fully multiple interior knots.\n     \n     3. Rational Nurbs curves do not have constant weights.\n     \n     4. Any segment for which IsLinear() or IsArc() is True is a Line, \n        Polyline segment, or an Arc.\n     \n     5. Adjacent Colinear or Cocircular segments are combined.\n     \n     6. Segments that meet with G1-continuity have there ends tuned up so\n        that they meet with G1-continuity to within machine precision.",since:5,returns:"New simplified curve on success, None on failure."},{signature:"Curve SimplifyEnd(CurveEnd end,CurveSimplifyOptions options,double distanceTolerance,double angleToleranceRadians)",summary:'Same as SimplifyCurve, but simplifies only the last two segments at "side" end.',since:5,returns:"New simplified curve on success, None on failure."},{signature:"Curve Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem)",summary:"Smooths a curve by averaging the positions of control points in a specified region.",since:6,returns:"The smoothed curve if successful, None otherwise."},{signature:"Curve Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)",summary:"Smooths a curve by averaging the positions of control points in a specified region.",since:6,returns:"The smoothed curve if successful, None otherwise."},{signature:"Interval SpanDomain(int spanIndex)",summary:"Get the domain of the curve span with the given index. \n     Use the SpanCount property to test how many spans there are.",since:5,returns:"Interval of the span with the given index."},{signature:"Curve[] Split(Brep cutter,double tolerance)",summary:"Splits a curve into pieces using a polysurface.",since:5,returns:"An array of curves. This array can be empty."},{signature:"Curve[] Split(Brep cutter,double tolerance,double angleToleranceRadians)",summary:"Splits a curve into pieces using a polysurface.",since:6,returns:"An array of curves. This array can be empty."},{signature:"Curve[] Split(double t)",summary:"Splits (divides) the curve at the specified parameter. \n     The parameter must be in the interior of the curve's domain.",since:5,returns:"Two curves on success, None on failure."},{signature:"Curve[] Split(IEnumerable<double> t)",summary:"Splits (divides) the curve at a series of specified parameters. \n     The parameter must be in the interior of the curve domain.",since:5,returns:"Multiple curves on success, None on failure."},{signature:"Curve[] Split(Surface cutter,double tolerance)",summary:"Splits a curve into pieces using a surface.",since:5,returns:"An array of curves. This array can be empty."},{signature:"Curve[] Split(Surface cutter,double tolerance,double angleToleranceRadians)",summary:"Splits a curve into pieces using a surface.",since:6,returns:"An array of curves. This array can be empty."},{signature:"Vector3d TangentAt(double t)",summary:"Evaluates the unit tangent vector at a curve parameter.",since:5,returns:"Unit tangent vector of the curve at the parameter t."},{signature:"PolyCurve ToArcsAndLines(double tolerance,double angleTolerance,double minimumLength,double maximumLength)",summary:"Converts a curve into polycurve consisting of arc segments. Sections of the input curves that are nearly straight are converted to straight-line segments.",since:6,returns:"PolyCurve on success, None on error."},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a NURBS curve representation of this curve.",since:5,returns:"NURBS representation of the curve on success, None on failure."},{signature:"NurbsCurve ToNurbsCurve(Interval subdomain)",summary:"Constructs a NURBS curve representation of this curve.",since:5,returns:"NURBS representation of the curve on success, None on failure."},{signature:"PolylineCurve ToPolyline(double tolerance,double angleTolerance,double minimumLength,double maximumLength)",summary:"Gets a polyline approximation of a curve.",since:6,returns:"PolyCurve on success, None on error."},{signature:"PolylineCurve ToPolyline(int mainSegmentCount,int subSegmentCount,double maxAngleRadians,double maxChordLengthRatio,double maxAspectRatio,double tolerance,double minEdgeLength,double maxEdgeLength,bool keepStartPoint)",summary:"Gets a polyline approximation of a curve.",since:5,returns:"PolylineCurve on success, None on error."},{signature:"PolylineCurve ToPolyline(int mainSegmentCount,int subSegmentCount,double maxAngleRadians,double maxChordLengthRatio,double maxAspectRatio,double tolerance,double minEdgeLength,double maxEdgeLength,bool keepStartPoint,Interval curveDomain)",summary:"Gets a polyline approximation of a curve.",since:5,returns:"PolylineCurve on success, None on error."},{signature:"Curve Trim(CurveEnd side,double length)",summary:"Shortens a curve by a given length",since:5.1,returns:"Trimmed curve if successful, None on failure."},{signature:"Curve Trim(double t0,double t1)",summary:"Removes portions of the curve outside the specified interval.",since:5,returns:"Trimmed portion of this curve is successfull, None on failure."},{signature:"Curve Trim(Interval domain)",summary:"Removes portions of the curve outside the specified interval.",since:5,returns:"Trimmed curve if successful, None on failure."},{signature:"bool TryGetArc(Arc arc)",summary:"Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.",since:5,returns:"True if the curve could be converted into an arc."},{signature:"bool TryGetArc(Arc arc,double tolerance)",summary:"Try to convert this curve into an Arc using a custom tolerance.",since:5,returns:"True if the curve could be converted into an arc."},{signature:"bool TryGetArc(Plane plane,Arc arc)",summary:"Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.",since:5,returns:"True if the curve could be converted into an arc within the given plane."},{signature:"bool TryGetArc(Plane plane,Arc arc,double tolerance)",summary:"Try to convert this curve into an Arc using a custom tolerance.",since:5,returns:"True if the curve could be converted into an arc within the given plane."},{signature:"bool TryGetCircle(Circle circle)",summary:"Try to convert this curve into a circle using RhinoMath.ZeroTolerance.",since:5,returns:"True if the curve could be converted into a Circle."},{signature:"bool TryGetCircle(Circle circle,double tolerance)",summary:"Try to convert this curve into a Circle using a custom tolerance.",since:5,returns:"True if the curve could be converted into a Circle within tolerance."},{signature:"bool TryGetEllipse(Ellipse ellipse)",summary:"Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.",since:5,returns:"True if the curve could be converted into an Ellipse."},{signature:"bool TryGetEllipse(Ellipse ellipse,double tolerance)",summary:"Try to convert this curve into an Ellipse using a custom tolerance.",since:5,returns:"True if the curve could be converted into an Ellipse."},{signature:"bool TryGetEllipse(Plane plane,Ellipse ellipse)",summary:"Try to convert this curve into an Ellipse within RhinoMath.ZeroTolerance.",since:5,returns:"True if the curve could be converted into an Ellipse within the given plane."},{signature:"bool TryGetEllipse(Plane plane,Ellipse ellipse,double tolerance)",summary:"Try to convert this curve into an Ellipse using a custom tolerance.",since:5,returns:"True if the curve could be converted into an Ellipse within the given plane."},{signature:"bool TryGetPlane(Plane plane)",summary:"Test a curve for planarity and return the plane.",since:5,returns:"True if there is a plane such that the maximum distance from the curve to the plane is <= RhinoMath.ZeroTolerance."},{signature:"bool TryGetPlane(Plane plane,double tolerance)",summary:"Test a curve for planarity and return the plane.",since:5,returns:"True if there is a plane such that the maximum distance from the curve to the plane is <= tolerance."},{signature:"bool TryGetPolyline(Polyline polyline)",summary:"Several types of Curve can have the form of a polyline \n     including a degree 1 NurbsCurve, a PolylineCurve, \n     and a PolyCurve all of whose segments are some form of \n     polyline. IsPolyline tests a curve to see if it can be \n     represented as a polyline.",since:5,returns:"True if this curve can be represented as a polyline; otherwise, false."},{signature:"bool TryGetPolyline(Polyline polyline,double[] parameters)",summary:"Several types of Curve can have the form of a polyline \n     including a degree 1 NurbsCurve, a PolylineCurve, \n     and a PolyCurve all of whose segments are some form of \n     polyline. IsPolyline tests a curve to see if it can be \n     represented as a polyline.",since:5,returns:"True if this curve can be represented as a polyline; otherwise, false."}]},{name:"Rhino.Geometry.CurveBooleanRegions",dataType:1,summary:"Represents the results of a Curve.CreateBooleanRegions calculation.",properties:[{signature:"int PlanarCurveCount",summary:"Returns number of planar curves that were calculated by Curve.CreateBooleanRegions.",since:7},{signature:"int PointCount",summary:"If this object were created using the Curve.CreateBooleanRegions override that\n     accepts a collection of points as input, then this value will be equal to the length\n     of the points collection.",since:7},{signature:"int RegionCount",summary:"Returns the number of curve regions. A curve region is a collection of\n     curves that bound a single connected region of the plane.",since:7}],methods:[{signature:"int BoundaryCount(int regionIndex)",summary:"Returns the number of boundary curves in a curve region.",since:7,returns:"The number of boundary curves in the curve region."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"Curve PlanarCurve(int planarCurveIndex)",summary:"Returns a planar curve that was calculated by Curve.CreateBooleanRegions.",since:7,returns:"The planar curve if succesful, None if not successful."},{signature:"Curve[] RegionCurves(int regionIndex)",summary:"Returns the boundary curves in a curve region. A curve region is a collection of\n     curves that bound a single connected region of the plane. Note, the first curve\n     is always the outer boundary.",since:7,returns:"An array of boundary curves if successful, an empty array if not successful."},{signature:"int RegionPointIndex(int pointIndex)",summary:"If this object were created using the Curve.CreateBooleanRegions override that\n     accepts a collection of points as input, then you this method to retrieve the\n     index of the point contained in a curve region.\n     If this.RegionPointIndex(i) = n, then points[i] is contained in this.RegionCurves(n).\n     If points[i] is not in any region, then this.RegionPointIndex(i) = -1.",since:7,returns:"The index of the input point contained in the specified region if successful,\n     or -1 if points[i] was not used in any region or if not successful."},{signature:"int SegmentCount(int regionIndex,int boundaryIndex)",summary:"Returns the number of segments in a boundary curve in a curve region.",since:7,returns:"The number of curve segments in th boundary curves."},{signature:"int SegmentDetails(int regionIndex,int boundaryIndex,int segmmentIndex,Interval subDomain,bool reversed)",summary:"Returns the details of a segment in a boundary curve in a curve region.",since:7,returns:"The index of the planar curve used by the specified segment if successful, -1 if not successful."}]},{name:"Rhino.Geometry.CurveEnd",dataType:3,summary:"Defines the extremes of a curve through a flagged enumeration."},{name:"Rhino.Geometry.CurveEvaluationSide",dataType:3,summary:"Defines enumerated values for the options that defines a curve evaluation side when evaluating kinks."},{name:"Rhino.Geometry.CurveExtensionStyle",dataType:3,summary:'Defines enumerated values for styles to use during curve extension, such as "Line", "Arc" or "Smooth".'},{name:"Rhino.Geometry.CurveKnotStyle",dataType:3,summary:"Defines enumerated values for knot spacing styles in interpolated curves."},{name:"Rhino.Geometry.CurveOffsetCornerStyle",dataType:3,summary:"Defines enumerated values for all implemented corner styles in curve offsets."},{name:"Rhino.Geometry.CurveOrientation",dataType:3,summary:"Defines enumerated values for closed curve orientations."},{name:"Rhino.Geometry.CurveProxy",dataType:1,summary:"Provides strongly-typed access to Brep edges.",properties:[{signature:"bool ProxyCurveIsReversed",summary:'True if "this" is a curve is reversed from the "real" curve geometry',since:5.1}]},{name:"Rhino.Geometry.CurveSimplifyOptions",dataType:3,summary:"Enumerates the options to use when simplifying a curve."},{name:"Rhino.Geometry.Cylinder",dataType:2,summary:"Represents the values of a plane, a radius and two heights -on top and beneath-\n   that define a right circular cylinder.",constructors:[{signature:"Cylinder(Circle baseCircle)",summary:"Constructs a new cylinder with infinite height.",since:5},{signature:"Cylinder(Circle baseCircle,double height)",summary:"Constructs a new cylinder with a finite height.",since:5}],properties:[{signature:"static Cylinder Unset",summary:"Gets an invalid Cylinder.",since:5},{signature:"Vector3d Axis",summary:"Gets the axis direction of the cylinder.",since:5},{signature:"Plane BasePlane",summary:"Gets or sets the base plane of the cylinder.",since:6},{signature:"Point3d Center",summary:"Gets the center point of the defining circle.",since:5},{signature:"double Height1",summary:"Gets or sets the start height of the cylinder.\n     The center of bottom cap is: BasePlane.Origin + Height1 * BasePlane.ZAxis.",since:5},{signature:"double Height2",summary:"Gets or sets the end height of the cylinder. \n     If the end height equals the start height, the cylinder is \n     presumed to be infinite.\n     The center of top cap is: BasePlane.Origin + Height2 * BasePlane.ZAxis.",since:5},{signature:"bool IsFinite",summary:"True if the cylinder is finite (Height0 != Height1)\n     False if the cylinder is infinite.",since:5},{signature:"bool IsValid",summary:"Gets a boolean value indicating whether this cylinder is valid.\n     A valid cylinder is represented by a valid circle and two valid heights.",since:5},{signature:"double Radius",summary:"Gets or sets the radius of the cylinder.",since:6},{signature:"double TotalHeight",summary:"Gets the height of the cylinder. \n     Infinite cylinders have a height of zero, not Double.PositiveInfinity.",since:5}],methods:[{signature:"Circle CircleAt(double linearParameter)",summary:"Compute the circle at the given elevation parameter.",since:5},{signature:"bool EpsilonEquals(Cylinder other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"Line LineAt(double angularParameter)",summary:"Compute the line at the given angle parameter. This line will be degenerate if the cylinder is infite.",since:5},{signature:"Brep ToBrep(bool capBottom,bool capTop)",summary:"Constructs a Brep representation of this Cylinder. \n     This is synonymous with calling NurbsSurface.CreateFromCylinder().",since:5,returns:"A Brep representation of the cylinder or null."},{signature:"NurbsSurface ToNurbsSurface()",summary:"Constructs a Nurbs surface representation of this cylinder. \n     This is synonymous with calling NurbsSurface.CreateFromCylinder().",since:5,returns:"A Nurbs surface representation of the cylinder or null."},{signature:"RevSurface ToRevSurface()",summary:"Constructs a RevSurface representation of this Cylinder. \n     This is synonymous with calling RevSurface.CreateFromCylinder().",since:5,returns:"A RevSurface representation of the cylinder or null."}]},{name:"Rhino.Geometry.DetailView",dataType:1,summary:"Represents a view of the model placed on a page layout.",properties:[{signature:"bool IsParallelProjection",summary:"Gets or sets whether the view is parallel.",since:5},{signature:"bool IsPerspectiveProjection",summary:"Gets or sets whether the view is perspective.",since:5},{signature:"bool IsProjectionLocked",summary:"Gets or sets whether the view projection is locked.",since:5},{signature:"double PageToModelRatio",summary:"Gets the page units/model units quotient.",since:5}],methods:[{signature:"bool SetScale(double modelLength,UnitSystem modelUnits,double pageLength,UnitSystem pageUnits)",summary:"Sets the detail viewport's projection so geometry is displayed at a certain scale.",since:5,returns:"True on success. False if the DetailView projection is perspective or input values are incongruous."}]},{name:"Rhino.Geometry.DevelopableSrf",dataType:1,summary:"Helpers for developable surface functions",methods:[{signature:"static int GetLocalDevopableRuling(NurbsCurve rail0,double t0,Interval dom0,NurbsCurve rail1,double t1,Interval dom1,double t0_out,double t1_out)",summary:"Finds minimum twist ruling between 2 curves at local domains",since:6,returns:"-1: Error\n      0: Exact non-twisting ruling found between t0_out and t1_out\n      1: Ruling found between t0_out and t1_out that has less twist \n           the ruling between t0 and t1"},{signature:"static bool RulingMinTwist(NurbsCurve rail0,double t0,Interval dom0,NurbsCurve rail1,double t1,Interval dom1,double t0_out,double t1_out,double cos_twist_out)",summary:"Find a ruling from rail0(t0_out) to rail1(t1_out) that has the least twist\n     across the ruling with t0_out in domain0 and t1_out in domain1.\n     max_cos_twist is cos(twist) for the returned ruling",since:6},{signature:"static bool RulingMinTwist(NurbsCurve rail0,double t0,NurbsCurve rail1,double t1,Interval dom1,double t1_out,double cos_twist_out)",summary:"Find a ruling from rail0(t0) to rail1(t1_out) that has the least twist\n     across the ruling with t1_out in domain1.\n     max_cos_twist is cos(twist) for the returned ruling",since:6},{signature:"static bool UntwistRulings(NurbsCurve rail0,NurbsCurve rail1,IEnumerable<Point2d> rulings)"}]},{name:"Rhino.Geometry.Dimension",dataType:1,summary:"Base class for dimensions",properties:[{signature:"bool AlternateBelowLine",since:6},{signature:"double AltLengthFactor",since:6},{signature:"int AltLengthResolution",since:6},{signature:"double AltLengthRoundoff",since:6},{signature:"string AltPrefix",since:6},{signature:"string AltSuffix",since:6},{signature:"int AltToleranceResolution",since:6},{signature:"bool AltUnitsDisplay",since:6},{signature:"ZeroSuppression AltZeroSuppression",since:6},{signature:"Guid ArrowBlockId1",since:6},{signature:"Guid ArrowBlockId2",since:6},{signature:"ArrowFit ArrowFit",since:6.2},{signature:"ArrowType ArrowheadType1",since:6},{signature:"ArrowType ArrowheadType2",since:6},{signature:"double ArrowSize",since:6},{signature:"double BaselineSpacing",since:6},{signature:"double CentermarkSize",since:6},{signature:"CenterMarkStyle CentermarkStyle",since:6},{signature:"Guid DetailMeasured",since:6},{signature:"double DimensionLineExtension",since:6},{signature:"double DistanceScale",since:6},{signature:"double ExtensionLineExtension",since:6},{signature:"double ExtensionLineOffset",since:6},{signature:"double FixedExtensionLength",since:6},{signature:"bool FixedLengthExtensionOn",since:6},{signature:"ForceArrow ForceArrowPosition",since:6},{signature:"bool ForceDimensionLineBetweenExtensionLines",since:6.2},{signature:"bool ForceDimLine",since:6.2},{signature:"ForceText ForceTextPosition",since:6},{signature:"double LengthFactor",since:6},{signature:"int LengthResolution",since:6},{signature:"double LengthRoundoff",since:6},{signature:"double NumericValue",summary:"Gets the numeric value (or measurement), depending on geometry type.\n     LinearDimension: distance between arrow tipsRadialDimension: radius or diamater depending on typeAngularDimension: angle in degrees",since:6},{signature:"string PlainUserText",since:6},{signature:"string Prefix",since:6},{signature:"string Suffix",since:6},{signature:"bool SuppressExtension1",since:6},{signature:"bool SuppressExtension2",since:6},{signature:"LeaderContentAngleStyle TextAngleType",since:6},{signature:"TextFit TextFit",since:6.2},{signature:"string TextFormula",since:6},{signature:"TextLocation TextLocation",since:6},{signature:"TextOrientation TextOrientation",since:6},{signature:"Point2d TextPosition",summary:"Gets and sets the position of text on the plane.",since:6},{signature:"double TextRotation",since:6},{signature:"ToleranceDisplayFormat ToleranceFormat",since:6},{signature:"double ToleranceHeightScale",since:6},{signature:"double ToleranceLowerValue",since:6},{signature:"int ToleranceResolution",since:6},{signature:"double ToleranceUpperValue",since:6},{signature:"bool UseDefaultTextPoint",since:6},{signature:"ZeroSuppression ZeroSuppression",since:6}],methods:[{signature:"Transform GetTextTransform(ViewportInfo viewport,DimensionStyle style,double textScale,bool drawForward)",summary:"Get the transform for this text object's text geometry",since:6},{signature:"void SetAltDimensionLengthDisplayWithZeroSuppressionReset(LengthDisplay ld)",since:6},{signature:"void SetDimensionLengthDisplayWithZeroSuppressionReset(LengthDisplay ld)",since:6}]},{name:"Rhino.Geometry.DistancingMode",dataType:3,summary:"Defines how offset and similar operations should work."},{name:"Rhino.Geometry.EdgeAdjacency",dataType:3,summary:"Enumerates all possible Topological Edge adjacency types."},{name:"Rhino.Geometry.Ellipse",dataType:2,summary:"Represents the values of a plane and the two semiaxes radii in an ellipse.",constructors:[{signature:"Ellipse(Plane plane,double radius1,double radius2)",summary:"Initializes a new ellipse from base plane and both principal radii.",since:5},{signature:"Ellipse(Point3d center,Point3d second,Point3d third)",summary:"Initializes a new ellipse from a center point and the two semiaxes intersections.",since:5}],properties:[{signature:"bool IsValid",summary:"Returns an indication of the validity of this ellipse.",since:6},{signature:"Plane Plane",summary:"Gets or sets the base plane of the ellipse.",since:5},{signature:"double Radius1",summary:"Gets or sets the radius of the ellipse along the base plane X semiaxis.",since:5},{signature:"double Radius2",summary:"Gets or sets the radius of the ellipse along the base plane Y semiaxis.",since:5}],methods:[{signature:"bool EpsilonEquals(Ellipse other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a nurbs curve representation of this ellipse. \n     This is equivalent to calling NurbsCurve.CreateFromEllipse().",since:5,returns:"A nurbs curve representation of this ellipse or None if no such representation could be made."}]},{name:"Rhino.Geometry.ExtrudeCornerType",dataType:3,summary:"Corner types used for creating a tapered extrusion"},{name:"Rhino.Geometry.Extrusion",dataType:1,summary:"Represents an extrusion, or objects such as beams or linearly extruded elements,\n   that can be represented by profile curves and two miter planes at the extremes.",constructors:[{signature:"Extrusion()",summary:"Initializes a new instance of the  class.",since:5}],properties:[{signature:"int CapCount",summary:"Gets the amount of capping surfaces.",since:5},{signature:"bool IsCappedAtBottom",summary:"Gets a value indicating whether the surface that fills the bottom profile is existing.",since:5},{signature:"bool IsCappedAtTop",summary:"Gets a value indicating whether the surface that fills the top profile is existing.",since:5},{signature:"bool IsMiteredAtEnd",summary:"Gets a value indicating whether a miter plane at the end is defined.",since:5},{signature:"bool IsMiteredAtStart",summary:"Returns a value indicating whether a miter plane at start is defined.",since:5},{signature:"bool IsSolid",summary:"Gets a value indicating whether there is no gap among all surfaces constructing this object.",since:5},{signature:"Vector3d MiterPlaneNormalAtEnd",summary:"Gets or sets the normal of the miter plane at the end in profile coordinates.\n     In profile coordinates, 0,0,1 always maps to the extrusion axis",since:5},{signature:"Vector3d MiterPlaneNormalAtStart",summary:"Gets or sets the normal of the miter plane at the start in profile coordinates.\n     In profile coordinates, 0,0,1 always maps to the extrusion axis",since:5},{signature:"Point3d PathEnd",summary:"Gets the end point of the path.",since:5},{signature:"Point3d PathStart",summary:"Gets the start point of the path.",since:5},{signature:"Vector3d PathTangent",summary:"Gets the up vector of the path.",since:5},{signature:"int ProfileCount",summary:"Gets the amount of profile curves.",since:5}],methods:[{signature:"static Extrusion Create(Curve planarCurve,double height,bool cap)",summary:"Creates an extrusion of a 3d curve (which must be planar) and a height.",since:5.1,returns:"If the input is valid, then a new extrusion is returned. Otherwise None is returned"},{signature:"static Extrusion CreateBoxExtrusion(Box box,bool cap)",summary:"Gets an extrusion from a box.",since:6,returns:"Extrusion on success. None on failure."},{signature:"static Extrusion CreateCylinderExtrusion(Cylinder cylinder,bool capBottom,bool capTop)",summary:"Gets an extrusion form of a cylinder.",since:5,returns:"Extrusion on success. None on failure."},{signature:"static Extrusion CreatePipeExtrusion(Cylinder cylinder,double otherRadius,bool capTop,bool capBottom)",summary:"Gets an extrusion form of a pipe.",since:5,returns:"Extrusion on success. None on failure."},{signature:"bool AddInnerProfile(Curve innerProfile)",summary:"Adds an inner profile.",since:5,returns:"True if the profile was set."},{signature:"Mesh GetMesh(MeshType meshType)",summary:"Obtains a reference to a specified type of mesh for this extrusion.",since:5.6,returns:"A mesh."},{signature:"Plane GetPathPlane(double s)",summary:"Gets the 3D plane perpendicular to the path at a normalized path parameter.",since:5,returns:"A plane. The plane is Invalid on failure."},{signature:"Plane GetProfilePlane(double s)",summary:"Gets the 3D plane containing the profile curve at a normalized path parameter.",since:5,returns:"A plane. The plane is Invalid on failure."},{signature:"Transform GetProfileTransformation(double s)",summary:"Gets the transformation that maps the xy profile curve to its 3d location.",since:5,returns:"A Transformation. The transform is Invalid on failure."},{signature:"Curve[] GetWireframe()",summary:"Constructs all the Wireframe curves for this Extrusion.",since:5.6,returns:"An array of Wireframe curves."},{signature:"LineCurve PathLineCurve()",summary:"Gets the line-like curve that is the conceptual axis of the extrusion.",since:5,returns:"The path as a line curve."},{signature:"Curve Profile3d(ComponentIndex ci)",summary:"Gets one of the profiles.",since:5,returns:"The profile."},{signature:"Curve Profile3d(int profileIndex,double s)",summary:"Gets a transversal isocurve of the extruded profile.",since:5,returns:"The profile."},{signature:"int ProfileIndex(double profileParameter)",summary:"Gets the index of the profile curve at a domain related to a parameter.",since:5,returns:"-1 if profileParameter does not correspond to a point on the profile curve.\n     When the profileParameter corresponds to the end of one profile and the\n     beginning of the next profile, the index of the next profile is returned."},{signature:"bool SetOuterProfile(Curve outerProfile,bool cap)",summary:"Sets the outer profile of the extrusion.",since:5,returns:"True if the profile was set. If the outer profile is closed, then the\n     extrusion may also have inner profiles. If the outer profile is open,\n     the extrusion may not have inner profiles. If the extrusion already\n     has a profile, the set will fail."},{signature:"bool SetPathAndUp(Point3d a,Point3d b,Vector3d up)",summary:"Allows to set the two points at the extremes and the up vector.",since:5,returns:"True if the operation succeeded; otherwise false.\n     Setting up=a-b will make the operation fail."},{signature:"Brep ToBrep(bool splitKinkyFaces)",summary:"Constructs a brep form of the extrusion. The outer profile is always the first face of the brep.\n     If there are inner profiles, additional brep faces are created for each profile. If the\n     outer profile is closed, then end caps are added as the last two faces of the brep.",since:5,returns:"A brep with a similar shape like this extrustion, or None on error."},{signature:"Curve WallEdge(ComponentIndex ci)",summary:"Gets one of the longitudinal curves along the beam or extrusion.",since:5,returns:"The profile."},{signature:"Surface WallSurface(ComponentIndex ci)",summary:"Gets one of the longitudinal surfaces of the extrusion.",since:5,returns:"The surface."}]},{name:"Rhino.Geometry.GeometryBase",dataType:1,summary:"Provides a common base for most geometric classes. This class is abstract.",properties:[{signature:"bool HasBrepForm",summary:"Returns True if the Brep.TryConvertBrep function will be successful for this object",since:5.6},{signature:"bool IsDeformable",summary:'True if object can be accurately modified with "squishy" transformations like\n     projections, shears, and non-uniform scaling.',since:5},{signature:"bool IsDocumentControlled",summary:'If True this object may not be modified. Any properties or functions that attempt\n     to modify this object when it is set to "IsReadOnly" will throw a NotSupportedException.',since:5},{signature:"ObjectType ObjectType",summary:"Useful for switch statements that need to differentiate between\n     basic object types like points, curves, surfaces, and so on.",since:5},{signature:"int UserStringCount",summary:"Gets the amount of user strings.",since:5}],methods:[{signature:"static bool GeometryEquals(GeometryBase first,GeometryBase second)",summary:"Determines if two geometries equal one another, in pure geometrical shape.\n     This version only compares the geometry itself and does not include any user\n     data comparisons.\n     This is a comparison by value: for two identical items it will be true, no matter\n     where in memory they may be stored.",since:6,returns:"The indication of equality"},{signature:"ComponentIndex ComponentIndex()",summary:"If this piece of geometry is a component in something larger, like a BrepEdge\n     in a Brep, then this function returns the component index.",since:5,returns:"This object's component index.  If this object is not a sub-piece of a larger\n     geometric entity, then the returned index has \n     m_type = ComponentIndex.InvalidType\n     and m_index = -1."},{signature:"GeometryBase Duplicate()",summary:"Constructs a deep (full) copy of this object.",since:5,returns:"An object of the same type as this, with the same properties and behavior."},{signature:"GeometryBase DuplicateShallow()",summary:'Constructs a light copy of this object. By "light", it is meant that the same\n     underlying data is used until something is done to attempt to change it. For example,\n     you could have a shallow copy of a very heavy mesh object and the same underlying\n     data will be used when doing things like inspecting the number of faces on the mesh.\n     If you modify the location of one of the mesh vertices, the shallow copy will create\n     a full duplicate of the underlying mesh data and the shallow copy will become a\n     deep copy.',since:5,returns:"An object of the same type as this object.\n     This behavior is overridden by implementing classes."},{signature:"BoundingBox GetBoundingBox(bool accurate)",summary:"Boundingbox solver. Gets the world axis aligned boundingbox for the geometry.",since:5,returns:"The boundingbox of the geometry in world coordinates or BoundingBox.Empty \n     if not bounding box could be found."},{signature:"BoundingBox GetBoundingBox(Plane plane)",summary:"Aligned Boundingbox solver. Gets the plane aligned boundingbox.",since:5,returns:"A BoundingBox in plane coordinates."},{signature:"BoundingBox GetBoundingBox(Plane plane,Box worldBox)",summary:"Aligned Boundingbox solver. Gets the plane aligned boundingbox.",since:5,returns:"A BoundingBox in plane coordinates."},{signature:"BoundingBox GetBoundingBox(Transform xform)",summary:"Aligned Boundingbox solver. Gets the world axis aligned boundingbox for the transformed geometry.",since:5,returns:"The accurate boundingbox of the transformed geometry in world coordinates \n     or BoundingBox.Empty if not bounding box could be found."},{signature:"string GetUserString(string key)",summary:"Gets user string from this geometry.",since:5,returns:"string associated with the key if successful. None if no key was found."},{signature:"System.Collections.Specialized.NameValueCollection GetUserStrings()",summary:"Gets a copy of all (user key string, user value string) pairs attached to this geometry.",since:5,returns:"A new collection."},{signature:"bool MakeDeformable()",summary:'If possible, converts the object into a form that can be accurately modified\n     with "squishy" transformations like projections, shears, an non-uniform scaling.',since:5,returns:"False if object cannot be converted to a deformable object. True if object was\n     already deformable or was converted into a deformable object."},{signature:"uint MemoryEstimate()",summary:"Computes an estimate of the number of bytes that this object is using in memory.",since:5,returns:"An estimated memory footprint."},{signature:"bool Rotate(double angleRadians,Vector3d rotationAxis,Point3d rotationCenter)",summary:"Rotates the object about the specified axis. A positive rotation \n     angle results in a counter-clockwise rotation about the axis (right hand rule).",since:5,returns:"True if geometry successfully rotated."},{signature:"bool Scale(double scaleFactor)",summary:"Scales the object by the specified factor. The scale is centered at the origin.",since:5,returns:"True if geometry successfully scaled."},{signature:"bool SetUserString(string key,string value)",summary:"Attach a user string (key,value combination) to this geometry.",since:5,returns:"True on success."},{signature:"bool Transform(Transform xform)",summary:"Transforms the geometry. If the input Transform has a SimilarityType of\n     OrientationReversing, you may want to consider flipping the transformed\n     geometry after calling this function when it makes sense. For example,\n     you may want to call Flip() on a Brep after transforming it.",since:5,returns:"True if geometry successfully transformed."},{signature:"bool Translate(double x,double y,double z)",summary:"Translates the object along the specified vector.",since:5,returns:"True if geometry successfully translated."},{signature:"bool Translate(Vector3d translationVector)",summary:"Translates the object along the specified vector.",since:5,returns:"True if geometry successfully translated."}]},{name:"Rhino.Geometry.Hatch",dataType:1,summary:"Represents a hatch in planar boundary loop or loops.\n   This is a 2d entity with a plane defining a local coordinate system.\n   The loops, patterns, angles, etc are all in this local coordinate system.\n   The Hatch object manages the plane and loop array\n   Fill definitions are in the HatchPattern or class derived from HatchPattern\n   Hatch has an index to get the pattern definition from the pattern table.",properties:[{signature:"Point3d BasePoint",summary:"Gets or sets the hatchpattern basepoint",since:6.11},{signature:"int PatternIndex",summary:"Gets or sets the index of the pattern in the document hatch pattern table.",since:5},{signature:"double PatternRotation",summary:"Gets or sets the relative rotation of the pattern.",since:5},{signature:"double PatternScale",summary:"Gets or sets the scaling factor of the pattern.",since:5},{signature:"Plane Plane",summary:"Gets or sets the hatch plane",since:6.11}],methods:[{signature:"static Hatch[] Create(Curve curve,int hatchPatternIndex,double rotationRadians,double scale)",summary:"Constructs an array of hatches from one curve.",since:5,returns:"An array of hatches. The array might be empty on error."},{signature:"static Hatch[] Create(Curve curve,int hatchPatternIndex,double rotationRadians,double scale,double tolerance)",summary:"Constructs an array of hatches from one curve.",since:6,returns:"An array of hatches. The array might be empty on error."},{signature:"static Hatch[] Create(IEnumerable<Curve> curves,int hatchPatternIndex,double rotationRadians,double scale)",summary:"Constructs an array of hatches from a set of curves.",since:5,returns:"An array of hatches. The array might be empty on error."},{signature:"static Hatch[] Create(IEnumerable<Curve> curves,int hatchPatternIndex,double rotationRadians,double scale,double tolerance)",summary:"Constructs an array of hatches from a set of curves.",since:6,returns:"An array of hatches. The array might be empty on error."},{signature:"void CreateDisplayGeometry(HatchPattern pattern,double patternScale,Curve[] bounds,Line[] lines,Brep solidBrep)",summary:"Generate geometry that would be used to draw the hatch with a given hatch pattern",since:5.6},{signature:"GeometryBase[] Explode()",summary:"Decomposes the hatch pattern into an array of geometry.",since:5,returns:"An array of geometry that formed the appearance of the original elements."},{signature:"Curve[] Get3dCurves(bool outer)",summary:"Gets 3d curves that define the boundaries of the hatch",since:5},{signature:"Rhino.Display.ColorGradient GetGradientFill()",summary:'Get gradient fill information for this hatch. If the "GradientType" for\n     the fill is None, then this hatch doesn\'t have any gradient fill.',since:7},{signature:"void ScalePattern(Transform xform)",summary:"Scale the hatch's pattern",since:6.11},{signature:"void SetGradientFill(ColorGradient fill)",since:7}]},{name:"Rhino.Geometry.HermiteSurface",dataType:1,summary:"Create an ON_NurbsSurface satisfying Hermite interpolation conditions at a grid of points.",constructors:[{signature:"HermiteSurface()",summary:"Initializes a new  instance.",since:7},{signature:"HermiteSurface(int uCount,int vCount)",summary:"Initializes a new  instance.",since:7}],properties:[{signature:"bool IsValid",summary:"Returns True if the all of values in all of the internal data structues contain valid values, False otherwise.",since:7},{signature:"int UCount",summary:'Gets the number of parameters in the "u" direction.',since:7},{signature:"int VCount",summary:'Gets the number of parameters in the "v" direction.',since:7}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this class.",since:7,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this class.",since:7,returns:"The non-const pointer."},{signature:"Point3d PointAt(int uIndex,int vIndex)",summary:"Gets the interpolation point at the u,v parameter location.",since:7,returns:"The point location."},{signature:"void SetPointAt(int uIndex,int vIndex,Point3d point)",summary:"Sets the interpolation point at the u,v parameter location.",since:7},{signature:"void SetTwistAt(int uIndex,int vIndex,Vector3d twist)",summary:"Set the twist direction (mixed second partial derivative) to intepolate at the u,v parameter location.",since:7},{signature:"void SetUParameterAt(int index,double parameter)",summary:'Sets the "u" parameter at an index. These parameters are strictly increasing.',since:7},{signature:"void SetUTangentAt(int uIndex,int vIndex,Vector3d tangent)",summary:'Set the "u" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',since:7},{signature:"void SetVParameterAt(int index,double parameter)",summary:'Sets the "v" parameter at an index. These parameters are strictly increasing.',since:7},{signature:"void SetVTangentAt(int uIndex,int vIndex,Vector3d tangent)",summary:'Set the "v" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',since:7},{signature:"NurbsSurface ToNurbsSurface()",summary:"Constructs a NURBS surface satisfying the Hermite interpolation conditions.",since:7,returns:"A NURBS surface is successful, None otherwise."},{signature:"Vector3d TwistAt(int uIndex,int vIndex)",summary:"Get the twist direction (mixed second partial derivative) to intepolate at the u,v parameter location.",since:7,returns:"The twist direction."},{signature:"double UParameterAt(int index)",summary:'Gets the "u" parameter at an index. These parameters are strictly increasing.',since:7,returns:"The parameter."},{signature:"Vector3d UTangentAt(int uIndex,int vIndex)",summary:'Get the "u" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',since:7,returns:"The tangent direction."},{signature:"double VParameterAt(int index)",summary:'Gets the "v" parameter at an index. These parameters are strictly increasing.',since:7,returns:"The parameter."},{signature:"Vector3d VTangentAt(int uIndex,int vIndex)",summary:'Get the "v" tangent direction (actually first derivative) to intepolate at the u,v parameter location.',since:7,returns:"The tangent direction."}]},{name:"Rhino.Geometry.HiddenLineDrawing",dataType:1,summary:"Represents a hidden line drawing object.\n   A hidden line drawing consists of curves generated from source objects.\n   The curves correspond to edges, and silhouettes of  source objects and\n   intersections with cutting planes.",properties:[{signature:"IEnumerable<HiddenLineDrawingPoint> Points",summary:"Point objects calculated by the hidden line drawing.",since:6.8},{signature:"IEnumerable<HiddenLineDrawingSegment> Segments",summary:"Subcurve objects calculated by the hidden line drawing.",since:6},{signature:"ViewportInfo Viewport",summary:"Returns the ViewportInfo used by the hidden line drawing.",since:6},{signature:"Transform WorldToHiddenLine",summary:"Returns the world-coordinate system to HLD-coordinate system transformation.",since:6}],methods:[{signature:"static HiddenLineDrawing Compute(HiddenLineDrawingParameters parameters,bool multipleThreads)",summary:"Perform the hidden line drawing calculation based on input parameters",since:6,returns:"Results of calculation on success, None on failure"},{signature:"static HiddenLineDrawing Compute(HiddenLineDrawingParameters parameters,bool multipleThreads,IProgress<double> progress,CancellationToken cancelToken)",summary:"Perform the hidden line drawing calculation based on input parameters",since:6,returns:"Results of calculation on success, None on failure or cancellation"},{signature:"BoundingBox BoundingBox(bool includeHidden)",summary:"Get tight bounding box of the hidden line drawing.",since:6,returns:"The tight bounding box."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6}]},{name:"Rhino.Geometry.HiddenLineDrawingObject",dataType:1,summary:"Represents an object added to a HiddenLineDrawing",properties:[{signature:"GeometryBase Geometry",summary:"Returns the geometry in world coordinates if UseXform is false. \n     Otherwise, the geometry in object space coordinates is returned.",since:6},{signature:"object Tag",summary:"Returns the extra data used to cross-reference the object specified in\n     HiddenLineDrawing.AddObject.",since:6},{signature:"Transform Transform",summary:"Returns the transformation passed into the Add... function\n     when setting up the hidden line drawing parameters.",since:6}]},{name:"Rhino.Geometry.HiddenLineDrawingObjectCurve",dataType:1,summary:"Curves generated from source objects which correspond to edges, and\n   silhouettes of source objects and intersections with cutting planes. A\n   HiddenLineDrawingObjectCurve is partitioned into hidden and visible\n   segments called HiddenLineDrawingSegment",properties:[{signature:"int ClippingPlaneIndex",summary:"Index into HiddenLineDrawing.ClippingPlanes when SilhouetteType == SilhouetteType.SectionCut.",since:6},{signature:"int Index",summary:"Index of this object in HiddenLineDrawing.FullCurves.",since:6},{signature:"bool IsProjecting",summary:"Returns True if all the non clipped portions of this curve are projecting.",since:6},{signature:"bool IsValid",summary:"Verifies the object is valid.",since:6},{signature:"double OriginalDomainStart",summary:"Initialized to RhinoMath.UnsetValue. Valid if the full curve is closed.\n     Rejoin can reparmeterize the curve by moving the seam.  When this has been\n      done the original domain start is stored here.",since:6},{signature:"double[] Parameters",summary:"Increasing, partition of curve.Domain.",since:6},{signature:"HiddenLineDrawingSegment[] Segments",summary:"The HiddenLineDrawingCurve objects that make up this full curve.",since:6},{signature:"SilhouetteType SilhouetteType",summary:"The silhouette event type",since:6},{signature:"HiddenLineDrawingObject SourceObject",summary:"Return the source object that this curve came from",since:6},{signature:"ComponentIndex SourceObjectComponentIndex",summary:"Component of source object part that generated this curve.",since:6}],methods:[{signature:"HiddenLineDrawingSegment Curve(double t)",summary:"Returns the HiddenLineDrawingCurve object containing parameter 't'.",since:6,returns:"The HiddenLineDrawingCurve object if successful."},{signature:"HiddenLineDrawingSegment Curve(double t,int side)",summary:"Returns the HiddenLineDrawingCurve object containing parameter 't'.",since:6,returns:"The HiddenLineDrawingCurve object if successful."}]},{name:"Rhino.Geometry.HiddenLineDrawingParameters",dataType:1,summary:"Input used for computing a hidden line drawing",constructors:[{signature:"HiddenLineDrawingParameters()",summary:"default constructor",since:6}],properties:[{signature:"double AbsoluteTolerance",summary:"Absolute tolerance is used to decide if curves overlap or intersect.\n     A suggested value is to use RhinoDoc.AbsoluteTolerance",since:6},{signature:"bool Flatten",summary:"Flatten the computed geometry",since:6},{signature:"bool IncludeHiddenCurves",summary:"Include hidden curves in hidden line drawing (default is true)",since:6},{signature:"bool IncludeTangentEdges",summary:"Include tangent edges in hidden line drawing (default is true)",since:6},{signature:"bool IncludeTangentSeams",summary:"Include tangent seams in hidden line drawing (default is true)",since:6}],methods:[{signature:"void AddClippingPlane(Plane plane)",summary:"Specify clipping planes that are active for this view.",since:6},{signature:"bool AddGeometry(GeometryBase geometry,object tag)",summary:"Add geometry that should be included in the calculation",since:6,returns:"True if the type of geometry can be added for calculations.\n     Currently only curves, meshes, breps, surfaces and extrusions are supported"},{signature:"bool AddGeometry(GeometryBase geometry,Transform xform,object tag)",summary:"Add geometry that should be included in the calculation",since:6,returns:"True if the type of geometry can be added for calculations.\n     Currently only points, point clouds, curves, meshes, breps, surfaces and extrusions are supported"},{signature:"void SetViewport(RhinoViewport viewport)",summary:"Set the viewport for the hidden line drawing (HLD). The viewport supplies\n     the projection that determinest he visibility of curves, and the HLD \n     coordinate system in which the resulting curves are represented. The\n     HLD-coordinate system is a right handed system for 3-D model space, in \n     which the 3rd coordinate direction is the projection direction. In particular\n     the z-coordinate direction points from the scene toward the camera.",since:6,returns:"True if the viewport has been set."},{signature:"void SetViewport(ViewportInfo viewport)",summary:"Set the viewport for the hidden line drawing (HLD). The viewport supplies\n     the projection that determines the visibility of curves, and the HLD \n     coordinate system in which the resulting curves are represented. The\n     HLD-coordinate system is a right handed system for 3-D model space, in \n     which the 3rd coordinate direction is the projection direction. In particular\n     the z-coordinate direction points from the scene toward the camera.",since:6,returns:"True if the viewport has been set."}]},{name:"Rhino.Geometry.HiddenLineDrawingPoint",dataType:1,summary:"Points generated from source objects which coorespond to point and point cloud source objects.",properties:[{signature:"int ClippingPlaneIndex",summary:"Index into HiddenLineDrawing.ClippingPlanes when SilhouetteType == SilhouetteType.SectionCut.",since:6.8},{signature:"int Index",summary:"Index of this object in HiddenLineDrawing.Points.",since:6.8},{signature:"Point3d Location",summary:"Returns the location of this object in HiddenLineDrawing coordinates.",since:6.8},{signature:"Visibility PointVisibility",summary:"Returns the point's visibility",since:6.8},{signature:"HiddenLineDrawingObject SourceObject",summary:"Return the source object that this point came from.",since:6.8},{signature:"ComponentIndex SourceObjectComponentIndex",summary:"Component of source object part that generated this curve.",since:6.8}]},{name:"Rhino.Geometry.HiddenLineDrawingPoint.Visibility",dataType:3,summary:"The different types of HiddenLineObjectPoint visiblity"},{name:"Rhino.Geometry.HiddenLineDrawingSegment",dataType:1,summary:"The results of HiddenLineDrawing calculation are a collection of segments.\n   A segment is a subcurve of a HiddenLineDrawingObjectCurve.",properties:[{signature:"Curve CurveGeometry",summary:"The actual curve geometry",since:6},{signature:"SideFill[] CurveSideFills",summary:"The SideFill fields are only valid for visible curves.\n     With respect to the HiddenLineDrawing, the region to the left (or right respecively) of this curve is\n     described by CurveSideFills[0] or CurveSideFills[1], respectively.  If exactly one of these regions is empty \n     this is a scene silhouette. If this region conains a surface it is either a surface which in 3-D is adjacent \n     to this edge or it an surface that is further away from the camera, we call this a shadow surface.  \n     unknown is used for unset values and for projecting curves",since:6},{signature:"int Index",summary:"Index of this curve in HiddenLineDrawing.Curves.",since:6},{signature:"bool IsSceneSilhouette",summary:"Returns True if this curve is a scene silhoutte.",since:6},{signature:"HiddenLineDrawingObjectCurve ParentCurve",summary:"This curve is a subcurve of the returned HiddenLineDrawingFullCurve object.",since:6},{signature:"Visibility SegmentVisibility",summary:"Returns the segment's visibility",since:6}]},{name:"Rhino.Geometry.HiddenLineDrawingSegment.SideFill",dataType:3,summary:"When a silhouette is projected on the image plane (determined by the camera location or direction),\n     and projects to a curve (not a point), the image area to the left or right of a projected silhouette\n     curve is filled with either the surface or a void."},{name:"Rhino.Geometry.HiddenLineDrawingSegment.Visibility",dataType:3,summary:"The different types of HiddenLineDrawingSegment visiblity"},{name:"Rhino.Geometry.InstanceDefinitionGeometry",dataType:1,summary:"Represents a block definition in a File3dm. This is the same as\n   Rhino.DocObjects.InstanceDefinition, but not associated with a RhinoDoc.",constructors:[{signature:"InstanceDefinitionGeometry()",summary:"Initializes a new block definition.",since:5}],properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"string Description",summary:"Gets or sets the description of the definition.",since:5}],methods:[{signature:"Guid[] GetObjectIds()",summary:"list of object ids in the instance geometry table",since:5.6}]},{name:"Rhino.Geometry.InstanceReferenceGeometry",dataType:1,summary:"Represents a reference to the geometry in a block definition.",constructors:[{signature:"InstanceReferenceGeometry(Guid instanceDefinitionId,Transform transform)",summary:"Constructor used when creating nested instance references.",since:5.1}],properties:[{signature:"Guid ParentIdefId",summary:"The unique id for the parent instance definition of this instance reference.",since:5.6},{signature:"Transform Xform",summary:"Transformation for this reference.",since:5.6}]},{name:"Rhino.Geometry.Interpolator",dataType:1,summary:"Exposes a set of standard numeric interpolation algorithms.",constructors:[{signature:"Interpolator()",summary:"Constructs a new, empty Interpolator.",since:5},{signature:"Interpolator(IEnumerable<double> collection)",summary:"Constructs an Interpolator from a collection of numbers.",since:5},{signature:"Interpolator(int initialCapacity)",summary:"Constructs an empty Interpolator with a certain capacity.",since:5},{signature:"Interpolator(int amount,double defaultValue)",summary:"Constructs a new Interpolator with a specified amount of numbers.",since:5},{signature:"Interpolator(RhinoList<double> list)",summary:"Copy all the numbers from an existing RhinoList.",since:5}],properties:[{signature:"bool Cyclical",summary:"Gets or sets a value indicating whether or not the values inside this Interpolator \n     are to be treated as cyclical (i.e. circular).",since:5}],methods:[{signature:"double InterpolateCatmullRom(double t)",summary:"Sample the list of numbers with Catmull-Rom interpolation.",since:5,returns:"The sampled value at t."},{signature:"double InterpolateCosine(double t)",summary:"Sample the list of numbers with cosine interpolation.",since:5,returns:"The sampled value at t."},{signature:"double InterpolateCubic(double t)",summary:"Sample the list of numbers with cubic interpolation.",since:5,returns:"The sampled value at t."},{signature:"double InterpolateLinear(double t)",summary:"Sample the list of numbers with linear interpolation.",since:5,returns:"The sampled value at t."},{signature:"double InterpolateNearestNeighbour(double t)",summary:"Sample the list of numbers with Nearest Neighbour interpolation.",since:5,returns:"The sampled value at t."}]},{name:"Rhino.Geometry.Intersect.CurveIntersections",dataType:1,summary:"Maintains an ordered list of Curve Intersection results.",properties:[{signature:"int Count",summary:"Gets the number of recorded intersection events.",since:5}],methods:[{signature:"void CopyTo(IntersectionEvent[] array,int arrayIndex)",summary:"Copies all intersection results into another array, departing at an index in the target array.",since:5},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IEnumerator<IntersectionEvent> GetEnumerator()",summary:"Returns an enumerator that is capable of yielding all IntersectionEvents in the collection.",since:5,returns:"The constructed enumerator."}]},{name:"Rhino.Geometry.Intersect.Intersection",dataType:1,summary:"Provides static methods for the computation of intersections, projections, sections and similar.",properties:[{signature:"static double MeshIntersectionsTolerancesCoefficient",summary:"Offers a requested adjustment coefficient for mesh-mesh intersections tolerances.\n     The value can be used to multiply the document absolute tolerance.This is only a UI value; it is up to developer to honor (or not) this request, depending on application needs.",since:7}],methods:[{signature:"static bool BrepBrep(Brep brepA,Brep brepB,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)",summary:"Intersects two Breps.",since:5,returns:"True on success; False on failure."},{signature:"static bool BrepPlane(Brep brep,Plane plane,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)",summary:"Intersects a Brep with an (infinite) plane.",since:5,returns:"True on success, False on failure."},{signature:"static bool BrepSurface(Brep brep,Surface surface,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)",summary:"Intersects a Brep and a Surface.",since:5,returns:"True on success; False on failure."},{signature:"static bool CurveBrep(Curve curve,Brep brep,double tolerance,Curve[] overlapCurves,Point3d[] intersectionPoints)",summary:"Intersects a curve with a Brep. This function returns the 3D points of intersection\n     and 3D overlap curves. If an error occurs while processing overlap curves, this function \n     will return false, but it will still provide partial results.",since:5,returns:"True on success, False on failure."},{signature:"static bool CurveBrep(Curve curve,Brep brep,double tolerance,Curve[] overlapCurves,Point3d[] intersectionPoints,double[] curveParameters)",summary:"Intersects a curve with a Brep. This function returns the 3D points of intersection, curve parameters at the intersection locations,\n     and 3D overlap curves. If an error occurs while processing overlap curves, this function \n     will return false, but it will still provide partial results.",since:6,returns:"True on success, False on failure."},{signature:"static bool CurveBrep(Curve curve,Brep brep,double tolerance,double angleTolerance,double[] t)",summary:"Intersect a curve with a Brep. This function returns the intersection parameters on the curve.",since:6,returns:"True on success, False on failure."},{signature:"static bool CurveBrepFace(Curve curve,BrepFace face,double tolerance,Curve[] overlapCurves,Point3d[] intersectionPoints)",summary:"Intersects a curve with a Brep face.",since:5,returns:"True on success, False on failure."},{signature:"static CurveIntersections CurveCurve(Curve curveA,Curve curveB,double tolerance,double overlapTolerance)",summary:"Finds the intersections between two curves.",since:5,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurveCurveValidate(Curve curveA,Curve curveB,double tolerance,double overlapTolerance,int[] invalidIndices,TextLog textLog)",summary:"Finds the intersections between two curves.",since:7,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurveLine(Curve curve,Line line,double tolerance,double overlapTolerance)",summary:"Intersects a curve and an infinite line.",since:6,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurvePlane(Curve curve,Plane plane,double tolerance)",summary:"Intersects a curve with an (infinite) plane.",since:5,returns:"A list of intersection events or None if no intersections were recorded."},{signature:"static CurveIntersections CurveSelf(Curve curve,double tolerance)",summary:"Finds the places where a curve intersects itself.",since:5,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurveSurface(Curve curve,Interval curveDomain,Surface surface,double tolerance,double overlapTolerance)",summary:"Intersects a sub-curve and a surface.",since:5,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurveSurface(Curve curve,Surface surface,double tolerance,double overlapTolerance)",summary:"Intersects a curve and a surface.",since:5,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurveSurfaceValidate(Curve curve,Interval curveDomain,Surface surface,double tolerance,double overlapTolerance,int[] invalidIndices,TextLog textLog)",summary:"Intersects a sub-curve and a surface.",since:7,returns:"A collection of intersection events."},{signature:"static CurveIntersections CurveSurfaceValidate(Curve curve,Surface surface,double tolerance,double overlapTolerance,int[] invalidIndices,TextLog textLog)",summary:"Intersects a curve and a surface.",since:7,returns:"A collection of intersection events."},{signature:"static bool LineBox(Line line,BoundingBox box,double tolerance,Interval lineParameters)",summary:"Intersects an infinite line and an axis aligned bounding box.",since:5,returns:"True if the line intersects the box, False if no intersection occurs."},{signature:"static bool LineBox(Line line,Box box,double tolerance,Interval lineParameters)",summary:"Intersects an infinite line with a box volume.",since:5,returns:"True if the line intersects the box, False if no intersection occurs."},{signature:"static LineCircleIntersection LineCircle(Line line,Circle circle,double t1,Point3d point1,double t2,Point3d point2)",summary:"Intersects a line with a circle using exact calculations.",since:5,returns:"If  is returned, only t1 and point1 will have valid values. \n     If  is returned, t2 and point2 will also be filled out."},{signature:"static LineCylinderIntersection LineCylinder(Line line,Cylinder cylinder,Point3d intersectionPoint1,Point3d intersectionPoint2)",summary:"Intersects a line with a cylinder using exact calculations.",since:5,returns:"If None is returned, the first point is the point on the line closest\n     to the cylinder and the second point is the point on the cylinder closest to\n     the line. \n     If  is returned, the first point\n     is the point on the line and the second point is the  same point on the\n     cylinder."},{signature:"static bool LineLine(Line lineA,Line lineB,double a,double b)",summary:"Finds the closest point between two infinite lines.",since:5,returns:"True if points are found and False if the lines are numerically parallel. \n     Numerically parallel means the 2x2 matrix:\n     +AoA  -AoB-AoB  +BoB\n     is numerically singular, where A = (lineA.To - lineA.From) and B = (lineB.To-lineB.From)"},{signature:"static bool LineLine(Line lineA,Line lineB,double a,double b,double tolerance,bool finiteSegments)",summary:"Intersects two lines.",since:5,returns:"True if a closest point can be calculated and the result passes the tolerance parameter test; otherwise false."},{signature:"static bool LinePlane(Line line,Plane plane,double lineParameter)",summary:"Intersects a line and a plane. This function only returns True if the \n     intersection result is a single point (i.e. if the line is coincident with \n     the plane then no intersection is assumed).",since:5,returns:"True on success, False on failure."},{signature:"static LineSphereIntersection LineSphere(Line line,Sphere sphere,Point3d intersectionPoint1,Point3d intersectionPoint2)",summary:"Intersects a line with a sphere using exact calculations.",since:5,returns:"If  is returned, the first point is the point on the line closest to the sphere and \n     the second point is the point on the sphere closest to the line. \n     If  is returned, the first point is the point on the line and the second point is the \n     same point on the sphere."},{signature:"static Point3d[] MeshLine(Mesh mesh,Line line,int[] faceIds)",summary:"Finds the intersection of a mesh and a line",since:5,returns:"An array of points: one for each face that was passed by the faceIds out reference."},{signature:"static bool MeshMesh(IEnumerable<Mesh> meshes,double tolerance,Polyline[] intersections,bool overlapsPolylines,Polyline[] overlapsPolylinesResult,bool overlapsMesh,Mesh overlapsMeshResult,TextLog textLog,CancellationToken cancel,IProgress<double> progress)",summary:"Intersects meshes. Overlaps and perforations are provided in the output list.",since:7,returns:"True, if the operation succeeded, otherwise false."},{signature:"static Polyline[] MeshMeshAccurate(Mesh meshA,Mesh meshB,double tolerance)",summary:"Intersects two meshes. Overlaps and near misses are handled. This is an old method kept for compatibility.",since:5,returns:"An array of intersection and overlaps polylines."},{signature:"static Line[] MeshMeshFast(Mesh meshA,Mesh meshB)",summary:"This is an old overload kept for compatibility. Overlaps and near misses are ignored.",since:5,returns:"An array of intersection line segments, or null."},{signature:"static Polyline[] MeshPlane(Mesh mesh,IEnumerable<Plane> planes)",summary:"Intersects a mesh with a collection of (infinite) planes.",since:5,returns:"An array of polylines describing the intersection loops or None (Nothing in Visual Basic) if no intersections could be found."},{signature:"static Polyline[] MeshPlane(Mesh mesh,Plane plane)",summary:"Intersects a mesh with an (infinite) plane.",since:5,returns:"An array of polylines describing the intersection loops or None (Nothing in Visual Basic) if no intersections could be found."},{signature:"static Point3d[] MeshPolyline(Mesh mesh,PolylineCurve curve,int[] faceIds)",summary:"Finds the intersection of a mesh and a polyline.",since:5,returns:"An array of points: one for each face that was passed by the faceIds out reference."},{signature:"static double MeshRay(Mesh mesh,Ray3d ray)",summary:"Finds the first intersection of a ray with a mesh.",since:5,returns:">= 0.0 parameter along ray if successful.\n     < 0.0 if no intersection found."},{signature:"static double MeshRay(Mesh mesh,Ray3d ray,int[] meshFaceIndices)",summary:"Finds the first intersection of a ray with a mesh.",since:5,returns:">= 0.0 parameter along ray if successful.\n     < 0.0 if no intersection found."},{signature:"static PlaneCircleIntersection PlaneCircle(Plane plane,Circle circle,double firstCircleParameter,double secondCircleParameter)",summary:"Intersects a plane with a circle using exact calculations.",since:5,returns:"The type of intersection that occured."},{signature:"static bool PlanePlane(Plane planeA,Plane planeB,Line intersectionLine)",summary:"Intersects two planes and return the intersection line. If the planes are \n     parallel or coincident, no intersection is assumed.",since:5,returns:"True on success, False on failure."},{signature:"static bool PlanePlanePlane(Plane planeA,Plane planeB,Plane planeC,Point3d intersectionPoint)",summary:"Intersects three planes to find the single point they all share.",since:5,returns:"True on success, False on failure. If at least two out of the three planes \n     are parallel or coincident, failure is assumed."},{signature:"static PlaneSphereIntersection PlaneSphere(Plane plane,Sphere sphere,Circle intersectionCircle)",summary:"Intersects a plane with a sphere using exact calculations.",since:5,returns:"If  is returned, the intersectionCircle has a radius of zero and the center point \n     is the point on the plane closest to the sphere."},{signature:"static Point3d[] ProjectPointsToBreps(IEnumerable<Brep> breps,IEnumerable<Point3d> points,Vector3d direction,double tolerance)",summary:"Projects points onto breps.",since:5,returns:"Array of projected points, or None in case of any error or invalid input."},{signature:"static Point3d[] ProjectPointsToBrepsEx(IEnumerable<Brep> breps,IEnumerable<Point3d> points,Vector3d direction,double tolerance,int[] indices)",summary:"Projects points onto breps.",since:5.1,returns:"Array of projected points, or None in case of any error or invalid input."},{signature:"static Point3d[] ProjectPointsToMeshes(IEnumerable<Mesh> meshes,IEnumerable<Point3d> points,Vector3d direction,double tolerance)",summary:"Projects points onto meshes.",since:5,returns:"Array of projected points, or None in case of any error or invalid input."},{signature:"static Point3d[] ProjectPointsToMeshesEx(IEnumerable<Mesh> meshes,IEnumerable<Point3d> points,Vector3d direction,double tolerance,int[] indices)",summary:"Projects points onto meshes.",since:5.1,returns:"Array of projected points, or None in case of any error or invalid input."},{signature:"static Point3d[] RayShoot(Ray3d ray,IEnumerable<GeometryBase> geometry,int maxReflections)",summary:"Computes point intersections that occur when shooting a ray to a collection of surfaces.",since:5,returns:"An array of points: one for each face that was passed by the faceIds out reference."},{signature:"static SphereSphereIntersection SphereSphere(Sphere sphereA,Sphere sphereB,Circle intersectionCircle)",summary:"Intersects two spheres using exact calculations.",since:5,returns:"The intersection type."},{signature:"static bool SurfaceSurface(Surface surfaceA,Surface surfaceB,double tolerance,Curve[] intersectionCurves,Point3d[] intersectionPoints)",summary:"Intersects two Surfaces.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.Intersect.IntersectionEvent",dataType:1,summary:"Provides all the information for a single Curve Intersection event.",properties:[{signature:"bool IsOverlap",summary:"All curve intersection events are either a single point or an overlap.",since:5},{signature:"bool IsPoint",summary:"All curve intersection events are either a single point or an overlap.",since:5},{signature:"Interval OverlapA",summary:"Gets the interval on curve A where the overlap occurs. \n     If the intersection type is not overlap, this value is meaningless.",since:5},{signature:"Interval OverlapB",summary:"Gets the interval on curve B where the overlap occurs. \n     If the intersection type is not overlap, this value is meaningless.",since:5},{signature:"double ParameterA",summary:"Gets the parameter on Curve A where the intersection occured. \n     If the intersection type is overlap, then this will return the \n     start of the overlap region.",since:5},{signature:"double ParameterB",summary:"Gets the parameter on Curve B where the intersection occured. \n     If the intersection type is overlap, then this will return the \n     start of the overlap region.",since:5},{signature:"Point3d PointA",summary:"Gets the point on Curve A where the intersection occured. \n     If the intersection type is overlap, then this will return the \n     start of the overlap region.",since:5},{signature:"Point3d PointA2",summary:"Gets the end point of the overlap on Curve A. \n     If the intersection type is not overlap, this value is meaningless.",since:5},{signature:"Point3d PointB",summary:"Gets the point on Curve B (or Surface B) where the intersection occured. \n     If the intersection type is overlap, then this will return the \n     start of the overlap region.",since:5},{signature:"Point3d PointB2",summary:"Gets the end point of the overlap on Curve B (or Surface B). \n     If the intersection type is not overlap, this value is meaningless.",since:5}],methods:[{signature:"static bool CompareEquivalent(IntersectionEvent eventA,IntersectionEvent eventB,double relativePointTolerance)",summary:"Compare intersection events.",since:7,returns:"True if the two inputs represent the same intersection, False otherwise."},{signature:"static bool CompareEquivalent(IntersectionEvent eventA,IntersectionEvent eventB,double relativePointTolerance,TextLog log)",summary:"Compare intersection events.",since:7},{signature:"void SurfaceOverlapParameter(Interval uDomain,Interval vDomain)",summary:"If this instance records a Curve|Surface intersection event, \n     and the intersection type if overlap, then use this function \n     to get the U and V domains on the surface where the overlap occurs.",since:5},{signature:"void SurfacePointParameter(double u,double v)",summary:"If this instance records a Curve|Surface intersection event, \n     and the intersection type is point, then use this function \n     to get the U and V parameters on the surface where the intersection occurs.",since:5}]},{name:"Rhino.Geometry.Intersect.LineCircleIntersection",dataType:3,summary:"Represents all possible cases of a Line|Circle intersection event."},{name:"Rhino.Geometry.Intersect.LineCylinderIntersection",dataType:3,summary:"Represents all possible cases of a Line|Cylinder intersection event."},{name:"Rhino.Geometry.Intersect.LineSphereIntersection",dataType:3,summary:"Represents all possible cases of a Line|Sphere intersection event."},{name:"Rhino.Geometry.Intersect.MeshClash",dataType:1,summary:"Represents a particular instance of a clash or intersection between two meshes.",properties:[{signature:"Point3d ClashPoint",summary:"If valid, then the sphere centered at ClashPoint of ClashRadius\n     distance intersects the clashing meshes.",since:5},{signature:"double ClashRadius",summary:"Gets the clash, or intersection, radius.",since:5},{signature:"Mesh MeshA",summary:"Gets the first mesh.",since:5},{signature:"Mesh MeshB",summary:"Gets the second mesh.",since:5}],methods:[{signature:"static Mesh[] FindDetail(RhinoObject objA,RhinoObject objB,double distance)",summary:"Finds all of the mesh faces on each of two Rhino objects that interfere within a clash distance.\n     This function uses the object's mesh to calculate the interferences.\n     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.",since:7,returns:"The resulting meshes are sub-meshes of the input meshes if successful, or an empty array on error."},{signature:"static Mesh[] FindDetail(RhinoObject objA,RhinoObject objB,double distance,MeshType meshType,MeshingParameters meshingParameters)",summary:"Finds all of the mesh faces on each of two Rhino objects that interfere within a clash distance.\n     This function uses the object's mesh to calculate the interferences.\n     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.",since:7,returns:"The resulting meshes are sub-meshes of the input meshes if successful, or an empty array on error."},{signature:"static MeshClash[] Search(IEnumerable<Mesh> setA,IEnumerable<Mesh> setB,double distance,int maxEventCount)",summary:"Searches for locations where the distance from a mesh in one set of meshes\n     is less than distance to another mesh in a second set of meshes.",since:5,returns:"An array of clash objects."},{signature:"static MeshInterference[] Search(IEnumerable<RhinoObject> setA,IEnumerable<RhinoObject> setB,double distance)",summary:"Searches for locations where the distance from a RhinoObject, in one set of objects,\n     is less than the specified distance to another RhinoObject in a second set of objects.\n     This function uses the object's mesh to calculate the interferences.\n     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.",since:7,returns:"An array of mesh interference object if successful, or an empty array on failure."},{signature:"static MeshInterference[] Search(IEnumerable<RhinoObject> setA,IEnumerable<RhinoObject> setB,double distance,MeshType meshType,MeshingParameters meshingParameters)",summary:"Searches for locations where the distance from a RhinoObject, in one set of objects,\n     is less than the specified distance to another RhinoObject in a second set of objects.\n     This function uses the object's mesh to calculate the interferences.\n     Acceptable object types include: BrepObject, ExtrusionObject, MeshObject, and SubDObject.",since:7,returns:"An array of mesh interference object if successful, or an empty array on failure."},{signature:"static MeshClash[] Search(Mesh meshA,IEnumerable<Mesh> setB,double distance,int maxEventCount)",summary:"Searches the locations where the distance from the first mesh to a mesh in the second set of meshes\n     is less than the provided value.",since:5,returns:"An array of clash objects."},{signature:"static MeshClash[] Search(Mesh meshA,Mesh meshB,double distance,int maxEventCount)",summary:"Searches the locations where the distance from the first mesh to the second mesh\n     is less than the provided value.",since:5,returns:"An array of clash objects."}]},{name:"Rhino.Geometry.Intersect.MeshInterference",dataType:2,summary:"Represents an element which is part of a curve region boundary.",properties:[{signature:"Point3d[] HitPoints",summary:"Array of hit points where the objects of IndexA and IndexB interfere.",since:7},{signature:"int IndexA",summary:"The index of the first clashing, or interfering object.",since:7},{signature:"int IndexB",summary:"The index of the second clashing, or interfering object.",since:7}]},{name:"Rhino.Geometry.Intersect.PlaneCircleIntersection",dataType:3,summary:"Represents all possible cases of a Plane|Circle intersection event."},{name:"Rhino.Geometry.Intersect.PlaneSphereIntersection",dataType:3,summary:"Represents all possible cases of a Plane|Sphere intersection event."},{name:"Rhino.Geometry.Intersect.SphereSphereIntersection",dataType:3,summary:"Represents all possible cases of a Sphere|Sphere intersection event."},{name:"Rhino.Geometry.Interval",dataType:2,summary:"Represents an interval in one-dimensional space,\n   that is defined as two extrema or bounds.",constructors:[{signature:"Interval(double t0,double t1)",summary:"Initializes a new instance of the Rhino.Geometry.Interval class.",since:5},{signature:"Interval(Interval other)",summary:"Initializes a new instance copying the other instance values.",since:5}],properties:[{signature:"static Interval Unset",summary:"Gets an Interval whose limits are RhinoMath.UnsetValue.",since:5},{signature:"bool IsDecreasing",summary:"Returns True if T[0] > T[1].",since:5},{signature:"bool IsIncreasing",summary:"Returns True if T0 < T1.",since:5},{signature:"bool IsSingleton",summary:"Returns True if T0 == T1 != ON.UnsetValue.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether or not this Interval is valid. \n     Valid intervals must contain valid numbers.",since:5},{signature:"double Length",summary:"Gets the signed length of the numeric range. \n     If the interval is decreasing, a negative length will be returned.",since:5},{signature:"double Max",summary:"Gets the larger of T0 and T1.",since:5},{signature:"double Mid",summary:"Gets the average of T0 and T1.",since:5},{signature:"double Min",summary:"Gets the smaller of T0 and T1.",since:5},{signature:"double T0",summary:"Gets or sets the lower bound of the Interval.",since:5},{signature:"double T1",summary:"Gets or sets the upper bound of the Interval.",since:5}],methods:[{signature:"static Interval FromIntersection(Interval a,Interval b)",summary:"Returns a new Interval that is the Intersection of the two input Intervals.",since:5,returns:"If the intersection is not empty, then \n     intersection = [max(a.Min(),b.Min()), min(a.Max(),b.Max())]\n     The interval [ON.UnsetValue,ON.UnsetValue] is considered to be\n     the empty set interval.  The result of any intersection involving an\n     empty set interval or disjoint intervals is the empty set interval."},{signature:"static Interval FromUnion(Interval a,Interval b)",summary:"Returns a new Interval which contains both inputs.",since:5,returns:"The union of an empty set and an increasing interval is the increasing interval.\n     The union of two empty sets is empty.The union of an empty set an a non-empty interval is the non-empty interval.The union of two non-empty intervals is [min(a.Min(),b.Min()), max(a.Max(),b.Max())]"},{signature:"int CompareTo(Interval other)",summary:"Compares this  with another interval.\n     The lower bound has first evaluation priority.",since:5,returns:"0: if this is identical to other-1: if this[0] < other[0]+1: if this[0] > other[0]-1: if this[0] == other[0] and this[1] < other[1]+1: if this[0] == other[0] and this[1] > other[1]."},{signature:"bool EpsilonEquals(Interval other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(Interval other)",summary:"Determines whether the specified  is equal to the current ,\n     comparing by value.",since:5,returns:"True if obj is an  and has the same bounds; False otherwise."},{signature:"bool Equals(object obj)",summary:"Determines whether the specified  is equal to the current ,\n     comparing by value.",returns:"True if obj is an  and has the same bounds; False otherwise."},{signature:"int GetHashCode()",summary:"Computes the hash code for this  object.",returns:"A hash value that might be equal for two different  values."},{signature:"void Grow(double value)",summary:"Grows the  to include the given number.",since:5},{signature:"bool IncludesInterval(Interval interval)",summary:"Tests another interval for Interval inclusion.",since:5,returns:"True if the other interval is contained within or is coincident with the limits of this Interval; otherwise false."},{signature:"bool IncludesInterval(Interval interval,bool strict)",summary:"Tests another interval for Interval inclusion.",since:5,returns:"True if the other interval is contained within the limits of this Interval; otherwise false."},{signature:"bool IncludesParameter(double t)",summary:"Tests a parameter for Interval inclusion.",since:5,returns:"True if t is contained within or is coincident with the limits of this Interval."},{signature:"bool IncludesParameter(double t,bool strict)",summary:"Tests a parameter for Interval inclusion.",since:5,returns:"True if t is contained within the limits of this Interval."},{signature:"void MakeIncreasing()",summary:"Ensures this  is either singleton or increasing.",since:5},{signature:"Interval NormalizedIntervalAt(Interval intervalParameter)",summary:"Converts interval value, or pair of values, to normalized parameter.",since:5,returns:"Normalized parameter x so that min*(1.0-x) + max*x = intervalParameter."},{signature:"double NormalizedParameterAt(double intervalParameter)",summary:"Converts interval value, or pair of values, to normalized parameter.",since:5,returns:"Normalized parameter x so that min*(1.0-x) + max*x = intervalParameter."},{signature:"double ParameterAt(double normalizedParameter)",summary:"Converts normalized parameter to interval value, or pair of values.",since:5,returns:"Interval parameter min*(1.0-normalizedParameter) + max*normalizedParameter."},{signature:"Interval ParameterIntervalAt(Interval normalizedInterval)",summary:"Converts normalized parameter to interval value, or pair of values.",since:5,returns:"Interval parameter min*(1.0-normalizedParameter) + max*normalized_paramete."},{signature:"void Reverse()",summary:"Changes interval to [-T1, -T0].",since:5},{signature:"void Swap()",summary:"Exchanges T0 and T1.",since:5},{signature:"string ToString()",summary:"Returns a string representation of this .",returns:"A string with T0,T1."}]},{name:"Rhino.Geometry.InvalidDimensionStyleIdException",dataType:1,summary:"General exception that can be thrown by annotations",constructors:[{signature:"InvalidDimensionStyleIdException(string msg)",since:6}]},{name:"Rhino.Geometry.IsoStatus",dataType:3,summary:"Defines enumerated values for isoparametric curve direction on a surface, such as X or Y,\n   and curve sides, such as North or West boundary.\n   Note: odd values are all x-constant; even values > 0 are all y-constant."},{name:"Rhino.Geometry.Leader",dataType:1,summary:"Leader geometry class",constructors:[{signature:"Leader()",summary:"Constructor",since:6}],properties:[{signature:"NurbsCurve Curve",summary:"Gets the curve used by this leader",since:6},{signature:"Guid LeaderArrowBlockId",summary:"Id of the block used as the arrow for the leader when the arrow type is 'User arrow'",since:6},{signature:"double LeaderArrowSize",summary:"The size of the leader arrow",since:6},{signature:"ArrowType LeaderArrowType",summary:"The arrowhead type for the leader",since:6},{signature:"LeaderContentAngleStyle LeaderContentAngleStyle",summary:"Angle for text of leader text",since:6},{signature:"LeaderCurveStyle LeaderCurveStyle",summary:"The style of the leader curve: polyline or spline",since:6},{signature:"bool LeaderHasLanding",summary:"Returns True if the leader has a landing line",since:6},{signature:"double LeaderLandingLength",summary:"Gets or sets the length of the landing line",since:6},{signature:"TextHorizontalAlignment LeaderTextHorizontalAlignment",summary:"Gets or sets the horizontal alignment of the leader's text",since:6},{signature:"TextVerticalAlignment LeaderTextVerticalAlignment",summary:"Gets or sets the vertical alignment of the leader's text",since:6},{signature:"Point2d[] Points2D",summary:"Get or set the 2d points defining the curve used by this leader",since:6},{signature:"Point3d[] Points3D",summary:"Get or set the 3d points defining the curve used by this leader",since:6}],methods:[{signature:"static Leader Create(string text,Plane plane,DimensionStyle dimstyle,Point3d[] points)",summary:"Creates a Leader geometry object",since:6},{signature:"static Leader CreateWithRichText(string richText,Plane plane,DimensionStyle dimstyle,Point3d[] points)",summary:"Creates a Leader geometry object",since:6}]},{name:"Rhino.Geometry.Light",dataType:1,summary:"Represents a light that shines in the modeling space.",constructors:[{signature:"Light()",summary:"Initializes a new light.",since:5}],properties:[{signature:"Color Ambient",summary:"Gets or sets the ambient color.",since:5},{signature:"Attenuation AttenuationType",summary:"Get the type of attenuation for this light.",since:7},{signature:"Vector3d AttenuationVector",summary:"Gets or Sets the attenuation vector.",since:5.7},{signature:"CoordinateSystem CoordinateSystem",summary:"Gets a value, determined by LightStyle, that explains whether\n     the camera directions are relative to World or Camera spaces.",since:5},{signature:"Color Diffuse",summary:"Gets or sets the diffuse color.",since:5},{signature:"Vector3d Direction",summary:"Gets or sets the vector direction of the camera.",since:5},{signature:"double HotSpot",summary:"The hot spot setting runs from 0.0 to 1.0 and is used to\n     provides a linear interface for controling the focus or \n     concentration of a spotlight.\n     A hot spot setting of 0.0 corresponds to a spot exponent of 128.\n     A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.",since:5},{signature:"Guid Id",summary:"Gets the ID of this light.",since:6},{signature:"double Intensity",summary:"Gets or sets the light intensity.",since:5},{signature:"bool IsDirectionalLight",summary:"Gets a value indicating whether the light style\n     is  CameraDirectional or WorldDirectional.",since:5},{signature:"bool IsEnabled",summary:"Gets or sets a value that defines if the light is turned on (true) or off (false).",since:5},{signature:"bool IsLinearLight",summary:"Gets a value indicating whether the light style\n     is  WorldLinear.",since:5},{signature:"bool IsPointLight",summary:"Gets a value indicating whether the light style\n     is  CameraPoint or WorldPoint.",since:5},{signature:"bool IsRectangularLight",summary:"Gets a value indicating whether the light style\n     is  WorldRectangular.",since:5},{signature:"bool IsSpotLight",summary:"Gets a value indicating whether the light style\n     is  CameraSpot or WorldSpot.",since:5},{signature:"bool IsSunLight",summary:"Gets a value indicating whether this object is a Sun light.",since:5},{signature:"Vector3d Length",summary:"Gets or sets the height in linear and rectangular lights.\n     (ignored for non-linear/rectangular lights.)",since:5},{signature:"LightStyle LightStyle",summary:"Gets or sets a light style on this camera.",since:5},{signature:"Point3d Location",summary:"Gets or sets the light or 3D position or location.",since:5},{signature:"string Name",summary:"Gets or sets the spot light name.",since:5},{signature:"Vector3d PerpendicularDirection",summary:"Gets a perpendicular vector to the camera direction.",since:5},{signature:"double PowerCandela",summary:"Gets or sets the light power in candelas (cd).",since:5},{signature:"double PowerLumens",summary:"Gets or sets the light power in lumens (lm).",since:5},{signature:"double PowerWatts",summary:"Gets or sets the light power in watts (W).",since:5},{signature:"double ShadowIntensity",summary:"Gets or sets the shadow intensity for the light.",since:6},{signature:"Color Specular",summary:"Gets or sets the specular color.",since:5},{signature:"double SpotAngleRadians",summary:"Gets or sets the spot angle in radians.\n     Ignored for non-spot lights.angle = 0 to pi/2  (0 to 90 degrees).",since:5},{signature:"double SpotExponent",summary:"The spot exponent varies from 0.0 to 128.0 and provides\n     an exponential interface for controling the focus or \n     concentration of a spotlight (like the \n     OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent\n     and hot spot parameters are linked; changing one will\n     change the other.\n     A hot spot setting of 0.0 corresponds to a spot exponent of 128.\n     A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.",since:5},{signature:"double SpotLightShadowIntensity",summary:"Gets or sets the spot light shadow intensity.\n     (ignored for non-spot lights.)",since:5},{signature:"Vector3d Width",summary:"Gets or sets the width in linear and rectangular lights.\n     (ignored for non-linear/rectangular lights.)",since:5}],methods:[{signature:"static Light CreateSunLight(double northAngleDegrees,DateTime when,double latitudeDegrees,double longitudeDegrees)",summary:"Constructs a light which simulates the Sun based on a given time and location on Earth.",since:5,returns:"A newly constructed light object."},{signature:"static Light CreateSunLight(double northAngleDegrees,double azimuthDegrees,double altitudeDegrees)",summary:"Constructs a light that represents the Sun.",since:5,returns:"A new sun light."},{signature:"static Light CreateSunLight(Sun sun)",summary:"Constructs a light which simulates a .",since:5,returns:"A light."},{signature:"double GetAttenuation(double d)",summary:'Gets the attenuation settings (ignored for "directional" and "ambient" lights).\n     attenuation = 1/(a0 + d*a1 + d^2*a2) where d = distance to light.',since:5,returns:"0 if a0 + d*a1 + d^2*a2 <= 0."},{signature:"bool GetSpotLightRadii(double innerRadius,double outerRadius)",summary:"Gets the spot light radii.",since:5,returns:"True if operation succeeded; otherwise, false."},{signature:"void SetAttenuation(double a0,double a1,double a2)",summary:'Sets the attenuation settings (ignored for "directional" and "ambient" lights).\n     attenuation = 1/(a0 + d*a1 + d^2*a2) where d = distance to light.',since:5}]},{name:"Rhino.Geometry.Light.Attenuation",dataType:3,summary:"Types of light attenuation available."},{name:"Rhino.Geometry.LightStyle",dataType:3,summary:"Defines enumerated values to represent light styles or types, such as directional or spotlight."},{name:"Rhino.Geometry.Line",dataType:2,summary:"Represents the value of start and end points in a single line segment.",constructors:[{signature:"Line(double x0,double y0,double z0,double x1,double y1,double z1)",summary:"Constructs a new line segment between two points.",since:5},{signature:"Line(Point3d from,Point3d to)",summary:"Constructs a new line segment between two points.",since:5},{signature:"Line(Point3d start,Vector3d span)",summary:"Constructs a new line segment from start point and span vector.",since:5},{signature:"Line(Point3d start,Vector3d direction,double length)",summary:"Constructs a new line segment from start point, direction and length.",since:5}],properties:[{signature:"static Line Unset",summary:"Gets a line segment which has  end points.",since:5},{signature:"BoundingBox BoundingBox",summary:"Gets the line's 3d axis aligned bounding box.",since:5},{signature:"Vector3d Direction",summary:"Gets the direction of this line segment. \n     The length of the direction vector equals the length of \n     the line segment.",since:5},{signature:"Point3d From",summary:"Start point of line segment.",since:5},{signature:"double FromX",summary:"Gets or sets the X coordinate of the line From point.",since:5},{signature:"double FromY",summary:"Gets or sets the Y coordinate of the line From point.",since:5},{signature:"double FromZ",summary:"Gets or sets the Z coordinate of the line From point.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether or not this line is valid. \n     Valid lines must have valid start and end points.",since:5},{signature:"double Length",summary:"Gets or sets the length of this line segment. \n     Note that a negative length will invert the line segment without \n     making the actual length negative. The line From point will remain fixed \n     when a new Length is set.",since:5},{signature:"Point3d To",summary:"End point of line segment.",since:5},{signature:"double ToX",summary:"Gets or sets the X coordinate of the line To point.",since:5},{signature:"double ToY",summary:"Gets or sets the Y coordinate of the line To point.",since:5},{signature:"double ToZ",summary:"Gets or sets the Z coordinate of the line To point.",since:5},{signature:"Vector3d UnitTangent",summary:"Gets the tangent of the line segment. \n     Note that tangent vectors are always unit vectors.",since:5}],methods:[{signature:"static bool TryCreateBetweenCurves(Curve curve0,Curve curve1,double t0,double t1,bool perpendicular0,bool perpendicular1,Line line)",summary:"Creates a line segment between a pair of curves such that the line segment is either tangent or perpendicular to each of the curves.",since:5.2,returns:"True on success, False on failure."},{signature:"static bool TryFitLineToPoints(IEnumerable<Point3d> points,Line fitLine)",summary:"Attempt to fit a line through a set of points.",since:5,returns:"True on success, False on failure."},{signature:"double ClosestParameter(Point3d testPoint)",summary:"Finds the parameter on the infinite line segment that is closest to a test point.",since:5,returns:"The parameter on the line that is closest to testPoint."},{signature:"Point3d ClosestPoint(Point3d testPoint,bool limitToFiniteSegment)",summary:"Finds the point on the (in)finite line segment that is closest to a test point.",since:5,returns:"The point on the (in)finite line that is closest to testPoint."},{signature:"double DistanceTo(Point3d testPoint,bool limitToFiniteSegment)",summary:"Compute the shortest distance between this line segment and a test point.",since:5,returns:"The shortest distance between this line segment and testPoint."},{signature:"bool EpsilonEquals(Line other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(Line other)",summary:"Determines whether a line has the same value as this line.",since:5,returns:"True if other has the same coordinates as this; otherwise false."},{signature:"bool Equals(object obj)",summary:"Determines whether an object is a line that has the same value as this line.",returns:"True if obj is a Line and has the same coordinates as this; otherwise false."},{signature:"bool Extend(double startLength,double endLength)",summary:"Extend the line by custom distances on both sides.",since:5,returns:"True on success, False on failure."},{signature:"bool ExtendThroughBox(BoundingBox box)",summary:"Ensure the line extends all the way through a box. \n     Note, this does not result in the shortest possible line \n     that overlaps the box.",since:5,returns:"True on success, False on failure."},{signature:"bool ExtendThroughBox(BoundingBox box,double additionalLength)",summary:"Ensure the line extends all the way through a box. \n     Note, this does not result in the shortest possible line that overlaps the box.",since:5,returns:"True on success, False on failure."},{signature:"bool ExtendThroughBox(Box box)",summary:"Ensure the line extends all the way through a box. \n     Note, this does not result in the shortest possible line that overlaps the box.",since:5,returns:"True on success, False on failure."},{signature:"bool ExtendThroughBox(Box box,double additionalLength)",summary:"Ensure the line extends all the way through a box. \n     Note, this does not result in the shortest possible line that overlaps the box.",since:5,returns:"True on success, False on failure."},{signature:"void Flip()",summary:"Flip the endpoints of the line segment.",since:5},{signature:"int GetHashCode()",summary:"Computes a hash number that represents this line.",returns:"A number that is not unique to the value of this line."},{signature:"double MaximumDistanceTo(Line testLine)",summary:"Finds the largest distance between this line as a finite segment\n     and another finite segment.",since:5,returns:"The maximum distance."},{signature:"double MaximumDistanceTo(Point3d testPoint)",summary:"Finds the largest distance between this line as a finite segment\n     and a test point.",since:5,returns:"The maximum distance."},{signature:"double MinimumDistanceTo(Line testLine)",summary:"Finds the shortest distance between this line as a finite segment\n     and another finite segment.",since:5,returns:"The minimum distance."},{signature:"double MinimumDistanceTo(Point3d testPoint)",summary:"Finds the shortest distance between this line as a finite segment\n     and a test point.",since:5,returns:"The minimum distance."},{signature:"Point3d PointAt(double t)",summary:"Evaluates the line at the specified parameter.",since:5,returns:"The point at the specified parameter."},{signature:"Point3d PointAtLength(double distance)",summary:"Computes a point located at a specific metric distance from the line origin ().\n     If line start and end coincide, then the start point is always returned.",since:6,returns:"The newly found point."},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a nurbs curve representation of this line. \n     This amounts to the same as calling NurbsCurve.CreateFromLine().",since:5,returns:"A nurbs curve representation of this line or None if no such representation could be made."},{signature:"string ToString()",summary:'Constructs the string representation of this line, in the form "From,To".',returns:"A text string."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"bool Transform(Transform xform)",summary:"Transform the line using a Transformation matrix.",since:5,returns:"True on success, False on failure."},{signature:"bool TryGetPlane(Plane plane)",summary:"Gets a plane that contains the line. The origin of the plane is at the start of the line.\n     If possible, a plane parallel to the world xy, yz, or zx plane is returned.",since:5,returns:"True on success."}]},{name:"Rhino.Geometry.LinearDimension",dataType:1,summary:"Represents a linear dimension",constructors:[{signature:"LinearDimension()",since:5},{signature:"LinearDimension(Plane dimensionPlane,Point2d extensionLine1End,Point2d extensionLine2End,Point2d pointOnDimensionLine)",since:5}],properties:[{signature:"bool Aligned",summary:"Gets or sets a value indicating whether this annotation is aligned.",since:5},{signature:"AnnotationType AnnotationType",since:6},{signature:"Point2d Arrowhead1End",summary:"Gets the arrow head end of the first extension line.",since:5},{signature:"Point2d Arrowhead2End",summary:"Gets the arrow head end of the second extension line.",since:5},{signature:"Point2d DimensionLinePoint",summary:"Point on annotation plane where dimension line starts",since:6},{signature:"double DistanceBetweenArrowTips",summary:"Gets the distance between arrow tips.",since:5},{signature:"Point2d ExtensionLine1End",summary:"End of the first extension line.",since:5},{signature:"Point2d ExtensionLine2End",summary:"End of the second extension line.",since:5}],methods:[{signature:"static LinearDimension Create(AnnotationType dimtype,DimensionStyle dimStyle,Plane plane,Vector3d horizontal,Point3d defpoint1,Point3d defpoint2,Point3d dimlinepoint,double rotationInPlane)",summary:"Initialize Dimension parameters",since:6},{signature:"static LinearDimension FromPoints(Point3d extensionLine1End,Point3d extensionLine2End,Point3d pointOnDimensionLine)",summary:"Initializes a new instance of the  class, based on three points.",since:5},{signature:"bool Get3dPoints(Point3d extensionLine1End,Point3d extensionLine2End,Point3d arrowhead1End,Point3d arrowhead2End,Point3d dimlinepoint,Point3d textpoint)",summary:"Get locations of dimension's 3d points",since:6,returns:"True = success"},{signature:"bool GetDisplayLines(DimensionStyle style,double scale,IEnumerable<Line> lines)"},{signature:"string GetDistanceDisplayText(UnitSystem unitsystem,DimensionStyle style)",since:6},{signature:"bool GetTextRectangle(Point3d[] corners)",since:6},{signature:"void SetLocations(Point2d extensionLine1End,Point2d extensionLine2End,Point2d pointOnDimensionLine)",summary:"Sets the three locations of the point, using two-dimensional points\n     that refer to the plane of the annotation.",since:5}]},{name:"Rhino.Geometry.LineCurve",dataType:1,summary:"Represents a linear curve.",constructors:[{signature:"LineCurve()",summary:"Initializes a new instance of the  class.",since:5},{signature:"LineCurve(Line line)",summary:"Initializes a new instance of the  class, by\n     retrieving its value from a line.",since:5},{signature:"LineCurve(Line line,double t0,double t1)",summary:"Initializes a new instance of the  class, by\n     retrieving its value from a line and setting the domain.",since:5},{signature:"LineCurve(LineCurve other)",summary:"Initializes a new instance of the  class, by\n     copying values from another linear curve.",since:5},{signature:"LineCurve(Point2d from,Point2d to)",summary:"Initializes a new instance of the  class, by\n     setting start and end point from two 2D points.",since:5},{signature:"LineCurve(Point3d from,Point3d to)",summary:"Initializes a new instance of the  class, by\n     setting start and end point from two 3D points.",since:5}],properties:[{signature:"Line Line",summary:"Gets or sets the Line value inside this curve.",since:5}]},{name:"Rhino.Geometry.LoftType",dataType:3,summary:"Specifies enumerated constants for all supported loft types."},{name:"Rhino.Geometry.Matrix",dataType:1,summary:"Represents an arbitrarily sized matrix of double-precision\n   floating point numbers. If you are working with a 4x4 matrix, then you may want\n   to use the  class instead.",constructors:[{signature:"Matrix(int rowCount,int columnCount)",summary:"Initializes a new instance of the matrix.",since:5},{signature:"Matrix(Transform xform)",summary:"Initializes a new instance of the matrix based on a 4x4 matrix .",since:5}],properties:[{signature:"int ColumnCount",summary:"Gets the amount of columns.",since:5},{signature:"bool IsColumnOrthogonal",summary:"Gets a value indicating whether the matrix is column orthogonal.",since:5},{signature:"bool IsColumnOrthoNormal",summary:"Gets a value indicating whether the matrix is column orthonormal.",since:5},{signature:"bool IsRowOrthogonal",summary:"Gets a value indicating whether the matrix is row orthogonal.",since:5},{signature:"bool IsRowOrthoNormal",summary:"Gets a value indicating whether the matrix is row orthonormal.",since:5},{signature:"bool IsSquare",summary:"Gets a value indicating whether this matrix has the same number of rows\n     and columns. 0x0 matrices are not considered square.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether this matrix is valid.",since:5},{signature:"int RowCount",summary:"Gets the amount of rows.",since:5}],methods:[{signature:"double[] BackSolve(double zeroTolerance,double[] b)",summary:"Solves M*x=b where M is upper triangular with a unit diagonal and\n     b is a column of values.",since:5,returns:"Array of length ColumnCount on success. None on error."},{signature:"Point3d[] BackSolvePoints(double zeroTolerance,Point3d[] b)",summary:"Solves M*x=b where M is upper triangular with a unit diagonal and\n     b is a column of 3d points.",since:5,returns:"Array of length ColumnCount on success. None on error."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"Matrix Duplicate()",summary:"Create a duplicate of this matrix.",since:5.1,returns:"An exact duplicate of this matrix."},{signature:"int GetHashCode()",summary:"Gets the hash code for this matrix. The hash code will change \n     when the matrix changes so you cannot change matrices while they are stored in \n     hash tables.",returns:"Hash code."},{signature:"bool Invert(double zeroTolerance)",summary:"Modifies this matrix to become its own inverse.\n     Matrix might be non-invertible (singular) and the return value will be false.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"int RowReduce(double zeroTolerance,double determinant,double pivot)",summary:"Row reduces a matrix to calculate rank and determinant.",since:5,returns:"Rank of the matrix."},{signature:"int RowReduce(double zeroTolerance,double[] b,double pivot)",summary:"Row reduces a matrix as the first step in solving M*X=b where\n     b is a column of values.",since:5,returns:"Rank of the matrix."},{signature:"int RowReduce(double zeroTolerance,Point3d[] b,double pivot)",summary:"Row reduces a matrix as the first step in solving M*X=b where\n     b is a column of 3d points.",since:5,returns:"Rank of the matrix."},{signature:"void Scale(double s)",summary:"Modifies the current matrix by multiplying its values by a number.",since:5},{signature:"void SetDiagonal(double d)",summary:"Sets diagonal value and zeros off all non-diagonal values.",since:5},{signature:"bool SwapColumns(int columnA,int columnB)",summary:"Exchanges two columns.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool SwapRows(int rowA,int rowB)",summary:"Exchanges two rows.",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"bool Transpose()",summary:"Modifies this matrix to be its transpose.\n     This is like swapping rows with columns.http://en.wikipedia.org/wiki/Transpose",since:5,returns:"True if operation succeeded; otherwise false."},{signature:"void Zero()",summary:"Sets all values inside the matrix to zero.",since:5}]},{name:"Rhino.Geometry.Mesh",dataType:1,summary:"Represents a geometry type that is defined by vertices and faces.\n   This is often called a face-vertex mesh.",constructors:[{signature:"Mesh()",summary:"Initializes a new empty mesh.",since:5}],properties:[{signature:"MeshVertexStatusList ComponentStates",summary:"Gets access to the vertex hidden/visibility collection in this mesh.\n     This is a runtime property and it is not saved in the 3dm file.",since:6},{signature:"int DisjointMeshCount",summary:"Gets the number of disjoint (topologically unconnected) pieces in this mesh.",since:5},{signature:"MeshFaceNormalList FaceNormals",summary:"Gets access to the face normal collection in this mesh.",since:5},{signature:"MeshFaceList Faces",summary:"Gets access to the mesh face list.",since:5},{signature:"bool HasCachedTextureCoordinates",summary:"Will return True if SetCachedTextureCoordinates has been called;\n     otherwise will return false.",since:5.1},{signature:"bool HasPrincipalCurvatures",summary:"HasPrincipalCurvatures",since:7},{signature:"bool IsClosed",summary:"Gets a value indicating whether a mesh is considered to be closed (solid).\n     A mesh is considered solid when every mesh edge borders two or more faces.",since:5},{signature:"MeshNgonList Ngons",summary:"Gets access to the mesh ngon list.\n     Ngons represent groups of Faces (triangles + quads).Faces are used to tessellate an Ngon internally.When a triangle or quad is referenced in the Ngon list, it is no longer visualized and\n     conceived as a single entity, but takes part of the Ngon.If you need to get access to both Ngons and the faces that are not referenced by Ngons,\n     that is, all polygons that are visible in the mesh, then use the\n      helper method.",since:6},{signature:"MeshVertexNormalList Normals",summary:"Gets access to the vertex normal collection in this mesh.",since:5},{signature:"int PartitionCount",summary:"Number of partition information chunks stored on this mesh based\n     on the last call to CreatePartitions",since:5.6},{signature:"MeshTextureCoordinateList TextureCoordinates",summary:"Gets access to the vertex texture coordinate collection in this mesh.",since:5},{signature:"MeshTopologyEdgeList TopologyEdges",summary:"Gets the  object associated with this mesh.\n     This object stores edge connectivity.",since:5},{signature:"MeshTopologyVertexList TopologyVertices",summary:"Gets the  object associated with this mesh.\n     This object stores vertex connectivity and the indices of vertices\n     that were unified while computing the edge topology.",since:5},{signature:"MeshVertexColorList VertexColors",summary:"Gets access to the (optional) vertex color collection in this mesh.",since:5},{signature:"MeshVertexList Vertices",summary:"Gets access to the vertices set of this mesh.",since:5}],methods:[{signature:"static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes,double maximumThickness)",summary:"Compute thickness metrics for this mesh.",since:6,returns:"Array of thickness measurements."},{signature:"static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes,double maximumThickness,CancellationToken cancelToken)",summary:"Compute thickness metrics for this mesh.",since:6,returns:"Array of thickness measurements."},{signature:"static MeshThicknessMeasurement[] ComputeThickness(IEnumerable<Mesh> meshes,double maximumThickness,double sharpAngle,CancellationToken cancelToken)",summary:"Compute thickness metrics for this mesh.",since:6,returns:"Array of thickness measurements."},{signature:"static Mesh[] CreateBooleanDifference(IEnumerable<Mesh> firstSet,IEnumerable<Mesh> secondSet)",summary:"Computes the solid difference of two sets of Meshes.",since:5,returns:"An array of Mesh results or None on failure."},{signature:"static Mesh[] CreateBooleanIntersection(IEnumerable<Mesh> firstSet,IEnumerable<Mesh> secondSet)",summary:"Computes the solid intersection of two sets of meshes.",since:5,returns:"An array of Mesh results or None on failure."},{signature:"static Mesh[] CreateBooleanSplit(IEnumerable<Mesh> meshesToSplit,IEnumerable<Mesh> meshSplitters)",summary:"Splits a set of meshes with another set.",since:5,returns:"A new mesh array, or None on error."},{signature:"static Mesh[] CreateBooleanUnion(IEnumerable<Mesh> meshes)",summary:"Computes the solid union of a set of meshes.",since:5,returns:"An array of Mesh results or None on failure."},{signature:"static Curve[] CreateContourCurves(Mesh meshToContour,Plane sectionPlane)",summary:"Constructs contour curves for a mesh, sectioned at a plane.",since:5,returns:"An array of curves. This array can be empty."},{signature:"static Curve[] CreateContourCurves(Mesh meshToContour,Point3d contourStart,Point3d contourEnd,double interval)",summary:"Constructs contour curves for a mesh, sectioned along a linear axis.",since:5,returns:"An array of curves. This array can be empty."},{signature:"static Mesh CreateFromBox(BoundingBox box,int xCount,int yCount,int zCount)",summary:"Constructs new mesh that matches a bounding box.",since:5.6,returns:"A new brep, or None on failure."},{signature:"static Mesh CreateFromBox(Box box,int xCount,int yCount,int zCount)",summary:"Constructs new mesh that matches an aligned box.",since:5.3},{signature:"static Mesh CreateFromBox(IEnumerable<Point3d> corners,int xCount,int yCount,int zCount)",summary:"Constructs new mesh from 8 corner points.",since:5.3,returns:"A new brep, or None on failure."},{signature:"static Mesh[] CreateFromBrep(Brep brep)",summary:"Constructs a mesh from a brep.",since:5,returns:"An array of meshes."},{signature:"static Mesh[] CreateFromBrep(Brep brep,MeshingParameters meshingParameters)",summary:"Constructs a mesh from a brep.",since:5,returns:"An array of meshes."},{signature:"static Mesh CreateFromClosedPolyline(Polyline polyline)",summary:"Attempts to create a Mesh that is a triangulation of a simple closed polyline that projects onto a plane.",since:5,returns:"New mesh on success or None on failure."},{signature:"static Mesh CreateFromCone(Cone cone,int vertical,int around)",summary:"Constructs a solid mesh cone.",since:5,returns:"A valid mesh if successful."},{signature:"static Mesh CreateFromCone(Cone cone,int vertical,int around,bool solid)",summary:"Constructs a mesh cone.",since:6.8,returns:"A valid mesh if successful."},{signature:"static Mesh CreateFromCone(Cone cone,int vertical,int around,bool solid,bool quadCaps)",summary:"Constructs a mesh cone.",since:7,returns:"A valid mesh if successful."},{signature:"static Mesh CreateFromCurveExtrusion(Curve curve,Vector3d direction,MeshingParameters parameters,BoundingBox boundingBox)",summary:"Constructs a new extrusion from a curve.",since:7,returns:"A new mesh, or None on failure."},{signature:"static Mesh CreateFromCurvePipe(Curve curve,double radius,int segments,int accuracy,MeshPipeCapStyle capType,bool faceted,IEnumerable<Interval> intervals)",summary:"Constructs a new mesh pipe from a curve.",since:6,returns:"A new mesh, or None on failure."},{signature:"static Mesh CreateFromCylinder(Cylinder cylinder,int vertical,int around)",summary:"Constructs a capped mesh cylinder.",since:5,returns:"Returns a mesh cylinder if successful, None otherwise."},{signature:"static Mesh CreateFromCylinder(Cylinder cylinder,int vertical,int around,bool capBottom,bool capTop)",summary:"Constructs a mesh cylinder.",since:7,returns:"Returns a mesh cylinder if successful, None otherwise."},{signature:"static Mesh CreateFromCylinder(Cylinder cylinder,int vertical,int around,bool capBottom,bool capTop,bool quadCaps)",summary:"Constructs a mesh cylinder.",since:7,returns:"Returns a mesh cylinder if successful, None otherwise."},{signature:"static Mesh[] CreateFromIterativeCleanup(IEnumerable<Mesh> meshes,double tolerance)",summary:"Repairs meshes with vertices that are too near, using a tolerance value.",since:7,returns:"A valid meshes array if successful. If no change was required, some meshes can be null. Otherwise, null, when no changes were done."},{signature:"static Mesh CreateFromLines(Curve[] lines,int maxFaceValence,double tolerance)",summary:"Creates a mesh by analizing the edge structure. Input lines could be from the extraction\n     of edges from an original mesh.",since:6,returns:"A new mesh, or None if no mesh is constructed."},{signature:"static Mesh CreateFromPlanarBoundary(Curve boundary,MeshingParameters parameters)",summary:"Do not use this overload. Use version that takes a tolerance parameter instead.",since:5,returns:"Do not use."},{signature:"static Mesh CreateFromPlanarBoundary(Curve boundary,MeshingParameters parameters,double tolerance)",summary:"Attempts to construct a mesh from a closed planar curve.RhinoMakePlanarMeshes",since:6,returns:"New mesh on success or None on failure."},{signature:"static Mesh CreateFromPlane(Plane plane,Interval xInterval,Interval yInterval,int xCount,int yCount)",summary:"Constructs a planar mesh grid.",since:5},{signature:"static Mesh CreateFromSphere(Sphere sphere,int xCount,int yCount)",summary:"Constructs a mesh sphere.",since:5},{signature:"static Mesh CreateFromSubD(SubD subd,int displayDensity)",summary:"Create a mesh from a SubD limit surface",since:7},{signature:"static Mesh CreateFromSubDControlNet(SubD subd)",summary:"Create a mesh from a SubD control net",since:7},{signature:"static Mesh CreateFromSurface(Surface surface)",summary:"Constructs a mesh from a surface",since:6.5,returns:"New mesh representing the surface"},{signature:"static Mesh CreateFromSurface(Surface surface,MeshingParameters meshingParameters)",summary:"Constructs a mesh from a surface",since:6.5,returns:"New mesh representing the surface"},{signature:"static Mesh CreateFromTessellation(IEnumerable<Point3d> points,IEnumerable<IEnumerable<Point3d>> edges,Plane plane,bool allowNewVertices)",summary:"Attempts to create a mesh that is a triangulation of a list of points, projected on a plane,\n     including its holes and fixed edges.",returns:"A new mesh, or None if not successful."},{signature:"static Mesh CreateFromTorus(Torus torus,int vertical,int around)",summary:"Constructs a mesh torus.",since:7,returns:"Returns a mesh torus if successful, None otherwise."},{signature:"static Mesh CreateIcoSphere(Sphere sphere,int subdivisions)",summary:"Constructs a icospherical mesh. A mesh icosphere differs from a standard\n     UV mesh sphere in that it's vertices are evenly distributed. A mesh icosphere\n     starts from an icosahedron (a regular polyhedron with 20 equilateral triangles).\n     It is then refined by splitting each triangle into 4 smaller triangles.\n     This splitting can be done several times.",since:6,returns:"A welded mesh icosphere if successful, or None on failure."},{signature:"static Mesh CreatePatch(Polyline outerBoundary,double angleToleranceRadians,Surface pullbackSurface,IEnumerable<Curve> innerBoundaryCurves,IEnumerable<Curve> innerBothSideCurves,IEnumerable<Point3d> innerPoints,bool trimback,int divisions)",summary:"Construct a mesh patch from a variety of input geometry.",since:6,returns:"mesh on success; None on failure"},{signature:"static Mesh CreateQuadSphere(Sphere sphere,int subdivisions)",summary:"Constructs a quad mesh sphere. A quad mesh sphere differs from a standard\n     UV mesh sphere in that it's vertices are evenly distributed. A quad mesh sphere\n     starts from a cube (a regular polyhedron with 6 square sides).\n     It is then refined by splitting each quad into 4 smaller quads.\n     This splitting can be done several times.",since:6,returns:"A welded quad mesh sphere if successful, or None on failure."},{signature:"static Mesh CreateRefinedCatmullClarkMesh(Mesh mesh,RefinementSettings settings)",summary:"Instantiates a new mesh that represents a Catmull-Clark subdivision of the mesh.",since:6,returns:"A new mesh. None is never returned."},{signature:"static Mesh CreateRefinedLoopMesh(Mesh mesh,LoopFormula formula,RefinementSettings settings)",summary:"Instantiates a new mesh that represents a Loop subdivision of the mesh.",since:6,returns:"A new mesh. None is never returned."},{signature:"static Mesh QuadRemeshBrep(Brep brep,QuadRemeshParameters parameters)",summary:"Create QuadRemesh from a Brep\n     Set Brep Face Mode by setting QuadRemeshParameters.PreserveMeshArrayEdgesMode",since:7},{signature:"static Mesh QuadRemeshBrep(Brep brep,QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves)",summary:"Create Quad Remesh from a Brep",since:7},{signature:"static Task<Mesh> QuadRemeshBrepAsync(Brep brep,QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves,IProgress<int> progress,CancellationToken cancelToken)",summary:"Quad remesh this brep async",since:7},{signature:"static Task<Mesh> QuadRemeshBrepAsync(Brep brep,QuadRemeshParameters parameters,IProgress<int> progress,CancellationToken cancelToken)",summary:"Quad remesh this brep async",since:7},{signature:"static bool RequireIterativeCleanup(IEnumerable<Mesh> meshes,double tolerance)",summary:"Analyzes some meshes, and determines if a pass of CreateFromIterativeCleanup would change the array.\n     All available cleanup steps are used. Currently available cleanup steps are:- mending of single precision coincidence even though double precision vertices differ.- union of nearly identical vertices, irrespectively of their origin.- removal of t-joints along edges.",since:7,returns:"True if meshes would be changed, otherwise false."},{signature:"void Append(IEnumerable<Mesh> meshes)",summary:"Append a list of meshes. This function is much more efficient than making\n     repeated calls to Mesh.Append(Mesh) when lots of meshes are being joined\n     into a single large mesh.",since:6.8},{signature:"void Append(Mesh other)",summary:"Appends a copy of another mesh to this one and updates indices of appended mesh parts.",since:5},{signature:"bool Check(TextLog textLog,MeshCheckParameters parameters)",summary:"Examines the mesh and logs a description of what it finds right or wrong.\n     The various properties the function checks for are described in MeshCheckParameters.",since:7,returns:"Returns True if the mesh is valid, False otherwise."},{signature:"void ClearSurfaceData()",summary:"Removes surface parameters, curvature parameters and surface statistics from the mesh.",since:6},{signature:"void ClearTextureData()",summary:"Removes all texture coordinate information from this mesh.",since:5},{signature:"MeshPoint ClosestMeshPoint(Point3d testPoint,double maximumDistance)",summary:"Gets the point on the mesh that is closest to a given test point. Similar to the \n     ClosestPoint function except this returns a MeshPoint class which includes\n     extra information beyond just the location of the closest point.",since:5,returns:"closest point information on success. None on failure."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Gets the point on the mesh that is closest to a given test point.",since:5,returns:"The point on the mesh closest to testPoint, or Point3d.Unset on failure."},{signature:"int ClosestPoint(Point3d testPoint,Point3d pointOnMesh,double maximumDistance)",summary:"Gets the point on the mesh that is closest to a given test point.",since:5,returns:"Index of face that the closest point lies on if successful. \n     -1 if not successful; the value of pointOnMesh is undefined."},{signature:"int ClosestPoint(Point3d testPoint,Point3d pointOnMesh,Vector3d normalAtPoint,double maximumDistance)",summary:"Gets the point on the mesh that is closest to a given test point.",since:5,returns:"Index of face that the closest point lies on if successful. \n     -1 if not successful; the value of pointOnMesh is undefined."},{signature:"int CollapseFacesByArea(double lessThanArea,double greaterThanArea)",summary:"Collapses multiple mesh faces, with areas less than LessThanArea and greater than GreaterThanArea, \n     based on the principles found in Stan Melax's mesh reduction PDF, \n     see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf",since:6,returns:"Number of faces that were collapsed in the process."},{signature:"int CollapseFacesByByAspectRatio(double aspectRatio)",summary:"Collapses a multiple mesh faces, determined by face aspect ratio, based on criteria found in Stan Melax's polygon reduction,\n     see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf",since:6,returns:"Number of faces that were collapsed in the process."},{signature:"int CollapseFacesByEdgeLength(bool bGreaterThan,double edgeLength)",summary:"Collapses multiple mesh faces, with greater/less than edge length, based on the principles \n     found in Stan Melax's mesh reduction PDF, \n     see http://pomax.nihongoresources.com/downloads/PolygonReduction.pdf",since:6,returns:"Number of edges (faces) that were collapsed."},{signature:"Color ColorAt(int faceIndex,double t0,double t1,double t2,double t3)",summary:"Evaluate a mesh normal at a set of barycentric coordinates. Barycentric coordinates must \n     be assigned in accordance with the rules as defined by MeshPoint.T.",since:5,returns:"The interpolated vertex color on the mesh or Color.Transparent if the faceIndex is not valid, \n     if the barycentric coordinates could not be evaluated, or if there are no colors defined on the mesh."},{signature:"Color ColorAt(MeshPoint meshPoint)",summary:"Evaluate a mesh color at a set of barycentric coordinates.",since:5,returns:"The interpolated vertex color on the mesh or Color.Transparent if the faceIndex is not valid, \n     if the barycentric coordinates could not be evaluated, or if there are no colors defined on the mesh."},{signature:"bool Compact()",summary:"Removes any unreferenced objects from arrays, reindexes as needed \n     and shrinks arrays to minimum required size.",since:5,returns:"True on success, False on failure."},{signature:"byte[] ComputeAutoCreaseInformation()",summary:"Do not use this method.\n     Length: top.Mesh.Vertices.Count",since:6,returns:"An array that is bound to change."},{signature:"void CopyFrom(Mesh other)",summary:"Copies mesh values into this mesh from another mesh.",since:5},{signature:"bool CreatePartitions(int maximumVertexCount,int maximumTriangleCount)",summary:"In ancient times (or modern smartphone times), some rendering engines\n     were only able to process small batches of triangles and the\n     CreatePartitions() function was provided to partition the mesh into\n     subsets of vertices and faces that those rendering engines could handle.",since:5.6,returns:"True on success"},{signature:"void DestroyPartition()",summary:"Destroys mesh partition.",since:6},{signature:"void DestroyTopology()",summary:"Removes topology data, forcing all topology information to be recomputed.",since:6},{signature:"void DestroyTree()",summary:"Destroys the mesh vertex access tree.",since:6},{signature:"GeometryBase Duplicate()",summary:"Constructs a copy of this mesh.\n     This is the same as .",since:5,returns:"A mesh."},{signature:"Mesh DuplicateMesh()",summary:"Constructs a copy of this mesh.\n     This is the same as .",since:5},{signature:"bool EvaluateMeshGeometry(Surface surface)",summary:"If the mesh has SurfaceParameters, the surface is evaluated at\n     these parameters and the mesh geometry is updated.",since:5,returns:"True if the operation succceeded; False otherwise."},{signature:"Mesh[] ExplodeAtUnweldedEdges()",summary:'Explode the mesh into submeshes where a submesh is a collection of faces that are contained\n     within a closed loop of "unwelded" edges. Unwelded edges are edges where the faces that share\n     the edge have unique mesh vertexes (not mesh topology vertexes) at both ends of the edge.',since:5,returns:"Array of submeshes on success; None on error. If the count in the returned array is 1, then\n     nothing happened and the ouput is essentially a copy of the input."},{signature:"int[] ExtendSelectionByEdgeRidge(int[] preselectedEdges,int newEdge,bool iterative)",summary:"Suggests an extension of a selection set by using information related with topology and alignment.",since:6,returns:"An array of edges that are in a visual relationship with newEdge."},{signature:"int[] ExtendSelectionByFaceLoop(int[] preselectedFaces,int newFace,bool iterative)",summary:"Suggests an extension of a face selection set by using information related with topology and alignment.",since:6,returns:"An array of faces that are in a visual relationship with newFace."},{signature:"Mesh ExtractNonManifoldEdges(bool selective)",summary:"Extracts, or removes, non-manifold mesh edges.",since:6,returns:"A mesh containing the extracted non-manifold parts if successful, None otherwise."},{signature:"bool FileHole(int topologyEdgeIndex)",summary:'Given a starting "naked" edge index, this function attempts to determine a "hole"\n     by chaining additional naked edges together until if returns to the start index.\n     Then it triangulates the closed polygon and either adds the faces to the mesh.',since:6,returns:"True if successful, False otherwise."},{signature:"bool FillHoles()",summary:'Attempts to determine "holes" in the mesh by chaining naked edges together. \n     Then it triangulates the closed polygons adds the faces to the mesh.',since:6,returns:"True if successful, False otherwise."},{signature:"void Flip(bool vertexNormals,bool faceNormals,bool faceOrientation)",summary:"Reverses the direction of the mesh.",since:5},{signature:"void Flip(bool vertexNormals,bool faceNormals,bool faceOrientation,bool ngonsBoundaryDirection)",summary:"Reverses the direction of the mesh.",since:7},{signature:"CachedTextureCoordinates GetCachedTextureCoordinates(Guid textureMappingId)",summary:"Call this method to get cached texture coordinates for a texture\n     mapping with the specified Id.",since:5.1,returns:"Object which allows access to coordinates and other props."},{signature:"bool[] GetNakedEdgePointStatus()",summary:"Returns an array of bool values equal in length to the number of vertices in this\n     mesh. Each value corresponds to a mesh vertex and is set to True if the vertex is\n     not completely surrounded by faces.",since:5,returns:"An array of true/False flags that, at each index, reveals if the corresponding\n     vertex is completely surrounded by faces."},{signature:"Polyline[] GetNakedEdges()",summary:'Returns all edges of a mesh that are considered "naked" in the\n     sense that the edge only has one face.',since:5,returns:"An array of polylines, or None on error."},{signature:"int GetNgonAndFacesCount()",summary:"Retrieves the count of items that  will provide.",since:6,returns:"The amount of faces that are not part of an ngon + the amount of ngons."},{signature:"IEnumerable<MeshNgon> GetNgonAndFacesEnumerable()",summary:"Retrieves a complete enumerable, i.e., one that provides an iterator over every face that is present,\n     no matter if defined as a triangle, a quad, or a strictly over-four-sided ngon.",since:6,returns:"The enumerator capable of enumerating through Mesh.Ngons> Mesh.Ngons and Faces"},{signature:"Polyline[] GetOutlines(Plane plane)",summary:"Constructs the outlines of a mesh projected against a plane.",since:5,returns:"An array of polylines, or None on error."},{signature:"Polyline[] GetOutlines(RhinoViewport viewport)",summary:"Constructs the outlines of a mesh. The projection information in the\n     viewport is used to determine how the outlines are projected.",since:5,returns:"An array of polylines, or None on error."},{signature:"Polyline[] GetOutlines(ViewportInfo viewportInfo,Plane plane)",summary:"Constructs the outlines of a mesh.",since:6,returns:"An array of polylines, or None on error."},{signature:"MeshPart GetPartition(int which)",summary:"Retrieves a partition. See  for details.",since:5.6},{signature:"bool GetSelfIntersections(double tolerance,Polyline[] intersections,bool overlapsPolylines,Polyline[] overlapsPolylinesResult,bool overlapsMesh,Mesh overlapsMeshResult,TextLog textLog,CancellationToken cancel,IProgress<double> progress)",summary:"Gets the self intersections of this mesh.",since:7},{signature:"MeshUnsafeLock GetUnsafeLock(bool writable)",summary:"Allows to obtain unsafe pointers to the underlying unmanaged data structures of the mesh.",since:6,returns:"A lock that needs to be released."},{signature:"bool HealNakedEdges(double distance)",summary:'Attempts to "heal" naked edges in a mesh based on a given distance.  \n     First attempts to move vertexes to neighboring vertexes that are within that\n     distance away. Then it finds edges that have a closest point to the vertex within\n     the distance and splits the edge. When it finds one it splits the edge and\n     makes two new edges using that point.',since:6,returns:"True if successful, False otherwise."},{signature:"bool IsManifold(bool topologicalTest,bool isOriented,bool hasBoundary)",summary:"Gets a value indicating whether or not the mesh is manifold. \n     A manifold mesh does not have any edge that borders more than two faces.",since:5,returns:'True if every mesh "edge" has at most two adjacent faces.'},{signature:"bool IsPointInside(Point3d point,double tolerance,bool strictlyIn)",summary:"Determines if a point is inside a solid mesh.",since:5,returns:"True if point is inside the solid mesh, False if not."},{signature:"Vector3d NormalAt(int faceIndex,double t0,double t1,double t2,double t3)",summary:"Evaluate a mesh normal at a set of barycentric coordinates. Barycentric coordinates must \n     be assigned in accordance with the rules as defined by MeshPoint.T.",since:5,returns:"A Normal vector to the mesh or Vector3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{signature:"Vector3d NormalAt(MeshPoint meshPoint)",summary:"Evaluate a mesh normal at a set of barycentric coordinates.",since:5,returns:"A Normal vector to the mesh or Vector3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{signature:"Mesh Offset(double distance)",summary:"Makes a new mesh with vertices offset a distance in the opposite direction of the existing vertex normals.\n     Same as Mesh.Offset(distance, false)",since:5,returns:"A new mesh on success, or None on failure."},{signature:"Mesh Offset(double distance,bool solidify)",summary:"Makes a new mesh with vertices offset a distance in the opposite direction of the existing vertex normals.\n     Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges.\n     If solidify is False it acts exactly as the Offset(distance) function.",since:5,returns:"A new mesh on success, or None on failure."},{signature:"Mesh Offset(double distance,bool solidify,Vector3d direction)",summary:"Makes a new mesh with vertices offset a distance along the direction parameter.\n     Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges.\n     If solidify is False it acts exactly as the Offset(distance) function.",since:6.2,returns:"A new mesh on success, or None on failure."},{signature:"Mesh Offset(double distance,bool solidify,Vector3d direction,List<int> wallFacesOut)",summary:"Makes a new mesh with vertices offset a distance along the direction parameter.\n     Optionally, based on the value of solidify, adds the input mesh and a ribbon of faces along any naked edges.\n     If solidify is False it acts exactly as the Offset(distance) function. Returns list of wall faces, i.e. the\n     faces that connect original and offset mesh when solidified.",returns:"A new mesh on success, or None on failure."},{signature:"Point3d PointAt(int faceIndex,double t0,double t1,double t2,double t3)",summary:"Evaluates a mesh at a set of barycentric coordinates. Barycentric coordinates must \n     be assigned in accordance with the rules as defined by MeshPoint.T.",since:5,returns:"A Point on the mesh or Point3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{signature:"Point3d PointAt(MeshPoint meshPoint)",summary:"Evaluate a mesh at a set of barycentric coordinates.",since:5,returns:"A Point on the mesh or Point3d.Unset if the faceIndex is not valid or if the barycentric coordinates could not be evaluated."},{signature:"PolylineCurve PullCurve(Curve curve,double tolerance)",summary:'Gets a polyline approximation of the input curve and then moves its control points to the closest point on the mesh.\n     Then it "connects the points" over edges so that a polyline on the mesh is formed.',since:7,returns:"A polyline curve, or None if none could be constructed."},{signature:"Point3d[] PullPointsToMesh(IEnumerable<Point3d> points)",summary:"Pulls a collection of points to a mesh.",since:5,returns:"An array of points. This can be empty."},{signature:"Mesh QuadRemesh(QuadRemeshParameters parameters)",summary:"Quad remesh this mesh",since:7},{signature:"Mesh QuadRemesh(QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves)",summary:"Quad remesh this mesh",since:7},{signature:"Task<Mesh> QuadRemeshAsync(IEnumerable<int> faceBlocks,QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves,IProgress<int> progress,CancellationToken cancelToken)",summary:"Quad remesh this mesh async",since:7},{signature:"Task<Mesh> QuadRemeshAsync(QuadRemeshParameters parameters,IEnumerable<Curve> guideCurves,IProgress<int> progress,CancellationToken cancelToken)",summary:"Quad remesh this mesh async",since:7},{signature:"Task<Mesh> QuadRemeshAsync(QuadRemeshParameters parameters,IProgress<int> progress,CancellationToken cancelToken)",summary:"Quad remesh this mesh async",since:7},{signature:"void RebuildNormals()",summary:"Removes mesh normals and reconstructs the face and vertex normals based\n     on the orientation of the faces.",since:6},{signature:"bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize)",summary:"Reduce polygon count",since:5.1,returns:"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{signature:"bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize,bool threaded)",summary:"Reduce polygon count",since:6.15,returns:"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{signature:"bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize,CancellationToken cancelToken,IProgress<double> progress,string problemDescription)",summary:"Reduce polygon count",since:6,returns:"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{signature:"bool Reduce(int desiredPolygonCount,bool allowDistortion,int accuracy,bool normalizeSize,CancellationToken cancelToken,IProgress<double> progress,string problemDescription,bool threaded)",summary:"Reduce polygon count",since:6.15,returns:"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{signature:"bool Reduce(ReduceMeshParameters parameters)",summary:"Reduce polygon count",since:6,returns:"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{signature:"bool Reduce(ReduceMeshParameters parameters,bool threaded)",summary:"Reduce polygon count",since:6.15,returns:"True if mesh is successfully reduced and False if mesh could not be reduced for some reason."},{signature:"void ReleaseUnsafeLock(MeshUnsafeLock meshData)",summary:"Updates the Mesh data with the information that was stored via the ."},{signature:"void SetCachedTextureCoordinates(TextureMapping tm,Transform xf)",summary:"Set cached texture coordinates using the specified mapping.",since:5.1},{signature:"void SetTextureCoordinates(TextureMapping tm,Transform xf,bool lazy)",summary:"Set texture coordinates using given mapping and applying given transform.\n     \n     Set lazy to False to generate texture coordinates right away.",since:6},{signature:"bool Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem)",summary:"Smooths a mesh by averaging the positions of mesh vertices in a specified region.",since:6,returns:"True if successful, False otherwise."},{signature:"bool Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)",summary:"Smooths a mesh by averaging the positions of mesh vertices in a specified region.",since:6,returns:"True if successful, False otherwise."},{signature:"bool Smooth(IEnumerable<int> vertexIndices,double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)",summary:"Smooths part of a mesh by averaging the positions of mesh vertices in a specified region.",since:6.8,returns:"True if successful, False otherwise."},{signature:"int SolidOrientation()",summary:'Determines orientation of a "solid" mesh.',since:5,returns:"+1 = mesh is solid with outward facing normals.-1 = mesh is solid with inward facing normals.0 = mesh is not solid."},{signature:"Mesh[] Split(IEnumerable<Mesh> meshes)",summary:"Split a mesh with a collection of meshes.\n     Does not split at coplanar intersections.",since:5,returns:"An array of mesh segments representing the split result."},{signature:"Mesh[] Split(IEnumerable<Mesh> meshes,double tolerance,bool splitAtCoplanar,TextLog textLog,CancellationToken cancel,IProgress<double> progress)",summary:"Split a mesh with a collection of meshes.",since:7,returns:"An array of mesh parts representing the split result, or null: when no mesh intersected, or if a cancel stopped the computation."},{signature:"Mesh[] Split(Mesh mesh)",summary:"Split a mesh with another mesh.",since:5,returns:"An array of mesh segments representing the split result."},{signature:"Mesh[] Split(Plane plane)",summary:"Split a mesh by an infinite plane.",since:5,returns:"A new mesh array with the split result. This can be None if no result was found."},{signature:"Mesh[] SplitDisjointPieces()",summary:"Splits up the mesh into its unconnected pieces.",since:5,returns:"An array containing all the disjoint pieces that make up this Mesh."},{signature:"Mesh[] SplitWithProjectedPolylines(IEnumerable<PolylineCurve> curves,double tolerance)",summary:"Splits a mesh by adding edges in correspondance with input polylines, and divides the mesh at partitioned areas.\n     Polyline segments that are measured not to be on the mesh will be ignored.",since:7,returns:"An array of meshes, or None if no change would happen."},{signature:"Mesh[] SplitWithProjectedPolylines(IEnumerable<PolylineCurve> curves,double tolerance,TextLog textLog,CancellationToken cancel,IProgress<double> progress)",summary:"Splits a mesh by adding edges in correspondance with input polylines, and divides the mesh at partitioned areas.\n     Polyline segments that are measured not to be on the mesh will be ignored.",since:7,returns:"An array of meshes, or None if no change would happen."},{signature:"int UnifyNormals()",summary:"Attempts to fix inconsistencies in the directions of mesh faces in a mesh. This function\n     does not modify mesh vertex normals, it rearranges the mesh face winding and face\n     normals to make them all consistent. Note, you may want to call Mesh.Normals.ComputeNormals()\n     to recompute vertex normals after calling this functions.",since:5,returns:"number of faces that were modified."},{signature:"int UnifyNormals(bool countOnly)",summary:"Attempts to fix inconsistencies in the directions of mesh faces in a mesh. This function\n     does not modify mesh vertex normals, it rearranges the mesh face winding and face\n     normals to make them all consistent. Note, you may want to call Mesh.Normals.ComputeNormals()\n     to recompute vertex normals after calling this functions.",since:6,returns:"If countOnly=false, the number of faces that were modified. If countOnly=true, the number of faces that would be modified."},{signature:"void Unweld(double angleToleranceRadians,bool modifyNormals)",summary:"Makes sure that faces sharing an edge and having a difference of normal greater\n     than or equal to angleToleranceRadians have unique vertexes along that edge,\n     adding vertices if necessary.",since:5},{signature:"bool UnweldEdge(IEnumerable<int> edgeIndices,bool modifyNormals)",summary:"Adds creases to a smooth mesh by creating coincident vertices along selected edges.",since:6.3,returns:"True if successful, False otherwise."},{signature:"double Volume()",summary:"Compute volume of the mesh.",since:6,returns:"Volume of the mesh."},{signature:"void Weld(double angleToleranceRadians)",summary:"Makes sure that faces sharing an edge and having a difference of normal greater\n     than or equal to angleToleranceRadians share vertexes along that edge, vertex normals\n     are averaged.",since:5},{signature:"Mesh WithDisplacement(MeshDisplacementInfo displacement)",summary:"Constructs new mesh from the current one, with displacement applied to it.",since:6,returns:"A new mesh with shutlining."},{signature:"Mesh WithEdgeSoftening(double softeningRadius,bool chamfer,bool faceted,bool force,double angleThreshold)",summary:"Constructs new mesh from the current one, with edge softening applied to it.",since:6,returns:"A new mesh with soft edges."},{signature:"Mesh WithShutLining(bool faceted,double tolerance,IEnumerable<ShutLiningCurveInfo> curves)",summary:"Constructs new mesh from the current one, with shut lining applied to it.",since:6,returns:"A new mesh with shutlining. Null on failure."}]},{name:"Rhino.Geometry.MeshCheckParameters",dataType:2,summary:"Output of a mesh checking operations.",properties:[{signature:"bool CheckForBadNormals",summary:"If true, then then look for vertex normals that are not unit vectors,\n     are zero length or vary greatly from the general direction of the\n     face normals.",since:7},{signature:"bool CheckForDegenerateFaces",summary:"If true, then look for triangles and quads that have zero area and quads\n     where one sub triangle has zero area.",since:7},{signature:"bool CheckForDisjointMeshes",summary:"If true, then look for faces in the mesh that are totally isolated from other faces in the mesh.  \n     (i.e. an island of faces, or many islands, that have a boundary of naked edges)",since:7},{signature:"bool CheckForDuplicateFaces",summary:"If true, then look for faces that have vertexes (not necessarily vertex indexes) that are identical.",since:7},{signature:"bool CheckForExtremelyShortEdges",summary:"If true, then look for topological edges where the distance between the\n     endpoints is less than ExtremelyShortEdgeDistance.",since:7},{signature:"bool CheckForInvalidNgons",summary:"If true, then look for ngons that have invalid information.",since:7},{signature:"bool CheckForNakedEdges",summary:"If true, then look for topological edges in the mesh topology where the\n     face count is 1. Note, this check is also made if CheckForDuplicateFaces\n     is True but the output is not shown if CheckForNakedEdges is false.",since:7},{signature:"bool CheckForNonManifoldEdges",summary:"If true, then look for topological edges in the mesh topology where the\n     face count is greater than 2. Note, this check is also made if\n     CheckForDuplicateFaces is True but the output is not shown if \n     CheckForNonManifoldEdges is false.",since:7},{signature:"bool CheckForRandomFaceNormals",summary:"If true, then look for adjacent faces that have the same edge orientation.\n     This typically means that clockwise/counterclockwise orientation, and face normal\n     are not in sync.",since:7},{signature:"bool CheckForSelfIntersection",summary:"If true, then look for self intersections.",since:7},{signature:"bool CheckForUnusedVertices",summary:"If true, then look for vertices that are not referenced by any face in the mesh.",since:7},{signature:"int DegenerateFaceCount",summary:"Gets the total degenerate face count for all meshes.",since:7},{signature:"int DisjointMeshCount",summary:"Gets the total count of disjoint pieces for all meshes.",since:7},{signature:"int DuplicateFaceCount",summary:"Gets the total count of duplicate faces for all meshes.",since:7},{signature:"int ExtremelyShortEdgeCount",summary:"Gets the total number of extremely short edges for all meshes.",since:7},{signature:"int InvalidNgonCount",summary:"Gets the total number of invalid ngons for all meshes.",since:7},{signature:"int NakedEdgeCount",summary:"Gets the total number of naked edges for all meshes.",since:7},{signature:"int NonManifoldEdgeCount",summary:"Gets the total number of non-manifold edges for all meshes.",since:7},{signature:"int NonUnitVectorNormalCount",summary:"Get the total count of normals that are not unit vectors for all meshes.",since:7},{signature:"int RandomFaceNormalCount",summary:"Gets the total count of random face normals for all meshes.",since:7},{signature:"int SelfIntersectingPairsCount",summary:"Gets the total count of self intersections for all meshes.",since:7},{signature:"int UnusedVertexCount",summary:"Gets the total count of unused vertices for all meshes.",since:7},{signature:"int VertexFaceNormalsDifferCount",summary:"Gets the total count of vertex normals that differ greatly from face \n     normals for all meshes.",since:7},{signature:"int ZeroLengthNormalCount",summary:"Gets the total count of zero length normals for all meshes.",since:7}],methods:[{signature:"static MeshCheckParameters Defaults()",summary:"Gets the default mesh check parameters.",since:7,returns:"The default mesh check parameters."}]},{name:"Rhino.Geometry.MeshDisplacementInfo",dataType:1,summary:"Contains mesh displacement information.",constructors:[{signature:"MeshDisplacementInfo(RenderTexture texture,TextureMapping mapping)",summary:"Constructs a displacement information instance with default values.\n     Users of this class should not rely on default values to stay constant\n     across service releases.",since:6}],properties:[{signature:"double Black",summary:"Value considered lowest point in the displacement.",since:6},{signature:"double BlackMove",summary:"The amount of displacement for the black color in the texture.",since:6},{signature:"int ChannelNumber",summary:"Mapping channel number for the displacement mapping.",since:6},{signature:"int FaceLimit",summary:"Runs a mesh reduction as a post process o simplify the result of\n     displacement to meet the specified number of faces.",since:6},{signature:"int FairingAmount",summary:"Straightens rough feature edges.\n     The value specifies the number of passes.",since:6},{signature:"Transform InstanceTransform",summary:"Instance transformation of the mesh.",since:6},{signature:"TextureMapping Mapping",summary:"The texture mapping of the mesh.",since:6},{signature:"Transform MappingTransform",summary:"Texture mapping transform.",since:6},{signature:"int MemoryLimit",summary:"Specifies how much memory can be allocated for use by the\n     displacement mesh. Value in megabytes.",since:6},{signature:"double PostWeldAngle",summary:"Specifies the maximum angle between face normals of adjacent faces\n     that will get welded together.",since:6},{signature:"double RefineSensitivity",summary:"Specifies how sensitive the divider for contrasts is on the\n     displacement texture.Specify 1 to split all mesh edges on each refine step.Specify 0.99 to make even slight contrasts on the displacement\n     texture cause edges to be split.Specifying 0.01 only splits edges where heavy contrast\n     exists.",since:6},{signature:"int RefineStepCount",summary:"Specifies the number of refinement passes.",since:6},{signature:"double SweepPitch",summary:"Specifies how densely the object is initially subdivided.\n     The lower the value, the higher the resolution of the displaced mesh.",since:6},{signature:"RenderTexture Texture",summary:"The texture used as displacement.",since:6},{signature:"double White",summary:"Value considered highest point of the displacement texture.",since:6},{signature:"double WhiteMove",summary:"The amount of displacement for the white color in the texture.",since:6}]},{name:"Rhino.Geometry.MeshExtruder",dataType:1,summary:"Extrudes a mesh and provides preview",constructors:[{signature:"MeshExtruder(Mesh inputMesh,IEnumerable<ComponentIndex> componentIndices)",summary:"Construct object to extrude given mesh faces, edges and ngons.",since:6.3}],properties:[{signature:"bool EdgeBasedUVN",summary:"Edge based UVN defines UVN directions according to boundary edge directions",since:6.4},{signature:"MeshExtruderFaceDirectionMode FaceDirectionMode",summary:"Face direction mode determines how faces are oriented",since:6.3},{signature:"bool KeepOriginalFaces",summary:"Whether or not to keep original faces.",since:6.3},{signature:"Line[] PreviewLines",summary:"Gets Line objects to preview extruded mesh.",since:6.3},{signature:"MeshExtruderParameterMode SurfaceParameterMode",summary:"Mode for creating surface parameters for extruded areas",since:6.3},{signature:"MeshExtruderParameterMode TextureCoordinateMode",summary:"Mode for creating texture coordinates for extruded areas",since:6.3},{signature:"Transform Transform",summary:"Transform of extrusion",since:6.3},{signature:"bool UVN",summary:"Whether or not to perform extrude in UVN basis.",since:6.3}],methods:[{signature:"void Dispose()",summary:"Dispose of this object and any unmanaged memory associated with it.",since:6.3},{signature:"bool ExtrudedMesh(Mesh extrudedMeshOut)",summary:"Creates new extruded mesh. Returns True if any edges or faces were extruded.",since:6.3},{signature:"bool ExtrudedMesh(Mesh extrudedMeshOut,List<ComponentIndex> componentIndicesOut)",summary:"Creates new extruded mesh. Returns True if any edges or faces were extruded."},{signature:"List<int> GetWallFaces()",summary:"Return list of faces that were added to connect transformed edges/faces to non-transformed edges/faces.",since:6.16,returns:"List of wall faces"}]},{name:"Rhino.Geometry.MeshFace",dataType:2,summary:"Represents the values of the four indices of a mesh face quad.\n   If the third and fourth values are the same, this face represents a\n   triangle.",constructors:[{signature:"MeshFace(int a,int b,int c)",summary:"Constructs a new triangular Mesh face.",since:5},{signature:"MeshFace(int a,int b,int c,int d)",summary:"Constructs a new quadrangular Mesh face.",since:5}],properties:[{signature:"static MeshFace Unset",summary:"Gets an Unset MeshFace. Unset faces have Int32.MinValue for all corner indices.",since:5},{signature:"int A",summary:"Gets or sets the first corner index of the mesh face.",since:5},{signature:"int B",summary:"Gets or sets the second corner index of the mesh face.",since:5},{signature:"int C",summary:"Gets or sets the third corner index of the mesh face.",since:5},{signature:"int D",summary:"Gets or sets the fourth corner index of the mesh face. \n     If D equals C, the mesh face is considered to be a triangle \n     rather than a quad.",since:5},{signature:"bool IsQuad",summary:"Gets a value indicating whether or not this mesh face is a quad. \n     A mesh face is considered to be a triangle when C does not equal D, \n     thus it is possible for an Invalid mesh face to also be a quad.",since:5},{signature:"bool IsTriangle",summary:"Gets a value indicating whether or not this mesh face is a triangle. \n     A mesh face is considered to be a triangle when C equals D, thus it is \n     possible for an Invalid mesh face to also be a triangle.",since:5}],methods:[{signature:"int CompareTo(MeshFace other)",summary:"Compares this  with another \n     and returns a value of 1, 0, or -1, referring to dictionary order.\n     Index evaluation priority is first A, then B, then C, then D.",since:6,returns:"0: if this is identical to other-1: if this < other. Priority is for index of corner A first, then B, then C, then D.+1: otherwise."},{signature:"bool Equals(MeshFace other)",summary:"Returns a value indicating whether the other mesh face\n     has precisely the same value as the current one.",since:6,returns:"True if the other face is, also orderly, equal\n     to the present one; otherwise false."},{signature:"bool Equals(object obj)",summary:"Returns a value indicating whether the other object obj\n     has precisely the same value as the current one.",returns:"True if obj is a mesh face that, also orderly, equals\n     to the present one; otherwise false."},{signature:"MeshFace Flip()",summary:"Reverses the orientation of the face by swapping corners. \n     The first corner is always maintained.",since:5},{signature:"int GetHashCode()",summary:"Returns a runtime-stable hashcode for the current mesh face.\n     You are not allowed to rely on persistance of this hashcode in\n     serialization, but for each version of RhinoCommon, this hashcode\n     will be the same for each mesh face.",returns:"A non-unique integer that represents this mesh face."},{signature:"bool IsValid()",summary:"Gets a value indicating whether or not this mesh face \n     is considered to be valid. Note that even valid mesh faces \n     could potentially be invalid in the context of a specific Mesh, \n     if one or more of the corner indices exceeds the number of \n     vertices on the mesh. If you want to perform a complete \n     validity check, use IsValid(int) instead.",since:5},{signature:"bool IsValid(int vertexCount)",summary:"Gets a value indicating whether or not this mesh face \n     is considered to be valid. Unlike the simple IsValid function, \n     this function takes upper bound indices into account.",since:5,returns:"True if the face is considered valid, False if not."},{signature:"bool IsValid(Point3d[] points)",summary:"Gets a value indicating whether or not this mesh face \n     is considered to be valid. Unlike the simple IsValid function, \n     this function takes actual point locations into account.",since:6,returns:"True if the face is considered valid, False if not."},{signature:"bool IsValidEx(Point3d[] points)",summary:"Gets a value indicating whether or not this mesh face \n     is considered to be valid. Unlike the simple IsValid function, \n     this function takes actual point locations into account.",since:6.5,returns:"True if the face is considered valid, False if not."},{signature:"bool Repair(Point3d[] points)",summary:"Attempts to repair this mesh face by taking both face indexes and \n     actual vertex locations into account.",since:6,returns:"True if the face was repaired, False if not."},{signature:"bool RepairEx(Point3d[] points)",summary:"Attempts to repair this mesh face by taking both face indexes and \n     actual vertex locations into account.",since:6.5,returns:"True if the face was repaired, False if not."},{signature:"void Set(int a,int b,int c)",summary:"Sets all the corners for this face as a triangle.",since:5},{signature:"void Set(int a,int b,int c,int d)",summary:"Sets all the corners for this face as a quad.",since:5},{signature:"string ToString()",summary:"Returns a string representation for this .\n     This is to provide a meaningful visualization of this structure\n     and is subject to change in newer releases.",returns:"The string representation."}]},{name:"Rhino.Geometry.MeshingParameters",dataType:1,summary:"Represents settings used for creating a mesh representation of a brep or surface.",constructors:[{signature:"MeshingParameters()",summary:"Initializes a new instance with default values.\n     Initial values are same as .",since:5},{signature:"MeshingParameters(double density)",summary:"Initializes a new instance with simple values, \n     similar to that of Rhino's meshing slider interface.",since:6},{signature:"MeshingParameters(double density,double minimumEdgeLength)",summary:"Initializes a new instance with simple values, \n     similar to that of Rhino's meshing slider interface.",since:6}],properties:[{signature:"static MeshingParameters Coarse",summary:'Gets mesh creation parameters for coarse meshing. \n     This corresponds with the "Jagged and Faster" default in Rhino.',since:5},{signature:"static MeshingParameters Default",summary:"Gets mesh creation parameters to create the default render mesh.\n     Only use this if you plan on specifying your own custom meshing\n     parameters.",since:5},{signature:"static MeshingParameters DefaultAnalysisMesh",summary:"Gets mesh creation parameters to create the default analysis mesh.",since:6},{signature:"static MeshingParameters FastRenderMesh",summary:"Gets mesh creation parameters to create the a render mesh when \n     meshing speed is prefered over mesh quality.",since:6},{signature:"static MeshingParameters Minimal",summary:"Gets minimal meshing parameters.",since:5},{signature:"static MeshingParameters QualityRenderMesh",summary:"Gets mesh creation parameters to create the a render mesh when mesh \n     quality is prefered over meshing speed.",since:6},{signature:"static MeshingParameters Smooth",summary:'Gets mesh creation parameters for smooth meshing. \n     This corresponds with the "Smooth and Slower" default in Rhino.',since:5},{signature:"bool ClosedObjectPostProcess",summary:"Gets or sets a value indicating whether or not to post process non-closed meshes\n     that should be closed. If the Brep being meshed is closed, JaggedSeams = false, \n     and ClosedObjectPostProcess = true, and the resulting mesh is not closed, then a\n     post meshing process is applied to find and close gaps in the mesh. Typically the\n     resulting mesh is not closed because the input Brep has a geometric flaw, like\n     loops in trimming curve.",since:6},{signature:"bool ComputeCurvature",summary:"Gets or sets a value indicating whether or not surface curvature \n     data will be embedded in the mesh.",since:5},{signature:"double GridAmplification",summary:"Gets or sets the grid amplification factor. \n     Values lower than 1.0 will decrease the number of initial quads, \n     values higher than 1.0 will increase the number of initial quads.",since:5},{signature:"double GridAngle",summary:"Gets or sets the maximum allowed angle difference (in radians) \n     for a single sampling quad. The angle pertains to the surface normals.",since:5},{signature:"double GridAspectRatio",summary:"Gets or sets the maximum allowed aspect ratio of sampling quads.",since:5},{signature:"int GridMaxCount",summary:"Gets or sets the maximum number of grid quads in the initial sampling grid.",since:5},{signature:"int GridMinCount",summary:"Gets or sets the minimum number of grid quads in the initial sampling grid.",since:5},{signature:"bool JaggedSeams",summary:"Gets or sets whether or not the mesh is allowed to have jagged seams. \n     When this flag is set to true, meshes on either side of a Brep Edge will not match up.",since:5},{signature:"double MaximumEdgeLength",summary:"Gets or sets the maximum allowed mesh edge length.",since:5},{signature:"double MinimumEdgeLength",summary:"Gets or sets the minimum allowed mesh edge length.",since:5},{signature:"double MinimumTolerance",summary:"Gets or sets the minimum tolerance.",since:5},{signature:"double RefineAngle",summary:"Gets or sets the mesh parameter refine angle.",since:5},{signature:"bool RefineGrid",summary:"Gets or sets a value indicating whether or not the sampling grid can be refined \n     when certain tolerances are not met.",since:5},{signature:"double RelativeTolerance",summary:"Gets or sets the relative tolerance.",since:5},{signature:"bool SimplePlanes",summary:"Gets or sets a value indicating whether or not planar areas are allowed \n     to be meshed in a simplified manner.",since:5},{signature:"MeshingParameterTextureRange TextureRange",summary:"Gets or sets how and if textures will be packed.",since:6},{signature:"double Tolerance",summary:"Gets or sets the maximum allowed edge deviation. \n     This tolerance is measured between the center of the mesh edge and the surface.",since:5}],methods:[{signature:"static MeshingParameters DocumentCurrentSetting(RhinoDoc doc)",summary:'Gets the MeshingParameters that are currently set for a document.\n     These are the same settings that are shown in the DocumentProperties\n     "mesh settings" user interface.',since:5,returns:"Meshing parameters of the document."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5}]},{name:"Rhino.Geometry.MeshingParameterStyle",dataType:3,summary:"Type of Mesh Parameters used by the RhinoDoc for meshing objects"},{name:"Rhino.Geometry.MeshingParameterTextureRange",dataType:3,summary:"Defines how to pack render/meshes textures."},{name:"Rhino.Geometry.MeshNgon",dataType:1,summary:"Represents a mesh ngon.\n   When retrieved from the Ngon property of a mesh,\n   this contains faces that have edge valence strictly higher than 4.When retrieving Ngons from ,\n   this might contain also triangles and quads.",properties:[{signature:"static MeshNgon Empty",summary:"Gets an empty MeshNgon.",since:6},{signature:"int BoundaryVertexCount",summary:"Get the number of vertices in this ngon.\n      about length information.",since:6},{signature:"int FaceCount",summary:"Get the number of faces in this ngon.",since:6}],methods:[{signature:"static MeshNgon Create(IList<int> meshVertexIndexList,IList<int> meshFaceIndexList)",summary:"Constructs an ngon from lists of mesh vertex and face indexes.",since:6},{signature:"uint[] BoundaryVertexIndexList()",summary:"Get the outer boundary mesh vertex list of the ngon.\n     Vertices are sorted counterclockwise with respect to the direction of the face,\n     although the degree by which vertex normals will respect this might vary.",since:6,returns:"A list of mesh vertex indexes."},{signature:"int CompareTo(MeshNgon otherNgon)",summary:"Compares this  with otherNgon\n     and returns a value of 1, 0, or -1.\n     Priority is for vertex count, then face count,\n     then vertex index list values, then face index list values.",since:6,returns:"0: if this is identical to otherNgon-1: if this < otherNgon. +1: if this > otherNgon."},{signature:"bool Equals(MeshNgon otherNgon)",summary:"Determines if this ngon and otherNgon are identical.",since:6,returns:"True if otherNgon is identical to this ngon; otherwise false."},{signature:"bool Equals(object otherObj)",summary:"Determines if otherObj is a MeshNgon and is identical to this ngon.",returns:"True if otherObj is a MeshNgon and is identical to this ngon; otherwise false."},{signature:"uint[] FaceIndexList()",summary:"Get the ngon's mesh face index list.",since:6,returns:"A list of mesh face indexes."},{signature:"int GetHashCode()",summary:"Returns a runtime-stable hashcode for the current mesh ngon.\n     You are not allowed to rely on persistance of this hashcode in\n     serialization, but for each instance of the application, this hashcode\n     will be the same for ngons with identical vertex and face lists.",returns:"A non-unique integer that represents this mesh ngon."},{signature:"void Set(IList<int> meshVertexIndexList,IList<int> meshFaceIndexList)",summary:"Set the ngon vertex and face index lists.",since:6},{signature:"string ToString()",summary:"Returns a string representation for this .\n     This is to provide a meaningful visualization of this structure\n     and is subject to change in newer releases.",returns:"The string representation."}]},{name:"Rhino.Geometry.MeshPart",dataType:1,summary:"Represents a portion of a mesh for partitioning",properties:[{signature:"int EndFaceIndex",summary:"End of subinterval of parent mesh face array",since:5.6},{signature:"int EndVertexIndex",summary:"End of subinterval of parent mesh vertex array",since:5.6},{signature:"int StartFaceIndex",summary:"Start of subinterval of parent mesh face array",since:5.6},{signature:"int StartVertexIndex",summary:"Start of subinterval of parent mesh vertex array",since:5.6},{signature:"int TriangleCount",since:5.6},{signature:"int VertexCount",summary:"EndVertexIndex - StartVertexIndex",since:5.6}]},{name:"Rhino.Geometry.MeshPoint",dataType:1,summary:"Represents a point that is found on a mesh.",properties:[{signature:"ComponentIndex ComponentIndex",summary:"Gets the component index of the intersecting element in the mesh.",since:5},{signature:"int EdgeIndex",summary:"When set, EdgeIndex is an index of an edge in the mesh's edge list.",since:5},{signature:"double EdgeParameter",summary:"Edge parameter when found.",since:5},{signature:"int FaceIndex",summary:"FaceIndex is an index of a face in mesh.Faces.\n     When ComponentIndex refers to a vertex, any face that uses the vertex\n     may appear as FaceIndex.  When ComponenctIndex refers to an Edge or\n     EdgeIndex is set, then any face that uses that edge may appear as FaceIndex.",since:5},{signature:"Mesh Mesh",summary:"The mesh that is ralated to this point.",since:5},{signature:"Point3d Point",summary:"Gets the location (position) of this point.",since:5},{signature:"double[] T",summary:"Barycentric quad coordinates for the point on the mesh\n     face mesh.Faces[FaceIndex].  If the face is a triangle\n     disregard T[3] (it should be set to 0.0). If the face is\n     a quad and is split between vertexes 0 and 2, then T[3]\n     will be 0.0 when point is on the triangle defined by vi[0],\n     vi[1], vi[2], and T[1] will be 0.0 when point is on the\n     triangle defined by vi[0], vi[2], vi[3]. If the face is a\n     quad and is split between vertexes 1 and 3, then T[2] will\n     be 0.0 when point is on the triangle defined by vi[0],\n     vi[1], vi[3], and m_t[0] will be 0.0 when point is on the\n     triangle defined by vi[1], vi[2], vi[3].",since:5},{signature:"char Triangle",summary:"Face triangle where the intersection takes place:\n     0 is unsetA is 0,1,2B is 0,2,3C is 0,1,3D is 1,2,3",since:5}],methods:[{signature:"bool GetTriangle(int a,int b,int c)",summary:"Gets the mesh face indices of the triangle where the\n     intersection is on the face takes into consideration\n     the way the quad was split during the intersection.",since:5}]},{name:"Rhino.Geometry.MeshRefinements.CreaseEdges",dataType:3,summary:"Defines the way naked edges are handled."},{name:"Rhino.Geometry.MeshRefinements.LoopFormula",dataType:3,summary:"Enumerates the alternative Loop implementations."},{name:"Rhino.Geometry.MeshRefinements.RefinementSettings",dataType:1,summary:"Defines the way a mesh refinement modifier works.",constructors:[{signature:"RefinementSettings()",summary:"Creates a default operation settings object.",since:6}],properties:[{signature:"CancellationToken ContinueRequest",summary:"A token to request computation termination.",since:6},{signature:"bool HasPull",summary:"Gets a value indicating whether this subdivision should create a result on a specific surface.",since:6},{signature:"int Level",summary:"The level of subdivision to achieve.",since:6},{signature:"CreaseEdges NakedEdgeMode",summary:"Set this property to define how naked edges should be treated.",since:6}]},{name:"Rhino.Geometry.MeshThicknessMeasurement",dataType:2,summary:"Thickness measurement used in the mesh thickness solver.",constructors:[{signature:"MeshThicknessMeasurement(int meshIndex,int vertexIndex,double thickness,Point3d point,Point3d oppositePoint)",summary:"Create a new thickness measurement.",since:6}],properties:[{signature:"int MeshIndex",summary:"Gets the index of the mesh associated with this thickness measurement.",since:6},{signature:"Point3d OppositePoint",summary:"Gets the point opposite to the measurement point.",since:6},{signature:"Point3d Point",summary:"Gets the location of the thickness measurement.",since:6},{signature:"double Thickness",summary:"Gets the local thickness of the mesh.",since:6},{signature:"int VertexIndex",summary:"Gets the index of the vertex associated with this thickness measurement.",since:6}]},{name:"Rhino.Geometry.MeshType",dataType:3,summary:"Defines enumerated values for various mesh types."},{name:"Rhino.Geometry.MeshUnsafeLock",dataType:1,summary:"Permits access to the underlying mesh raw data structures in an unsafe way.",methods:[{signature:"MeshFace* FacesArray(int length)",summary:"Retrieves a pointer to the raw faces array, which uses 4 integers for each face.\n     .",since:6.2,returns:"The beginning of the vertex array. Item 0 is the first vertex,\n     and item length-1 is the last valid one."},{signature:"Vector3f* NormalVector3fArray(int length)",summary:"Retrieves a pointer to the raw mesh vertex normal array, which uses vectors\n     defined with single precision floating point numbers, or throws an exception if none is available.",since:6.2,returns:"The beginning of the vertex array. Item 0 is the first vertex,\n     and item length-1 is the last valid one."},{signature:"void Release()",summary:"Releases the lock and updates the underlying unmanaged data structures.",since:6},{signature:"Point3d* VertexPoint3dArray(int length)",summary:"Retrieves a pointer to the raw mesh vertex array, which uses coordinates\n     defined with double precision floating point numbers, or throws an exception if none is available.",since:6.2,returns:"The beginning of the vertex array. Item 0 is the first vertex,\n     and item length-1 is the last valid one. If no array is available, None is returned."},{signature:"Point3f* VertexPoint3fArray(int length)",summary:"Retrieves a pointer to the raw mesh vertex array, which uses coordinates\n     defined with single precision floating point numbers, or None if none is available.",since:6,returns:"The beginning of the vertex array. Item 0 is the first vertex,\n     and item length-1 is the last valid one. If no array is available, None is returned."}]},{name:"Rhino.Geometry.MorphControl",dataType:1,summary:"Represents a geometry that is able to control the morphing behaviour of some other geometry.",constructors:[{signature:"MorphControl(NurbsCurve originCurve,NurbsCurve targetCurve)",summary:"Constructs a MorphControl that allows for morphing between two curves.",since:5}],properties:[{signature:"NurbsCurve Curve",summary:"Returns the morph control's curve.  While this should never be null, the \n     calling function should check.",since:6},{signature:"bool PreserveStructure",summary:"True if the morph should be done in a way that preserves the structure\n     of the geometry.  In particular, for NURBS objects, True  eans that\n     only the control points are moved.  The PreserveStructure value does not\n     affect the way meshes and points are morphed. The default is false.",since:5},{signature:"bool QuickPreview",summary:"True if the morph should be done as quickly as possible because the\n     result is being used for some type of dynamic preview.  If QuickPreview\n     is true, the tolerance may be ignored. The QuickPreview value does not\n     affect the way meshes and points are morphed. The default is false.",since:5},{signature:"double SpaceMorphTolerance",summary:"The 3d fitting tolerance used when morphing surfaces and breps.\n     The default is 0.0 and any value <= 0.0 is ignored by morphing functions.\n     The value returned by Tolerance does not affect the way meshes and points are morphed.",since:5},{signature:"NurbsSurface Surface",summary:"Returns the morph control's surface.  While this should never be null, the \n     calling function should check.",since:6}],methods:[{signature:"bool Morph(GeometryBase geometry)",summary:"Applies the space morph to geometry.",since:5,returns:"True on success, False on failure."}]},{name:"Rhino.Geometry.Morphs.BendSpaceMorph",dataType:1,summary:"Deforms objects by bending along a spine arc.",constructors:[{signature:"BendSpaceMorph(Point3d start,Point3d end,Point3d point,bool straight,bool symmetric)",summary:"Constructs a bend space morph.",since:5.9},{signature:"BendSpaceMorph(Point3d start,Point3d end,Point3d point,double angle,bool straight,bool symmetric)",summary:"Constructs a bend space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.FlowSpaceMorph",dataType:1,summary:"Re-aligns objects from a base curve to a target curve.",constructors:[{signature:"FlowSpaceMorph(Curve curve0,Curve curve1,bool preventStretching)",summary:"Constructs a flow space morph.",since:5.9},{signature:"FlowSpaceMorph(Curve curve0,Curve curve1,bool reverseCurve0,bool reverseCurve1,bool preventStretching)",summary:"Constructs a flow space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.MaelstromSpaceMorph",dataType:1,summary:"Deforms objects in a spiral as if they were caught in a whirlpool.",constructors:[{signature:"MaelstromSpaceMorph(Plane plane,double radius0,double radius1,double angle)",summary:"Constructs a maelstrom space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.SplopSpaceMorph",dataType:1,summary:"Rotates, scales, and wraps objects on a surface.",constructors:[{signature:"SplopSpaceMorph(Plane plane,Surface surface,Point2d surfaceParam)",summary:"Constructs a flow space morph.",since:5.9},{signature:"SplopSpaceMorph(Plane plane,Surface surface,Point2d surfaceParam,double scale)",summary:"Constructs a flow space morph.",since:5.9},{signature:"SplopSpaceMorph(Plane plane,Surface surface,Point2d surfaceParam,double scale,double angle)",summary:"Constructs a flow space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.SporphSpaceMorph",dataType:1,summary:"Deforms an object from a source surface to a target surface.",constructors:[{signature:"SporphSpaceMorph(Surface surface0,Surface surface1)",summary:"Constructs a sporph space morph.",since:5.9},{signature:"SporphSpaceMorph(Surface surface0,Surface surface1,Point2d surface0Param,Point2d surface1Param)",summary:"Constructs a sporph space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.StretchSpaceMorph",dataType:1,summary:"Deforms objects toward or away from a specified axis.",constructors:[{signature:"StretchSpaceMorph(Point3d start,Point3d end,double length)",summary:"Constructs a stretch space morph.",since:5.9},{signature:"StretchSpaceMorph(Point3d start,Point3d end,Point3d point)",summary:"Constructs a stretch space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.TaperSpaceMorph",dataType:1,summary:"Deforms objects toward or away from a specified axis.",constructors:[{signature:"TaperSpaceMorph(Point3d start,Point3d end,double startRadius,double endRadius,bool bFlat,bool infiniteTaper)",summary:"Constructs a taper space morph.",since:5.9}],properties:[{signature:"bool IsValid",summary:"Returns True if the space morph definition is valid, False otherwise.",since:5.9}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.9},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point.",since:5.9,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Morphs.TwistSpaceMorph",dataType:1,summary:"Deforms objects by rotating them around an axis.",constructors:[{signature:"TwistSpaceMorph()",summary:"Constructs a twist space morph.",since:5.1}],properties:[{signature:"bool InfiniteTwist",summary:"If true, the deformation is constant throughout the object, even if the axis is shorter than the object. \n     If false, the deformation takes place only the length of the axis.",since:5.1},{signature:"double TwistAngleRadians",summary:"Twist angle in radians.",since:5.1},{signature:"Line TwistAxis",summary:"Axis to rotate about.",since:5.1}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.1},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point. This method is abstract.",since:5.1,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.NurbsCurve",dataType:1,summary:"Represents a Non Uniform Rational B-Splines (NURBS) curve.",constructors:[{signature:"NurbsCurve(int dimension,bool rational,int order,int pointCount)",summary:"Constructs a new NURBS curve with knot and CV memory allocated.",since:5},{signature:"NurbsCurve(int degree,int pointCount)",summary:"Constructs a new NURBS curve with a specific degree and control point count.",since:5},{signature:"NurbsCurve(NurbsCurve other)",summary:"Initializes a NURBS curve by copying its values from another NURBS curve.",since:5}],properties:[{signature:"bool HasBezierSpans",summary:"Returns True if the NURBS curve has bezier spans (all distinct knots have multiplitity = degree)",since:5},{signature:"bool IsRational",summary:"Gets a value indicating whether or not the curve is rational. \n     Rational curves have control-points with custom weights.",since:5},{signature:"NurbsCurveKnotList Knots",summary:'Gets access to the knots (or "knot vector") of this nurbs curve.',since:5},{signature:"int Order",summary:"Gets the order of the curve. Order = Degree + 1.",since:5},{signature:"NurbsCurvePointList Points",summary:"Gets access to the control points of this nurbs curve.",since:5}],methods:[{signature:"static NurbsCurve Create(bool periodic,int degree,IEnumerable<Point3d> points)",summary:"Constructs a 3D NURBS curve from a list of control points.",since:5,returns:"new NURBS curve on success\n     None on error."},{signature:"static NurbsCurve CreateFromArc(Arc arc)",summary:"Gets a rational degree 2 NURBS curve representation\n     of the arc. Note that the parameterization of NURBS curve\n     does not match arc's transcendental paramaterization.",since:5,returns:"Curve on success, None on failure."},{signature:"static NurbsCurve CreateFromArc(Arc arc,int degree,int cvCount)",summary:"Create a uniform non-ratonal cubic NURBS approximation of an arc.",since:6,returns:"NURBS curve approximation of an arc on success"},{signature:"static NurbsCurve CreateFromCircle(Circle circle)",summary:"Gets a rational degree 2 NURBS curve representation\n     of the circle. Note that the parameterization of NURBS curve\n     does not match circle's transcendental paramaterization.  \n     Use GetRadianFromNurbFormParameter() and\n     GetParameterFromRadian() to convert between the NURBS curve \n     parameter and the transcendental parameter.",since:5,returns:"Curve on success, None on failure."},{signature:"static NurbsCurve CreateFromCircle(Circle circle,int degree,int cvCount)",summary:"Create a uniform non-ratonal cubic NURBS approximation of a circle.",since:6,returns:"NURBS curve approximation of a circle on success"},{signature:"static NurbsCurve CreateFromEllipse(Ellipse ellipse)",summary:"Gets a rational degree 2 NURBS curve representation of the ellipse.\n     Note that the parameterization of the NURBS curve does not match\n     with the transcendental paramaterization of the ellipsis.",since:5,returns:"A nurbs curve representation of this ellipse or None if no such representation could be made."},{signature:"static NurbsCurve CreateFromLine(Line line)",summary:"Gets a non-rational, degree 1 Nurbs curve representation of the line.",since:5,returns:"Curve on success, None on failure."},{signature:"static NurbsCurve CreateHSpline(IEnumerable<Point3d> points)",summary:"Construct an H-spline from a sequence of interpolation points",since:7},{signature:"static NurbsCurve CreateHSpline(IEnumerable<Point3d> points,Vector3d startTangent,Vector3d endTangent)",summary:"Construct an H-spline from a sequence of interpolation points and\n     optional start and end derivative information",since:7},{signature:"static NurbsCurve CreateParabolaFromFocus(Point3d focus,Point3d startPoint,Point3d endPoint)",summary:"Creates a parabola from focus and end points.",since:6,returns:"A 2 degree NURBS curve if successful, False otherwise."},{signature:"static NurbsCurve CreateParabolaFromVertex(Point3d vertex,Point3d startPoint,Point3d endPoint)",summary:"Createsa a parabola from vertex and end points.",since:6,returns:"A 2 degree NURBS curve if successful, False otherwise."},{signature:"static NurbsCurve CreateSpiral(Curve railCurve,double t0,double t1,Point3d radiusPoint,double pitch,double turnCount,double radius0,double radius1,int pointsPerTurn)",summary:"Create a C2 non-rational uniform cubic NURBS approximation of a swept helix or spiral.",since:5.2,returns:"NurbsCurve on success, None on failure."},{signature:"static NurbsCurve CreateSpiral(Point3d axisStart,Vector3d axisDir,Point3d radiusPoint,double pitch,double turnCount,double radius0,double radius1)",summary:"Creates a C1 cubic NURBS approximation of a helix or spiral. For a helix,\n     you may have radius0 == radius1. For a spiral radius0 == radius0 produces\n     a circle. Zero and negative radii are permissible.",since:5.2,returns:"NurbsCurve on success, None on failure."},{signature:"static bool IsDuplicate(NurbsCurve curveA,NurbsCurve curveB,bool ignoreParameterization,double tolerance)",summary:"Determines if two curves are similar.",since:5,returns:"True if curves are similar within tolerance."},{signature:"static NurbsCurve[] MakeCompatible(IEnumerable<Curve> curves,Point3d startPt,Point3d endPt,int simplifyMethod,int numPoints,double refitTolerance,double angleTolerance)",summary:"For expert use only. From the input curves, make an array of compatible NURBS curves.",since:6,returns:"The output NURBS surfaces if successful."},{signature:"bool EpsilonEquals(NurbsCurve other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"double GrevilleParameter(int index)",summary:"Gets the greville (edit point) parameter that belongs \n     to the control point at the specified index.",since:5},{signature:"double[] GrevilleParameters()",summary:"Gets all Greville parameters for this curve.",since:5},{signature:"Point3d GrevillePoint(int index)",summary:"Gets the Greville parameter that belongs \n     to the control point at the specified index.",since:5},{signature:"Point3dList GrevillePoints()",summary:"Gets all Greville points for this curve.",since:5},{signature:"Point3dList GrevillePoints(bool all)",summary:"Gets Greville points for this curve.",since:6.18,returns:"A list of points if successful, None otherwise."},{signature:"bool IncreaseDegree(int desiredDegree)",summary:"Increase the degree of this curve.",since:5,returns:"True on success, False on failure."},{signature:"bool MakePiecewiseBezier(bool setEndWeightsToOne)",summary:"Clamps ends and adds knots so the NURBS curve has bezier spans \n     (all distinct knots have multiplitity = degree).",since:5,returns:"True on success, False on failure."},{signature:"bool Reparameterize(double c)",summary:"Use a linear fractional transformation to reparameterize the NURBS curve.\n     This does not change the curve's domain.",since:5,returns:"True if successful."},{signature:"bool SetEndCondition(bool bSetEnd,NurbsCurveEndConditionType continuity,Point3d point,Vector3d tangent)",summary:"Set end condition of a nurbs curve to point, tangent and curvature.",since:6,returns:"True on success, False on failure."},{signature:"bool SetEndCondition(bool bSetEnd,NurbsCurveEndConditionType continuity,Point3d point,Vector3d tangent,Vector3d curvature)",summary:"Set end condition of a nurbs curve to point, tangent and curvature.",since:6,returns:"True on success, False on failure."},{signature:"bool SetGrevillePoints(IEnumerable<Point3d> points)",summary:"Sets all Greville edit points for this curve.",since:6.4,returns:"True if successful, False otherwise."},{signature:"bool UVNDirectionsAt(double t,Vector3d uDir,Vector3d vDir,Vector3d nDir)",summary:"Calculates the u, V, and N directions of a NURBS curve at a parameter similar to the method used by Rhino's MoveUVN command.",since:7,returns:"True if successful, False otherwise."}]},{name:"Rhino.Geometry.NurbsCurve.NurbsCurveEndConditionType",dataType:3,summary:"What end conditions to set"},{name:"Rhino.Geometry.NurbsSurface",dataType:1,summary:"Represents a Non Uniform Rational B-Splines (NURBS) surface.",constructors:[{signature:"NurbsSurface(NurbsSurface other)",summary:"Initializes a new NURBS surface by copying the values from another surface.",since:5}],properties:[{signature:"bool IsRational",summary:"Gets a value indicating whether or not the nurbs surface is rational.",since:5},{signature:"NurbsSurfaceKnotList KnotsU",summary:"The U direction knot vector.",since:5},{signature:"NurbsSurfaceKnotList KnotsV",summary:"The V direction knot vector.",since:5},{signature:"int OrderU",summary:"Gets the order in the U direction.",since:5},{signature:"int OrderV",summary:"Gets the order in the V direction.",since:5},{signature:"NurbsSurfacePointList Points",summary:"Gets a collection of surface control points that form this surface.",since:5}],methods:[{signature:"static NurbsSurface Create(int dimension,bool isRational,int order0,int order1,int controlPointCount0,int controlPointCount1)",summary:"Constructs a new NURBS surface with internal uninitialized arrays.",since:5,returns:"A new NURBS surface, or None on error."},{signature:"static NurbsCurve CreateCurveOnSurface(Surface surface,IEnumerable<Point2d> points,double tolerance,bool periodic)",summary:"Fit a sequence of 2d points on a surface to make a curve on the surface.",since:6.3,returns:"A curve interpolating the points if successful, None on error."},{signature:"static Point2d[] CreateCurveOnSurfacePoints(Surface surface,IEnumerable<Point2d> fixedPoints,double tolerance,bool periodic,int initCount,int levels)",summary:"Computes a discrete spline curve on the surface. In other words, computes a sequence \n     of points on the surface, each with a corresponding parameter value.",since:6.3,returns:"A sequence of surface points, given by surface parameters, if successful.\n     The number of output points is approximatelely: 2 ^ (level-1) * initCount * fixedPoints.Count."},{signature:"static NurbsSurface CreateFromCone(Cone cone)",summary:"Constructs a new NURBS surfaces from cone data.",since:5,returns:"A new NURBS surface, or None on error."},{signature:"static NurbsSurface CreateFromCorners(Point3d corner1,Point3d corner2,Point3d corner3)",summary:"Makes a surface from 3 corner points.",since:5,returns:"The resulting surface or None on error."},{signature:"static NurbsSurface CreateFromCorners(Point3d corner1,Point3d corner2,Point3d corner3,Point3d corner4)",summary:"Makes a surface from 4 corner points.\n     This is the same as calling  with tolerance 0.",since:5,returns:"the resulting surface or None on error."},{signature:"static NurbsSurface CreateFromCorners(Point3d corner1,Point3d corner2,Point3d corner3,Point3d corner4,double tolerance)",summary:"Makes a surface from 4 corner points.",since:5,returns:"The resulting surface or None on error."},{signature:"static NurbsSurface CreateFromCylinder(Cylinder cylinder)",summary:"Constructs a new NURBS surfaces from cylinder data.",since:5,returns:"A new NURBS surface, or None on error."},{signature:"static NurbsSurface CreateFromPoints(IEnumerable<Point3d> points,int uCount,int vCount,int uDegree,int vDegree)",summary:"Constructs a NURBS surface from a 2D grid of control points.",since:5,returns:"A NurbsSurface on success or None on failure."},{signature:"static NurbsSurface CreateFromSphere(Sphere sphere)",summary:"Constructs a new NURBS surfaces from sphere data.",since:5,returns:"A new NURBS surface, or None on error."},{signature:"static NurbsSurface CreateFromTorus(Torus torus)",summary:"Constructs a new NURBS surfaces from torus data.",since:5,returns:"A new NURBS surface, or None on error."},{signature:"static NurbsSurface CreateNetworkSurface(IEnumerable<Curve> curves,int continuity,double edgeTolerance,double interiorTolerance,double angleTolerance,int error)",summary:"Builds a surface from an autosorted network of curves/edges.",since:5,returns:"A NurbsSurface or None on failure."},{signature:"static NurbsSurface CreateNetworkSurface(IEnumerable<Curve> uCurves,int uContinuityStart,int uContinuityEnd,IEnumerable<Curve> vCurves,int vContinuityStart,int vContinuityEnd,double edgeTolerance,double interiorTolerance,double angleTolerance,int error)",summary:"Builds a surface from an ordered network of curves/edges.",since:5,returns:"A NurbsSurface or None on failure."},{signature:"static NurbsSurface CreateRailRevolvedSurface(Curve profile,Curve rail,Line axis,bool scaleHeight)",summary:"Constructs a railed Surface-of-Revolution.",since:5,returns:"A NurbsSurface or None on failure."},{signature:"static NurbsSurface CreateRuledSurface(Curve curveA,Curve curveB)",summary:"Constructs a ruled surface between two curves. Curves must share the same knot-vector.",since:5,returns:"A ruled surface on success or None on failure."},{signature:"static NurbsSurface CreateThroughPoints(IEnumerable<Point3d> points,int uCount,int vCount,int uDegree,int vDegree,bool uClosed,bool vClosed)",summary:"Constructs a NURBS surface from a 2D grid of points.",since:5,returns:"A NurbsSurface on success or None on failure."},{signature:"static bool MakeCompatible(Surface surface0,Surface surface1,NurbsSurface nurb0,NurbsSurface nurb1)",summary:"For expert use only. Makes a pair of compatible NURBS surfaces based on two input surfaces.",since:6,returns:"True if successsful, False on failure."},{signature:"void CopyFrom(NurbsSurface other)",summary:"Copies this NURBS surface from another NURBS surface.",since:5},{signature:"bool EpsilonEquals(NurbsSurface other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool IncreaseDegreeU(int desiredDegree)",summary:"Increase the degree of this surface in U direction.",since:5.1,returns:"True on success, False on failure."},{signature:"bool IncreaseDegreeV(int desiredDegree)",summary:"Increase the degree of this surface in V direction.",since:5.1,returns:"True on success, False on failure."},{signature:"bool MakeNonRational()",summary:"Makes this surface non-rational.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool MakeRational()",summary:"Makes this surface rational.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool UVNDirectionsAt(double u,double v,Vector3d uDir,Vector3d vDir,Vector3d nDir)",summary:"Calculates the U, V, and N directions of a NURBS surface at a u,v parameter similar to the method used by Rhino's MoveUVN command.",since:7,returns:"True if successful, False otherwise."}]},{name:"Rhino.Geometry.OrdinateDimension",dataType:1,summary:"Represents an ordinate dimension",constructors:[{signature:"OrdinateDimension()",since:6}],properties:[{signature:"Point2d DefPoint",since:6},{signature:"double KinkOffset1",since:6},{signature:"double KinkOffset2",since:6},{signature:"Point2d KinkPoint1",since:6},{signature:"Point2d KinkPoint2",since:6},{signature:"Point2d LeaderPoint",since:6}],methods:[{signature:"static OrdinateDimension Create(DimensionStyle dimStyle,Plane plane,MeasuredDirection direction,Point3d basepoint,Point3d defpoint,Point3d leaderpoint,double kinkoffset1,double kinkoffset2)",summary:"Initialize Dimension parameters",since:6},{signature:"bool AdjustFromPoints(Plane plane,MeasuredDirection direction,Point3d basepoint,Point3d defpoint,Point3d leaderpoint,double kinkoffset1,double kinkoffset2)",summary:"Update Dimension geometry from point locations",since:6},{signature:"bool Get3dPoints(Point3d basepoint,Point3d defpoint,Point3d leaderpoint,Point3d kinkpoint1,Point3d kinkpoint2)",summary:"Get locations of dimension's 3d points",since:6},{signature:"bool GetDisplayLines(DimensionStyle style,double scale,IEnumerable<Line> lines)"},{signature:"string GetDistanceDisplayText(UnitSystem unitsystem,DimensionStyle style)",since:6},{signature:"bool GetTextRectangle(Point3d[] corners)",since:6}]},{name:"Rhino.Geometry.Particle",dataType:1,summary:"Represents a simple particle.\n   This base class only defines position and display properties (size, color, bitmap id).\n   You will most likely create a class that derives from this particle class to perform some\n   sort of physical simulation (movement over time or frames).",constructors:[{signature:"Particle()",summary:"Initializes a new instance of the  class.",since:5}],properties:[{signature:"Color Color",since:5},{signature:"int DisplayBitmapIndex",since:5},{signature:"int Index",summary:"Index in ParentSystem for this Particle. Can change when the particle\n     system is modified.",since:5},{signature:"Point3d Location",summary:"3d Location of the Particle.",since:5},{signature:"ParticleSystem ParentSystem",summary:"Gets the parent particle system of this particle.",since:5},{signature:"float Size",since:5}],methods:[{signature:"void Update()",summary:"Base class implementation does nothing.",since:5}]},{name:"Rhino.Geometry.ParticleSystem",dataType:1,summary:"",properties:[{signature:"BoundingBox BoundingBox",since:5},{signature:"bool DisplaySizesInWorldUnits",since:5},{signature:"bool DrawRequiresDepthSorting",since:5}],methods:[{signature:"bool Add(Particle particle)",summary:"Adds a particle to this ParticleSystem. A Particle can only be in one system\n     at a time.  If the Particle already exists in a different system, this function\n     will return false. You should remove the particle from the other system first\n     before adding it.",since:5,returns:"True if this particle was added to the system or if is already in the system.\n     False if the particle already exists in a different system."},{signature:"void Clear()",summary:"Remove all Particles from this system.",since:5},{signature:"IEnumerator<Particle> GetEnumerator()",since:5},{signature:"void Remove(Particle particle)",summary:"Removes a single particle from this system.",since:5},{signature:"void Update()",summary:"Calls Update on every particle in the system.",since:5}]},{name:"Rhino.Geometry.PipeCapMode",dataType:3,summary:"Defines styles used for creating Brep pipes."},{name:"Rhino.Geometry.Plane",dataType:2,summary:"Represents the value of a center point and two axes in a plane in three dimensions.",constructors:[{signature:"Plane(double a,double b,double c,double d)",summary:"Constructs a plane from an equation\n     Ax+By+Cz+D=0.",since:5},{signature:"Plane(Plane other)",summary:"Copy constructor.\n     This is nothing special and performs the same as assigning to another variable.",since:5},{signature:"Plane(Point3d origin,Point3d xPoint,Point3d yPoint)",summary:"Initializes a plane from three non-colinear points.",since:5},{signature:"Plane(Point3d origin,Vector3d normal)",summary:"Constructs a plane from a point and a normal vector.",since:5},{signature:"Plane(Point3d origin,Vector3d xDirection,Vector3d yDirection)",summary:"Constructs a plane from a point and two vectors in the plane.",since:5}],properties:[{signature:"static Plane Unset",summary:"Gets a plane that contains Unset origin and axis vectors.",since:5},{signature:"static Plane WorldXY",summary:"plane coincident with the World XY plane.",since:5},{signature:"static Plane WorldYZ",summary:"plane coincident with the World YZ plane.",since:5},{signature:"static Plane WorldZX",summary:"plane coincident with the World ZX plane.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether or not this is a valid plane. \n     A plane is considered to be valid when all fields contain reasonable \n     information and the equation jibes with point and zaxis.",since:5},{signature:"Vector3d Normal",summary:"Gets the normal of this plane. This is essentially the ZAxis of the plane.",since:5},{signature:"Point3d Origin",summary:"Gets or sets the origin point of this plane.",since:5},{signature:"double OriginX",summary:"Gets or sets the X coordinate of the origin of this plane.",since:5},{signature:"double OriginY",summary:"Gets or sets the Y coordinate of the origin of this plane.",since:5},{signature:"double OriginZ",summary:"Gets or sets the Z coordinate of the origin of this plane.",since:5},{signature:"Vector3d XAxis",summary:"Gets or sets the X axis vector of this plane.",since:5},{signature:"Vector3d YAxis",summary:"Gets or sets the Y axis vector of this plane.",since:5},{signature:"Vector3d ZAxis",summary:"Gets or sets the Z axis vector of this plane.",since:5}],methods:[{signature:"static PlaneFitResult FitPlaneToPoints(IEnumerable<Point3d> points,Plane plane)",summary:"Fit a plane through a collection of points.",since:5,returns:"A value indicating the result of the operation."},{signature:"static PlaneFitResult FitPlaneToPoints(IEnumerable<Point3d> points,Plane plane,double maximumDeviation)",summary:"Fit a plane through a collection of points.",since:5,returns:"A value indicating the result of the operation."},{signature:"Plane Clone()",summary:"Returns a deep of this instance.",since:6,returns:"A plane with the same values as this item."},{signature:"bool ClosestParameter(Point3d testPoint,double s,double t)",summary:"Gets the parameters of the point on the plane closest to a test point.",since:5,returns:"True if a parameter could be found, \n     False if the point could not be projected successfully."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Gets the point on the plane closest to a test point.",since:5,returns:"The point on the plane that is closest to testPoint, \n     or Point3d.Unset on failure."},{signature:"bool DistanceTo(BoundingBox bbox,double min,double max)",summary:"Returns the signed minimum and maximum distances from bbox to this plane.",since:6,returns:"False if plane has zero length normal"},{signature:"double DistanceTo(Point3d testPoint)",summary:"Returns the signed distance from testPoint to its projection onto this plane. \n     If the point is below the plane, a negative distance is returned.",since:5,returns:"Signed distance from this plane to testPoint."},{signature:"bool EpsilonEquals(Plane other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines if an object is a plane and has the same components as this plane.",returns:"True if obj is a plane and has the same components as this plane; False otherwise."},{signature:"bool Equals(Plane plane)",summary:"Determines if another plane has the same components as this plane.",since:5,returns:"True if plane has the same components as this plane; False otherwise."},{signature:"bool ExtendThroughBox(BoundingBox box,Interval s,Interval t)",summary:"Extends this plane through a bounding box.",since:5,returns:"True on success, False on failure."},{signature:"bool ExtendThroughBox(Box box,Interval s,Interval t)",summary:"Extend this plane through a Box.",since:5,returns:"True on success, False on failure."},{signature:"void Flip()",summary:"Flip this plane by swapping out the X and Y axes and inverting the Z axis.",since:5},{signature:"int GetHashCode()",summary:"Gets a non-unique hashing code for this entity.",returns:"A particular number for a specific instance of plane."},{signature:"double[] GetPlaneEquation()",summary:"Gets the plane equation for this plane in the format of Ax+By+Cz+D=0.",since:5,returns:"Array of four values."},{signature:"Point3d PointAt(double u,double v)",summary:"Evaluate a point on the plane.",since:5,returns:"plane.origin + u*plane.xaxis + v*plane.yaxis."},{signature:"Point3d PointAt(double u,double v,double w)",summary:"Evaluate a point on the plane.",since:5,returns:"plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis."},{signature:"bool RemapToPlaneSpace(Point3d ptSample,Point3d ptPlane)",summary:"Convert a point from World space coordinates into Plane space coordinates.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double sinAngle,double cosAngle,Vector3d axis)",summary:"Rotate the plane about its origin point.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double sinAngle,double cosAngle,Vector3d axis,Point3d centerOfRotation)",summary:"Rotate the plane about a custom anchor point.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double angle,Vector3d axis)",summary:"Rotate the plane about its origin point.",since:5,returns:"True on success, False on failure."},{signature:"bool Rotate(double angle,Vector3d axis,Point3d centerOfRotation)",summary:"Rotate the plane about a custom anchor point.",since:5,returns:"True on success, False on failure."},{signature:"string ToString()",summary:"Constructs the string representation of this plane.",returns:"Text."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"bool Transform(Transform xform)",summary:"Transform the plane with a Transformation matrix.",since:5,returns:"True on success, False on failure."},{signature:"bool Translate(Vector3d delta)",summary:"Translate (move) the plane along a vector.",since:5,returns:"True on success, False on failure."},{signature:"bool UpdateEquation()",summary:"Update Equations",since:6,returns:"bool"},{signature:"double ValueAt(Point3d p)",summary:"Get the value of the plane equation at the point.",since:5.7,returns:"returns pe[0]*p.X + pe[1]*p.Y + pe[2]*p.Z + pe[3] where\n     pe[0], pe[1], pe[2] and pe[3] are the coeeficients of the plane equation."}]},{name:"Rhino.Geometry.PlaneFitResult",dataType:3,summary:"Enumerates all possible outcomes of a Least-Squares plane fitting operation."},{name:"Rhino.Geometry.PlaneSurface",dataType:1,summary:"Represents a plane surface, with plane and two intervals.",constructors:[{signature:"PlaneSurface(Plane plane,Interval xExtents,Interval yExtents)",summary:"Initializes a plane surface with x and y intervals.",since:5}],methods:[{signature:"static PlaneSurface CreateThroughBox(Line lineInPlane,Vector3d vectorInPlane,BoundingBox box)",summary:"Makes a plane that includes a line and a vector and goes through a bounding box.",since:5,returns:"A new plane surface on success, or None on error."},{signature:"static PlaneSurface CreateThroughBox(Plane plane,BoundingBox box)",summary:"Extends a plane into a plane surface so that the latter goes through a bounding box.",since:5,returns:"A new plane surface on success, or None on error."}]},{name:"Rhino.Geometry.Point",dataType:1,summary:"Represents a geometric point.\n   This is fundamentally a class that derives from\n    and contains a single  location.",constructors:[{signature:"Point(Point3d location)",summary:"Initializes a new point instance with a location.",since:5}],properties:[{signature:"Point3d Location",summary:"Gets or sets the location (position) of this point.",since:5}]},{name:"Rhino.Geometry.Point2d",dataType:2,summary:"Represents the two coordinates of a point in two-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Point2d(double x,double y)",summary:"Initializes a new instance of  from coordinates.",since:5},{signature:"Point2d(Point2d point)",summary:"Initializes a new instance of  by copying another .",since:5},{signature:"Point2d(Point3d point)",summary:"Initializes a new instance of  by copying the first two coordiantes of a .",since:5},{signature:"Point2d(Vector2d vector)",summary:"Initializes a new instance of  by converting a vector.",since:5}],properties:[{signature:"static Point2d Origin",summary:"Gets a point at 0,0.",since:5},{signature:"static Point2d Unset",summary:"Gets a point at RhinoMath.UnsetValue,RhinoMath.UnsetValue.",since:5},{signature:"bool IsValid",summary:"If any coordinate of a point is UnsetValue, then the point is not valid.",since:5},{signature:"double MaximumCoordinate",summary:"Gets the largest valid coordinate, or RhinoMath.UnsetValue if no coordinate is valid.",since:5},{signature:"double MinimumCoordinate",summary:"Gets the smallest (both positive and negative) valid coordinate, or RhinoMath.UnsetValue if no coordinate is valid.",since:5},{signature:"double X",summary:"Gets or sets the X (first) coordinate of the point.",since:5},{signature:"double Y",summary:"Gets or sets the Y (second) coordinate of the point.",since:5}],methods:[{signature:"static Point2d Add(Point2d point1,Point2d point2)",summary:"Adds a point with a point.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that is coordinatewise summed with the other point."},{signature:"static Point2d Add(Point2d point,Vector2d vector)",summary:"Adds a point with a vector.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that is coordinatewise summed with the vector."},{signature:"static Point2d Add(Vector2d vector,Point2d point)",summary:"Adds a vector with a point.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that is coordinatewise summed with the vector."},{signature:"static Point2d Divide(Point2d point,double t)",summary:"Divides a  by a number.\n     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)",since:5,returns:"A new point that is coordinatewise divided by t."},{signature:"static Point2d Multiply(double t,Point2d point)",summary:"Multiplies a  by a number.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new point that is coordinatewise multiplied by t."},{signature:"static Point2d Multiply(Point2d point,double t)",summary:"Multiplies a  by a number.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new point that is coordinatewise multiplied by t."},{signature:"static Vector2d Subtract(Point2d point1,Point2d point2)",summary:"Subtracts the second point from the first point.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new vector that is point1 coordinatewise subtracted by point2."},{signature:"static Point2d Subtract(Point2d point,Vector2d vector)",summary:"Subtracts a vector from a point.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new point that is coordinatewise subtracted by vector."},{signature:"int CompareTo(Point2d other)",summary:"Compares this  with another .\n     Coordinates evaluation priority is first X, then Y.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise."},{signature:"double DistanceTo(Point2d other)",summary:"Computes the distance between two points.",since:5,returns:"The length of the line between the two points, or 0 if either point is invalid."},{signature:"bool EpsilonEquals(Point2d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Point2d and has the same values as the present point.",returns:"True if obj is a Point2d and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Point2d point)",summary:"Determines whether the specified Point2d has the same values as the present point.",since:5,returns:"True if point has the same coordinates as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash number that represents the current point.",returns:"A hash code that is not unique for each point."},{signature:"string ToString()",summary:"Constructs the string representation for the current point.",returns:"The point representation in the form X,Y."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"void Transform(Transform xform)",summary:"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,\n     result = transformation*point",since:5.1}]},{name:"Rhino.Geometry.Point2f",dataType:2,summary:"Represents the two coordinates of a point in two-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Point2f(double x,double y)",summary:"Initializes a new two-dimensional point from two double-precision floating point numbers as coordinates.\n     Coordinates will be internally converted to floating point numbers. This might cause precision loss.",since:5},{signature:"Point2f(float x,float y)",summary:"Initializes a new two-dimensional point from two components.",since:5}],properties:[{signature:"static Point2f Unset",summary:"Gets the standard unset point.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether this point is considered valid.",since:5},{signature:"float X",summary:"Gets or sets the X (first) component of the vector.",since:5},{signature:"float Y",summary:"Gets or sets the Y (second) component of the vector.",since:5}],methods:[{signature:"int CompareTo(Point2f other)",summary:"Compares this  with another .\n     Coordinates evaluation priority is first X, then Y.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise."},{signature:"bool EpsilonEquals(Point2f other,float epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a  and has the same values as the present point.",returns:"True if obj is Point2f and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Point2f point)",summary:"Determines whether the specified  has the same values as the present point.",since:5,returns:"True if point has the same coordinates as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash number that represents the current point.",returns:"A hash code that is not unique for each point."},{signature:"string ToString()",summary:"Constructs the string representation for the current point.",returns:"The point representation in the form X,Y."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7}]},{name:"Rhino.Geometry.Point3d",dataType:2,summary:"Represents the three coordinates of a point in three-dimensional space,\n   using -precision floating point values.",constructors:[{signature:"Point3d(double x,double y,double z)",summary:"Initializes a new point by defining the X, Y and Z coordinates.",since:5},{signature:"Point3d(Point3d point)",summary:"Initializes a new point by copying coordinates from another point.",since:5},{signature:"Point3d(Point3f point)",summary:"Initializes a new point by copying coordinates from a single-precision point.",since:5},{signature:"Point3d(Point4d point)",summary:"Initializes a new point by copying coordinates from a four-dimensional point.\n     The first three coordinates are divided by the last one.\n     If the W (fourth) dimension of the input point is zero, then it will be just discarded.",since:5},{signature:"Point3d(Vector3d vector)",summary:"Initializes a new point by copying coordinates from the components of a vector.",since:5}],properties:[{signature:"static Point3d Origin",summary:"Gets the value of a point at location 0,0,0.",since:5},{signature:"static Point3d Unset",summary:"Gets the value of a point at location RhinoMath.UnsetValue,RhinoMath.UnsetValue,RhinoMath.UnsetValue.",since:5},{signature:"bool IsValid",summary:"Each coordinate of the point must pass the  test.",since:5},{signature:"double MaximumCoordinate",summary:"Gets the largest (both positive and negative) valid coordinate in this point,\n     or RhinoMath.UnsetValue if no coordinate is valid.",since:5},{signature:"double MinimumCoordinate",summary:"Gets the smallest (both positive and negative) coordinate value in this point.",since:5},{signature:"double X",summary:"Gets or sets the X (first) coordinate of this point.",since:5},{signature:"double Y",summary:"Gets or sets the Y (second) coordinate of this point.",since:5},{signature:"double Z",summary:"Gets or sets the Z (third) coordinate of this point.",since:5}],methods:[{signature:"static Point3d Add(Point3d point1,Point3d point2)",summary:"Sums two  instances.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that results from the addition of point1 and point2."},{signature:"static Point3d Add(Point3d point,Vector3d vector)",summary:"Sums up a point and a vector, and returns a new point.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that results from the addition of point and vector."},{signature:"static Point3d Add(Point3d point,Vector3f vector)",summary:"Sums up a point and a vector, and returns a new point.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that results from the addition of point and vector."},{signature:"static Point3d Add(Vector3d vector,Point3d point)",summary:"Sums up a point and a vector, and returns a new point.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that results from the addition of point and vector."},{signature:"static bool ArePointsCoplanar(IEnumerable<Point3d> points,double tolerance)",summary:"Determines whether a set of points is coplanar within a given tolerance.",since:5,returns:"True if points are on the same plane; False otherwise."},{signature:"static Point3d[] CullDuplicates(IEnumerable<Point3d> points,double tolerance)",summary:"Removes duplicates in the supplied set of points.",since:5,returns:"An array of points without duplicates; or None on error."},{signature:"static Point3d Divide(Point3d point,double t)",summary:"Divides a  by a number.\n     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)",since:5,returns:"A new point that is coordinatewise divided by t."},{signature:"static Point3d FromPoint3f(Point3f point)",summary:"Converts a single-precision point in a double-precision point.",since:6,returns:"The resulting point."},{signature:"static Point3d Multiply(double t,Point3d point)",summary:"Multiplies a  by a number.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new point that is coordinatewise multiplied by t."},{signature:"static Point3d Multiply(Point3d point,double t)",summary:"Multiplies a  by a number.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new point that is coordinatewise multiplied by t."},{signature:"static Point3d[] SortAndCullPointList(IEnumerable<Point3d> points,double minimumDistance)",summary:'Orders a set of points so they will be connected in a "reasonable polyline" order.\n     Also, removes points from the list if their common distance exceeds a specified threshold.',since:5,returns:"The new array of sorted and culled points."},{signature:"static Vector3d Subtract(Point3d point1,Point3d point2)",summary:"Subtracts a point from another point.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new vector that is the difference of point minus vector."},{signature:"static Point3d Subtract(Point3d point,Vector3d vector)",summary:"Subtracts a vector from a point.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new point that is the difference of point minus vector."},{signature:"static bool TryParse(string input,Point3d result)",summary:"Converts the string representation of a point to the equivalent Point3d structure.",since:6.12,returns:"True if successful, False otherwise."},{signature:"int CompareTo(Point3d other)",summary:"Compares this  with another .\n     Component evaluation priority is first X, then Y, then Z.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise."},{signature:"double DistanceTo(Point3d other)",summary:"Computes the distance between two points.",since:5,returns:"The length of the line between this and the other point; or 0 if any of the points is not valid."},{signature:"double DistanceToSquared(Point3d other)",summary:"Computes the square of the distance between two points.\n     This method is usually largely faster than DistanceTo().",since:6,returns:"The squared length of the line between this and the other point; or 0 if any of the points is not valid."},{signature:"bool EpsilonEquals(Point3d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified  is a  and has the same values as the present point.",returns:"True if obj is a Point3d and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Point3d point)",summary:"Determines whether the specified  has the same values as the present point.",since:5,returns:"True if point has the same coordinates as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash code for the present point.",returns:"A non-unique integer that represents this point."},{signature:"void Interpolate(Point3d pA,Point3d pB,double t)",summary:"Interpolate between two points.",since:5},{signature:"string ToString()",summary:"Constructs the string representation for the current point.",returns:"The point representation in the form X,Y,Z."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"void Transform(Transform xform)",summary:"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,\n     result = transformation*point",since:5}]},{name:"Rhino.Geometry.Point3dGrid",dataType:1,summary:"Represents a rectangular grid of 3D points.",constructors:[{signature:"Point3dGrid()",summary:"Initializes a rectangular grid of points, with no points in it.",since:5},{signature:"Point3dGrid(int rows,int columns)",summary:"Initializes a rectangular grid of points with a given number of columns and rows.",since:5}]},{name:"Rhino.Geometry.Point3f",dataType:2,summary:"Represents the three coordinates of a point in three-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Point3f(float x,float y,float z)",summary:"Initializes a new two-dimensional vector from two components.",since:5}],properties:[{signature:"static Point3f Origin",summary:"Gets the value of a point at location 0,0,0.",since:5},{signature:"static Point3f Unset",summary:"Gets the value of a point at location RhinoMath.UnsetValue,RhinoMath.UnsetValue,RhinoMath.UnsetValue.",since:5},{signature:"bool IsValid",summary:"Each coordinate of the point must pass the  test.",since:5},{signature:"float X",summary:"Gets or sets the X (first) component of the vector.",since:5},{signature:"float Y",summary:"Gets or sets the Y (second) component of the vector.",since:5},{signature:"float Z",summary:"Gets or sets the Z (third) component of the vector.",since:5}],methods:[{signature:"static Vector3f Subtract(Point3f point1,Point3f point2)",summary:"Subtracts a point from another point.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new vector that is the difference of point minus vector."},{signature:"int CompareTo(Point3f other)",summary:"Compares this  with another .\n     Component evaluation priority is first X, then Y, then Z.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise."},{signature:"double DistanceTo(Point3f other)",summary:"Computes the distance between two points.",since:5,returns:"The length of the line between this and the other point; or 0 if any of the points is not valid."},{signature:"bool EpsilonEquals(Point3f other,float epsilon)",summary:"Check that all values in other are withing epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Point3f and has the same values as the present point.",returns:"True if obj is Point3f and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Point3f point)",summary:"Determines whether the specified Point3f has the same values as the present point.",since:5,returns:"True if point has the same coordinates as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash code for the present point.",returns:"A non-unique integer that represents this point."},{signature:"string ToString()",summary:"Constructs the string representation for the current point.",returns:"The point representation in the form X,Y,Z."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"void Transform(Transform xform)",summary:"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,\n     result = transformation*point",since:5}]},{name:"Rhino.Geometry.Point4d",dataType:2,summary:"Represents the four coordinates of a point in four-dimensional space.\n   The W (fourth) dimension is often considered the weight of the point as seen in 3D space.",constructors:[{signature:"Point4d(double x,double y,double z,double w)",summary:"Initializes a new instance of the  class based on coordinates.",since:5},{signature:"Point4d(Point3d point)",summary:"Initializes a new instance of the  class from the coordinates of a point.",since:5},{signature:"Point4d(Point4d point)",summary:"Initializes a new point by copying coordinates from another point.",since:6}],properties:[{signature:"static Point4d Unset",summary:"Gets the value of a point with all coordinates set as RhinoMath.UnsetValue.",since:5},{signature:"bool IsValid",summary:"Returns an indication regarding the validity of this point.",since:6},{signature:"double W",summary:"Gets or sets the W (fourth) coordinate -or weight- of this point.",since:5},{signature:"double X",summary:"Gets or sets the X (first) coordinate of this point.",since:5},{signature:"double Y",summary:"Gets or sets the Y (second) coordinate of this point.",since:5},{signature:"double Z",summary:"Gets or sets the Z (third) coordinate of this point.",since:5}],methods:[{signature:"static Point4d Add(Point4d point1,Point4d point2)",summary:"Sums two  together.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that results from the weighted addition of point1 and point2."},{signature:"static Point4d Multiply(Point4d point,double d)",summary:"Multiplies a point by a number.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new point that results from the coordinatewise multiplication of point with d."},{signature:"static Point4d Subtract(Point4d point1,Point4d point2)",summary:"Subtracts the second point from the first point.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new point that results from the weighted subtraction of point2 from point1."},{signature:"bool EpsilonEquals(Point4d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is Point4d and has same coordinates as the present point.",returns:"True if obj is Point4d and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Point4d point)",summary:"Determines whether the specified point has same value as the present point.",since:5,returns:"True if point has the same value as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes the hash code for the present point.",returns:"A non-unique hash code, which uses all coordiantes of this object."},{signature:"string ToString()"},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"void Transform(Transform xform)",summary:"Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,\n     result = transformation*point",since:6}]},{name:"Rhino.Geometry.PointCloud",dataType:1,summary:"Represents a collection of coordinates with optional normal vectors and colors.",constructors:[{signature:"PointCloud()",summary:"Initializes a new instance of the  class\n     that is empty.",since:5},{signature:"PointCloud(IEnumerable<Point3d> points)",summary:"Initializes a new instance of the  class,\n     copying the content from a set of points.",since:5},{signature:"PointCloud(PointCloud other)",summary:"Initializes a new instance of the  class,\n     copying (Merge) the content of another pointcloud.",since:5}],properties:[{signature:"bool ContainsColors",summary:"Gets a value indicating whether or not the points in this \n     pointcloud have colors assigned to them.",since:5},{signature:"bool ContainsHiddenFlags",summary:"Gets a value indicating whether or not the points in this \n     pointcloud have hidden flags assigned to them.",since:5},{signature:"bool ContainsNormals",summary:"Gets a value indicating whether or not the points in this \n     pointcloud have normals assigned to them.",since:5},{signature:"int Count",summary:"Gets the number of points in this pointcloud.",since:5},{signature:"int HiddenPointCount",summary:"Gets the number of points that have their Hidden flag set.",since:5}],methods:[{signature:"void Add(Point3d point)",summary:"Append a new point to the end of the list.",since:5},{signature:"void Add(Point3d point,Color color)",summary:"Append a new point to the end of the list.",since:5},{signature:"void Add(Point3d point,Vector3d normal)",summary:"Append a new point to the end of the list.",since:5},{signature:"void Add(Point3d point,Vector3d normal,Color color)",summary:"Append a new point to the end of the list.",since:5},{signature:"void AddRange(IEnumerable<Point3d> points)",summary:"Appends a collection of points to this point cloud.",since:5},{signature:"void AddRange(IEnumerable<Point3d> points,IEnumerable<Color> colors)",summary:"Appends a collection of points and normal vectors to this point cloud.",since:6},{signature:"void AddRange(IEnumerable<Point3d> points,IEnumerable<Vector3d> normals)",summary:"Appends a collection of points and normal vectors to this point cloud.",since:6},{signature:"void AddRange(IEnumerable<Point3d> points,IEnumerable<Vector3d> normals,IEnumerable<Color> colors)",summary:"Appends a collection of points and normal vectors to this point cloud.",since:6},{signature:"PointCloudItem AppendNew()",summary:"Appends a new PointCloudItem to the end of this point cloud.",since:5,returns:"The newly appended item."},{signature:"IReadOnlyList<Point3d> AsReadOnlyListOfPoints()",summary:"Returns an enumerator and list indexer over point cloud locations.",since:6,returns:"The read-only list. This is a reference to the present point cloud."},{signature:"void ClearColors()",summary:"Destroys the color information in this point cloud.",since:5},{signature:"void ClearHiddenFlags()",summary:"Destroys the hidden flag information in this point cloud.",since:5},{signature:"void ClearNormals()",summary:"Destroys the normal vector information in this point cloud.",since:5},{signature:"int ClosestPoint(Point3d testPoint)",summary:"Returns index of the closest point in the point cloud to a given test point.",since:5,returns:"Index of point in the point cloud on success. -1 on failure."},{signature:"Color[] GetColors()",summary:"Copy all the point colors in this point cloud to an array.",since:5,returns:"An array containing all the colors in this point cloud."},{signature:"IEnumerator<PointCloudItem> GetEnumerator()",summary:"Gets an enumerator that allows to modify each pointcloud point.",since:5,returns:"A instance of ."},{signature:"Vector3d[] GetNormals()",summary:"Copy all the normal vectors in this point cloud to an array.",since:5,returns:"An array containing all the normals in this point cloud."},{signature:"Point3d[] GetPoints()",summary:"Copy all the point coordinates in this point cloud to an array.",since:5,returns:"An array containing all the points in this point cloud."},{signature:"void Insert(int index,Point3d point)",summary:"Inserts a new point into the point list.",since:5},{signature:"void Insert(int index,Point3d point,Color color)",summary:"Inserts a new point into the point list.",since:5},{signature:"void Insert(int index,Point3d point,Vector3d normal)",summary:"Inserts a new point into the point list.",since:5},{signature:"void Insert(int index,Point3d point,Vector3d normal,Color color)",summary:"Inserts a new point into the point list.",since:5},{signature:"PointCloudItem InsertNew(int index)",summary:"Inserts a new  at a specific position of the point cloud.",since:5,returns:"The newly inserted item."},{signature:"void InsertRange(int index,IEnumerable<Point3d> points)",summary:"Append a collection of points to this point cloud.",since:5},{signature:"void Merge(PointCloud other)",summary:"Copies the point values of another pointcloud into this one.",since:5},{signature:"Point3d PointAt(int index)",summary:"Returns the location of the point at a specific index.",since:6},{signature:"void RemoveAt(int index)",summary:"Remove the point at the given index.",since:5}]},{name:"Rhino.Geometry.PointCloudItem",dataType:1,summary:"Represents a single item in a pointcloud. A PointCloud item \n   always has a location, but it has an optional normal vector and color.",properties:[{signature:"Color Color",summary:"Gets or sets the color of this point cloud item.",since:5},{signature:"bool Hidden",summary:"Gets or sets the hidden flag of this point cloud item.",since:5},{signature:"int Index",summary:"Gets the index of this point cloud item.",since:5},{signature:"Point3d Location",summary:"Gets or sets the location of this point cloud item.",since:5},{signature:"Vector3d Normal",summary:"Gets or sets the normal vector for this point cloud item.",since:5},{signature:"double X",summary:"Gets or sets the X component of this point cloud item location.",since:5},{signature:"double Y",summary:"Gets or sets the Y component of this point cloud item location.",since:5},{signature:"double Z",summary:"Gets or sets the Z component of this point cloud item location.",since:5}]},{name:"Rhino.Geometry.PointContainment",dataType:3,summary:"Defines enumerated values for closed curve/point spatial relationships."},{name:"Rhino.Geometry.PointFaceRelation",dataType:3,summary:"Enumerates the possible point/BrepFace spatial relationships."},{name:"Rhino.Geometry.PolyCurve",dataType:1,summary:"Represents a curve that is the result of joining several (possibly different)\n   types of curves.",constructors:[{signature:"PolyCurve()",summary:"Initializes a new, empty polycurve.",since:5}],properties:[{signature:"bool HasGap",summary:"This is a quick way to see if the curve has gaps between the sub curve segments.",since:5},{signature:"bool IsNested",summary:"Gets a value indicating whether or not a PolyCurve contains nested PolyCurves.",since:5},{signature:"int SegmentCount",summary:"Gets the number of segments that make up this Polycurve.",since:5}],methods:[{signature:"bool Append(Arc arc)",summary:"Appends and matches the start of the arc to the end of polycurve. \n     This function will fail if the polycurve is closed or if SegmentCount > 0 and the arc is closed.",since:5,returns:"True on success, False on failure."},{signature:"bool Append(Curve curve)",summary:"Appends and matches the start of the curve to the end of polycurve. \n     This function will fail if the PolyCurve is closed or if SegmentCount > 0 and the new segment is closed.",since:5,returns:"True on success, False on failure."},{signature:"bool Append(Line line)",summary:"Appends and matches the start of the line to the end of polycurve. \n     This function will fail if the polycurve is closed.",since:5,returns:"True on success, False on failure."},{signature:"bool AppendSegment(Curve curve)",summary:"Appends the curve to the polycurve without changing the new segment's geometry. \n     This function will fail if the PolyCurve is closed or if SegmentCount > 0 and the new segment is closed.",since:6,returns:"True on success, False on failure."},{signature:"Curve CleanUp()",summary:"Removes any nesting of polycurves. If this polycurve has just a single segment, the segment is returned.\n     If, after nest removal, there are adjacent segments which are polylines, they are combined into a single polyline.\n     The new curve may have a different domain from this polycurve. If the start and end segments of a closed input are polylines,\n     the result may have a different seam location since the start and end segments will be combined.",since:7,returns:"A new curve that is not necessarily a polycurve if succesful, None otherwise."},{signature:"GeometryBase Duplicate()",summary:"Duplicates this polycurve.\n     When not overridden in a derived class, this calls .",since:5,returns:"An exact duplicate of this curve."},{signature:"PolyCurve DuplicatePolyCurve()",summary:"Duplicates this polycurve.\n     This is the same as .",since:5,returns:"An exact duplicate of this curve."},{signature:"Curve[] Explode()",summary:"Explodes this PolyCurve into a list of Curve segments. This will not explode nested polycurves. \n     Call  first if you need all individual segments.",since:5,returns:"An array of polycurve segments."},{signature:"double PolyCurveParameter(int segmentIndex,double segmentCurveParameter)",summary:"Converts a segment curve parameter to a polycurve parameter.",since:5,returns:"Polycurve evaluation parameter or UnsetValue if the polycurve curve parameter could not be computed."},{signature:"bool RemoveNesting()",summary:"Explodes nested polycurve segments and reconstructs this curve from the shattered remains. \n     The result will have not have any PolyCurves as segments but it will have identical \n     locus and parameterization.",since:5,returns:"True if any nested PolyCurve was found and absorbed, False if no PolyCurve segments could be found."},{signature:"Curve SegmentCurve(int index)",summary:"Gets the segment curve at the given index.",since:5,returns:"The segment at the given index or None on failure."},{signature:"double SegmentCurveParameter(double polycurveParameter)",summary:"Converts a polycurve parameter to a segment curve parameter.",since:5,returns:"Segment curve evaluation parameter or UnsetValue if the \n     segment curve parameter could not be computed."},{signature:"Interval SegmentDomain(int segmentIndex)",summary:"Returns the polycurve subdomain assigned to a segment curve.",since:5,returns:"The polycurve subdomain assigned to a segment curve. \n     Returns Interval.Unset if segment_index < 0 or segment_index >= Count()."},{signature:"int SegmentIndex(double polycurveParameter)",summary:"Finds the segment used for evaluation at polycurve_parameter.",since:5,returns:"Index of the segment used for evaluation at polycurve_parameter. \n     If polycurve_parameter < Domain.Min(), then 0 is returned. \n     If polycurve_parameter > Domain.Max(), then Count()-1 is returned."},{signature:"int SegmentIndexes(Interval subdomain,int segmentIndex0,int segmentIndex1)",summary:"Finds the segments that overlap the Polycurve sub domain.",since:5,returns:"Number of segments that overlap the subdomain."}]},{name:"Rhino.Geometry.Polyline",dataType:1,summary:"Represents an ordered set of points connected by linear segments.\n   Polylines are closed if start and end points coincide.",constructors:[{signature:"Polyline()",summary:"Initializes a new empty polyline.",since:5},{signature:"Polyline(IEnumerable<Point3d> collection)",summary:"Initializes a new polyline from a collection of points.",since:5},{signature:"Polyline(int initialCapacity)",summary:"Initializes a new empty polyline with an initial capacity.",since:5}],properties:[{signature:"bool IsClosed",summary:"Gets a value that indicates whether this polyline is closed. \n     The polyline is considered to be closed if its start is \n     identical to its endpoint.",since:5},{signature:"bool IsValid",summary:"Gets a value that indicates whether this polyline is valid. \n     Valid polylines have at least one segment, no Invalid points and no zero length segments.Closed polylines with only two segments are also not considered valid.",since:5},{signature:"double Length",summary:"Gets the total length of the polyline.",since:5},{signature:"int SegmentCount",summary:"Gets the number of segments for this polyline.",since:5}],methods:[{signature:"static Polyline CreateCircumscribedPolygon(Circle circle,int sideCount)",summary:"Create a regular polygon circumscribe about a circle. The midpoints of the polygon's edges will be tanget to the circle.",since:6.1,returns:"A closed polyline if successful, None otherwise."},{signature:"static Polyline CreateInscribedPolygon(Circle circle,int sideCount)",summary:"Create a regular polygon inscribed in a circle. The vertices of the polygon will be on the circle.",since:6.1,returns:"A closed polyline if successful, None otherwise."},{signature:"static Polyline CreateStarPolygon(Circle circle,double radius,int cornerCount)",summary:"Create a regular star polygon. The star begins at circle.PointAt(0) and the vertices\n     alternate between being on circle and begin on a concentric circle of other_radius.",since:6.1,returns:"A closed polyline if successful, None otherwise."},{signature:"Polyline[] BreakAtAngles(double angle)",summary:"Breaks this polyline into sections at sharp kinks. \n     Closed polylines will also be broken at the first and last vertex.",since:5,returns:"An array of polyline segments, or None on error."},{signature:"Point3d CenterPoint()",summary:"Compute the center point of the polyline as the weighted average of all segments.",since:5,returns:"The weighted average of all segments."},{signature:"double ClosestParameter(Point3d testPoint)",summary:"Gets the parameter along the polyline which is closest to a test-point.",since:5,returns:"The parameter along the polyline closest to testPoint."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Gets the point on the polyline which is closest to a test-point.",since:5,returns:"The point on the polyline closest to testPoint."},{signature:"int CollapseShortSegments(double tolerance)",summary:"Collapses all segments until none are shorter than tolerance. \n     This function is significantly slower than DeleteShortSegments, \n     since it recursively operates on the shortest segment. \n     When a segment is collapsed the end-points are placed in the center of the segment.",since:5,returns:"The number of segments that were collapsed."},{signature:"int DeleteShortSegments(double tolerance)",summary:"Removes all points that are closer than tolerance to the previous point. \n     Start and end points are left intact.",since:5,returns:"Number of points (and segments) removed."},{signature:"Polyline Duplicate()",summary:"Returns a deep copy of this polyline instance.",since:6,returns:"The duplicated polyline."},{signature:"Line[] GetSegments()",summary:"Constructs an array of line segments that make up the entire polyline.",since:5,returns:"An array of line segments or None if the polyline contains fewer than 2 points."},{signature:"bool IsClosedWithinTolerance(double tolerance)",summary:"Determines whether the polyline is closed, provided a tolerance value.",since:5,returns:"True if the polyline is closed to within tolerance, False otherwise."},{signature:"int MergeColinearSegments(double angleTolerance,bool includeSeam)",summary:"Merge co-linear consecutive segments in a polyline.\n     This method will automatically remove any zero-length segments as well.",since:6.3,returns:"Number of segments removed from the entire polyline."},{signature:"Point3d PointAt(double t)",summary:"Gets the point on the polyline at the given parameter. \n     The integer part of the parameter indicates the index of the segment.",since:5,returns:"The point on the polyline at t."},{signature:"int ReduceSegments(double tolerance)",summary:"Constructs a reduction of this polyline by recursively removing the least significant segments.",since:5,returns:"The number of vertices that disappeared due to reduction."},{signature:"Line SegmentAt(int index)",summary:"Gets the line segment at the given index.",since:5,returns:"Line segment at index or Line.Unset on failure."},{signature:"bool Smooth(double amount)",summary:"Smoothens the polyline segments by averaging adjacent vertices. \n     Smoothing requires a polyline with exclusively valid vertices.",since:5,returns:"True on success, False on failure."},{signature:"Vector3d TangentAt(double t)",summary:"Gets the unit tangent vector along the polyline at the given parameter. \n     The integer part of the parameter indicates the index of the segment.",since:5,returns:"The tangent along the polyline at t."},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a nurbs curve representation of this polyline.",since:5,returns:"A Nurbs curve shaped like this polyline or None on failure."},{signature:"PolylineCurve ToPolylineCurve()",summary:"Constructs a polyline curve representation of this polyline.",since:6,returns:"A curve shaped like this polyline or None on failure."},{signature:"MeshFace[] TriangulateClosedPolyline()",summary:"Attempts to create a list of triangles which represent a\n     triangulation of a closed polyline",since:5},{signature:"Polyline Trim(Interval domain)",summary:"Constructs a polyline out of a parameter subdomain in this curve.",since:5,returns:"The polyline as defined by the subdomain, or None on failure."}]},{name:"Rhino.Geometry.PolylineCurve",dataType:1,summary:"Represents the geometry of a set of linked line segments.\n   This is fundamentally a class that derives from \n   and internally contains a .",constructors:[{signature:"PolylineCurve()",summary:"Initializes a new empty polyline curve.",since:5},{signature:"PolylineCurve(IEnumerable<Point3d> points)",summary:"Initializes a new polyline curve by copying its content from another set of points.",since:5},{signature:"PolylineCurve(PolylineCurve other)",summary:"Initializes a new polyline curve by copying its content from another polyline curve.",since:5}],properties:[{signature:"int PointCount",summary:"Gets the number of points in this polyline.",since:5}],methods:[{signature:"double Parameter(int index)",summary:"Gets a parameter at a specified index in the polyline curve.",since:6,returns:"A parameter."},{signature:"Point3d Point(int index)",summary:"Gets a point at a specified index in the polyline curve.",since:5,returns:"A point."},{signature:"void SetParameter(int index,double parameter)",summary:"Sets a parameter at a specified index in the polyline curve.",since:6},{signature:"void SetPoint(int index,Point3d point)",summary:"Sets a point at a specified index in the polyline curve.",since:5},{signature:"Polyline ToPolyline()",summary:"Returns the underlying Polyline, or points.",since:6,returns:"The Polyline if successful, None of the curve has no points."}]},{name:"Rhino.Geometry.QuadRemeshParameters",dataType:1,summary:"Parameters for QuadRemesh method",properties:[{signature:"bool AdaptiveQuadCount",summary:"Respect the original Target Quad Count value as much as possible.\n     True returns more quads than TargetQuadCount depending on amount of high-curvature areas.",since:7},{signature:"double AdaptiveSize",summary:"Larger values results in for quad sizes that adjust to match input curvature.\n     Smaller values results in more uniform quad sizes at the risk of less feature preservation.\n     Range [0 - 100]",since:7},{signature:"bool DetectHardEdges",summary:"When enabled the hard edges in models will be retained.",since:7},{signature:"int GuideCurveInfluence",summary:"0 = Approximate\n     1 = Interpolate Edge Ring\n     2 = Interpolate Edge Loop\n     This value is ignored if Guide Curves are not supplied",since:7},{signature:"int PreserveMeshArrayEdgesMode",summary:"0=off, 1=On(Smart), 2=On(Strict) :\n     Mesh array's created from Breps will have their brep face edge boundaries retained.\n     Smart - Small or insignificant input faces are ignored.\n     Strict - All input faces are factored in remeshed result.",since:7},{signature:"QuadRemeshSymmetryAxis SymmetryAxis",summary:"Symmetry axis to use for symmetric remeshing",since:7},{signature:"int TargetQuadCount",summary:"The number of quads to try to achieve in the final remeshed object",since:7}]},{name:"Rhino.Geometry.QuadRemeshSymmetryAxis",dataType:3,summary:"Symmetrical meshing axis"},{name:"Rhino.Geometry.Quaternion",dataType:2,summary:"Represents the four coefficient values in a quaternion.\n   The first value a is the real part,\n   while the rest multipies i, j and k, that are imaginary.quaternion = a + bi + cj + dk",constructors:[{signature:"Quaternion(double a,double b,double c,double d)",summary:"Initializes a new quaternion with the provided coefficients.",since:5}],properties:[{signature:"static Quaternion I",summary:"Returns the (0,1,0,0) quaternion.",since:5},{signature:"static Quaternion Identity",summary:"Returns the (1,0,0,0) quaternion.",since:5},{signature:"static Quaternion J",summary:"Returns the (0,0,1,0) quaternion.",since:5},{signature:"static Quaternion K",summary:"Returns the (0,0,0,1) quaternion.",since:5},{signature:"static Quaternion Zero",summary:"Returns the dafault quaternion, where all coefficients are 0.",since:5},{signature:"double A",summary:"Gets or sets the real part of the quaternion.",since:5},{signature:"double B",summary:"Gets or sets the first imaginary coefficient of the quaternion.",since:5},{signature:"double C",summary:"Gets or sets the second imaginary coefficient of the quaternion.",since:5},{signature:"Quaternion Conjugate",summary:"Gets a new quaternion that is the conjugate of this quaternion.\n     This is (a,-b,-c,-d)",since:5},{signature:"double D",summary:"Gets or sets the third imaginary coefficient of the quaternion.",since:5},{signature:"Quaternion Inverse",summary:"Computes a new inverted quaternion,\n     (a/L2, -b/L2, -c/L2, -d/L2),where L2 = length squared = (a*a + b*b + c*c + d*d).\n     This is the multiplicative inverse, i.e.,\n     (a,b,c,d)*(a/L2, -b/L2, -c/L2, -d/L2) = (1,0,0,0).\n     If this is the zero quaternion, then the zero quaternion is returned.",since:5},{signature:"bool IsScalar",summary:"True if b, c, and d are all zero.",since:5},{signature:"bool IsValid",summary:"Determines if the four coefficients are valid numbers within RhinoCommon.\n     See .",since:5},{signature:"bool IsVector",summary:"True if a = 0 and at least one of b, c, or d is not zero.",since:5},{signature:"bool IsZero",summary:"True if a, b, c, and d are all zero.",since:5},{signature:"double Length",summary:"Returns the length or norm of the quaternion.",since:5},{signature:"double LengthSquared",summary:"Gets the result of (a^2 + b^2 + c^2 + d^2).",since:5},{signature:"double Scalar",summary:"The real (scalar) part of the quaternion\n     This is .",since:5},{signature:"Vector3d Vector",summary:"The imaginary part of the quaternion\n     (B,C,D)",since:5}],methods:[{signature:"static Quaternion CrossProduct(Quaternion p,Quaternion q)",summary:"Computes the vector cross product of p and q = (0,x,y,z),\n     where (x,y,z) = CrossProduct(p.Vector,q.Vector).This is not the same as the quaternion product p*q.",since:5,returns:"A new quaternion."},{signature:"static double Distance(Quaternion p,Quaternion q)",summary:"Returns the distance or norm of the difference between two quaternions.",since:5,returns:"(p - q).Length()"},{signature:"static Quaternion Product(Quaternion p,Quaternion q)",summary:"The quaternion product of p and q.  This is the same value as p*q.",since:5,returns:"A transform value."},{signature:"static Quaternion Rotation(double angle,Vector3d axisOfRotation)",summary:"Returns the unit quaternion\n     cos(angle/2), sin(angle/2)*x, sin(angle/2)*y, sin(angle/2)*z\n     where (x,y,z) is the unit vector parallel to axis.  This is the\n     unit quaternion that represents the rotation of angle about axis.",since:5,returns:"A new quaternion."},{signature:"static Quaternion Rotation(Plane plane0,Plane plane1)",summary:"Returns the unit quaternion that represents the the rotation that maps\n     plane0.xaxis to plane1.xaxis, plane0.yaxis to plane1.yaxis, and \n     plane0.zaxis to plane1.zaxis.",since:5,returns:"A quaternion value."},{signature:"double DistanceTo(Quaternion q)",summary:"Computes the distance or norm of the difference between this and another quaternion.",since:5,returns:"(this - q).Length."},{signature:"bool EpsilonEquals(Quaternion other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether an object is a quaternion and has the same value of this quaternion.",returns:"True if obj is a quaternion and has exactly equal coefficients; otherwise false."},{signature:"bool Equals(Quaternion other)",summary:"Determines whether this quaternion has the same value of another quaternion.",since:5,returns:"True if the quaternions have exactly equal coefficients; otherwise false."},{signature:"int GetHashCode()",summary:"Gets a non-unique but repeatable hashing code for this quaternion.",returns:"A signed number."},{signature:"bool GetRotation(double angle,Vector3d axis)",summary:"Returns the rotation defined by the quaternion.",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool GetRotation(Plane plane)",summary:"Returns the frame created by applying the quaternion's rotation\n     to the canonical world frame (1,0,0),(0,1,0),(0,0,1).",since:5,returns:"True if the operation succeeded; otherwise, false."},{signature:"bool Invert()",summary:"Modifies this quaternion to become\n     (a/L2, -b/L2, -c/L2, -d/L2),where L2 = length squared = (a*a + b*b + c*c + d*d).This is the multiplicative inverse, i.e.,\n     (a,b,c,d)*(a/L2, -b/L2, -c/L2, -d/L2) = (1,0,0,0).",since:5,returns:"True if successful. False if the quaternion is zero and cannot be inverted."},{signature:"Transform MatrixForm()",summary:"Returns 4x4 real valued matrix form of the quaternion\n     a  b  c  d\n     -b  a -d  c\n     -c  d  a -b\n     -d -c  b  a\n     which has the same arithmetic properties as the quaternion.",since:5,returns:"A transform value."},{signature:"Vector3d Rotate(Vector3d v)",summary:"Rotates a 3d vector. This operation is also called conjugation,\n     because the result is the same as\n     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector.",since:5,returns:"R*v, where R is the rotation defined by the unit quaternion.\n     This is mathematically the same as the values\n     (Inverse(q)*(0,x,y,z)*q).Vector\n     and\n     (q.Conjugate()*(0,x,y,x)*q/q.LengthSquared).Vector."},{signature:"void Set(double a,double b,double c,double d)",summary:"Sets all coefficients of the quaternion.",since:5},{signature:"void SetRotation(double angle,Vector3d axisOfRotation)",summary:"Sets the quaternion to cos(angle/2), sin(angle/2)*x, sin(angle/2)*y, sin(angle/2)*z\n     where (x,y,z) is the unit vector parallel to axis.  This is the unit quaternion\n     that represents the rotation of angle about axis.",since:5},{signature:"void SetRotation(Plane plane0,Plane plane1)",summary:"Sets the quaternion to the unit quaternion which rotates\n     plane0.xaxis to plane1.xaxis, plane0.yaxis to plane1.yaxis,\n     and plane0.zaxis to plane1.zaxis.",since:5},{signature:"bool Unitize()",summary:"Scales the quaternion's coordinates so that a*a + b*b + c*c + d*d = 1.",since:5,returns:"True if successful.  False if the quaternion is zero and cannot be unitized."}]},{name:"Rhino.Geometry.RadialDimension",dataType:1,summary:"Represents a dimension of a circular entity that can be measured with radius or diameter.",constructors:[{signature:"RadialDimension()",since:6}],properties:[{signature:"AnnotationType AnnotationType",since:6},{signature:"Point2d CenterPoint",since:6},{signature:"Point2d DimlinePoint",since:6},{signature:"bool IsDiameterDimension",summary:"Gets a value indicating whether the value refers to the diameter, rather than the radius.",since:5},{signature:"Point2d KneePoint",since:6},{signature:"Guid LeaderArrowBlockId",since:6},{signature:"double LeaderArrowSize",since:6},{signature:"ArrowType LeaderArrowType",since:6},{signature:"LeaderCurveStyle LeaderCurveStyle",since:6},{signature:"TextHorizontalAlignment LeaderTextHorizontalAlignment",summary:"Gets or sets the horizontal alignment of the radial dimension's text",since:6.9},{signature:"Point2d RadiusPoint",since:6},{signature:"LeaderContentAngleStyle TextAngleType",since:6},{signature:"TextLocation TextLocation",since:6},{signature:"TextOrientation TextOrientation",since:6}],methods:[{signature:"static RadialDimension Create(DimensionStyle dimStyle,AnnotationType dimtype,Plane plane,Point3d centerpoint,Point3d radiuspoint,Point3d dimlinepoint)",summary:"Initialize Dimension parameters",since:6},{signature:"bool AdjustFromPoints(Plane plane,Point3d centerpoint,Point3d radiuspoint,Point3d dimlinepoint,double rotationInPlane)",summary:"Update Dimension geometry from point locations",since:6},{signature:"bool Get3dPoints(Point3d centerpoint,Point3d radiuspoint,Point3d dimlinepoint,Point3d kneepoint)",summary:"Get locations of dimension's 3d points",since:6},{signature:"bool GetDisplayLines(DimensionStyle style,double scale,IEnumerable<Line> lines)"},{signature:"string GetDistanceDisplayText(UnitSystem unitsystem,DimensionStyle style)",since:6},{signature:"bool GetTextRectangle(Point3d[] corners)",since:6}]},{name:"Rhino.Geometry.RailType",dataType:3,summary:"Rail types used for creating filleted Brep edges"},{name:"Rhino.Geometry.Ray3d",dataType:2,summary:"Represents an immutable ray in three dimensions, using position and direction.",constructors:[{signature:"Ray3d(Point3d position,Vector3d direction)",summary:"Initializes a new Ray3d instance.",since:5}],properties:[{signature:"Vector3d Direction",summary:"Gets the direction vector of this ray.",since:5},{signature:"Point3d Position",summary:"Gets the starting position of this ray.",since:5}],methods:[{signature:"bool EpsilonEquals(Ray3d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Ray3d and has the same values as the present ray.",returns:"True if obj is a Ray3d and has the same position and direction as this; otherwise false."},{signature:"bool Equals(Ray3d ray)",summary:"Determines whether the specified Ray3d has the same value as the present ray.",since:5,returns:"True if ray has the same position and direction as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hashing number that represents the current ray.",returns:"A signed integer that represents both postion and direction, but is not unique."},{signature:"Point3d PointAt(double t)",summary:"Evaluates a point along the ray.",since:5,returns:"A point at (Direction*t + Position)."}]},{name:"Rhino.Geometry.Rectangle3d",dataType:2,summary:"Represents the values of a plane and two intervals\n   that form an oriented rectangle in three dimensions.",constructors:[{signature:"Rectangle3d(Plane plane,double width,double height)",summary:"Initializes a new rectangle from width and height.",since:5},{signature:"Rectangle3d(Plane plane,Interval width,Interval height)",summary:"Initializes a new rectangle from dimensions.",since:5},{signature:"Rectangle3d(Plane plane,Point3d cornerA,Point3d cornerB)",summary:"Initializes a new rectangle from a base plane and two corner points.",since:5}],properties:[{signature:"static Rectangle3d Unset",summary:"Gets a rectangle with Unset components.",since:5},{signature:"double Area",summary:"Gets the unsigned Area of the rectangle.",since:5},{signature:"BoundingBox BoundingBox",summary:"Gets the world aligned boundingbox for this rectangle.",since:5},{signature:"Point3d Center",summary:"Gets the point in the center of the rectangle.",since:5},{signature:"double Circumference",summary:"Gets the circumference of the rectangle.",since:5},{signature:"double Height",summary:"Gets the signed height of the rectangle. If the Y dimension is decreasing, the height will be negative.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether or not this is a valid rectangle. \n     A rectangle is considered to be valid when the base plane and both dimensions are valid.",since:5},{signature:"Plane Plane",summary:"Gets or sets the base plane of the rectangle.",since:5},{signature:"double Width",summary:"Gets the signed width of the rectangle. If the X dimension is decreasing, the width will be negative.",since:5},{signature:"Interval X",summary:"Gets or sets the dimensions of the rectangle along the base plane X-Axis (i.e. the width).",since:5},{signature:"Interval Y",summary:"Gets or sets the dimensions of the rectangle along the base plane Y-Axis (i.e. the height).",since:5}],methods:[{signature:"static Rectangle3d CreateFromPolyline(IEnumerable<Point3d> polyline)",summary:"Attempts to create a rectangle from a polyline. This method only works well for\n     polylines that already closely resemble rectangles. If the polyline contains\n     more than four vertices, the least significant ones will be ignored. If the\n     polylines is non-orthogonal, the discrepancies will be averaged away.\n     This method should not be used as a Rectangle fitter.",since:5,returns:"A rectangle that is shaped similarly to the polyline or Rectangle3d.Unset \n     if the polyline does not represent a rectangle."},{signature:"static Rectangle3d CreateFromPolyline(IEnumerable<Point3d> polyline,double deviation,double angleDeviation)",summary:"Attempts to create a rectangle from a polyline. This method only works well for\n     polylines that already closely resemble rectangles. If the polyline contains\n     more than four vertices, the least significant ones will be ignored. If the\n     polylines is non-orthogonal, the discrepancies will be averaged away.\n     This method should not be used as a Rectangle fitter.",since:5,returns:"A rectangle that is shaped similarly to the polyline or Rectangle3d.Unset \n     if the polyline does not represent a rectangle."},{signature:"Point3d ClosestPoint(Point3d point)",summary:"Gets the point on the rectangle that is closest to a test-point.",since:5,returns:"The point on or in the rectangle closest to the test point or Point3d.Unset on failure."},{signature:"Point3d ClosestPoint(Point3d point,bool includeInterior)",summary:"Gets the point on the rectangle that is closest to a test-point.",since:5,returns:"The point on the rectangle closest to the test point or Point3d.Unset on failure."},{signature:"PointContainment Contains(double x,double y)",summary:"Determines if two plane parameters are included in this rectangle.",since:5,returns:"Parameter Rectangle relationship."},{signature:"PointContainment Contains(Point3d pt)",summary:"Determines if a point is included in this rectangle.",since:5,returns:"Point Rectangle relationship."},{signature:"Point3d Corner(int index)",summary:"Gets the corner at the given index.",since:5,returns:"The point at the given corner index."},{signature:"bool EpsilonEquals(Rectangle3d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"void MakeIncreasing()",summary:"Ensures the X and Y dimensions are increasing or singleton intervals.",since:5},{signature:"Point3d PointAt(double t)",summary:"Gets a point along the rectangle boundary.",since:5,returns:"The point at the given boundary parameter."},{signature:"Point3d PointAt(double x,double y)",summary:"Gets a point in Rectangle space.",since:5,returns:"The point at the given x,y parameter."},{signature:"void RecenterPlane(int index)",summary:"Recenters the base plane on one of the corners.",since:5},{signature:"void RecenterPlane(Point3d origin)",summary:"Recenters the base plane on a new origin.",since:5},{signature:"NurbsCurve ToNurbsCurve()",summary:"Constructs a nurbs curve representation of this rectangle.",since:5,returns:"A nurbs curve with the same shape as this rectangle."},{signature:"Polyline ToPolyline()",summary:"Constructs a polyline from this rectangle.",since:5,returns:"A polyline with the same shape as this rectangle."},{signature:"bool Transform(Transform xform)",summary:"Transforms this rectangle. Note that rectangles cannot be skewed or tapered.",since:5}]},{name:"Rhino.Geometry.ReduceMeshParameters",dataType:1,summary:"Parameters for Reduce method",constructors:[{signature:"ReduceMeshParameters()",summary:"Constructs a polygon reduction parameter object with default values.\n     Users of this class should not rely on default values to stay constant\n     across service releases.",since:6}],properties:[{signature:"int Accuracy",summary:"Integer from 1 to 10 telling how accurate reduction algorithm\n     to use. Greater number gives more accurate results",since:6},{signature:"bool AllowDistortion",summary:"If True mesh appearance is not changed even if the target polygon count is not reached",since:6},{signature:"CancellationToken CancelToken",since:6},{signature:"int DesiredPolygonCount",summary:"Desired or target number of faces",since:6},{signature:"string Error",since:6},{signature:"int[] FaceTags",since:6},{signature:"ComponentIndex[] LockedComponents",summary:"List of topological mesh vertices and mesh vertices that will not be moved or deleted in reduction process.\n     Each mesh vertex will lock the corresponding topological mesh vertex. In other words it is not possible to have a\n     locked and non-locked mesh vertex at the same location.",since:6},{signature:"bool NormalizeMeshSize",summary:"If True mesh is fitted to an axis aligned unit cube until reduction is complete",since:6},{signature:"IProgress<double> ProgressReporter",since:6}]},{name:"Rhino.Geometry.RegionContainment",dataType:3,summary:"Defines enumerated values for closed curve/closed curve relationships."},{name:"Rhino.Geometry.RevSurface",dataType:1,summary:"Represents a surface of revolution.\n   Revolutions can be incomplete (they can form arcs).",properties:[{signature:"Interval Angle",summary:"Gets the start and end angles of revolution in radians. \n     The interval angle must be increasing and satisfy \n     RhinoMath.ZeroTolerance < Angle.Length<= 2.0 * System.Math.PI.",since:6},{signature:"Line Axis",summary:"Gets the axis of revolution.",since:6},{signature:"Curve Curve",summary:"Gets the revolute curve.",since:6}],methods:[{signature:"static RevSurface Create(Curve revoluteCurve,Line axisOfRevolution)",summary:"Constructs a new surface of revolution from a generatrix curve and an axis.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface Create(Curve revoluteCurve,Line axisOfRevolution,double startAngleRadians,double endAngleRadians)",summary:"Constructs a new surface of revolution from a generatrix curve and an axis.\n     This overload accepts a slice start and end angles.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface Create(Line revoluteLine,Line axisOfRevolution)",summary:"Constructs a new surface of revolution from a generatrix line and an axis.\n     If the operation succeeds, results can be (truncated) cones, cylinders and circular hyperboloids.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface Create(Line revoluteLine,Line axisOfRevolution,double startAngleRadians,double endAngleRadians)",summary:"Constructs a new surface of revolution from a generatrix line and an axis.\n     This overload accepts a slice start and end angles.Results can be (truncated) cones, cylinders and circular hyperboloids, or can fail.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface Create(Polyline revolutePolyline,Line axisOfRevolution)",summary:"Constructs a new surface of revolution from a generatrix polyline and an axis.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface Create(Polyline revolutePolyline,Line axisOfRevolution,double startAngleRadians,double endAngleRadians)",summary:"Constructs a new surface of revolution from a generatrix polyline and an axis.\n     This overload accepts a slice start and end angles.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface CreateFromCone(Cone cone)",summary:"Constructs a new surface of revolution from the values of a cone.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface CreateFromCylinder(Cylinder cylinder)",summary:"Constructs a new surface of revolution from the values of a cylinder.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface CreateFromSphere(Sphere sphere)",summary:"Constructs a new surface of revolution from the values of a sphere.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."},{signature:"static RevSurface CreateFromTorus(Torus torus)",summary:"Constructs a new surface of revolution from the values of a torus.",since:5,returns:"A new surface of revolution, or None if any of the inputs is invalid or on error."}]},{name:"Rhino.Geometry.RTree",dataType:1,summary:"Represents a spatial search structure based on implementations of the\n   R-tree algorithm by Toni Gutman.",constructors:[{signature:"RTree()",summary:"Initializes a new, empty instance of the tree.",since:5}],properties:[{signature:"int Count",summary:"Gets the number of items in this tree.",since:5}],methods:[{signature:"static RTree CreateFromPointArray(IEnumerable<Point3d> points)",summary:"Constructs a new tree with an element for each pointcloud point.",since:6,returns:"A new tree, or None on error."},{signature:"static RTree CreateMeshFaceTree(Mesh mesh)",summary:"Constructs a new tree with an element for each face in the mesh.\n     The element id is set to the index of the face.",since:5,returns:"A new tree, or None on error."},{signature:"static RTree CreatePointCloudTree(PointCloud cloud)",summary:"Constructs a new tree with an element for each pointcloud point.",since:5,returns:"A new tree, or None on error."},{signature:"static IEnumerable<int[]> Point3dClosestPoints(IEnumerable<Point3d> hayPoints,IEnumerable<Point3d> needlePts,double limitDistance)",summary:"Finds the point in a list of 3D points that is closest to a test point.",since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> Point3dKNeighbors(IEnumerable<Point3d> hayPoints,IEnumerable<Point3d> needlePts,int amount)",summary:"Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.",since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> PointCloudClosestPoints(PointCloud pointcloud,IEnumerable<Point3d> needlePts,double limitDistance)",summary:"Finds the point in a list of 3D points that is closest to a test point.",since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static IEnumerable<int[]> PointCloudKNeighbors(PointCloud pointcloud,IEnumerable<Point3d> needlePts,int amount)",summary:"Finds a certain amout of points in a list of 3D points that are the k-closest to a test point.",since:6,returns:"An enumerable of arrays of indices; each array contains the indices for each of the needlePts."},{signature:"static bool SearchOverlaps(RTree treeA,RTree treeB,double tolerance,EventHandler<RTreeEventArgs> callback)",summary:"Searches two R-trees for all pairs elements whose bounding boxes overlap.",since:5,returns:"True if entire tree was searched.  It is possible no results were found."},{signature:"void Clear()",summary:"Removes all elements.",since:5},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"bool Insert(BoundingBox box,int elementId)",summary:"Inserts an element into the tree.",since:5,returns:"True if element was successfully inserted."},{signature:"bool Insert(BoundingBox box,IntPtr elementId)",summary:"Inserts an element into the tree.",since:5,returns:"True if element was successfully inserted."},{signature:"bool Insert(Point2d point,int elementId)",summary:"Inserts an element into the tree.",since:5,returns:"True if element was successfully inserted."},{signature:"bool Insert(Point2d point,IntPtr elementId)",summary:"Inserts an element into the tree.",since:5,returns:"True if element was successfully inserted."},{signature:"bool Insert(Point3d point,int elementId)",summary:"Inserts an element into the tree.",since:5,returns:"True if element was successfully inserted."},{signature:"bool Insert(Point3d point,IntPtr elementId)",summary:"Inserts an element into the tree.",since:5,returns:"True if element was successfully inserted."},{signature:"bool Remove(BoundingBox box,int elementId)",summary:"Removes an element from the tree.",since:5,returns:"True if element was successfully removed."},{signature:"bool Remove(BoundingBox box,IntPtr elementId)",summary:"Removes an element from the tree.",since:5,returns:"True if element was successfully removed."},{signature:"bool Remove(Point2d point,int elementId)",summary:"Removes an element from the tree.",since:5,returns:"True if element was successfully removed."},{signature:"bool Remove(Point3d point,int elementId)",summary:"Removes an element from the tree.",since:5,returns:"True if element was successfully removed."},{signature:"bool Remove(Point3d point,IntPtr elementId)",summary:"Removes an element from the tree.",since:5,returns:"True if element was successfully removed."},{signature:"bool Search(BoundingBox box,EventHandler<RTreeEventArgs> callback)",summary:"Searches for items in a bounding box.\n     The bounding box can be singular and contain exactly one single point.",since:5,returns:"True if entire tree was searched. It is possible no results were found."},{signature:"bool Search(BoundingBox box,EventHandler<RTreeEventArgs> callback,object tag)",summary:"Searches for items in a bounding box.\n     The bounding box can be singular and contain exactly one single point.",since:5,returns:"True if entire tree was searched. It is possible no results were found."},{signature:"bool Search(Sphere sphere,EventHandler<RTreeEventArgs> callback)",summary:"Searches for items in a sphere.",since:5,returns:"True if entire tree was searched. It is possible no results were found."},{signature:"bool Search(Sphere sphere,EventHandler<RTreeEventArgs> callback,object tag)",summary:"Searches for items in a sphere.",since:5,returns:"True if entire tree was searched. It is possible no results were found."}]},{name:"Rhino.Geometry.RTreeEventArgs",dataType:1,summary:"Represents event data that is passed when when an item that meets certain \n   criteria is found and the passed RTree event is raised.",properties:[{signature:"bool Cancel",summary:"Gets or sets a value that determines if the search should be conducted farther.",since:5},{signature:"int Id",summary:"Gets the identifier of the found item.",since:5},{signature:"int IdB",summary:"If search is using two r-trees, IdB is element b in the search.",since:5},{signature:"IntPtr IdBPtr",summary:"If search is using two r-trees, IdB is the element b pointer in the search.",since:5},{signature:"IntPtr IdPtr",summary:"Gets the identifier pointer of the found item.",since:5},{signature:"BoundingBox SearchBoundingBox",summary:"Bounding box bounds used during a search. You may modify the box in a search callback\n     to help reduce the bounds to search.",since:5},{signature:"Sphere SearchSphere",summary:"Sphere bounds used during a search. You can modify the sphere in a search callback to\n     help reduce the bounds to search.",since:5},{signature:"object Tag",summary:'Gets or sets an arbitrary object that can be attached to this event args.\n     This object will "stick" through a single search and can represent user-defined state.',since:5}]},{name:"Rhino.Geometry.ShutLiningCurveInfo",dataType:1,summary:"Contains shutlining curve information. This is used in .",constructors:[{signature:"ShutLiningCurveInfo(Curve curve,double radius,int profile,bool pull,bool isBump,IEnumerable<Interval> curveIntervals,bool enabled)",summary:"Creates a new instance of the ShutLining curve information class.",since:6}],properties:[{signature:"Curve Curve",summary:"The profile curve.",since:6},{signature:"ReadOnlyCollection<Interval> CurveIntervals",summary:"The parts of the curve to use as profiles.",since:6},{signature:"bool Enabled",summary:"If true, this curve is active.",since:6},{signature:"bool IsBump",summary:"True if profile constitutes a bump. See Rhino's Help for more information.",since:6},{signature:"int Profile",summary:">The profile type.",since:6},{signature:"bool Pull",summary:"True if the curve should be pulled.",since:6},{signature:"double Radius",summary:"The profile radius.",since:6}]},{name:"Rhino.Geometry.Silhouette",dataType:1,summary:"Information about silhouette curves that are generated from\n   geometry (surfaces, brep faces, meshes)",properties:[{signature:"Curve Curve",summary:"3D curve representing the shape of the silhouette.",since:6},{signature:"ComponentIndex GeometryComponentIndex",summary:"Gets the component index corresponding with this silhouette curve.\n     This field is only set when the entire silhouette curve is part of some geometry component.",since:6},{signature:"SilhouetteType SilhouetteType",summary:"Gets the type of this silhouette curve.",since:6}],methods:[{signature:"static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Point3d perspectiveCameraLocation,double tolerance,double angleToleranceRadians)",summary:"Compute silhouettes of a shape for a perspective projection.",since:6,returns:"Array of silhouette curves."},{signature:"static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Point3d perspectiveCameraLocation,double tolerance,double angleToleranceRadians,IEnumerable<Plane> clippingPlanes,CancellationToken cancelToken)",summary:"Compute silhouettes of a shape for a perspective projection.",since:6,returns:"Array of silhouette curves."},{signature:"static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Vector3d parallelCameraDirection,double tolerance,double angleToleranceRadians)",summary:"Compute silhouettes of a shape for a parallel projection.",since:6,returns:"Array of silhouette curves."},{signature:"static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,Vector3d parallelCameraDirection,double tolerance,double angleToleranceRadians,IEnumerable<Plane> clippingPlanes,CancellationToken cancelToken)",summary:"Compute silhouettes of a shape for a parallel projection.",since:6,returns:"Array of silhouette curves."},{signature:"static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,ViewportInfo viewport,double tolerance,double angleToleranceRadians)",summary:"Compute silhouettes of a shape for a specified projection.",since:6,returns:"Array of silhouette curves."},{signature:"static Silhouette[] Compute(GeometryBase geometry,SilhouetteType silhouetteType,ViewportInfo viewport,double tolerance,double angleToleranceRadians,IEnumerable<Plane> clippingPlanes,CancellationToken cancelToken)",summary:"Compute silhouettes of a shape for a specified projection.",since:6,returns:"Array of silhouette curves."},{signature:"static Silhouette[] ComputeDraftCurve(GeometryBase geometry,double draftAngle,Vector3d pullDirection,double tolerance,double angleToleranceRadians)",summary:"Computes draft curve silhouettes of a shape.",since:7,returns:"Array of silhouette curves."},{signature:"static Silhouette[] ComputeDraftCurve(GeometryBase geometry,double draftAngle,Vector3d pullDirection,double tolerance,double angleToleranceRadians,CancellationToken cancelToken)",summary:"Computes draft curve silhouettes of a shape.",since:7,returns:"Array of silhouette curves."}]},{name:"Rhino.Geometry.SilhouetteType",dataType:3,summary:"Enumerates the different types of silhouettes and their origins."},{name:"Rhino.Geometry.SmoothingCoordinateSystem",dataType:3,summary:"The direction of the smoothing used by Curve, Surface, and Mesh Smooth."},{name:"Rhino.Geometry.SpaceMorph",dataType:1,summary:"Represents a spacial, Euclidean morph.",properties:[{signature:"bool PreserveStructure",summary:"True if the morph should be done in a way that preserves the structure of the geometry.\n     In particular, for NURBS objects, True means that only the control points are moved.\n     The PreserveStructure value does not affect the way meshes and points are morphed.\n     The default is false.",since:5},{signature:"bool QuickPreview",summary:"True if the morph should be done as quickly as possible because the result\n     is being used for some type of dynamic preview. If QuickPreview is true,\n     the tolerance may be ignored.\n     The QuickPreview value does not affect the way meshes and points are morphed.\n     The default is false.",since:5},{signature:"double Tolerance",summary:"The desired accuracy of the morph. This value is primarily used for deforming\n     surfaces and breps. The default is 0.0 and any value <= 0.0 is ignored by\n     morphing functions. The Tolerance value does not affect the way meshes and points\n     are morphed.",since:5}],methods:[{signature:"static bool IsMorphable(GeometryBase geometry)",summary:"True if the geometry can be morphed by calling SpaceMorph.Morph(geometry)",since:5},{signature:"bool Morph(GeometryBase geometry)",summary:"Apply the space morph to geometry.",since:5,returns:"True on success, False on failure."},{signature:"bool Morph(Plane plane)",summary:"Apply the space morph to a plane.",since:6,returns:"True on success, False on failure."},{signature:"Point3d MorphPoint(Point3d point)",summary:"Morphs an Euclidean point. This method is abstract.",since:5,returns:"Resulting morphed point."}]},{name:"Rhino.Geometry.Sphere",dataType:2,summary:"Represents the plane and radius values of a sphere.",constructors:[{signature:"Sphere(Plane equatorialPlane,double radius)",summary:"Initializes a new sphere given the plane of the equator circle and radius.",since:5},{signature:"Sphere(Point3d center,double radius)",summary:"Initializes a new sphere given center point and radius.",since:5}],properties:[{signature:"static Sphere Unset",summary:"Gets a sphere with invalid members.",since:5},{signature:"BoundingBox BoundingBox",summary:"Gets the world aligned boundingbox for this Sphere. \n     If the Sphere is Invalid, an empty box is returned.",since:5},{signature:"Point3d Center",summary:"Gets or sets the center point of the sphere.",since:5},{signature:"double Diameter",summary:"Gets or sets the diameter for this sphere.",since:5},{signature:"Plane EquatorialPlane",summary:"Gets or sets the Equatorial plane for this sphere.",since:6},{signature:"Plane EquitorialPlane",summary:"Gets or sets the Equatorial plane for this sphere.",since:5},{signature:"bool IsValid",summary:"Gets a value that indicates whether the sphere is valid.",since:5},{signature:"Point3d NorthPole",summary:"Gets the point at the North Pole of the sphere.\n     This is the parameterization singularity that can be obtained,\n     at V value +Math.Pi/2.",since:5},{signature:"double Radius",summary:"Gets or sets the Radius for this sphere.",since:5},{signature:"Point3d SouthPole",summary:"Gets the point at the South Pole of the sphere.\n     This is the parameterization singularity that can be obtained,\n     at V value -Math.Pi/2.",since:5}],methods:[{signature:"static Sphere FitSphereToPoints(IEnumerable<Point3d> points)",summary:"Attempts to fit a sphere to a collection of points.",since:5,returns:"The Sphere that best approximates the points or Sphere.Unset on failure."},{signature:"bool ClosestParameter(Point3d testPoint,double longitudeRadians,double latitudeRadians)",summary:"Finds the angle parameters on this sphere that are closest to a test point.",since:5,returns:"True on success, False on failure. This function will fail if the point it coincident with the sphere center."},{signature:"Point3d ClosestPoint(Point3d testPoint)",summary:"Returns point on sphere that is closest to given point.",since:5,returns:"Point on sphere surface closest to testPoint."},{signature:"bool EpsilonEquals(Sphere other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"Circle LatitudeDegrees(double degrees)",summary:"Computes the parallel at a specific latitude angle.\n     The angle is specified in degrees.",since:5,returns:"A circle."},{signature:"Circle LatitudeRadians(double radians)",summary:"Computes the parallel at a specific latitude angle.\n     The angle is specified in radians.",since:5,returns:"A circle."},{signature:"Circle LongitudeDegrees(double degrees)",summary:"Computes the meridian at a specific longitude angle.\n     The angle is specified in degrees.",since:5,returns:"A circle."},{signature:"Circle LongitudeRadians(double radians)",summary:"Computes the meridian at a specific longitude angle.\n     The angle is specified in radians.",since:5,returns:"A circle."},{signature:"Vector3d NormalAt(double longitudeRadians,double latitudeRadians)",summary:"Computes the normal at a specific angular location on the sphere.",since:5,returns:"A vector."},{signature:"Point3d PointAt(double longitudeRadians,double latitudeRadians)",summary:"Evaluates the sphere at specific longitude and latitude angles.",since:5,returns:"A point value."},{signature:"bool Rotate(double sinAngle,double cosAngle,Vector3d axisOfRotation)",summary:"Rotates this sphere about the center point.",since:5,returns:"True on success; False on failure."},{signature:"bool Rotate(double sinAngle,double cosAngle,Vector3d axisOfRotation,Point3d centerOfRotation)",summary:"Rotates this sphere about a point and an axis.",since:5,returns:"True on success; False on failure."},{signature:"bool Rotate(double angleRadians,Vector3d axisOfRotation)",summary:"Rotates the sphere about the center point.",since:5,returns:"True on success; False on failure."},{signature:"bool Rotate(double angleRadians,Vector3d axisOfRotation,Point3d centerOfRotation)",summary:"Rotates this sphere about a point and an axis.",since:5,returns:"True on success; False on failure."},{signature:"Brep ToBrep()",summary:"Converts this sphere is it Brep representation",since:5},{signature:"NurbsSurface ToNurbsSurface()",summary:"Converts this sphere to its NurbsSurface representation. \n     This is synonymous with calling NurbsSurface.CreateFromSphere().",since:5,returns:"A nurbs surface representation of this sphere or null."},{signature:"RevSurface ToRevSurface()",summary:"Converts this Sphere to a RevSurface representation. \n     This is synonymous with calling RevSurface.CreateFromSphere().",since:5,returns:"A surface of revolution representation of this sphere or null."},{signature:"bool Transform(Transform xform)",summary:"Transforms this sphere. Note that non-similarity preserving transformations \n     cannot be applied to a sphere as that would result in an ellipsoid.",since:5,returns:"True on success, False on failure."},{signature:"bool Translate(Vector3d delta)",summary:"Moves this sphere along a motion vector.",since:5,returns:"True on success; False on failure."}]},{name:"Rhino.Geometry.SubD",dataType:1,summary:"Subdivision surface",constructors:[{signature:"SubD()",summary:"Create a new instance of SubD geometry",since:7}],properties:[{signature:"SubDEdgeList Edges",summary:"All edges in this SubD",since:7},{signature:"SubDFaceList Faces",summary:"All faces in this SubD",since:7},{signature:"bool IsSolid",summary:'Test subd to see if the active level is a solid.  \n     A "solid" is a closed oriented manifold, or a closed oriented manifold.',since:7},{signature:"SubDVertexList Vertices",summary:"All vertices in this SubD",since:7}],methods:[{signature:"static SubD CreateFromMesh(Mesh mesh)",summary:"Create a new SubD from a mesh",since:7},{signature:"static SubD CreateFromMesh(Mesh mesh,SubDCreationOptions options)",summary:"Create a new SubD from a mesh",since:7},{signature:"void ClearEvaluationCache()",summary:"Clear cached information that depends on the location of vertex control points",since:7},{signature:"bool Subdivide(int count)",summary:"Apply the Catmull-Clark subdivision algorithm and save the results in\n     this SubD",since:7,returns:"True on success"},{signature:"Brep ToBrep()",summary:"Create a Brep based on this SubD geometry",since:7},{signature:"uint UpdateAllTagsAndSectorCoefficients()",summary:"Updates vertex tag, edge tag, and edge coefficient values on the active\n     level. After completing custom editing operations that modify the\n     topology of the SubD control net or changing values of vertex or edge\n     tags, the tag and sector coefficients information on nearby components\n     in the edited areas need to be updated.",since:7,returns:"Number of vertices and edges that were changed during the update."}]},{name:"Rhino.Geometry.SubDComponent",dataType:1,summary:"A part of SubD geometry. Common base class for vertices, faces, and edges",properties:[{signature:"uint Id",summary:"Unique id within the parent SubD for this item",since:7},{signature:"SubD ParentSubD",summary:"SubD that this component belonds to",since:7}]},{name:"Rhino.Geometry.SubDCreationOptions",dataType:1,summary:"Options used for creating a SubD",constructors:[{signature:"SubDCreationOptions()",summary:"Create default options",since:7}],properties:[{signature:"static SubDCreationOptions ConvexCornerAtMeshCorner",summary:"Look for convex corners at sub-D vertices with 2 edges that have an\n     included angle <= 90 degrees.",since:7},{signature:"static SubDCreationOptions InteriorCreaseAtMeshCrease",summary:"Create an interior sub-D crease along coincident input mesh edges\n     where the vertex normal directions at one end differ by at \n     least 30 degrees.",since:7},{signature:"static SubDCreationOptions InteriorCreaseAtMeshEdge",summary:"Create an interior sub-D crease along all coincident input mesh edges.",since:7},{signature:"static SubDCreationOptions Smooth",summary:"No interior creases and no corners.",since:7},{signature:"ConvexCornerOption ConvexCornerTest",summary:"how convex corners are treated",since:7},{signature:"InteriorCreaseOption InteriorCreaseTest",summary:"how interior creases are treated",since:7},{signature:"bool InterpolateMeshVertices",summary:"If false, input mesh vertex locations will be used to set subd vertex control net locations.\n     If true, input mesh vertex locations will be used to set subd vertex limit surface locations.",since:7},{signature:"double MaximumConvexCornerAngleRadians",summary:"If ConvexCornerTest is at_mesh_corner, then an input mesh boundary\n     vertex becomes a sub-D corner when the number of edges that end at the\n     vertex is <= MaximumConvexCornerEdgeCount edges and the corner angle\n     is <= MaximumConvexCornerAngleRadians.",since:7},{signature:"uint MaximumConvexCornerEdgeCount",summary:"If ConvexCornerTest is at_mesh_corner, then an input mesh boundary\n     vertex becomes a sub-D corner when the number of edges that end at the\n     vertex is <= MaximumConvexCornerEdgeCount edges and the corner angle\n     is <= MaximumConvexCornerAngleRadians.",since:7},{signature:"double MinimumCreaseAngleRadians",summary:"When the interior crease option is AtMeshCreases the value of\n     MinimumCreaseAngleRadians determines which coincident input mesh edges\n     generate sub-D creases.\n     If the input mesh has vertex normals, and the angle between vertex\n     normals is > MinimumCreaseAngleRadians at an end of a coincident\n     input mesh edge, the the correspondeing sub-D edge will be a crease.",since:7}],methods:[{signature:"void Dispose()",summary:"Delete unmanager pointer for this",since:7}]},{name:"Rhino.Geometry.SubDEdge",dataType:1,summary:"Single edge of a SubD",properties:[{signature:"Line ControlNetLine",summary:"Line representing the control net end points",since:7},{signature:"int FaceCount",summary:"Number of faces for this edge",since:7},{signature:"SubDEdgeTag Tag",summary:"identifies the type of subdivision edge",since:7},{signature:"SubDVertex VertexFrom",summary:"Start vertex for this edge",since:7},{signature:"SubDVertex VertexTo",summary:"End vertex for this edge",since:7}],methods:[{signature:"SubDFace FaceAt(int index)",summary:"Retrieve a SubDFace from this edge",since:7},{signature:"NurbsCurve ToNurbsCurve(bool clampEnds)",summary:"Get a cubic, uniform, nonrational, NURBS curve that is on the\n     edge's limit curve.",since:7}]},{name:"Rhino.Geometry.SubDFace",dataType:1,summary:"Single face of a SubD",properties:[{signature:"int EdgeCount",summary:"Number of edges for this face. Note that EdgeCount is always the same\n     as VertexCount. Two properties are provided simply for clarity.",since:7},{signature:"Point3d LimitSurfaceCenterPoint",summary:"Get the limit surface point location at the center of the face",since:7},{signature:"int VertexCount",summary:"Number of vertices for this face. Note that EdgeCount is always the same\n     as VertexCount. Two properties are provided simply for clarity.",since:7}],methods:[{signature:"SubDEdge EdgeAt(int index)",summary:"Get an edge at a given index",since:7},{signature:"bool EdgeDirectionMatchesFaceOrientation(int index)",summary:"Check if a given edge in this face has the same direction as the face orientation",since:7},{signature:"SubDVertex VertexAt(int index)",summary:"Get a vertex that this face uses by index",since:7}]},{name:"Rhino.Geometry.SubDVertex",dataType:1,summary:"Single vertex of a SubD",properties:[{signature:"Point3d ControlNetPoint",summary:'Location of the "control net" point that this SubDVertex represents',since:7},{signature:"int EdgeCount",summary:"Number of edges for this vertex",since:7},{signature:"IEnumerable<SubDEdge> Edges",summary:"All edges that this vertex is part of",since:7},{signature:"int FaceCount",summary:"Number of faces for this vertex",since:7},{signature:"SubDVertex Next",summary:"Next vertex in linked list of vertices on this level",since:7},{signature:"SubDVertex Previous",summary:"Previous vertex in linked list of vertices on this level",since:7}],methods:[{signature:"SubDEdge EdgeAt(int index)",summary:"Retrieve a SubDEdge from this vertex",since:7}]},{name:"Rhino.Geometry.SumSurface",dataType:1,summary:"Represents a sum surface, or an extrusion of a curve along a curved path.",methods:[{signature:"static SumSurface Create(Curve curveA,Curve curveB)",summary:"Constructs a new sum surface by extruding a curve A along a path B.",since:5,returns:"A new sum surface on success; None on failure."}]},{name:"Rhino.Geometry.Surface",dataType:1,summary:"Represents a base class that is common to most RhinoCommon surface types.\n   A surface represents an entity that can be all visited by providing\n   two independent parameters, usually called (u, v), or sometimes (s, t).",properties:[{signature:"bool IsSolid",summary:"Gets a values indicating whether a surface is solid.",since:5}],methods:[{signature:"static Surface CreateExtrusion(Curve profile,Vector3d direction)",summary:"Constructs a surface by extruding a curve along a vector.",since:5,returns:"A surface on success or None on failure."},{signature:"static Surface CreateExtrusionToPoint(Curve profile,Point3d apexPoint)",summary:"Constructs a surface by extruding a curve to a point.",since:5,returns:"A Surface on success or None on failure."},{signature:"static Surface CreatePeriodicSurface(Surface surface,int direction)",summary:"Constructs a periodic surface from a base surface and a direction.",since:5,returns:"A Surface on success or None on failure."},{signature:"static Surface CreatePeriodicSurface(Surface surface,int direction,bool bSmooth)",summary:"Constructs a periodic surface from a base surface and a direction.",since:6,returns:"A periodic surface if successful, None on failure."},{signature:"static Surface[] CreateRollingBallFillet(Surface surfaceA,bool flipA,Surface surfaceB,bool flipB,double radius,double tolerance)",summary:"Constructs a rolling ball fillet between two surfaces.",since:5,returns:"A new array of rolling ball fillet surfaces; this array can be empty on failure."},{signature:"static Surface[] CreateRollingBallFillet(Surface surfaceA,Point2d uvA,Surface surfaceB,Point2d uvB,double radius,double tolerance)",summary:"Constructs a rolling ball fillet between two surfaces.",since:5,returns:"A new array of rolling ball fillet surfaces; this array can be empty on failure."},{signature:"static Surface[] CreateRollingBallFillet(Surface surfaceA,Surface surfaceB,double radius,double tolerance)",summary:"Constructs a rolling ball fillet between two surfaces.",since:5,returns:"A new array of rolling ball fillet surfaces; this array can be empty on failure."},{signature:"static Surface CreateSoftEditSurface(Surface surface,Point2d uv,Vector3d delta,double uLength,double vLength,double tolerance,bool fixEnds)",summary:"Creates a soft edited surface from an exising surface using a smooth field of influence.",since:6,returns:"The soft edited surface if successful. None on failure."},{signature:"bool ClosestPoint(Point3d testPoint,double u,double v)",summary:"Input the parameters of the point on the surface that is closest to testPoint.",since:5,returns:"True on success, False on failure."},{signature:"IsoStatus ClosestSide(double u,double v)",summary:"Gets the side that is closest, in terms of 3D-distance, to a U and V parameter.",since:5,returns:"A side."},{signature:"SurfaceCurvature CurvatureAt(double u,double v)",summary:"Computes the curvature at the given UV coordinate.",since:5,returns:"Surface Curvature data for the point at uv or None on failure."},{signature:"int Degree(int direction)",summary:"Returns the maximum algebraic degree of any span\n     (or a good estimate if curve spans are not algebraic).",since:5,returns:"The maximum degree."},{signature:"Interval Domain(int direction)",summary:"Gets the domain in a direction.",since:5,returns:"An interval value."},{signature:"bool Evaluate(double u,double v,int numberDerivatives,Point3d point,Vector3d[] derivatives)",summary:"Evaluates a surface mathematically.",since:5,returns:"True if the operation succeeded; False otherwise."},{signature:"Surface Extend(IsoStatus edge,double extensionLength,bool smooth)",summary:"Extends an untrimmed surface along one edge.",since:5,returns:"New extended surface on success."},{signature:"Surface Fit(int uDegree,int vDegree,double fitTolerance)",summary:"Fits a new surface through an existing surface.",since:5,returns:"A surface, or None on error."},{signature:"bool FrameAt(double u,double v,Plane frame)",summary:"Computes the orient plane on a surface given a U and V parameter.\n     This is the simple evaluation call with no error handling.",since:5,returns:"True if this operation succeeded; otherwise false."},{signature:"bool GetNextDiscontinuity(int direction,Continuity continuityType,double t0,double t1,double t)",summary:"Searches for a derivative, tangent, or curvature discontinuity.",since:5,returns:"Parametric continuity tests c = (C0_continuous, ..., G2_continuous):\n     TRUE if a parametric discontinuity was found strictly between t0 and t1.\n     Note well that all curves are parametrically continuous at the ends of their domains.\n     \n     Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):\n     TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1 is the\n     at the end of a curve. Note well that all open curves (IsClosed()=false) are locus\n     discontinuous at the ends of their domains.  All closed curves (IsClosed()=true) are\n     at least C0_locus_continuous at the ends of their domains."},{signature:"bool GetNurbsFormParameterFromSurfaceParameter(double surfaceS,double surfaceT,double nurbsS,double nurbsT)",summary:"Translates a parameter from the current surface to the parameter space of the surface returned by .",since:6,returns:"True if the operation succeded; otherwise, false."},{signature:"double[] GetSpanVector(int direction)",summary:'Gets array of span "knots".',since:5,returns:"An array with span vectors; or None on error."},{signature:"bool GetSurfaceParameterFromNurbsFormParameter(double nurbsS,double nurbsT,double surfaceS,double surfaceT)",summary:"Translates a parameter from a value on the surface returned by  to the current surface.",since:6,returns:"True if the operation succeded; otherwise, false."},{signature:"bool GetSurfaceSize(double width,double height)",summary:"Gets an estimate of the size of the rectangle that would be created\n     if the 3d surface where flattened into a rectangle.",since:5,returns:"True if successful."},{signature:"int HasNurbsForm()",summary:"Is there a NURBS surface representation of this surface.",since:5,returns:"0 unable to create NURBS representation with desired accuracy.\n     1 success - NURBS parameterization matches the surface's\n     2 success - NURBS point locus matches the surface's and the\n     domain of the NURBS surface is correct. However, This surface's\n     parameterization and the NURBS surface parameterization may not\n     match.  This situation happens when getting NURBS representations\n     of surfaces that have a transendental parameterization like spheres,\n     cylinders, and cones."},{signature:"NurbsCurve InterpolatedCurveOnSurface(IEnumerable<Point3d> points,double tolerance)",summary:"Constructs an interpolated curve on a surface, using 3D points.",since:5,returns:"A new nurbs curve, or None on error."},{signature:"NurbsCurve InterpolatedCurveOnSurfaceUV(IEnumerable<Point2d> points,double tolerance)",summary:"Returns a curve that interpolates points on a surface. The interpolant lies on the surface.",since:5,returns:"A new NURBS curve if successful, or None on error."},{signature:"NurbsCurve InterpolatedCurveOnSurfaceUV(IEnumerable<Point2d> points,double tolerance,bool closed,int closedSurfaceHandling)",summary:"Returns a curve that interpolates points on a surface. The interpolant lies on the surface.",since:6.18,returns:"A new NURBS curve if successful, or None on error."},{signature:"int IsAtSeam(double u,double v)",summary:"Tests if a surface parameter value is at a seam.",since:5,returns:"0 if not a seam,\n     1 if u == Domain(0)[i] and srf(u, v) == srf(Domain(0)[1-i], v)\n     2 if v == Domain(1)[i] and srf(u, v) == srf(u, Domain(1)[1-i])\n     3 if 1 and 2 are true."},{signature:"bool IsAtSingularity(double u,double v,bool exact)",summary:"Tests if a surface parameter value is at a singularity.",since:5,returns:"True if surface is singular at (s,t)"},{signature:"bool IsClosed(int direction)",summary:"Gets a value indicating if the surface is closed in a direction.",since:5,returns:"The indicating boolean value."},{signature:"bool IsCone()",summary:"Determines if the surface is a portion of a cone within RhinoMath.ZeroTolerance.",since:5,returns:"True if the surface is a portion of a cone."},{signature:"bool IsCone(double tolerance)",summary:"Determines if the surface is a portion of a cone within a given tolerance.",since:5,returns:"True if the surface is a portion of a cone."},{signature:"bool IsContinuous(Continuity continuityType,double u,double v)",summary:"Tests continuity at a surface parameter value.",since:5,returns:"True if the surface has at least the specified continuity at the (u,v) parameter."},{signature:"bool IsCylinder()",summary:"Determines if the surface is a portion of a cylinder within RhinoMath.ZeroTolerance.",since:5,returns:"True if the surface is a portion of a cylinder."},{signature:"bool IsCylinder(double tolerance)",summary:"Determines if the surface is a portion of a cylinder within a given tolerance.",since:5,returns:"True if the surface is a portion of a cylinder."},{signature:"IsoStatus IsIsoparametric(BoundingBox bbox)",summary:"Determines if a 2d bounding box is iso-parameteric in the parameter space of this surface.",since:5,returns:"IsoStatus flag describing the iso-parametric relationship between the surface and the bounding box."},{signature:"IsoStatus IsIsoparametric(Curve curve)",summary:"Determines if a 2d curve is iso-parameteric in the parameter space of this surface.",since:5,returns:"IsoStatus flag describing the iso-parametric relationship between the surface and the curve."},{signature:"IsoStatus IsIsoparametric(Curve curve,Interval curveDomain)",summary:"Determines if a 2D curve is iso-parameteric in the parameter space of this surface.",since:5,returns:"IsoStatus flag describing the iso-parametric relationship between the surface and the curve."},{signature:"Curve IsoCurve(int direction,double constantParameter)",summary:"Gets isoparametric curve.",since:5,returns:"An isoparametric curve or None on error."},{signature:"bool IsPeriodic(int direction)",summary:"Gets a value indicating if thr surface is periodic in a direction (default is false).",since:5,returns:"The indicating boolean value."},{signature:"bool IsPlanar()",summary:"Tests a surface to see if it is planar to zero tolerance.",since:5,returns:"True if the surface is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12)."},{signature:"bool IsPlanar(double tolerance)",summary:"Tests a surface to see if it is planar to a given tolerance.",since:5,returns:"True if there is a plane such that the maximum distance from\n     the surface to the plane is <= tolerance."},{signature:"bool IsSingular(int side)",summary:"True if surface side is collapsed to a point.",since:5,returns:"True if this specific side of the surface is singular; otherwise, false."},{signature:"bool IsSphere()",summary:"Determines if the surface is a portion of a sphere within RhinoMath.ZeroTolerance.",since:5,returns:"True if the surface is a portion of a sphere."},{signature:"bool IsSphere(double tolerance)",summary:"Determines if the surface is a portion of a sphere within a given tolerance.",since:5,returns:"True if the surface is a portion of a sphere."},{signature:"bool IsTorus()",summary:"Determines if the surface is a portion of a torus within RhinoMath.ZeroTolerance.",since:5,returns:"True if the surface is a portion of a torus."},{signature:"bool IsTorus(double tolerance)",summary:"Determines if the surface is a portion of a torus within a given tolerance.",since:5,returns:"True if the surface is a portion of a torus."},{signature:"bool LocalClosestPoint(Point3d testPoint,double seedU,double seedV,double u,double v)",summary:"Find parameters of the point on a surface that is locally closest to\n     the testPoint. The search for a local close point starts at seed parameters.",since:6.3,returns:"True if the search is successful, False if the search fails."},{signature:"Vector3d NormalAt(double u,double v)",summary:"Computes the surface normal at a point.\n     This is the simple evaluation call - it does not support error handling.",since:5,returns:"The normal."},{signature:"Surface Offset(double distance,double tolerance)",summary:"Constructs a new surface which is offset from the current surface.",since:5,returns:"The offsetted surface or None on failure."},{signature:"Point3d PointAt(double u,double v)",summary:"Evaluates a point at a given parameter.",since:5,returns:"Point3d.Unset on failure."},{signature:"Curve Pullback(Curve curve3d,double tolerance)",summary:"Pulls a 3d curve back to the surface's parameter space.",since:5,returns:"2d curve."},{signature:"Curve Pullback(Curve curve3d,double tolerance,Interval curve3dSubdomain)",summary:"Pulls a 3d curve back to the surface's parameter space.",since:5,returns:"2d curve."},{signature:"Curve Pushup(Curve curve2d,double tolerance)",summary:"Computes a 3d curve that is the composite of a 2d curve and the surface map.",since:5,returns:"3d curve."},{signature:"Curve Pushup(Curve curve2d,double tolerance,Interval curve2dSubdomain)",summary:"Computes a 3d curve that is the composite of a 2d curve and the surface map.",since:5,returns:"3d curve."},{signature:"NurbsSurface Rebuild(int uDegree,int vDegree,int uPointCount,int vPointCount)",summary:"Rebuilds an existing surface to a given degree and point count.",since:5,returns:"new rebuilt surface on success. None on failure."},{signature:"NurbsSurface RebuildOneDirection(int direction,int pointCount,LoftType loftType,double refitTolerance)",summary:"Rebuilds an existing surface with a new surface to a given point count in either the u or v directions independently.",since:6.7,returns:"new rebuilt surface on success. None on failure."},{signature:"Surface Reverse(int direction)",summary:"Reverses parameterization Domain changes from [a,b] to [-b,-a]",since:5,returns:"a new reversed surface on success."},{signature:"Surface Reverse(int direction,bool inPlace)",summary:"Same as Reverse, but if inPlace is set to True this Surface is modified\n     instead of a new copy being created.",since:5.8,returns:"If inPlace is False, a new reversed surface on success. If inPlace is\n     true, this surface instance is returned on success."},{signature:"bool SetDomain(int direction,Interval domain)",summary:"Sets the domain in a direction.",since:5,returns:"True if setting succeeded, otherwise false."},{signature:"Curve ShortPath(Point2d start,Point2d end,double tolerance)",summary:"Constructs a geodesic between 2 points, used by ShortPath command in Rhino.",since:5,returns:"a geodesic curve on the surface on success. None on failure."},{signature:"Surface Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem)",summary:"Smooths a surface by averaging the positions of control points in a specified region.",since:6,returns:"The smoothed surface if successful, None otherwise."},{signature:"Surface Smooth(double smoothFactor,bool bXSmooth,bool bYSmooth,bool bZSmooth,bool bFixBoundaries,SmoothingCoordinateSystem coordinateSystem,Plane plane)",summary:"Smooths a surface by averaging the positions of control points in a specified region.",since:6,returns:"The smoothed surface if successful, None otherwise."},{signature:"int SpanCount(int direction)",summary:"Gets number of smooth nonempty spans in the parameter direction.",since:5,returns:"The span count."},{signature:"Surface[] Split(int direction,double parameter)",summary:"Splits (divides) the surface into two parts at the specified parameter",since:5,returns:"Array of two surfaces on success"},{signature:"Brep ToBrep()",summary:"Converts the surface into a Brep.",since:5,returns:"A Brep with a similar shape like this surface or null."},{signature:"NurbsSurface ToNurbsSurface()",summary:"Gets a NURBS surface representation of this surface. Default \n     tolerance of 0.0 is used.",since:5,returns:"NurbsSurface on success, None on failure."},{signature:"NurbsSurface ToNurbsSurface(double tolerance,int accuracy)",summary:"Gets a NURBS surface representation of this surface.",since:5,returns:"NurbsSurface on success, None on failure."},{signature:"Surface Transpose()",summary:"Transposes surface parameterization (swap U and V)",since:5,returns:"New transposed surface on success, None on failure."},{signature:"Surface Transpose(bool inPlace)",summary:"Transposes surface parameterization (swap U and V)",since:5.8,returns:"New transposed surface on success, None on failure."},{signature:"Surface Trim(Interval u,Interval v)",summary:"Constructs a sub-surface that covers the specified UV trimming domain.",since:5,returns:"SubSurface on success, None on failure."},{signature:"bool TryGetCone(Cone cone)",summary:"Tests a surface to see if it is a portion of a cone within RhinoMath.ZeroTolerance and return the cone.",since:5,returns:"True if the surface is a portion of a cone."},{signature:"bool TryGetCone(Cone cone,double tolerance)",summary:"Tests a surface to see if it is a portion of a cone and returns the cone.",since:5,returns:"True if the surface is a portion of a cone."},{signature:"bool TryGetCylinder(Cylinder cylinder)",summary:"Tests a surface to see if it is a portion of a cylinder within RhinoMath.ZeroTolerance and return the cylinder.",since:5,returns:"True if the surface is a portion of a cylinder."},{signature:"bool TryGetCylinder(Cylinder cylinder,double tolerance)",summary:"Tests a surface to see if it is a portion of a cylinder and return the infinite cylinder.",since:5,returns:"True if the surface is a portion of a cylinder."},{signature:"bool TryGetFiniteCylinder(Cylinder cylinder,double tolerance)",summary:"Tests a surface with the assumption that it might be a right circular cylinder and returns this geometry.",since:6,returns:"True if the surface is a portion of a cylinder."},{signature:"bool TryGetPlane(Plane plane)",summary:"Tests a surface for planarity and return the plane.",since:5,returns:"True if there is a plane such that the maximum distance from the surface to the plane is <= RhinoMath.ZeroTolerance."},{signature:"bool TryGetPlane(Plane plane,double tolerance)",summary:"Tests a surface for planarity and return the plane.",since:5,returns:"True if there is a plane such that the maximum distance from the surface to the plane is <= tolerance."},{signature:"bool TryGetSphere(Sphere sphere)",summary:"Test a surface to see if it is a portion of a sphere and return the sphere.",since:5,returns:"True if the surface is a portion of a sphere."},{signature:"bool TryGetSphere(Sphere sphere,double tolerance)",summary:"Test a surface to see if it is a portion of a sphere and return the sphere.",since:5,returns:"True if the surface is a portion of a sphere."},{signature:"bool TryGetTorus(Torus torus)",summary:"Tests a surface to see if it is a portion of a torus within RhinoMath.ZeroTolerance and returns the torus.",since:5,returns:"True if the surface is a portion of a torus."},{signature:"bool TryGetTorus(Torus torus,double tolerance)",summary:"Tests a surface to see if it is a portion of a torus and returns the torus.",since:5,returns:"True if the surface is a portion of a torus."},{signature:"Surface VariableOffset(double uMinvMin,double uMinvMax,double uMaxvMin,double uMaxvMax,double tolerance)",summary:"Copies a surface so that all locations at the corners of the copied surface are specified distances from the original surface.",since:6.13,returns:"The offset surface if successful, None otherwise."},{signature:"Surface VariableOffset(double uMinvMin,double uMinvMax,double uMaxvMin,double uMaxvMax,IEnumerable<Point2d> interiorParameters,IEnumerable<double> interiorDistances,double tolerance)",summary:"Copies a surface so that all locations at the corners, and from specified interior locations, of the copied surface are specified distances from the original surface.",since:6.13,returns:"The offset surface if successful, None otherwise."}]},{name:"Rhino.Geometry.SurfaceCurvature",dataType:1,summary:"Maintains computed information for surface curvature evaluation.",properties:[{signature:"double Gaussian",summary:"Gets the Gaussian curvature value at UV.",since:5},{signature:"double Mean",summary:"Gets the Mean curvature value at UV.",since:5},{signature:"Vector3d Normal",summary:"Gets the surface normal at UV.",since:5},{signature:"Point3d Point",summary:"Gets the surface point at UV.",since:5},{signature:"Point2d UVPoint",summary:"Gets the UV location where the curvature was computed.",since:5}],methods:[{signature:"Vector3d Direction(int direction)",summary:"Gets the principal curvature direction vector.",since:5,returns:"The specified direction vector."},{signature:"double Kappa(int direction)",summary:"Gets the Kappa curvature value.",since:5,returns:"The specified kappa value."},{signature:"Circle OsculatingCircle(int direction)",summary:"Computes the osculating circle along the given direction.",since:5,returns:"The osculating circle in the given direction or Circle.Unset on failure."}]},{name:"Rhino.Geometry.SurfaceProxy",dataType:1,summary:"Provides a base class to brep faces and other surface proxies."},{name:"Rhino.Geometry.SweepOneRail",dataType:1,summary:"Utility class for generating Breps by sweeping cross section curves over a single rail curve. \n   Note, this class has been superceeded by the Rhino.Geometry.Brep.CreateFromSweep static functions.",constructors:[{signature:"SweepOneRail()",since:5}],properties:[{signature:"double AngleToleranceRadians",since:5},{signature:"bool ClosedSweep",summary:"If the input rail is closed, ClosedSweep determines if the swept breps will also\n     be closed.",since:5},{signature:"bool GlobalShapeBlending",summary:"If true, the sweep is linearly blended from one end to the other,\n     creating sweeps that taper from one cross-section curve to the other.\n     If false, the sweep stays constant at the ends and changes more\n     rapidly in the middle.",since:5.1},{signature:"bool IsFreeform",since:5},{signature:"bool IsRoadlike",since:5},{signature:"bool IsRoadlikeFront",since:5},{signature:"bool IsRoadlikeTop",since:5},{signature:"bool IsRoadlineRight",since:5},{signature:"int MiterType",summary:"0: don't miter,  1: intersect surfaces and trim sweeps,  2: rotate shapes at kinks and don't trim.",since:5},{signature:"double SweepTolerance",since:5}],methods:[{signature:"Brep[] PerformSweep(Curve rail,Curve crossSection)",since:5},{signature:"Brep[] PerformSweep(Curve rail,Curve crossSection,double crossSectionParameter)",since:5},{signature:"Brep[] PerformSweep(Curve rail,IEnumerable<Curve> crossSections)",since:5},{signature:"Brep[] PerformSweep(Curve rail,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail,Curve crossSection,double crossSectionParameter,int rebuildCount)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail,Curve crossSection,int rebuildCount)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters,int rebuildCount)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail,IEnumerable<Curve> crossSections,int rebuildCount)",since:5},{signature:"Brep[] PerformSweepRefit(Curve rail,Curve crossSection,double refitTolerance)",since:5},{signature:"Brep[] PerformSweepRefit(Curve rail,Curve crossSection,double crossSectionParameter,double refitTolerance)",since:5},{signature:"Brep[] PerformSweepRefit(Curve rail,IEnumerable<Curve> crossSections,double refitTolerance)",since:5},{signature:"Brep[] PerformSweepRefit(Curve rail,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters,double refitTolerance)",since:5},{signature:"void SetRoadlikeUpDirection(Vector3d up)",since:5},{signature:"void SetToRoadlikeFront()",since:5},{signature:"void SetToRoadlikeRight()",since:5},{signature:"void SetToRoadlikeTop()",since:5}]},{name:"Rhino.Geometry.SweepRebuild",dataType:3,summary:"Rebuild types for creating swept surfaces"},{name:"Rhino.Geometry.SweepTwoRail",dataType:1,summary:"Utility class for generating Breps by sweeping cross section curves over two rail curves.\n   Note, this class has been superceeded by the Rhino.Geometry.Brep.CreateFromSweep static functions.",constructors:[{signature:"SweepTwoRail()",since:5}],properties:[{signature:"double AngleToleranceRadians",summary:"Gets or sets the angle tolerance in radians.",since:5},{signature:"bool ClosedSweep",summary:"If the input rails are closed, ClosedSweep determines if the swept Breps will also be closed.",since:5},{signature:"bool MaintainHeight",summary:"Removes the association between the height scaling from the width scaling.",since:5},{signature:"double SweepTolerance",summary:"Gets or sets the sweeping tolerance.",since:5}],methods:[{signature:"Brep[] PerformSweep(Curve rail1,Curve rail2,Curve crossSection)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"Brep[] PerformSweep(Curve rail1,Curve rail2,Curve crossSection,double crossSectionParameterRail1,double crossSectionParameterRail2)",since:5},{signature:"Brep[] PerformSweep(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"Brep[] PerformSweep(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParameters1,IEnumerable<double> crossSectionParameters2)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,Curve crossSection,double crossSectionParameterRail1,double crossSectionParameterRail2,int rebuildCount)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,Curve crossSection,int rebuildCount)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParametersRail1,IEnumerable<double> crossSectionParametersRail2,int rebuildCount)",since:5},{signature:"Brep[] PerformSweepRebuild(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,int rebuildCount)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"Brep[] PerformSweepRefit(Curve rail1,Curve rail2,Curve crossSection,double refitTolerance)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"Brep[] PerformSweepRefit(Curve rail1,Curve rail2,Curve crossSection,double crossSectionParameterRail1,double crossSectionParameterRail2,double refitTolerance)",since:5},{signature:"Brep[] PerformSweepRefit(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,double refitTolerance)",summary:"Sweep2 function that fits a surface through profile curves that define the surface cross-sections\n     and two curves that defines a surface edge.",since:5,returns:"Array of Brep sweep results"},{signature:"Brep[] PerformSweepRefit(Curve rail1,Curve rail2,IEnumerable<Curve> crossSections,IEnumerable<double> crossSectionParametersRail1,IEnumerable<double> crossSectionParametersRail2,double refitTolerance)",since:5}]},{name:"Rhino.Geometry.TextDot",dataType:1,summary:"Represents a text dot, or an annotation entity with text that always faces the camera and always has the same size.\n   This class refers to the geometric element that is independent from the document.",constructors:[{signature:"TextDot(string text,Point3d location)",summary:"Initializes a new textdot based on the text and the location.",since:5}],properties:[{signature:"string FontFace",summary:"Font face used for displaying the dot",since:5.2},{signature:"int FontHeight",summary:"Height of font used for displaying the dot",since:5.2},{signature:"Point3d Point",summary:"Gets or sets the position of the textdot.",since:5},{signature:"string SecondaryText",summary:"Gets or sets the secondary text of the textdot.",since:6},{signature:"string Text",summary:"Gets or sets the primiary text of the textdot.",since:5}]},{name:"Rhino.Geometry.TextEntity",dataType:1,summary:"",constructors:[{signature:"TextEntity()",summary:"Initializes a new instance of the  class.",since:5}],properties:[{signature:"TextJustification Justification",summary:"Gets or sets the justification of text in relation to its base point.",since:5},{signature:"TextHorizontalAlignment TextHorizontalAlignment",since:6},{signature:"TextOrientation TextOrientation",since:6},{signature:"TextVerticalAlignment TextVerticalAlignment",since:6}],methods:[{signature:"static TextEntity Create(string text,Plane plane,DimensionStyle style,bool wrapped,double rectWidth,double rotationRadians)",summary:"Create Text geometry or None if input is invalid",since:6},{signature:"static TextEntity CreateWithRichText(string richTextString,Plane plane,DimensionStyle style,bool wrapped,double rectWidth,double rotationRadians)",summary:"Create RichText geometry or None if input is invalid",since:6},{signature:"Curve[] CreateCurves(DimensionStyle dimstyle,bool bAllowOpen,double smallCapsScale,double spacing)",summary:"Returns the outline curves.",since:6,returns:"An array of curves that forms the outline or content of this text entity."},{signature:"Extrusion[] CreateExtrusions(DimensionStyle dimstyle,double height,double smallCapsScale,double spacing)",summary:"Creates extrusions from the outline curves with specified height.",since:6,returns:"An array of planar breps."},{signature:"Brep[] CreatePolySurfaces(DimensionStyle dimstyle,double height,double smallCapsScale,double spacing)",summary:"Creates breps from the outline curves with specified height.",since:6,returns:"An array of planar breps."},{signature:"Brep[] CreateSurfaces(DimensionStyle dimstyle,double smallCapsScale,double spacing)",summary:"Creates planar breps from the outline curves.",since:6,returns:"An array of planar breps."},{signature:"Curve[] Explode()",summary:"Explodes this text entity into an array of curves.",since:5,returns:"An array of curves that forms the outline or content of this text entity."},{signature:"Transform GetTextTransform(double textscale,DimensionStyle dimstyle)",summary:"Get the transform for this text object's text geometry",since:6},{signature:"bool Transform(Transform transform,DimensionStyle style)",summary:"Transform the object by a 4x4 transform matrix and change text height\n     override to accommodate scaling in the transform if necessary",since:6,returns:"Returns True on success otherwise returns false."}]},{name:"Rhino.Geometry.TextJustification",dataType:3,summary:"Specifies enumerated constants used to indicate the internal alignment and justification of text."},{name:"Rhino.Geometry.TextRunType",dataType:3,summary:""},{name:"Rhino.Geometry.Torus",dataType:2,summary:"Represents the value of a plane and two radii in a torus that is oriented in three-dimensional space.",constructors:[{signature:"Torus(Plane basePlane,double majorRadius,double minorRadius)",summary:"Initializes a new Torus from base pane and two radii.",since:5}],properties:[{signature:"static Torus Unset",summary:"Gets an invalid Torus.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether this torus is valid.",since:5},{signature:"double MajorRadius",summary:"Gets or sets the radius of the circle that lies at the heart of the torus.",since:5},{signature:"double MinorRadius",summary:"Gets or sets the radius of the torus section.",since:5},{signature:"Plane Plane",summary:"Gets or sets the plane for the torus large circle.",since:5}],methods:[{signature:"bool EpsilonEquals(Torus other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"NurbsSurface ToNurbsSurface()",summary:"Converts this torus to its nurbs surface representation. \n     This is synonymous with calling NurbsSurface.CreateFromTorus().",since:5,returns:"A nurbs surface representation of this torus, or None on error."},{signature:"RevSurface ToRevSurface()",summary:"Convert this torus to a surface of revolution representation. \n     This is synonymous with calling RevSurface.CreateFromTorus().",since:5,returns:"A surface of revolution representation of this torus, or None on error."}]},{name:"Rhino.Geometry.Transform",dataType:2,summary:"Represents the values in a 4x4 transform matrix.\n   This is parallel to C++ ON_Xform.",constructors:[{signature:"Transform(double diagonalValue)",summary:"Initializes a new transform matrix with a specified value along the diagonal.",since:5},{signature:"Transform(Transform value)",summary:"Initializes a new transform matrix with a specified value.",since:6}],properties:[{signature:"static Transform Identity",summary:"Gets a new identity transform matrix. An identity matrix defines no transformation.",since:5},{signature:"static Transform Unset",summary:"Gets an XForm filled with RhinoMath.UnsetValue.",since:5},{signature:"static Transform ZeroTransformation",summary:"ZeroTransformation diagonal = (0,0,0,1)",since:6.1},{signature:"double Determinant",summary:"The determinant of this 4x4 matrix.",since:5},{signature:"bool IsAffine",summary:"Tests for an affine transformation.\n     An affine transformation can be broken into a linear transformation and a translation.",since:6.12},{signature:"bool IsIdentity",summary:"Return True if this Transform is the identity transform",since:6},{signature:"bool IsLinear",summary:"Tests for a linear transformation.\n     An affine transformation can be broken into a linear transformation and a translation.",since:6.12},{signature:"bool IsRotation",summary:"Returns True if this is a proper rotation.",since:6.12},{signature:"bool IsValid",summary:"Gets a value indicating whether or not this Transform is a valid matrix. \n     A valid transform matrix is not allowed to have any invalid numbers.",since:5},{signature:"bool IsZero",summary:"True if matrix is Zero4x4, ZeroTransformation, or some other type of\n     zero.The value xform[3][3] can be anything.",since:6.1},{signature:"bool IsZero4x4",summary:"True if all values are 0",since:6.1},{signature:"bool IsZeroTransformation",summary:"True if all values are 0 and M33 is 1",since:6.1},{signature:"double M00",summary:"Gets or sets this[0,0].",since:5},{signature:"double M01",summary:"Gets or sets this[0,1].",since:5},{signature:"double M02",summary:"Gets or sets this[0,2].",since:5},{signature:"double M03",summary:"Gets or sets this[0,3].",since:5},{signature:"double M10",summary:"Gets or sets this[1,0].",since:5},{signature:"double M11",summary:"Gets or sets this[1,1].",since:5},{signature:"double M12",summary:"Gets or sets this[1,2].",since:5},{signature:"double M13",summary:"Gets or sets this[1,3].",since:5},{signature:"double M20",summary:"Gets or sets this[2,0].",since:5},{signature:"double M21",summary:"Gets or sets this[2,1].",since:5},{signature:"double M22",summary:"Gets or sets this[2,2].",since:5},{signature:"double M23",summary:"Gets or sets this[2,3].",since:5},{signature:"double M30",summary:"Gets or sets this[3,0].",since:5},{signature:"double M31",summary:"Gets or sets this[3,1].",since:5},{signature:"double M32",summary:"Gets or sets this[3,2].",since:5},{signature:"double M33",summary:"Gets or sets this[3,3].",since:5},{signature:"TransformRigidType RigidType",summary:"Gets a value indicating whether or not the Transform is rigid. \n     A rigid transformation can be broken into  a proper rotation and a translation,\n     while an isometry transformation could also include a reflection.",since:6.12},{signature:"TransformSimilarityType SimilarityType",summary:"Gets a value indicating whether or not the Transform maintains similarity. \n     The easiest way to think of Similarity is that any circle, when transformed, \n     remains a circle. Whereas a non-similarity Transform deforms circles into ellipses.",since:5}],methods:[{signature:"static Transform ChangeBasis(Plane plane0,Plane plane1)",summary:"Computes a change of basis transformation. A basis change is essentially a remapping \n     of geometry from one coordinate system to another.",since:5,returns:"A transformation matrix which orients geometry from one coordinate system to another on success.\n     Transform.Unset on failure."},{signature:"static Transform ChangeBasis(Vector3d initialBasisX,Vector3d initialBasisY,Vector3d initialBasisZ,Vector3d finalBasisX,Vector3d finalBasisY,Vector3d finalBasisZ)",summary:"Computes a change of basis transformation. A basis change is essentially a remapping \n     of geometry from one coordinate system to another.",since:5,returns:"A transformation matrix which orients geometry from one coordinate system to another on success.\n     Transform.Unset on failure."},{signature:"static Transform Diagonal(double d0,double d1,double d2)",summary:"Constructs a new transformation with diagonal (d0,d1,d2,1.0).",since:6.12,returns:"A transformation with diagonal (d0,d1,d2,1.0)."},{signature:"static Transform Diagonal(Vector3d diagonal)",summary:"Constructs a new transformation with diagonal (d0,d1,d2,1.0).",since:6.12,returns:"A transformation with diagonal (d0,d1,d2,1.0)."},{signature:"static Transform Mirror(Plane mirrorPlane)",summary:"Constructs a new Mirror transformation.",since:5,returns:"A transformation matrix which mirrors geometry in a specified plane."},{signature:"static Transform Mirror(Point3d pointOnMirrorPlane,Vector3d normalToMirrorPlane)",summary:"Create mirror transformation matrix\n     The mirror transform maps a point Q to \n     Q - (2*(Q-P)oN)*N, where\n     P = pointOnMirrorPlane and N = normalToMirrorPlane.",since:5,returns:"A transformation matrix which mirrors geometry in a specified plane."},{signature:"static Transform Multiply(Transform a,Transform b)",summary:"Multiplies (combines) two transformations.\n     This is the same as the * operator between two transformations.",since:5,returns:"A transformation matrix that combines the effect of both input transformations. \n     The resulting Transform gives the same result as though you'd first apply B then A."},{signature:"static Transform PlanarProjection(Plane plane)",summary:"Constructs a projection transformation.",since:5,returns:"A transformation matrix which projects geometry onto a specified plane."},{signature:"static Transform PlaneToPlane(Plane plane0,Plane plane1)",summary:"Create a rotation transformation that orients plane0 to plane1. If you want to orient objects from\n     one plane to another, use this form of transformation.",since:5,returns:"The translation transformation if successful, Transform.Unset on failure."},{signature:"static Transform ProjectAlong(Plane plane,Vector3d direction)",summary:"Construct a projection onto a plane along a specific direction.",since:6,returns:"Projection transformation or identity transformation if projection could not be calculated."},{signature:"static Transform Rotation(double sinAngle,double cosAngle,Vector3d rotationAxis,Point3d rotationCenter)",summary:"Constructs a new rotation transformation with specified angle, rotation center and rotation axis.",since:5,returns:"A transformation matrix which rotates geometry around an anchor point."},{signature:"static Transform Rotation(double angleRadians,Point3d rotationCenter)",summary:"Constructs a new rotation transformation with specified angle and rotation center.",since:5,returns:"A transformation matrix which rotates geometry around an anchor point."},{signature:"static Transform Rotation(double angleRadians,Vector3d rotationAxis,Point3d rotationCenter)",summary:"Constructs a new rotation transformation with specified angle, rotation center and rotation axis.",since:5,returns:"A transformation matrix which rotates geometry around an anchor point."},{signature:"static Transform Rotation(Vector3d startDirection,Vector3d endDirection,Point3d rotationCenter)",summary:"Constructs a new rotation transformation with start and end directions and rotation center.",since:5,returns:"A transformation matrix which rotates geometry around an anchor point."},{signature:"static Transform Rotation(Vector3d x0,Vector3d y0,Vector3d z0,Vector3d x1,Vector3d y1,Vector3d z1)",summary:"Constructs a transformation that maps X0 to X1, Y0 to Y1, Z0 to Z1.",since:5,returns:"A rotation transformation value."},{signature:"static Transform RotationZYX(double yaw,double pitch,double roll)",summary:"Create rotation transformation From Tait-Byran angles (also loosely known as Euler angles).",since:6.11,returns:"A transform matrix from Tait-Byran angles."},{signature:"static Transform RotationZYZ(double alpha,double beta,double gamma)",summary:"Create rotation transformation From Euler angles.",since:6.11,returns:"A transform matrix from Euler angles."},{signature:"static Transform Scale(Plane plane,double xScaleFactor,double yScaleFactor,double zScaleFactor)",summary:"Constructs a new non-uniform scaling transformation with a specified scaling anchor point.",since:5,returns:"A transformation matrix which scales geometry non-uniformly."},{signature:"static Transform Scale(Point3d anchor,double scaleFactor)",summary:"Constructs a new uniform scaling transformation with a specified scaling anchor point.",since:5,returns:"A transform matrix which scales geometry uniformly around the anchor point."},{signature:"static Transform Shear(Plane plane,Vector3d x,Vector3d y,Vector3d z)",summary:"Constructs a Shear transformation.",since:5,returns:"A transformation matrix which shear geometry."},{signature:"static Transform Translation(double dx,double dy,double dz)",summary:"Constructs a new translation (move) tranformation. \n     Right column is (dx, dy, dz, 1.0).",since:5,returns:"A transform matrix which moves geometry with the specified distances."},{signature:"static Transform Translation(Vector3d motion)",summary:"Constructs a new translation (move) transformation.",since:5,returns:"A transform matrix which moves geometry along the motion vector."},{signature:"void Affineize()",summary:"Replaces the last row with (0 0 0 1), discarding any perspecive part of this transform",since:6.12},{signature:"Transform Clone()",summary:"Returns a deep copy of the transform. For languages that treat structures as value types, this can \n     be accomplished by a simple assignment.",since:6,returns:"A deep copy of this data structure."},{signature:"int CompareTo(Transform other)",summary:"Compares this transform with another transform.\n     M33 has highest value, then M32, etc..",since:5,returns:"-1 if this < other; 0 if both are equal; 1 otherwise."},{signature:"bool DecomposeAffine(Transform linear,Vector3d translation)",summary:"Decomposes an affine transformation.\n     An affine transformation can be broken into a linear transformation and a translation.\n     Note, a perspective transformation is not affine.",since:6.12,returns:"True if successful decomposition."},{signature:"bool DecomposeAffine(Vector3d translation,Transform linear)",summary:"Decomposes an affine transformation.\n     An affine transformation can be broken into a linear transformation and a translation.\n     Note, a perspective transformation is not affine.",since:6.12,returns:"True if successful decomposition."},{signature:"bool DecomposeAffine(Vector3d translation,Transform rotation,Transform orthogonal,Vector3d diagonal)",summary:"An affine transformation can be decomposed into a Symmetric, Rotation and Translation.\n     Then the Symmetric component may be further decomposed as non-uniform scale in an orthonormal\n     coordinate system.",since:6.12,returns:"True if successful decomposition."},{signature:"TransformRigidType DecomposeRigid(Vector3d translation,Transform rotation,double tolerance)",summary:"Decomposes a rigid transformation. The transfomration must be affine.",since:6.12,returns:"The rigid type."},{signature:"TransformSimilarityType DecomposeSimilarity(Vector3d translation,double dilation,Transform rotation,double tolerance)",summary:"Decomposes a similarity transformation. The transformation must be affine.\n     A similarity transformation can be broken into a sequence of a dialation, translation, rotation, and a reflection.",since:6.12,returns:"The similarity type."},{signature:"bool DecomposeSymmetric(Transform matrix,Vector3d diagonal)",summary:"A Symmetric linear transformation can be decomposed A = Q * Diag * Q ^ T, where Diag is a diagonal\n     transformation. Diag[i][i] is an eigenvalue of A and the i-th coulmn of Q is a corresponding\n     unit length eigenvector. Note, this transformation must be Linear and Symmetric.",since:6.12,returns:"True if successful, False otherwise."},{signature:"bool Equals(object obj)",summary:"Determines if another object is a transform and its value equals this transform value.",returns:"True if obj is a transform and has the same value as this transform; otherwise, false."},{signature:"bool Equals(Transform other)",summary:"Determines if another transform equals this transform value.",since:5,returns:"True if other has the same value as this transform; otherwise, false."},{signature:"bool GetEulerZYZ(double alpha,double beta,double gamma)",summary:"Find the Euler angles for a rotation transformation.",since:6.11,returns:"If true, then RotationZYZ(alpha, beta, gamma) = R_z(alpha) * R_y(beta) * R_z(gamma)\n     where R_*(angle) is rotation of angle radians about the corresponding *-world coordinate axis.\n     If false, then this is not a rotation."},{signature:"int GetHashCode()",summary:"Gets a non-unique hashing code for this transform.",returns:"A number that can be used to hash this transform in a dictionary."},{signature:"bool GetYawPitchRoll(double yaw,double pitch,double roll)",summary:"Find the Tait-Byran angles (also loosely called Euler angles) for a rotation transformation.",since:6.11,returns:"If true, then RotationZYX(yaw, pitch, roll) = R_z(yaw) * R_y(pitch) * R_x(roll) \n     where R_*(angle) is rotation of angle radians about the corresponding world coordinate axis.\n     If false, then this is not a rotation."},{signature:"TransformRigidType IsRigid(double tolerance)",summary:"Gets a value indicating whether or not the Transform is rigid. \n     A rigid transformation can be broken into  a proper rotation and a translation,\n     while an isometry transformation could also include a reflection.",since:6.12,returns:"The rigid type."},{signature:"TransformSimilarityType IsSimilarity(double tolerance)",summary:"Gets a value indicating whether or not the Transform maintains similarity. \n     A similarity transformation can be broken into a sequence of a dialation, translation, rotation, and a reflection.",since:6.12,returns:"The similarity type."},{signature:"bool IsZeroTransformaton(double zeroTolerance)",summary:"True if all values are 0 and M33 is 1 within tolerance.",since:6.12,returns:"Returns True if all values are 0 and M33 is 1 within tolerance."},{signature:"void Linearize()",summary:"Affineize() and replaces the last column with (0 0 0 1)^T, discarding any translation part of this transform.",since:6.12},{signature:"bool Orthogonalize(double tolerance)",summary:"Force the linear part of this transformation to be a rotation (or a rotation with reflection).\n     Use DecomposeRigid(T,R) to find the nearest rotation.",since:6.12,returns:"True if successful, False otherwise."},{signature:"float[] ToFloatArray(bool rowDominant)",summary:"Return the matrix as a linear array of 16 float values",since:5.9},{signature:"string ToString()",summary:"Returns a string representation of this transform.",returns:"A textual representation."},{signature:"BoundingBox TransformBoundingBox(BoundingBox bbox)",summary:"Computes a new boundingbox that is the smallest axis aligned\n     boundingbox that contains the transformed result of its 8 original corner\n     points.",since:5,returns:"A new bounding box."},{signature:"Point3d[] TransformList(IEnumerable<Point3d> points)",summary:"Given a list, an array or any enumerable set of points, computes a new array of tranformed points.",since:5,returns:"A new array."},{signature:"Transform Transpose()",summary:"Flip row/column values",since:5.9},{signature:"bool TryGetInverse(Transform inverseTransform)",summary:"Attempts to get the inverse transform of this transform.",since:5,returns:"True on success. \n     If False is returned and this Transform is Invalid, inserveTransform will be set to this Transform. \n     If False is returned and this Transform is Valid, inverseTransform will be set to a pseudo inverse."}]},{name:"Rhino.Geometry.TransformRigidType",dataType:3,summary:"Lists all possible outcomes for rigid transformation."},{name:"Rhino.Geometry.TransformSimilarityType",dataType:3,summary:"Lists all possible outcomes for transform similarity."},{name:"Rhino.Geometry.Unroller",dataType:1,summary:"Represents the operation of unrolling a single surface.",constructors:[{signature:"Unroller(Brep brep)",summary:"Initializes a new instance of the  class with a brep.",since:5},{signature:"Unroller(Surface surface)",summary:"Initializes a new instance of the  class with surface.",since:5}],properties:[{signature:"double AbsoluteTolerance",summary:"Gets or sets the absolute tolerance for the unrolling operation.\n     Absolute tolerance is used in the evaluation of new entities,\n     such as intersections, reprojections and splits.In the current implementation, absolute tolerance is used \n     in tessellating rails, fitting curves and pulling back trims.",since:5},{signature:"bool ExplodeOutput",summary:"Gets or sets a value determining whether geometry should be exploded.",since:5},{signature:"double ExplodeSpacing",summary:"Gets or sets a value determining whether spacing should be exploded.",since:5},{signature:"double RelativeTolerance",summary:'Gets or sets the relative tolerance for the unrolling operation.\n     Relative tolerance is used in the evaluation of intrinsic properties,\n     such as computations "along" the surface or brep.In the current implementation, relative tolerance is used to decide\n     if a surface is flat enough to try to unroll. That helps ease the scale dependency.\n     The surface has to be linear in one direction within (length * RelativeTolerance)\n     to be considered linear for that purpose. Otherwise smash will ignore that tolerance and\n     unroll anything.',since:5}],methods:[{signature:"void AddFollowingGeometry(Curve curve)",summary:"Adds a curve that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(IEnumerable<Curve> curves)",summary:"Adds curves that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(IEnumerable<Point3d> points)",summary:"Adds points that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(IEnumerable<Point3d> dotLocations,IEnumerable<string> dotText)",summary:"Adds text dots that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(IEnumerable<TextDot> dots)",summary:"Adds text dots that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(Point point)",summary:"Adds a point that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(Point3d point)",summary:"Adds a point that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(Point3d dotLocation,string dotText)",summary:"Adds a text dot that should be unrolled along with the surface/brep.",since:5},{signature:"void AddFollowingGeometry(TextDot dot)",summary:"Adds a text dot that should be unrolled along with the surface/brep.",since:5},{signature:"int FollowingGeometryIndex(Curve curve)",summary:"Given an unrolled curve, returns the index of the source, or following curve.",since:6,returns:"The index of the curve added by Unroller.AddFollowingGeometry if successful, otherwise -1."},{signature:"int FollowingGeometryIndex(TextDot dot)",summary:"Given an unrolled text dot, returns the index of the source, or following text dot.",since:6,returns:"The index of the text dot added by Unroller.AddFollowingGeometry if successful, otherwise -1."},{signature:"Brep[] PerformUnroll(Curve[] unrolledCurves,Point3d[] unrolledPoints,TextDot[] unrolledDots)",summary:"Executes unrolling operations.",since:5,returns:"An array of breps. This array can be empty."},{signature:"int PerformUnroll(List<Brep> flatbreps)",summary:"Executes unrolling operations.",since:6,returns:"Number of breps in result"}]},{name:"Rhino.Geometry.Vector2d",dataType:2,summary:"Represents the two components of a vector in two-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Vector2d(double x,double y)",summary:"Initializes a new instance of the vector based on two, X and Y, components.",since:5}],properties:[{signature:"static Vector2d Unset",summary:"Gets the value of the vector with components set as RhinoMath.UnsetValue,RhinoMath.UnsetValue.",since:5},{signature:"static Vector2d Zero",summary:"Gets the value of the vector with components 0,0.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether this vector is valid. \n     A valid vector must be formed of valid component values for x, y and z.",since:5.7},{signature:"double Length",summary:"Computes the length (or magnitude, or size) of this vector.\n     This is an application of Pythagoras' theorem.",since:5},{signature:"double SquareLength",summary:"Returns the square of the length of the vector.",since:6},{signature:"double X",summary:"Gets or sets the X (first) component of this vector.",since:5},{signature:"double Y",summary:"Gets or sets the Y (second) component of this vector.",since:5}],methods:[{signature:"static Vector2d Add(Vector2d vector1,Vector2d vector2)",summary:"Sums up two vectors.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:6,returns:"A new vector that results from the componentwise addition of the two vectors."},{signature:"static Vector2d Divide(Vector2d vector,double t)",summary:"Divides a  by a number, having the effect of shrinking it.\n     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)",since:6,returns:"A new vector that is componentwise divided by t."},{signature:"static Vector2d Multiply(double t,Vector2d vector)",summary:"Multiplies a vector by a number, having the effect of scaling it.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:6,returns:"A new vector that is the original vector coordinatewise multiplied by t."},{signature:"static Vector2d Multiply(Vector2d vector,double t)",summary:"Multiplies a vector by a number, having the effect of scaling it.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:6,returns:"A new vector that is the original vector coordinatewise multiplied by t."},{signature:"static double Multiply(Vector2d vector1,Vector2d vector2)",summary:"Multiplies two vectors together, returning the dot product (or inner product).\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:6,returns:"A value that results from the evaluation of v1.X*v2.X + v1.Y*v2.Y.\n     This value equals v1.Length * v2.Length * cos(alpha), where alpha is the angle between vectors."},{signature:"static Vector2d Negate(Vector2d vector)",summary:"Computes the reversed vector.\n     (Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)",since:6,returns:"A new vector where all components were multiplied by -1."},{signature:"static Vector2d Subtract(Vector2d vector1,Vector2d vector2)",summary:"Subtracts the second vector from the first one.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:6,returns:"A new vector that results from the componentwise difference of vector1 - vector2."},{signature:"int CompareTo(Vector2d other)",summary:"Compares this  with another .\n     Components evaluation priority is first X, then Y.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise."},{signature:"bool EpsilonEquals(Vector2d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Vector2d and has the same value as the present vector.",returns:"True if obj is Vector2d and has the same components as this; otherwise false."},{signature:"bool Equals(Vector2d vector)",summary:"Determines whether the specified vector has the same value as the present vector.",since:5,returns:"True if vector has the same components as this; otherwise false."},{signature:"int GetHashCode()",summary:"Provides a hashing value for the present vector.",returns:"A non-unique number based on vector components."},{signature:"bool IsTiny()",summary:"Uses RhinoMath.ZeroTolerance for IsTiny calculation.",since:6,returns:"True if vector is very small, otherwise false."},{signature:"bool IsTiny(double tolerance)",summary:"Determines whether a vector is very short.",since:6,returns:"(Math.Abs(X) <= tiny_tol) AND (Math.Abs(Y) <= tiny_tol) AND (Math.Abs(Z) <= tiny_tol)."},{signature:"bool Rotate(double angleRadians)",summary:"Rotates this vector.",since:6,returns:"True on success, False on failure."},{signature:"string ToString()",summary:"Constructs a string representation of the current vector.",returns:"A string in the form X,Y."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"bool Unitize()",summary:"Unitizes the vector in place. A unit vector has length 1 unit. \n     An invalid or zero length vector cannot be unitized.",since:5.7,returns:"True on success or False on failure."}]},{name:"Rhino.Geometry.Vector2f",dataType:2,summary:"Represents the two components of a vector in two-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Vector2f(float x,float y)",summary:"Creates an instance.",since:6}],properties:[{signature:"bool IsValid",summary:"Returns an indication regarding the validity of this vector.",since:6},{signature:"float SquareLength",summary:"Returns the square of the length of this vector.\n     This method does not check for the validity of its inputs.",since:6},{signature:"float X",summary:"Gets or sets the X (first) component of this vector.",since:5},{signature:"float Y",summary:"Gets or sets the Y (second) component of this vector.",since:5}],methods:[{signature:"static double Multiply(Vector2f point1,Vector2f point2)",summary:"Multiplies two  together, returning the dot (internal) product of the two.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:6,returns:"A value that results from the coordinatewise multiplication of point1 and point2."},{signature:"int CompareTo(Vector2f other)",summary:"Compares this  with another .\n     Components evaluation priority is first X, then Y.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y+1: otherwise."},{signature:"bool EpsilonEquals(Vector2f other,float epsilon)",summary:"Check that all values in other are withing epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Vector2f and has the same values as the present vector.",returns:"True if obj is Vector2f and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Vector2f vector)",summary:"Determines whether the specified vector has the same values as the present vector.",since:5,returns:"True if obj is Vector2f and has the same coordinates as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash number that represents the current vector.",returns:"A hash code that is not unique for each vector."},{signature:"string ToString()",summary:"Constructs the string representation of the current vector.",returns:"The vector representation in the form X,Y,Z."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7}]},{name:"Rhino.Geometry.Vector3d",dataType:2,summary:"Represents the three components of a vector in three-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Vector3d(double x,double y,double z)",summary:"Initializes a new instance of a vector, using its three components.",since:5},{signature:"Vector3d(Point3d point)",summary:"Initializes a new instance of a vector, copying the three components from the three coordinates of a point.",since:5},{signature:"Vector3d(Vector3d vector)",summary:"Initializes a new instance of a vector, copying the three components from a vector.",since:5},{signature:"Vector3d(Vector3f vector)",summary:"Initializes a new instance of a vector, copying the three components from a single-precision vector.",since:5}],properties:[{signature:"static Vector3d Unset",summary:"Gets the value of the vector with each component set to RhinoMath.UnsetValue.",since:5},{signature:"static Vector3d XAxis",summary:"Gets the value of the vector with components 1,0,0.",since:5},{signature:"static Vector3d YAxis",summary:"Gets the value of the vector with components 0,1,0.",since:5},{signature:"static Vector3d ZAxis",summary:"Gets the value of the vector with components 0,0,1.",since:5},{signature:"static Vector3d Zero",summary:"Gets the value of the vector with components 0,0,0.",since:5},{signature:"bool IsUnitVector",summary:"Gets a value indicating whether or not this is a unit vector. \n     A unit vector has length 1.",since:5},{signature:"bool IsValid",summary:"Gets a value indicating whether this vector is valid. \n     A valid vector must be formed of valid component values for x, y and z.",since:5},{signature:"bool IsZero",summary:"Gets a value indicating whether the X, Y, and Z values are all equal to 0.0.",since:5},{signature:"double Length",summary:"Computes the length (or magnitude, or size) of this vector.\n     This is an application of Pythagoras' theorem.\n     If this vector is invalid, its length is considered 0.",since:5},{signature:"double MaximumCoordinate",summary:"Gets the largest (both positive and negative) component value in this vector.",since:5},{signature:"double MinimumCoordinate",summary:"Gets the smallest (both positive and negative) component value in this vector.",since:5},{signature:"double SquareLength",summary:"Computes the squared length (or magnitude, or size) of this vector.\n     This is an application of Pythagoras' theorem.\n     While the Length property checks for input validity,\n     this property does not. You should check validity in advance,\n     if this vector can be invalid.",since:5},{signature:"double X",summary:"Gets or sets the X (first) component of the vector.",since:5},{signature:"double Y",summary:"Gets or sets the Y (second) component of the vector.",since:5},{signature:"double Z",summary:"Gets or sets the Z (third) component of the vector.",since:5}],methods:[{signature:"static Vector3d Add(Vector3d vector1,Vector3d vector2)",summary:"Sums up two vectors.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new vector that results from the componentwise addition of the two vectors."},{signature:"static bool AreOrthogonal(Vector3d x,Vector3d y,Vector3d z)",summary:"Test whether three vectors describe an orthogonal axis system.\n     All vectors must be mutually perpendicular this to be the case.",since:6.7,returns:"True if all vectors are non-zero and mutually perpendicular."},{signature:"static bool AreOrthonormal(Vector3d x,Vector3d y,Vector3d z)",summary:"Test whether three vectors describe an orthogonal, unit axis system.\n     All vectors must be mutually perpendicular and have unit length for this to be the case.",since:6.7,returns:"True if all vectors are non-zero and mutually perpendicular."},{signature:"static bool AreRighthanded(Vector3d x,Vector3d y,Vector3d z)",summary:"Test whether three vectors describe a right-handed, orthogonal, unit axis system.\n     The vectors must be orthonormal and follow the right-hand ordering; index-finger=x,\n     middle-finger=y, thumb=z.",since:6.7,returns:"True if all vectors are non-zero and mutually perpendicular."},{signature:"static Vector3d CrossProduct(Vector3d a,Vector3d b)",summary:"Computes the cross product (or vector product, or exterior product) of two vectors.\n     This operation is not commutative.",since:5,returns:"A new vector that is perpendicular to both a and b,\n     has Length == a.Length * b.Length * sin(theta) where theta is the angle between a and b.The resulting vector is oriented according to the right hand rule."},{signature:"static Vector3d Divide(Vector3d vector,double t)",summary:"Divides a  by a number, having the effect of shrinking it.\n     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)",since:5,returns:"A new vector that is componentwise divided by t."},{signature:"static Vector3d Multiply(double t,Vector3d vector)",summary:"Multiplies a vector by a number, having the effect of scaling it.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new vector that is the original vector coordinatewise multiplied by t."},{signature:"static Vector3d Multiply(Vector3d vector,double t)",summary:"Multiplies a vector by a number, having the effect of scaling it.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new vector that is the original vector coordinatewise multiplied by t."},{signature:"static double Multiply(Vector3d vector1,Vector3d vector2)",summary:"Multiplies two vectors together, returning the dot product (or inner product).\n     This differs from the cross product.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A value that results from the evaluation of v1.X*v2.X + v1.Y*v2.Y + v1.Z*v2.Z.\n     This value equals v1.Length * v2.Length * cos(alpha), where alpha is the angle between vectors."},{signature:"static Vector3d Negate(Vector3d vector)",summary:"Computes the reversed vector.\n     (Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)",since:5,returns:"A new vector where all components were multiplied by -1."},{signature:"static Vector3d Subtract(Vector3d vector1,Vector3d vector2)",summary:"Subtracts the second vector from the first one.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:5,returns:"A new vector that results from the componentwise difference of vector1 - vector2."},{signature:"static double VectorAngle(Vector3d a,Vector3d b)",summary:"Compute the angle between two vectors.\n     This operation is commutative.",since:5,returns:"If the input is valid, the angle (in radians) between a and b; RhinoMath.UnsetValue otherwise."},{signature:"static double VectorAngle(Vector3d a,Vector3d b,Plane plane)",summary:"Computes the angle on a plane between two vectors.",since:5,returns:"On success, the angle (in radians) between a and b as projected onto the plane; RhinoMath.UnsetValue on failure."},{signature:"static double VectorAngle(Vector3d v1,Vector3d v2,Vector3d vNormal)",summary:"Computes the angle of v1, v2 with a normal vector.",since:6,returns:"On success, the angle (in radians) between a and b with respect of normal vector; RhinoMath.UnsetValue on failure."},{signature:"int CompareTo(Vector3d other)",summary:"Compares this  with another .\n     Component evaluation priority is first X, then Y, then Z.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise."},{signature:"bool EpsilonEquals(Vector3d other,double epsilon)",summary:"Check that all values in other are within epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Vector3d and has the same values as the present vector.",returns:"True if obj is a Vector3d and has the same coordinates as this; otherwise false."},{signature:"bool Equals(Vector3d vector)",summary:"Determines whether the specified vector has the same value as the present vector.",since:5,returns:"True if vector has the same coordinates as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes the hash code for the current vector.",returns:"A non-unique number that represents the components of this vector."},{signature:"int IsParallelTo(Vector3d other)",summary:"Determines whether this vector is parallel to another vector, within one degree (within Pi / 180).",since:5,returns:"Parallel indicator:\n     +1 = both vectors are parallel 0 = vectors are not parallel, or at least one of the vectors is zero-1 = vectors are anti-parallel."},{signature:"int IsParallelTo(Vector3d other,double angleTolerance)",summary:"Determines whether this vector is parallel to another vector, within a provided tolerance.",since:5,returns:"Parallel indicator:\n     +1 = both vectors are parallel.0 = vectors are not parallel or at least one of the vectors is zero.-1 = vectors are anti-parallel."},{signature:"bool IsPerpendicularTo(Vector3d other)",summary:"Test to see whether this vector is perpendicular to within one degree of another one.",since:5,returns:"True if both vectors are perpendicular, False if otherwise."},{signature:"bool IsPerpendicularTo(Vector3d other,double angleTolerance)",summary:"Determines whether this vector is perpendicular to another vector, within a provided angle tolerance.",since:5,returns:"True if vectors form Pi-radians (90-degree) angles with each other; otherwise false."},{signature:"bool IsTiny()",summary:"Uses RhinoMath.ZeroTolerance for IsTiny calculation.",since:5,returns:"True if vector is very small, otherwise false."},{signature:"bool IsTiny(double tolerance)",summary:"Determines whether a vector is very short.",since:5,returns:"(Math.Abs(X) <= tiny_tol) AND (Math.Abs(Y) <= tiny_tol) AND (Math.Abs(Z) <= tiny_tol)."},{signature:"bool PerpendicularTo(Vector3d other)",summary:"Sets this vector to be perpendicular to another vector. \n     Result is not unitized.",since:5,returns:"True on success, False if input vector is zero or invalid."},{signature:"bool Reverse()",summary:"Reverses this vector in place (reverses the direction).\n     If this vector is Invalid, no changes will occur and False will be returned.",since:5,returns:"True on success or False if the vector is invalid."},{signature:"bool Rotate(double angleRadians,Vector3d rotationAxis)",summary:"Rotates this vector around a given axis.",since:5,returns:"True on success, False on failure."},{signature:"string ToString()",summary:"Returns the string representation of the current vector, in the form X,Y,Z.",returns:"A string with the current location of the point."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"void Transform(Transform transformation)",summary:"Transforms the vector in place.\n     The transformation matrix acts on the left of the vector; i.e.,result = transformation*vector",since:5},{signature:"bool Unitize()",summary:"Unitizes the vector in place. A unit vector has length 1 unit. \n     An invalid or zero length vector cannot be unitized.",since:5,returns:"True on success or False on failure."}]},{name:"Rhino.Geometry.Vector3f",dataType:2,summary:"Represents the three components of a vector in three-dimensional space,\n   using -precision floating point numbers.",constructors:[{signature:"Vector3f(float x,float y,float z)",summary:"Constructs a new vector from 3 single precision numbers.",since:5}],properties:[{signature:"static Vector3f Unset",summary:"Gets the value of the vector with each component set to RhinoMath.UnsetValue.",since:5},{signature:"static Vector3f XAxis",summary:"Gets the value of the vector with components 1,0,0.",since:5},{signature:"static Vector3f YAxis",summary:"Gets the value of the vector with components 0,1,0.",since:5},{signature:"static Vector3f ZAxis",summary:"Gets the value of the vector with components 0,0,1.",since:5},{signature:"static Vector3f Zero",summary:"Gets the value of the vector with components 0,0,0.",since:5},{signature:"bool IsUnitVector",summary:"Gets a value indicating whether or not this is a unit vector. \n     A unit vector has length 1.",since:6},{signature:"bool IsValid",summary:"Returns an indication regarding the validity of this vector.",since:6},{signature:"bool IsZero",summary:"Gets a value indicating whether the X, Y, and Z values are all equal to 0.0.",since:6},{signature:"float Length",summary:"Computes the length (or magnitude, or size) of this vector.\n     This is an application of Pythagoras' theorem.\n     If this vector is invalid, its length is considered 0.",since:5},{signature:"float SquareLength",summary:"Returns the square length of the vector.\n     This property does not check for the validity of the inputs.",since:6},{signature:"float X",summary:"Gets or sets the X (first) component of this vector.",since:5},{signature:"float Y",summary:"Gets or sets the Y (second) component of this vector.",since:5},{signature:"float Z",summary:"Gets or sets the Z (third) component of this vector.",since:5}],methods:[{signature:"static Point3f Add(Point3f point,Vector3f vector)",summary:"Sums up a point and a vector, and returns a new point.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:5,returns:"A new point that results from the addition of point and vector."},{signature:"static Vector3f Add(Vector3f vector1,Vector3f vector2)",summary:"Sums up two vectors.\n     (Provided for languages that do not support operator overloading. You can use the + operator otherwise)",since:6,returns:"A new vector that results from the componentwise addition of the two vectors."},{signature:"static Vector3f CrossProduct(Vector3f a,Vector3f b)",summary:"Computes the cross product (or vector product, or exterior product) of two vectors.\n     This operation is not commutative.",since:5,returns:"A new vector that is perpendicular to both a and b,\n     has Length == a.Length * b.Length andwith a result that is oriented following the right hand rule."},{signature:"static Vector3f Divide(Vector3f vector,double t)",summary:"Divides a  by a number, having the effect of shrinking it, t times.\n     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)",since:6,returns:"A new vector that is componentwise divided by t."},{signature:"static Vector3f Divide(Vector3f vector,float t)",summary:"Divides a  by a number, having the effect of shrinking it, t times.\n     (Provided for languages that do not support operator overloading. You can use the / operator otherwise)",since:6,returns:"A new vector that is componentwise divided by t."},{signature:"static Vector3f Multiply(float t,Vector3f vector)",summary:"Multiplies a vector by a number, having the effect of scaling it.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new vector that is the original vector coordinatewise multiplied by t."},{signature:"static Vector3f Multiply(Vector3f vector,float t)",summary:"Multiplies a vector by a number, having the effect of scaling it.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:5,returns:"A new vector that is the original vector coordinatewise multiplied by t."},{signature:"static double Multiply(Vector3f point1,Vector3f point2)",summary:"Multiplies two  together, returning the dot (internal) product of the two.\n     This is not the cross product.\n     (Provided for languages that do not support operator overloading. You can use the * operator otherwise)",since:6,returns:"A value that results from the coordinatewise multiplication of point1 and point2."},{signature:"static Vector3f Negate(Vector3f vector)",summary:"Computes the reversed vector.\n     (Provided for languages that do not support operator overloading. You can use the - unary operator otherwise)",since:6,returns:"A new vector where all components were multiplied by -1."},{signature:"static Vector3f Subtract(Vector3f vector1,Vector3f vector2)",summary:"Subtracts the second vector from the first one.\n     (Provided for languages that do not support operator overloading. You can use the - operator otherwise)",since:6,returns:"A new vector that results from the componentwise difference of vector1 - vector2."},{signature:"int CompareTo(Vector3f other)",summary:"Compares this  with another .\n     Component evaluation priority is first X, then Y, then Z.",since:5,returns:"0: if this is identical to other-1: if this.X < other.X-1: if this.X == other.X and this.Y < other.Y-1: if this.X == other.X and this.Y == other.Y and this.Z < other.Z+1: otherwise."},{signature:"bool EpsilonEquals(Vector3f other,float epsilon)",summary:"Check that all values in other are withing epsilon of the values in this",since:5.4},{signature:"bool Equals(object obj)",summary:"Determines whether the specified System.Object is a Vector3f and has the same values as the present vector.",returns:"True if obj is Vector3f and has the same components as this; otherwise false."},{signature:"bool Equals(Vector3f vector)",summary:"Determines whether the specified vector has the same values as the present vector.",since:5,returns:"True if vector has the same components as this; otherwise false."},{signature:"int GetHashCode()",summary:"Computes a hash number that represents the current vector.",returns:"A hash code that is not unique for each vector."},{signature:"bool PerpendicularTo(Vector3f other)",summary:"Sets this vector to be perpendicular to another vector. \n     Result is not unitized.",since:5,returns:"True on success, False if input vector is zero or invalid."},{signature:"bool Reverse()",summary:"Reverses this vector in place (reverses the direction).\n     If this vector contains RhinoMath.UnsetValue, the \n     reverse will also be invalid and False will be returned.",since:5,returns:"True on success or False if the vector is invalid."},{signature:"bool Rotate(double angleRadians,Vector3f rotationAxis)",summary:"Rotates this vector around a given axis.",since:5,returns:"True on success, False on failure."},{signature:"string ToString()",summary:"Constructs the string representation of the current vector.",returns:"The vector representation in the form X,Y,Z."},{signature:"string ToString(string format,IFormatProvider formatProvider)",since:7},{signature:"void Transform(Transform transformation)",summary:"Transforms the vector in place.\n     The transformation matrix acts on the left of the vector; i.e.,result = transformation*vector",since:5},{signature:"bool Unitize()",summary:"Unitizes the vector in place. A unit vector has length 1 unit. \n     An invalid or zero length vector cannot be unitized.",since:5,returns:"True on success or False on failure."}]},{name:"Rhino.Geometry.VolumeMassProperties",dataType:1,summary:"Contains static initialization methods and allows access to the computed\n   metrics of volume, volume centroid and volume moments in \n   in solid meshes, in solid surfaces and in solid (closed) boundary representations.",properties:[{signature:"Point3d Centroid",summary:"Gets the volume centroid in the world coordinate system.",since:5},{signature:"Vector3d CentroidCoordinatesMomentsOfInertia",summary:"Moments of inertia with respect to centroid coordinate system.\n     X = integral of ((y-y0)^2 + (z-z0)^2) dm\n     Y = integral of ((z-z0)^2 + (x-x0)^2) dm\n     Z = integral of ((z-z0)^2 + (y-y0)^2) dm\n     where (x0,y0,z0) = centroid.",since:5},{signature:"Vector3d CentroidCoordinatesMomentsOfInertiaError",summary:"Uncertainty in centroid coordinates moments of inertia calculation.",since:5},{signature:"Vector3d CentroidCoordinatesRadiiOfGyration",summary:"Radii of gyration with respect to centroid coordinate system.\n     X = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)\n     Y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)\n     Z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)\n     where (x0,y0,z0) = centroid.",since:5},{signature:"Vector3d CentroidCoordinatesSecondMoments",summary:"Second moments with respect to centroid coordinate system.\n     X = integral of (x-x0)^2 dm\n     Y = integral of (y-y0)^2 dm\n     Z = integral of (z-z0)^2 dm\n     where (x0,y0,z0) = centroid.",since:5},{signature:"Vector3d CentroidCoordinatesSecondMomentsError",summary:"Uncertainty in centroid coordinates second moments calculation.",since:5},{signature:"Vector3d CentroidError",summary:"Gets the uncertainty in the Centroid calculation.",since:5},{signature:"double Volume",summary:"Gets the volume solution.",since:5},{signature:"double VolumeError",summary:"Gets the uncertainty in the volume calculation.",since:5},{signature:"Vector3d WorldCoordinatesFirstMoments",summary:'Returns the world coordinate first moments if they were able to be calculated.\n     X is integral of "x dm" over the volume\n     Y is integral of "y dm" over the volume\n     Z is integral of "z dm" over the volume.',since:5},{signature:"Vector3d WorldCoordinatesFirstMomentsError",summary:"Uncertainty in world coordinates first moments calculation.",since:5},{signature:"Vector3d WorldCoordinatesMomentsOfInertia",summary:"The moments of inertia about the world coordinate axes.\n     X = integral of (y^2 + z^2) dm\n     Y = integral of (z^2 + x^2) dm\n     Z = integral of (z^2 + y^2) dm.",since:5},{signature:"Vector3d WorldCoordinatesMomentsOfInertiaError",summary:"Uncertainty in world coordinates moments of inertia calculation.",since:5},{signature:"Vector3d WorldCoordinatesProductMoments",summary:'Returns the world coordinate product moments if they were able to be calculated.\n     X is integral of "xy dm" over the area\n     Y is integral of "yz dm" over the area\n     Z is integral of "zx dm" over the area.',since:5},{signature:"Vector3d WorldCoordinatesProductMomentsError",summary:"Uncertainty in world coordinates second moments calculation.",since:5},{signature:"Vector3d WorldCoordinatesRadiiOfGyration",summary:"Radii of gyration with respect to world coordinate system.\n     X = sqrt(integral of (y^2 + z^2) dm/M)\n     Y = sqrt(integral of (z^2 + x^2) dm/M)\n     Z = sqrt(integral of (z^2 + y^2) dm/M)",since:5},{signature:"Vector3d WorldCoordinatesSecondMoments",summary:'Returns the world coordinate first moments if they were able to be calculated.\n     X is integral of "xx dm" over the area\n     Y is integral of "yy dm" over the area\n     Z is integral of "zz dm" over the area.',since:5},{signature:"Vector3d WorldCoordinatesSecondMomentsError",summary:"Uncertainty in world coordinates second moments calculation.",since:5}],methods:[{signature:"static VolumeMassProperties Compute(Brep brep)",summary:"Compute the VolumeMassProperties for a single Brep.",since:5,returns:"The VolumeMassProperties for the given Brep or None on failure."},{signature:"static VolumeMassProperties Compute(Brep brep,bool volume,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Compute the VolumeMassProperties for a single Brep.",since:6.3,returns:"The VolumeMassProperties for the given Brep or None on failure."},{signature:"static VolumeMassProperties Compute(IEnumerable<GeometryBase> geometry)",summary:"Computes the VolumeMassProperties for a collection of geometric objects. \n     At present only Breps, Surfaces, and Meshes are supported.",since:6.3,returns:"The VolumeMassProperties for the entire collection or None on failure."},{signature:"static VolumeMassProperties Compute(IEnumerable<GeometryBase> geometry,bool volume,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Computes the VolumeMassProperties for a collection of geometric objects. \n     At present only Breps, Surfaces, Meshes and Planar Closed Curves are supported.",since:6.3,returns:"The VolumeMassProperties for the entire collection or None on failure."},{signature:"static VolumeMassProperties Compute(Mesh mesh)",summary:"Compute the VolumeMassProperties for a single Mesh.",since:5,returns:"The VolumeMassProperties for the given Mesh or None on failure."},{signature:"static VolumeMassProperties Compute(Mesh mesh,bool volume,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Compute the VolumeMassProperties for a single Mesh.",since:6.3,returns:"The VolumeMassProperties for the given Mesh or None on failure."},{signature:"static VolumeMassProperties Compute(Surface surface)",summary:"Compute the VolumeMassProperties for a single Surface.",since:5,returns:"The VolumeMassProperties for the given Surface or None on failure."},{signature:"static VolumeMassProperties Compute(Surface surface,bool volume,bool firstMoments,bool secondMoments,bool productMoments)",summary:"Compute the VolumeMassProperties for a single Surface.",since:6.3,returns:"The VolumeMassProperties for the given Surface or None on failure."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"bool Sum(VolumeMassProperties summand)",summary:"Sum mass properties together to get an aggregate mass.",since:5,returns:"True if successful."}]},{name:"Rhino.IEpsilonComparable",dataType:4,summary:""},{name:"Rhino.IEpsilonFComparable",dataType:4,summary:""},{name:"Rhino.IndexPair",dataType:2,summary:"Represents two indices: I and J.",constructors:[{signature:"IndexPair(int i,int j)",summary:"Initializes a new instance of  with two indices.",since:5}],properties:[{signature:"int Count",summary:"Returns the amount of elements in this pair of indices, which is always 2.",since:6},{signature:"int I",summary:"Gets or sets the first, I index.",since:5},{signature:"int J",summary:"Gets or sets the second, J index.",since:5}],methods:[{signature:"bool Contains(int item)",summary:"Determines whether the  contains a specific value.",since:6,returns:"True if  is found in the ; otherwise, false."},{signature:"void CopyTo(int[] array,int arrayIndex)",summary:"Copies the elements of the  to an , starting at a particular  index.",since:6},{signature:"IEnumerator<int> GetEnumerator()",summary:"Gets an enumerator that goes over  and , in this order.",since:6,returns:"The needed enumerator."},{signature:"int IndexOf(int item)",summary:"Determines the index of a specific item in .",since:6,returns:"The index, 0 for I or 1 for J of  if found in the list; otherwise, -1."}]},{name:"Rhino.Input.Custom.CommandLineOption",dataType:1,summary:"",properties:[{signature:"int CurrentListOptionIndex",since:5},{signature:"string EnglishName",summary:"The English command option name",since:5},{signature:"int Index",since:5},{signature:"string LocalName",summary:"The localized command option name",since:6.24},{signature:"string StringOptionValue",summary:"Assigned by RhinoGet.Get if an option value is specified in a script or by a command window control.",since:6.24}],methods:[{signature:"static bool IsValidOptionName(string optionName)",summary:"Test a string to see if it can be used as an option name in any of the RhinoGet::AddCommandOption...() functions.",since:5,returns:"True if string can be used as an option name."},{signature:"static bool IsValidOptionValueName(string optionValue)",summary:"Test a string to see if it can be used as an option value in RhinoGet::AddCommandOption,\n     RhinoGet::AddCommandOptionToggle, or RhinoGet::AddCommandOptionList.",since:5,returns:"True if string can be used as an option value."}]},{name:"Rhino.Input.Custom.ConeConstraint",dataType:3,summary:""},{name:"Rhino.Input.Custom.CylinderConstraint",dataType:3,summary:""},{name:"Rhino.Input.Custom.GeometryAttributeFilter",dataType:3,summary:"If an object passes the geometry TYPE filter, then the geometry ATTRIBUTE\n   filter is applied."},{name:"Rhino.Input.Custom.GetArc",dataType:1,summary:"",constructors:[{signature:"GetArc()",since:6}],properties:[{signature:"bool AllowDeformable",summary:"Allow for deformable options",since:6},{signature:"double DefaultRadius",summary:"Default radius used for start and end radius",since:6},{signature:"bool Deformable",summary:"Is the deformable option set",since:6},{signature:"int DeformableDegree",since:6},{signature:"int DeformablePointCount",since:6}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"Commands.Result Get(Arc arc)",summary:"Perform the 'get' operation.",since:6}]},{name:"Rhino.Input.Custom.GetBaseClass",dataType:1,summary:'Base class for GetObject, GetPoint, GetSphere, etc.\n   \n   You will never directly create a GetBaseClass but you will use its member\n   functions after calling GetObject.Gets(), GetPoint.Get(), and so on.\n   \n   Provides tools to set command prompt, set command options, and specify\n   if the "get" can optionally accept numbers, nothing (pressing enter),\n   and undo.',methods:[{signature:"static void PostCustomMessage(object messageData)",since:5},{signature:"void AcceptColor(bool enable)",summary:"If you want to allow the user to be able to type in a color r,g,b or name\n     during GetPoint.Get(), GetObject::GetObjects(), etc., then call AcceptColor(true)\n     before calling GetPoint()/GetObject(). If the user chooses to type in a color,\n     then the result code GetResult.Color is returned and you can use RhinoGet.Color()\n     to get the value of the color.  If the get accepts points, then the user will not\n     be able to type in r,g,b colors but will be able to type color names.",since:5},{signature:"void AcceptCustomMessage(bool enable)",since:5},{signature:"void AcceptEnterWhenDone(bool enable)",summary:'There are instances of RhinoGet that prompt with "Press Enter when Done." yet do not call AcceptNothing().\n     On the Mac, these instances need an additional call to AcceptEnterWhenDone() so the GetPointOptions dialog\n     can correctly enable the Done button.',since:6},{signature:"void AcceptNothing(bool enable)",summary:"If you want to allow the user to be able to press enter in order to\n     skip selecting a something in GetPoint.Get(), GetObject::GetObjects(),\n     etc., then call AcceptNothing( True ) beforehand.",since:5},{signature:"void AcceptNumber(bool enable,bool acceptZero)",summary:'If you want to allow the user to be able to type in a number during GetPoint.Get(),\n     GetObject::GetObjects(), etc., then call AcceptNumber() beforehand.\n     If the user chooses to type in a number, then the result code GetResult.Number is\n     returned and you can use RhinoGet.Number() to get the value of the number. If you\n     are using GetPoint and you want "0" to return (0,0,0) instead of the number zero, \n     then set acceptZero = false.',since:5},{signature:"void AcceptPoint(bool enable)",summary:"If you want to allow the user to be able to type in a point then call AcceptPoint(true)\n     before calling GetPoint()/GetObject(). If the user chooses to type in a number, then\n     the result code GetResult.Point is returned and you can use RhinoGet.Point()\n     to get the value of the point.",since:5},{signature:"void AcceptString(bool enable)",summary:"If you want to allow the user to be able to type in a string during GetPoint.Get(),\n     GetObject::GetObjects(), etc., then call AcceptString(true) before calling\n     GetPoint()/GetObject(). If the user chooses to type in a string, then the result code\n     GetResult.String is returned and you can use RhinoGet.String() to get the value of the string.",since:5},{signature:"void AcceptUndo(bool enable)",summary:"If you want to allow the user to have an 'undo' option in GetPoint.Get(),\n     GetObject.GetObjects(), etc., then call AcceptUndo(true) beforehand.",since:5},{signature:"int AddOption(LocalizeStringPair optionName)",summary:"Adds a command line option.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOption(LocalizeStringPair optionName,LocalizeStringPair optionValue)",summary:"Adds a command line option.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOption(LocalizeStringPair optionName,LocalizeStringPair optionValue,bool hiddenOption)",summary:"Adds a command line option.",since:6.9,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOption(string englishOption)",summary:"Adds a command line option.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOption(string englishOption,string englishOptionValue)",summary:"Adds a command line option.",since:5,returns:"Option index value (>0) or 0 if option cannot be added."},{signature:"int AddOption(string englishOption,string englishOptionValue,bool hiddenOption)",summary:"Adds a command line option.",since:6.9,returns:"Option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionColor(LocalizeStringPair optionName,OptionColor colorValue)",summary:"Add a command line option to get colors and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionColor(LocalizeStringPair optionName,OptionColor colorValue,string prompt)",summary:"Add a command line option to get colors and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionColor(string englishName,OptionColor colorValue)",summary:"Add a command line option to get colors and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionColor(string englishName,OptionColor colorValue,string prompt)",summary:"Add a command line option to get colors and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionDouble(LocalizeStringPair optionName,OptionDouble numberValue)",summary:"Adds a command line option to get numbers and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionDouble(LocalizeStringPair optionName,OptionDouble numberValue,string prompt)",summary:"Adds a command line option to get numbers and automatically saves the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionDouble(string englishName,OptionDouble numberValue)",summary:"Adds a command line option to get numbers and automatically save the value.",since:5,returns:"Option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionDouble(string englishName,OptionDouble numberValue,string prompt)",summary:"Adds a command line option to get numbers and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionEnumList(string englishOptionName,T defaultValue)",summary:"Adds a choice of enum values as list option",since:5.4,returns:"Option index"},{signature:"int AddOptionEnumList(string englishOptionName,T defaultValue,T[] include)",summary:"Adds a choice of enum values as list option. Allows to include only some enum values.",since:6,returns:"Option index"},{signature:"int AddOptionEnumSelectionList(string englishOptionName,IEnumerable<T> enumSelection,int listCurrentIndex)",summary:"Adds a list of enum values as option list. Use enumSelection[go.Option.CurrentListOptionIndex] to retrieve selection.",since:5.4},{signature:"int AddOptionInteger(LocalizeStringPair optionName,OptionInteger intValue)",summary:"Adds a command line option to get integers and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionInteger(LocalizeStringPair optionName,OptionInteger intValue,string prompt)",summary:"Adds a command line option to get integers and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionInteger(string englishName,OptionInteger intValue)",summary:"Adds a command line option to get integers and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionInteger(string englishName,OptionInteger intValue,string prompt)",summary:"Adds a command line option to get integers and automatically save the value.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionList(LocalizeStringPair optionName,IEnumerable<LocalizeStringPair> listValues,int listCurrentIndex)",summary:"Adds a command line list option.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionList(string englishOptionName,IEnumerable<string> listValues,int listCurrentIndex)",summary:"Adds a command line list option.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionToggle(LocalizeStringPair optionName,OptionToggle toggleValue)",summary:"Adds a command line option to toggle a setting.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"int AddOptionToggle(string englishName,OptionToggle toggleValue)",summary:"Adds a command line option to toggle a setting.",since:5,returns:"option index value (>0) or 0 if option cannot be added."},{signature:"void ClearCommandOptions()",summary:"Clear all command options.",since:5},{signature:"void ClearDefault()",summary:"Clears any defaults set using SetDefaultPoint, SetDefaultNumber, SetDefaultString, or SetCommandPromptDefault.",since:5},{signature:"Color Color()",summary:"Gets a color if Get*() returns GetResult.Color.",since:5,returns:"The color chosen by the user."},{signature:"Result CommandResult()",summary:"Helper method for getting command result value from getter results.",since:5,returns:"The converted command result."},{signature:"object CustomMessage()",since:5},{signature:"void Dispose()",since:5},{signature:"void EnableTransparentCommands(bool enable)",summary:"Control the availability of transparent commands during the get.",since:5},{signature:"T GetSelectedEnumValue()",summary:"Returns the selected enum value. Use this in combination with .\n     This must be called directly after having called a Get method, and having obtained a  value.",since:5.4},{signature:"T GetSelectedEnumValueFromSelectionList(IEnumerable<T> selectionList)",summary:"Returns the selected enum value by looking at the list of values from which to select.\n     Use this in combination with",since:5.4},{signature:"bool GotDefault()",summary:"Returns True if user pressed Enter to accept a default point, number,\n     or string set using SetDefaultPoint, SetDefaultNumber, or SetDefaultString.",since:5,returns:"True if the result if the default point, number or string set. Otherwise, false."},{signature:"System.Drawing.Point[] Line2d()",summary:"Returns two points defining the location in the view window of the 2d line selected\n     in GetPoint::Get2dLine().\n     (0,0) = upper left corner of window.",since:5,returns:"An array with two 2D points."},{signature:"double Number()",summary:"Gets a number if GetPoint.Get(), GetObject.GetObjects(), etc., returns GetResult.Number.",since:5,returns:"The number chosen by the user."},{signature:"CommandLineOption Option()",since:5},{signature:"int OptionIndex()",since:5},{signature:"Rectangle PickRectangle()",summary:"If the get was a GetObjects() and the mouse was used to select the objects,\n     then the returned rect has left < right and top < bottom. This rect\n     is the Windows GDI screen coordinates of the picking rectangle.\n     RhinoViewport.GetPickXform( pick_rect, pick_xform )\n     will calculate the picking transformation that was used.\n     In all other cases, left=right=top=bottom=0;",since:5,returns:"The picking rectangle; or 0 in the specified cases."},{signature:"Point3d Point()",summary:"Gets a point if Get*() returns GetResult.Point.",since:5,returns:"The point chosen by the user."},{signature:"System.Drawing.Point Point2d()",summary:"Returns location in view of point in selected in GetPoint::Get() or GetPoint::Get2dPoint().\n     (0,0) = upper left corner of window.",since:5,returns:"The location."},{signature:"Rectangle Rectangle2d()",summary:"Returns the location in the view of the 2d rectangle selected in GetPoint::Get2dRectangle().\n     rect.left < rect.right and rect.top < rect.bottom\n     (0,0) = upper left corner of window.",since:5,returns:"The rectangle."},{signature:"GetResult Result()",summary:"Returns result of the Get*() call.",since:5,returns:"The result of the last Get*() call."},{signature:"void SetCommandPrompt(string prompt)",summary:"Sets prompt message that appears in the command prompt window.",since:5},{signature:"void SetCommandPromptDefault(string defaultValue)",summary:"Sets message that describes what default value will be used if the user presses enter.\n     This description appears in angle brackets <> in the command prompt window. You do\n     not need to provide a default value description unless you explicity enable AcceptNothing.",since:5},{signature:"void SetDefaultColor(Color defaultColor)",summary:"Sets a color as default value that will be returned if the user presses ENTER key during the get.",since:5},{signature:"void SetDefaultInteger(int defaultValue)",summary:"Sets a number as default value that will be returned if the user presses ENTER key during the get.",since:5},{signature:"void SetDefaultNumber(double defaultNumber)",summary:"Sets a number as default value that will be returned if the user presses ENTER key during the get.",since:5},{signature:"void SetDefaultPoint(Point3d point)",summary:"Sets a point as default value that will be returned if the user presses the ENTER key during the get.",since:5},{signature:"void SetDefaultString(string defaultValue)",summary:"Sets a string as default value that will be returned\n     if the user presses ENTER key during the get.",since:5},{signature:"void SetWaitDuration(int milliseconds)",summary:"Sets the wait duration (in milliseconds) of the getter. If the duration passes without \n     the user making a decision, the GetResult.Timeout code is returned.",since:5},{signature:"string StringResult()",summary:"Gets a string if GetPoint.Get(), GetObject.GetObjects(), etc., returns GetResult.String.",since:5,returns:"The string chosen by the user."},{signature:"Vector3d Vector()",summary:"Gets a direction if Get*() returns GetResult.Point (Set by some digitizers, but in general it's (0,0,0).",since:5,returns:"The vector chosen by the user."},{signature:"RhinoView View()",summary:"Gets a view the user clicked in during GetPoint.Get(), GetObject.GetObjects(), etc.",since:5,returns:"The view chosen by the user."}]},{name:"Rhino.Input.Custom.GetCancel",dataType:1,summary:"",constructors:[{signature:"GetCancel()",since:6}],properties:[{signature:"IProgress<double> Progress",since:6},{signature:"string ProgressMessage",since:6},{signature:"bool ProgressReporting",since:6},{signature:"CancellationToken Token",since:6}],methods:[{signature:"Result Wait(Task task,RhinoDoc doc)",summary:"Awaits a particular task to finish.",since:7,returns:"A result enumeration."},{signature:"Result Wait(Task<TResult> task,RhinoDoc doc)",summary:"Awaits a particular task to finish.",since:6,returns:"A result enumeration."},{signature:"Result WaitAll(IEnumerable<Task<TResult>> tasks,RhinoDoc doc)",summary:"Awaits some tasks to finish.",returns:"A result enumeration."},{signature:"Result WaitAll(IEnumerable<Task> tasks,RhinoDoc doc)",summary:"Awaits some tasks to finish.",since:7,returns:"A result enumeration."}]},{name:"Rhino.Input.Custom.GetCircle",dataType:1,summary:"",constructors:[{signature:"GetCircle()",since:6}],properties:[{signature:"bool AllowDeformable",summary:"Allow for deformable options",since:6},{signature:"double DefaultSize",summary:"Default radius or diameter (based on InDiameterMode)",since:6},{signature:"bool Deformable",summary:"Is the deformable option set",since:6},{signature:"int DeformableDegree",since:6},{signature:"int DeformablePointCount",since:6},{signature:"bool InDiameterMode",summary:'Determines if the "size" value is reperesenting a radius or diameter',since:6}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"Commands.Result Get(Circle circle)",summary:"Perform the 'get' operation.",since:6}]},{name:"Rhino.Input.Custom.GetCone",dataType:1,summary:"Class provides user interface to define a cone.",constructors:[{signature:"GetCone()",since:6}],properties:[{signature:"bool AllowInputAngle",since:6},{signature:"double ApexAngleDegrees",since:6},{signature:"double BaseAngleDegrees",since:6},{signature:"bool Cap",summary:"Gets or sets whether or not the output should be capped.",since:6},{signature:"ConeConstraint ConeConstraint",summary:'State of the cone/cyl constraint option. When the cone/cyl option is\n     selected, the circle is being made as a base for a cone/cyl.\n     By default the vertical cone/cyl option not available but is not\n     selected.  By default the "Vertical" option applies to VerticalCircle.',since:6},{signature:"double DefaultSize",summary:"Default radius or diameter (based on InDiameterMode)",since:6},{signature:"double Height",since:6},{signature:"bool InDiameterMode",summary:'Determines if the "size" value is reperesenting a radius or diameter',since:6}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"Commands.Result Get(Cone cone)",summary:"Prompt for the getting of a cone.",since:6,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,Cone cone)",summary:"Prompt for the getting of a mesh cone.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,int capStyle,Cone cone)",summary:"Prompt for the getting of a mesh cone.",since:7,returns:"The result of the getting operation."}]},{name:"Rhino.Input.Custom.GetCylinder",dataType:1,summary:"Class provides user interface to define a cylinder.",constructors:[{signature:"GetCylinder()",since:6}],properties:[{signature:"bool BothSidesOption",summary:'Determine if the "both sides" option is enabled',since:6},{signature:"bool Cap",summary:"Gets or sets whether or not the output should be capped.",since:6},{signature:"CylinderConstraint CylinderConstraint",summary:'State of the cone/cyl constraint option. When the cone/cyl option is\n     selected, the circle is being made as a base for a cone/cyl.\n     By default the vertical cone/cyl option not available but is not\n     selected.  By default the "Vertical" option applies to VerticalCircle.',since:6},{signature:"double DefaultSize",summary:"Default radius or diameter (based on InDiameterMode)",since:6},{signature:"double Height",summary:"Height of cylinder",since:6},{signature:"bool InDiameterMode",summary:'Determines if the "size" value is reperesenting a radius or diameter',since:6}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"Commands.Result Get(Cylinder cylinder)",summary:"Prompt for the getting of a cylinder.",since:6,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,Cylinder cylinder)",summary:"Prompt for the getting of a mesh cylinder.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,int capStyle,Cylinder cylinder)",summary:"Prompt for the getting of a mesh cylinder.",since:7,returns:"The result of the getting operation."}]},{name:"Rhino.Input.Custom.GetEllipsoid",dataType:1,summary:"Class provides user interface to define a truncated cone.",constructors:[{signature:"GetEllipsoid()",since:7}],properties:[{signature:"Point3d FirstPoint",summary:'Returns the first point. If in "from foci" mode, then this is the first foci point.',since:7},{signature:"bool IsModeFromFoci",summary:"Indicates the ellipsoid was created from foci.",since:7},{signature:"bool MarkFoci",summary:"Indicates the user wants the ellipsoid foci marked with point objects.",since:7},{signature:"Point3d SecondPoint",summary:'Returns the second point. If in "from foci" mode, then this is the second foci point.',since:7}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"Commands.Result Get(NurbsSurface ellipsoid)",summary:"Prompt for the getting of a ellipsoid.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,bool quadCaps,Mesh ellipsoid)",summary:"Prompt for the getting of a mesh ellipsoid.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,Mesh ellipsoid)",summary:"Prompt for the getting of a mesh ellipsoid.",since:7,returns:"The result of the getting operation."}]},{name:"Rhino.Input.Custom.GetFileNameMode",dataType:3,summary:""},{name:"Rhino.Input.Custom.GetInteger",dataType:1,summary:"Used to get integer numbers.",constructors:[{signature:"GetInteger()",since:5}],methods:[{signature:"GetResult Get()",summary:"Call to get an integer.",since:5,returns:"If the user chose a number, then ; another enumeration value otherwise."},{signature:"int Number()",since:5},{signature:"void SetLowerLimit(int lowerLimit,bool strictlyGreaterThan)",summary:"Sets a lower limit on the number that can be returned.\n     By default there is no lower limit.",since:5},{signature:"void SetUpperLimit(int upperLimit,bool strictlyLessThan)",summary:"Sets an upper limit on the number that can be returned.\n     By default there is no upper limit.",since:5}]},{name:"Rhino.Input.Custom.GetLine",dataType:1,summary:'Use to interactively get a line.  The Rhino "Line" command uses GetLine.',constructors:[{signature:"GetLine()",since:5.1}],properties:[{signature:"bool AcceptZeroLengthLine",summary:"Controls whether or not a zero length line is acceptable.\n     The default is to require the user to keep picking the end\n     point until we get a point different than the start point.",since:5.1},{signature:"Color FeedbackColor",summary:"If set, the feedback color is used to draw the dynamic\n     line when the second point is begin picked.  If not set,\n     the active layer color is used.",since:5.1},{signature:"string FirstPointPrompt",summary:"Prompt when getting first point",since:5.1},{signature:"double FixedLength",summary:"If FixedLength > 0, the line must have the specified length",since:5.1},{signature:"GetLineMode GetLineMode",summary:"Mode used",since:5.1},{signature:"bool HaveFeedbackColor",summary:"If true, the feedback color is used to draw the dynamic\n     line when the second point is begin picked.  If false,\n     the active layer color is used.",since:5.1},{signature:"string MidPointPrompt",summary:"Prompt when getting midpoint",since:5.1},{signature:"string SecondPointPrompt",summary:"Prompt when getting second point",since:5.1}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.1},{signature:"void EnableAllVariations(bool on)",summary:"If true, then all line variations are shown if the default line mode is used",since:5.1},{signature:"void EnableFromBothSidesOption(bool on)",summary:'If true, then the "BothSides" option shows up when the\n     start point is inteactively picked.',since:5.1},{signature:"void EnableFromMidPointOption(bool on)",summary:'If true, the the "MidPoint" options shows up',since:5.1},{signature:"Commands.Result Get(Line line)",summary:"Perform the 'get' operation.",since:5.1},{signature:"void SetFirstPoint(Point3d point)",summary:"Use SetFirstPoint to specify the line's starting point and skip\n     the start point interactive picking",since:5.1}]},{name:"Rhino.Input.Custom.GetLineMode",dataType:3,summary:""},{name:"Rhino.Input.Custom.GetNumber",dataType:1,summary:"Used to get double precision numbers.",constructors:[{signature:"GetNumber()",summary:"Create a new GetNumber.",since:5}],methods:[{signature:"GetResult Get()",summary:"Call to get a number.",since:5,returns:"If the user chose a number, then ; another enumeration value otherwise."},{signature:"void SetLowerLimit(double lowerLimit,bool strictlyGreaterThan)",summary:"Sets a lower limit on the number that can be returned.\n     By default there is no lower limit.",since:5},{signature:"void SetUpperLimit(double upperLimit,bool strictlyLessThan)",summary:"Sets an upper limit on the number that can be returned.\n     By default there is no upper limit.",since:5}]},{name:"Rhino.Input.Custom.GetObject",dataType:1,summary:"The GetObject class is the tool commands use to interactively select objects.",constructors:[{signature:"GetObject()",since:5}],properties:[{signature:"bool AlreadySelectedObjectSelect",summary:"Allow selecting objects that are already selected. By default, GetObjects() disallows\n     selection of objects that are already selected to avoid putting the same object\n     in the selection set more than once. Calling EnableAlreadySelectedObjectSelect = true\n     overrides that restriction and allows selected objects to be selected and\n     returned by GetObjects. This is useful because, coupled with the return immediately\n     mode of GetObjects(1, -1), it is possible to select a selected object to deselect\n     when the selected objects are being managed outside GetObjects() as in the case of\n     CRhinoPolyEdge::GetEdge().",since:5},{signature:"bool BottomObjectPreference",summary:"By default, if a call to Input is permitted to select different parts of\n     the same object, like a polysurface, a surface and an edge, then the\n     top-most object is prefered. (polysurface beats face beats edge). If\n     you want the bottom most object to be prefered, then call \n     EnableBottomObjectPreference = True before calling GetObjects().",since:5},{signature:"bool ChooseOneQuestion",summary:"By default, if a call to Input is permitted to select different parts\n     of the same object, like a polysurface and an edge of that polysurface,\n     then the top-most object is automatically selected. If you want the\n     choose-one-object mechanism to include pop up in these cases, then call\n     EnableChooseOneQuestion = True before calling GetObjects().",since:5},{signature:"bool DeselectAllBeforePostSelect",summary:"True if pre-selected input will be deselected before\n     post-selection begins when no pre-selected input is valid.",since:5},{signature:"GeometryAttributeFilter GeometryAttributeFilter",summary:"The geometry attribute filter provides a secondary filter that\n     can be used to restrict which objects can be selected. Control\n     of the type of geometry (points, curves, surfaces, meshes, etc.)\n     is provided by GetObject.SetGeometryFilter. The geometry attribute\n     filter is used to require the selected geometry to have certain\n     attributes (open, closed, etc.). The default attribute filter\n     permits selection of all types of geometry.",since:5},{signature:"ObjectType GeometryFilter",summary:"The geometry type filter controls which types of geometry\n     (points, curves, surfaces, meshes, etc.) can be selected.\n     The default geometry type filter permits selection of all\n     types of geometry.\n     NOTE: the filter can be a bitwise combination of multiple ObjectTypes.",since:5},{signature:"bool GroupSelect",summary:"By default, groups are ignored in GetObject. If you want your call to\n     GetObjects() to select every object in a group that has any objects\n     selected, then enable group selection.",since:5},{signature:"bool InactiveDetailPickEnabled",summary:"By default, objects in inactive details are not permitted to be picked.\n     In a few rare cases this is used (ex. picking circles during DimRadius)",since:5.8},{signature:"int ObjectCount",summary:"Gets the number of objects that were selected.",since:5},{signature:"bool ObjectsWerePreselected",since:5},{signature:"bool OneByOnePostSelect",summary:"In one-by-one post selection, the user is forced\n     to select objects by post picking them one at a time.",since:5},{signature:"bool ReferenceObjectSelect",summary:"By default, reference objects can be selected. If you do not want to be\n     able to select reference objects, then call EnableReferenceObjectSelect=false.",since:5},{signature:"uint SerialNumber",summary:"Each instance of GetObject has a unique runtime serial number that\n     is used to identify object selection events associated with that instance.",since:5},{signature:"bool SubObjectSelect",summary:'By default, GetObject.Input will permit a user to select\n     sub-objects (like a curve in a b-rep or a curve in a group).\n     If you only want the user to select "top" level objects,\n     then call EnableSubObjectSelect = false.',since:5}],methods:[{signature:"static GetObject ActiveGetObject(RhinoDoc doc)",summary:"Get the currently running GetObject for a given document",since:6.3},{signature:"void AppendToPickList(ObjRef objref)",since:6.3},{signature:"void ClearObjects()",summary:"Clear possible special object drawing",since:6.12},{signature:"bool CustomGeometryFilter(RhinoObject rhObject,GeometryBase geometry,ComponentIndex componentIndex)",summary:"Checks geometry to see if it can be selected.\n     Override to provide fancy filtering.",since:5,returns:"The default returns True unless you've set a custom geometry filter. If a custom\n     filter has been set, that delegate is called."},{signature:"void DisablePreSelect()",since:5},{signature:"void EnableClearObjectsOnEntry(bool enable)",summary:"By default the picked object list is cleared when GetObject.GetObjects() is called.\n     If you are reusing a GetObject class and do not want the existing object list\n     cleared when you call Input, then call EnableClearObjectsOnEntry(false) before\n     calling GetObjects().",since:5},{signature:"void EnableHighlight(bool enable)",summary:"By default, any object post-pick selected by GetObjects() is highlighted.\n     If you want to post-pick objects and not have them automatically highlight,\n     then call EnableHighlight = false.",since:5},{signature:"void EnableIgnoreGrips(bool enable)",summary:"By default, post selection will select objects with grips on. If you do\n     not want to be able to post select objects with grips on, then call\n     EnableIgnoreGrips = false. The ability to preselect an object with grips\n     on is determined by the value returned by the virtual\n     RhinoObject.IsSelectableWithGripsOn.",since:5},{signature:"void EnablePostSelect(bool enable)",summary:"Control the availability of post selection in GetObjects.",since:5},{signature:"void EnablePreSelect(bool enable,bool ignoreUnacceptablePreselectedObjects)",summary:"Control the pre selection behavior GetObjects.",since:5},{signature:"void EnablePressEnterWhenDonePrompt(bool enable)",summary:'By default, when GetObject.GetObjects is called with minimumNumber > 0\n     and maximumNumber = 0, the command prompt automatically includes "Press Enter\n     when done" after the user has selected at least minimumNumber of objects. If\n     you want to prohibit the addition of the "Press Enter when done", then call\n     EnablePressEnterWhenDonePrompt = false;',since:5},{signature:"void EnableSelPrevious(bool enable)",summary:'By default, any object selected during a command becomes part of the\n     "previous selection set" and can be reselected by the SelPrev command.\n     If you need to select objects but do not want them to be selected by\n     a subsquent call to SelPrev, then call EnableSelPrev = false.',since:5},{signature:"void EnableUnselectObjectsOnExit(bool enable)",summary:"By default any objects in the object list are unselected when GetObject.GetObjects()\n     exits with any return code besides Object. If you want to leave the objects\n     selected when non-object input is returned, then call EnableUnselectObjectsOnExit(false)\n     before calling GetObjects().",since:5},{signature:"GetResult Get()",summary:"Call to select a single object.",since:5,returns:"GetResult.Object if an object was selected.\n     GetResult.Cancel if the user pressed ESCAPE to cancel the selection.\n     See GetResults for other possible values that may be returned when options, numbers,\n     etc., are acceptable responses."},{signature:"GetResult GetMultiple(int minimumNumber,int maximumNumber)",summary:"Call to select objects.",since:5,returns:"GetResult.Object if one or more objects were selected.\n     GetResult.Cancel if the user pressed ESCAPE to cancel the selection.\n     See GetResults for other possible values that may be returned when options, numbers,\n     etc., are acceptable responses."},{signature:"ObjRef Object(int index)",since:5},{signature:"ObjRef[] Objects()",since:5},{signature:"bool PassesGeometryAttributeFilter(RhinoObject rhObject,GeometryBase geometry,ComponentIndex componentIndex)",summary:"Checks geometry to see if it passes the basic GeometryAttributeFilter.",since:5,returns:"True if the geometry passes the filter returned by GeometryAttributeFilter()."},{signature:"void SetCustomGeometryFilter(GetObjectGeometryFilter filter)",summary:"Set filter callback function that will be called by the CustomGeometryFilter",since:5},{signature:"void SetPressEnterWhenDonePrompt(string prompt)",summary:'The default prompt when EnablePressEnterWhenDonePrompt is enabled is "Press Enter\n     when done". Use this function to specify a different string to be appended.',since:5}]},{name:"Rhino.Input.Custom.GetOption",dataType:1,summary:"If you want to explicitly get string input, then use GetString class with\n   options. If you only want to get options, then use this class (GetOption)",constructors:[{signature:"GetOption()",since:5}],methods:[{signature:"GetResult Get()",summary:'Call to get an option. A return value of "option" means the user selected\n     a valid option. Use Option() the determine which option.',since:5,returns:"If the user chose an option, then ; another enumeration value otherwise."}]},{name:"Rhino.Input.Custom.GetPoint",dataType:1,summary:"Used to interactively get a point.",constructors:[{signature:"GetPoint()",summary:"Create a new GetPoint.",since:5}],properties:[{signature:"Color DynamicDrawColor",summary:"Color used by CRhinoGetPoint::DynamicDraw to draw the current point and\n     the line from the base point to the current point.",since:5},{signature:"bool FullFrameRedrawDuringGet",summary:'In the "RARE" case that you need to draw some depth buffered geometry during\n     a Get() operation, setting this value to True will force entire frames to be redrawn\n     while the user moves the mouse. This allows DisplayPipeline events to be triggered\n     as well as OnPostDrawObjects\n     NOTE!! Setting this value to True comes with a significant performance penalty because the\n     scene needs to be fully regenerated every frame where the standard\n     DynamicDraw event draws temporary decorations (geometry) on top of a static scene.',since:5},{signature:"OsnapModes OsnapEventType",summary:"Gets the type of object snap used to obtain the point.",since:6.24},{signature:"object Tag",summary:"Gets or sets an arbitrary object that can be attached to this  instance.\n     Useful for passing some/ information that you may need in a DynamicDraw event since you can get at this Tag from\n     the GetPointDrawEventArgs.",since:5}],methods:[{signature:"int AddConstructionPoint(Point3d point)",summary:"Adds a point to the list of construction points.",since:5,returns:"Total number of construction points."},{signature:"int AddConstructionPoints(Point3d[] points)",summary:"Adds points to the list of construction points.",since:5,returns:"Total number of construction points."},{signature:"int AddSnapPoint(Point3d point)",summary:"Adds a point to the list of osnap points.",since:5,returns:"Total number of snap points."},{signature:"int AddSnapPoints(Point3d[] points)",summary:"Adds points to the list of osnap points.",since:5,returns:"Total number of snap points."},{signature:"void ClearConstraints()",summary:"Removes any explicit constraints added by calls to GetPoint::Constraint() and enable\n     the built-in constraint options.",since:5},{signature:"void ClearConstructionPoints()",summary:"Remove all construction points.",since:5},{signature:"void ClearSnapPoints()",summary:"Remove all snap points.",since:5},{signature:"bool Constrain(Arc arc)",summary:"Constrains the picked point to lie on an arc.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Brep brep,int wireDensity,int faceIndex,bool allowPickingPointOffObject)",summary:"Constrains the picked point to lie on a brep.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Circle circle)",summary:"Constrains the picked point to lie on a circle.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Curve curve,bool allowPickingPointOffObject)",summary:"Constrains the picked point to lie on a curve.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Cylinder cylinder)",summary:"Constrains the picked point to lie on a cylinder.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Line line)",summary:"Constrains the picked point to lie on a line.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Mesh mesh,bool allowPickingPointOffObject)",summary:"Constrains the picked point to lie on a mesh.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Plane plane,bool allowElevator)",summary:"constrain the picked point to lie on a plane.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Point3d from,Point3d to)",summary:"Constrains the picked point to lie on a line.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Sphere sphere)",summary:"Constrains the picked point to lie on a sphere.",since:5,returns:"True if constraint could be applied."},{signature:"bool Constrain(Surface surface,bool allowPickingPointOffObject)",summary:"Constrains the picked point to lie on a surface.",since:5,returns:"True if constraint could be applied."},{signature:"void ConstrainDistanceFromBasePoint(double distance)",summary:"Sets distance constraint from base point.",since:5},{signature:"bool ConstrainToConstructionPlane(bool throughBasePoint)",summary:"If enabled, the picked point is constrained to be on the active construction plane.\n     If the base point is set, then the point is constrained to be on the plane that contains\n     the base point and is parallel to the active construction plane. By default this\n     constraint is enabled.",since:5,returns:"If True and the base point is set, then the point is constrained to be on the plane parallel\n     to the construction plane that passes through the base point, even when planar mode is off.\n     If throughBasePoint is false, then the base point shift only happens if planar mode is on."},{signature:"void ConstrainToTargetPlane()",summary:"Constrains point to lie on a plane that is parallel to the\n     viewing plane and passes through the view's target point.",since:5},{signature:"bool ConstrainToVirtualCPlaneIntersection(Plane plane)",summary:"If enabled, the picked point is constrained to be on the \n     intersection of the plane and the virtual CPlane going through\n     the plane origin.\n     If the planes are parallel, the constraint works just like planar constraint.",since:5,returns:"True if the operation succeeded; False otherwise."},{signature:"void DrawLineFromPoint(Point3d startPoint,bool showDistanceInStatusBar)",summary:"Use DrawLineFromPoint() if you want a dynamic line drawn from a point to the point being picked.",since:5},{signature:"void EnableCurveSnapArrow(bool drawDirectionArrowAtSnapPoint,bool reverseArrow)",summary:"Controls display of the curve snap arrow icon.",since:5},{signature:"void EnableCurveSnapPerpBar(bool drawPerpBarAtSnapPoint,bool drawEndPoints)",summary:"Controls display of the curve snap perpendicular bar icon.",since:5},{signature:"void EnableCurveSnapTangentBar(bool drawTangentBarAtSnapPoint,bool drawEndPoints)",summary:"Controls display of the curve snap tangent bar icon.",since:5},{signature:"void EnableDrawLineFromPoint(bool enable)",summary:"Controls drawing of dynamic a line from the start point.",since:5},{signature:"void EnableNoRedrawOnExit(bool noRedraw)",summary:"The default functionality of the getpoint operation is to perform a redraw on exit.\n     Calling this function with True turns off automatic redraw at the end of GetPoint.\n     May be needed in some commands for flicker free feedback.\n     When set to true, the caller is responsible for cleaning up the screen\n     after GetPoint.",since:6},{signature:"void EnableObjectSnapCursors(bool enable)",summary:"Enables or disables object snap cursors. By default, object snap cursors are enabled.",since:6},{signature:"void EnableSnapToCurves(bool enable)",summary:"If you want GetPoint() to try to snap to curves when the mouse is near a curve\n     (like the center point in the Circle command when the AroundCurve option is on),\n     then enable the snap to curves option.",since:5},{signature:"GetResult Get()",summary:"After setting up options and so on, call GetPoint::Get to get a 3d point. The\n     point is retrieved when the mouse goes down.",since:5},{signature:"GetResult Get(bool onMouseUp)",summary:"After setting up options and so on, call this method to get a 3d point.",since:5,returns:"if the user chose a point; other enumeration value otherwise."},{signature:"GetResult Get(bool onMouseUp,bool get2DPoint)",summary:"After setting up options and so on, call this method to get a 2d or 3d point.",since:5.12,returns:"if the user chose a 3d point;  if the user chose a 2d point; other enumeration value otherwise."},{signature:"Point3d[] GetConstructionPoints()",summary:"Gets current construction points.",since:5,returns:"An array of points."},{signature:"bool GetPlanarConstraint(RhinoViewport vp,Plane plane)",since:6},{signature:"Point3d[] GetSnapPoints()",summary:"Gets current snap points.",since:5,returns:"An array of points."},{signature:"bool InterruptMouseMove()",summary:"If you have lengthy computations in OnMouseMove() and/or DymanicDraw()\n     overrides, then periodically call InterruptMouseMove() to see if you\n     should interrupt your work because the mouse has moved again.",since:5,returns:"True if you should interrupt your work; False otherwise."},{signature:"void PermitConstraintOptions(bool permit)",summary:'Control the availability of the built-in linear, planar, curve, and surface\n     constraint options like "Along", "AlongPerp", "AlongTan", "AlongParallel",\n     "Between", "OnCrv", "OnSrf", ".x", ".y", ".z", ".xy", etc.',since:5},{signature:"void PermitElevatorMode(int permitMode)",summary:"Permits the use of the control key to define a line constraint.",since:5},{signature:"void PermitFromOption(bool permit)",summary:'Control the availability of the built-in "From" option. By default, the "From" option is enabled.',since:5},{signature:"void PermitObjectSnap(bool permit)",summary:'By default, object snaps like "end", "near", etc. are controled by the user.\n     If you want to disable this ability, then call PermitObjectSnap(false).',since:5},{signature:"void PermitOrthoSnap(bool permit)",summary:"Controls availability of ortho snap. Default is true.",since:5},{signature:"void PermitTabMode(bool permit)",summary:"Permits the use of the tab key to define a line constraint.",since:5},{signature:"BrepFace PointOnBrep(double u,double v)",summary:"Use to determine if point was on a Brep face. If the point was on a Brep face, \n     then the (u,v) are the face parameters for the point.",since:6,returns:"The Brep face or None if the point was not on a Brep face."},{signature:"Curve PointOnCurve(double t)",summary:"Use to determine is point was on a curve.",since:5,returns:"A curve at a specified parameter value."},{signature:"DocObjects.ObjRef PointOnObject()",summary:"Call this function to see if the point was on an object. If the point was\n     on an object an ObjRef is returned; otherwise None is returned.",since:5,returns:"A point object reference."},{signature:"Surface PointOnSurface(double u,double v)",summary:"Use to determine if point was on a surface. If the point was on a surface, \n     then the (u,v) are the surface parameters for the point. The point returned\n     by Point() is the same as surface.PointAt(u,v).",since:6,returns:"The surface or None if the point was not on a surface."},{signature:"void SetBasePoint(Point3d basePoint,bool showDistanceInStatusBar)",summary:"Sets a base point used by ortho snap, from snap, planar snap, etc.",since:5},{signature:"void SetCursor(CursorStyle cursor)",summary:"Sets cursor that will be used when Get() is called and snap is not\n     happening.",since:6},{signature:"bool TryGetBasePoint(Point3d basePoint)",since:5}]},{name:"Rhino.Input.Custom.GetPointDrawEventArgs",dataType:1,summary:"Arguments for drawing during point getting.",properties:[{signature:"Point3d CurrentPoint",since:5},{signature:"GetPoint Source",summary:"GetPoint class that this draw event originated from.",since:5}]},{name:"Rhino.Input.Custom.GetPointMouseEventArgs",dataType:1,summary:"Arguments for mouse information during point getting.",properties:[{signature:"bool ControlKeyDown",since:5},{signature:"bool LeftButtonDown",since:5},{signature:"bool MiddleButtonDown",since:5},{signature:"Point3d Point",since:5},{signature:"bool RightButtonDown",since:5},{signature:"bool ShiftKeyDown",since:5},{signature:"GetPoint Source",since:5},{signature:"RhinoViewport Viewport",since:5},{signature:"Point WindowPoint",since:5}]},{name:"Rhino.Input.Custom.GetPolyline",dataType:1,summary:"Use to interactively get a polyline.",constructors:[{signature:"GetPolyline()",since:6}],properties:[{signature:"string FirstPointPrompt",summary:"Prompt when getting first point",since:6},{signature:"string FourthPointPrompt",summary:"Prompt when getting fourth point",since:6},{signature:"int MaxPointCount",since:6},{signature:"int MinPointCount",since:6},{signature:"string SecondPointPrompt",summary:"Prompt when getting second point",since:6},{signature:"string ThirdPointPrompt",summary:"Prompt when getting third point",since:6}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"Commands.Result Get(Polyline polyline)",summary:"Perform the 'get' operation.",since:6},{signature:"void SetFirstPoint(Point3d point)",summary:"Use SetFirstPoint to specify the line's starting point and skip\n     the start point interactive picking",since:6}]},{name:"Rhino.Input.Custom.GetSphere",dataType:1,summary:"Class provides user interface to define a sphere.",constructors:[{signature:"GetSphere()",since:7}],properties:[{signature:"double DefaultSize",summary:"Default radius or diameter (based on InDiameterMode)",since:7},{signature:"bool InDiameterMode",summary:'Determines if the "size" value is reperesenting a radius or diameter',since:7}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"Commands.Result Get(Sphere sphere)",summary:"Prompt for the getting of a sphere.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(MeshSphereStyle style,int verticalFaces,int aroundFaces,int triangleSubdivisions,int quadSubdivisions,Sphere sphere)",summary:"Prompt for the getting of a mesh sphere.",since:7,returns:"The result of the getting operation."}]},{name:"Rhino.Input.Custom.GetString",dataType:1,summary:"Used to get strings.",constructors:[{signature:"GetString()",summary:"Constructs a new GetString.",since:5}],methods:[{signature:"GetResult Get()",summary:"Returns the string that the user typed. By default, space stops the string input.",since:5,returns:"The result type. If the user typed a string, this is ."},{signature:"GetResult GetLiteralString()",summary:"Returns the string that the user typed. By default, space does not stop input.",since:5,returns:"The result type. If the user typed a string, this is ."}]},{name:"Rhino.Input.Custom.GetTorus",dataType:1,summary:"Class provides user interface to define a torus.",constructors:[{signature:"GetTorus()",since:7}],properties:[{signature:"double DefaultSize",summary:"Default radius or diameter (based on InDiameterMode)",since:7},{signature:"bool FixInnerRadius",summary:"Second radius opion. The first radius chosen sets the inner dimension of the torus and the second radius is constrained to be outside of the first radius.",since:7},{signature:"bool InDiameterMode",summary:'Determines if the "size" value is reperesenting a radius or diameter',since:7},{signature:"bool InSecondDiameterMode",summary:'Second radius opion. Determines if the second "size" value is reperesenting a radius or diameter',since:7},{signature:"double SecondSize",summary:"Second radius or diameter (based on InSecondDiameterMode)",since:7}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"Commands.Result Get(Torus torus)",summary:"Prompt for the getting of a torus.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,Torus torus)",summary:"Prompt for the getting of a mesh torus.",since:7,returns:"The result of the getting operation."}]},{name:"Rhino.Input.Custom.GetTransform",dataType:1,summary:"Used for getting a Transform",properties:[{signature:"bool HaveTransform",since:5},{signature:"TransformObjectList ObjectList",since:5},{signature:"Transform Transform",since:5}],methods:[{signature:"void AddTransformObjects(TransformObjectList list)",summary:"Adds any objects you want transformed and grips you want transformed.\n     Make sure no duplicates are in the list and that no grip ownwers are\n     passed in as objects.",since:5},{signature:"Transform CalculateTransform(RhinoViewport viewport,Point3d point)",summary:"Retrieves the final transformation.\n     Override this virtual function to provide your own custom transformation method.",since:5,returns:"A transformation matrix value."},{signature:"GetResult GetXform()",summary:"Gets the Transformation.\n     Call this after having set up options and so on.",since:5,returns:"The result based on user choice."}]},{name:"Rhino.Input.Custom.GetTruncatedCone",dataType:1,summary:"Class provides user interface to define a truncated cone.",constructors:[{signature:"GetTruncatedCone()",since:7}],properties:[{signature:"bool Cap",summary:"Gets or sets whether or not the output should be capped.",since:7},{signature:"CylinderConstraint CylinderConstraint",summary:'State of the cone/cyl constraint option. When the cone/cyl option is\n     selected, the circle is being made as a base for a cone/cyl.\n     By default the vertical cone/cyl option not available but is not\n     selected.  By default the "Vertical" option applies to VerticalCircle.',since:7},{signature:"double DefaultSize",summary:"Default radius or diameter (based on InDiameterMode)",since:7},{signature:"double Height",summary:"Height of truncated cone.",since:7},{signature:"bool InDiameterMode",summary:'Determines if the "size" value is reperesenting a radius or diameter',since:7},{signature:"double SecondRadius",summary:"Radius of second circle.",since:7}],methods:[{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"Commands.Result Get(Brep truncatedCone)",summary:"Prompt for the getting of a truncated cone.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,int capStyle,Mesh truncatedCone)",summary:"Prompt for the getting of a mesh truncated cone.",since:7,returns:"The result of the getting operation."},{signature:"Commands.Result GetMesh(int verticalFaces,int aroundFaces,Mesh truncatedCone)",summary:"Prompt for the getting of a mesh truncated cone.",since:7,returns:"The result of the getting operation."}]},{name:"Rhino.Input.Custom.OptionColor",dataType:1,summary:"",constructors:[{signature:"OptionColor(Color initialValue)",since:5}],properties:[{signature:"Color CurrentValue",since:5},{signature:"Color InitialValue",since:5}],methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.Input.Custom.OptionDouble",dataType:1,summary:"",constructors:[{signature:"OptionDouble(double initialValue)",since:5},{signature:"OptionDouble(double initialValue,bool setLowerLimit,double limit)",summary:"Initializes a new instance of the double option class.",since:5},{signature:"OptionDouble(double initialValue,double lowerLimit,double upperLimit)",summary:"Initializes a new instance of the  class with lower and upper limits.",since:5}],properties:[{signature:"double CurrentValue",since:5},{signature:"double InitialValue",since:5}],methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.Input.Custom.OptionInteger",dataType:1,summary:"",constructors:[{signature:"OptionInteger(int initialValue)",since:5},{signature:"OptionInteger(int initialValue,bool setLowerLimit,int limit)",summary:"Initializes a new instance of the  class.",since:5},{signature:"OptionInteger(int initialValue,int lowerLimit,int upperLimit)",summary:"Initializes a new instance of the  class wiht both lower and upper limits.",since:5}],properties:[{signature:"int CurrentValue",since:5},{signature:"int InitialValue",since:5}],methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.Input.Custom.OptionToggle",dataType:1,summary:"",constructors:[{signature:"OptionToggle(bool initialValue,LocalizeStringPair offValue,LocalizeStringPair onValue)",since:5},{signature:"OptionToggle(bool initialValue,string offValue,string onValue)",since:5}],properties:[{signature:"bool CurrentValue",since:5},{signature:"bool InitialValue",since:5}],methods:[{signature:"void Dispose()",since:5}]},{name:"Rhino.Input.Custom.PickContext",dataType:1,summary:"Utility for determining if objects are picked",constructors:[{signature:"PickContext()",since:5}],properties:[{signature:"GetObject GetObjectUsed",since:5},{signature:"bool PickGroupsEnabled",summary:"Thue if GroupObjects should be added to the pick list",since:5},{signature:"Line PickLine",summary:"pick chord starts on near clipping plane and ends on far clipping plane.",since:5},{signature:"PickMode PickMode",since:5},{signature:"PickStyle PickStyle",since:5},{signature:"bool SubObjectSelectionEnabled",summary:"True if the user had activated subobject selection",since:5},{signature:"RhinoView View",summary:"This view can be a model view or a page view. When view is a page view,\n     then you need to distingish between the viewports MainViewport() and\n     ActiveViewport().  When m_view is a model view, both MainViewport() and\n     ActiveViewport() return the world view's viewport.",since:5}],methods:[{signature:"void Dispose()",since:5},{signature:"bool PickFrustumTest(BezierCurve bezier,double t,double depth,double distance)",since:5},{signature:"bool PickFrustumTest(BoundingBox box,bool boxCompletelyInFrustum)",summary:"Fast test to check if a bounding box intersects a pick frustum.",since:5,returns:"False if bbox is invalid or box does not intersect the pick frustum"},{signature:"bool PickFrustumTest(Line line,double t,double depth,double distance)",since:5},{signature:"bool PickFrustumTest(Mesh mesh,MeshPickStyle pickStyle,Point3d hitPoint,double depth,double distance,MeshHitFlag hitFlag,int hitIndex)",summary:"Utility for picking meshes",since:5},{signature:"bool PickFrustumTest(Mesh mesh,MeshPickStyle pickStyle,Point3d hitPoint,Point2d hitSurfaceUV,Point2d hitTextureCoordinate,double depth,double distance,MeshHitFlag hitFlag,int hitIndex)",summary:"Utility for picking meshes",since:5},{signature:"bool PickFrustumTest(NurbsCurve curve,double t,double depth,double distance)",since:5},{signature:"bool PickFrustumTest(Point3d point,double depth,double distance)",summary:"Utility for picking 3d point",since:5,returns:"True if there is a hit"},{signature:"bool PickFrustumTest(Point3d[] points,int pointIndex,double depth,double distance)",since:5},{signature:"bool PickFrustumTest(PointCloud cloud,int pointIndex,double depth,double distance)",since:5},{signature:"int[] PickMeshTopologyVertices(Mesh mesh)",summary:"Utility for picking mesh vertices",since:5,returns:"indices of mesh topology vertices that were picked"},{signature:"void SetPickTransform(Transform transform)",since:5},{signature:"void UpdateClippingPlanes()",summary:"Updates the clipping plane information in pick region. The\n     SetClippingPlanes and View fields must be called before calling\n     UpdateClippingPlanes().",since:5}]},{name:"Rhino.Input.Custom.PickContext.MeshHitFlag",dataType:3,summary:""},{name:"Rhino.Input.Custom.PickContext.MeshPickStyle",dataType:3,summary:""},{name:"Rhino.Input.Custom.PickMode",dataType:3,summary:"Picking can happen in wireframe or shaded display mode"},{name:"Rhino.Input.Custom.PickStyle",dataType:3,summary:"Provides picking values that describe common CAD picking behavior."},{name:"Rhino.Input.Custom.TaskCompleteEventArgs",dataType:1,summary:"",constructors:[{signature:"TaskCompleteEventArgs(Task task,RhinoDoc doc)",since:6}],properties:[{signature:"RhinoDoc Doc",since:6},{signature:"bool Redraw",since:6},{signature:"Task Task",since:6}]},{name:"Rhino.Input.GetBoxMode",dataType:3,summary:"Enumerates all Box getter modes."},{name:"Rhino.Input.GetResult",dataType:3,summary:"Possible results from GetObject.Get(), GetPoint.Get(), etc..."},{name:"Rhino.Input.RhinoGet",dataType:1,summary:'Base class for GetObject, GetPoint, GetSphere, etc.\n   \n   You will never directly create a RhinoGet but you will use its member\n   functions after calling GetObject::GetObjects(), GetPoint::GetPoint(), and so on.\n   \n   Provides tools to set command prompt, set command options, and specify\n   if the "get" can optionally accept numbers, nothing (pressing enter),\n   and undo.',properties:[{signature:"static BitmapFileTypes AllBitmapFileTypes",since:6}],methods:[{signature:"static Result Get2dRectangle(bool solidPen,Rectangle rectangle,RhinoView rectView)",summary:"Gets a rectangle in view window coordinates.",since:5,returns:"Success or Cancel."},{signature:"static Result GetAngle(string commandPrompt,Point3d basePoint,Point3d referencePoint,double defaultAngleRadians,double angleRadians)",summary:"Allows user to interactively pick an angle",since:5.2},{signature:"static Result GetArc(Arc arc)",since:5},{signature:"static Result GetBool(string prompt,bool acceptNothing,string offPrompt,string onPrompt,bool boolValue)",summary:"Easy to use bool getter.",since:5,returns:"The getter result based on user choice.\n     Commands.Result.Success - got value.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancelled value getting."},{signature:"static Result GetBox(Box box)",summary:"Asks the user to select a Box in the viewport.",since:5,returns:"Commands.Result.Success if successful."},{signature:"static Result GetBox(Box box,GetBoxMode mode,Point3d basePoint,string prompt1,string prompt2,string prompt3)",summary:"Asks the user to select a Box in the viewport.",since:5,returns:"Commands.Result.Success if successful."},{signature:"static Result GetBoxWithCounts(int xMin,int xCount,int yMin,int yCount,int zMin,int zCount,Point3d[] corners)",summary:"Gets a 3d box with prompts for counts in X, Y and Z directions.",since:6,returns:"Commands.Result.Success if successful."},{signature:"static Result GetCircle(Circle circle)",since:5},{signature:"static Result GetColor(string prompt,bool acceptNothing,Color color)",summary:"Easy to use color getter.",since:5,returns:"Commands.Result.Success - got color.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancel color getting."},{signature:"static string GetFileName(GetFileNameMode mode,string defaultName,string title,object parent)",since:6},{signature:"static string GetFileName(GetFileNameMode mode,string defaultName,string title,object parent,BitmapFileTypes fileTypes)",since:6},{signature:"static string GetFileNameScripted(GetFileNameMode mode,string defaultName)",since:5},{signature:"static Result GetGrip(GripObject grip,string prompt)",since:5},{signature:"static Result GetGrips(GripObject[] grips,string prompt)",since:5},{signature:"static Result GetHelix(NurbsCurve helix)",since:5},{signature:"static Result GetInteger(string prompt,bool acceptNothing,int outputNumber)",summary:"Easy to use number getter.",since:5,returns:"Commands.Result.Success - got number\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel number getting."},{signature:"static Result GetInteger(string prompt,bool acceptNothing,int outputNumber,int lowerLimit,int upperLimit)",summary:"Easy to use number getter.",since:5,returns:"Commands.Result.Success - got number\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel number getting."},{signature:"static Result GetLine(Line line)",since:5},{signature:"static Result GetLinearDimension(LinearDimension dimension)",since:5},{signature:"static Result GetMultipleObjects(string prompt,bool acceptNothing,GetObjectGeometryFilter filter,ObjRef[] rhObjects)",summary:"Easy to use object getter for getting multiple objects.",since:5,returns:"Commands.Result.Success - got object\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel object getting."},{signature:"static Result GetMultipleObjects(string prompt,bool acceptNothing,ObjectType filter,ObjRef[] rhObjects)",summary:"Easy to use object getter for getting multiple objects.",since:5,returns:"Commands.Result.Success - got object\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel object getting."},{signature:"static Result GetNumber(string prompt,bool acceptNothing,double outputNumber)",summary:"Easy to use number getter.",since:5,returns:"Commands.Result.Success - got number\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel number getting."},{signature:"static Result GetNumber(string prompt,bool acceptNothing,double outputNumber,double lowerLimit,double upperLimit)",summary:"Easy to use number getter.",since:5,returns:"Commands.Result.Success - got number.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancel number getting."},{signature:"static Result GetOneObject(string prompt,bool acceptNothing,GetObjectGeometryFilter filter,ObjRef objref)",summary:"Easy to use object getter.",since:5,returns:"Commands.Result.Success - got object\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel object getting."},{signature:"static Result GetOneObject(string prompt,bool acceptNothing,ObjectType filter,ObjRef rhObject)",summary:"Easy to use object getter.",since:5,returns:"Commands.Result.Success - got object\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel object getting."},{signature:"static Result GetPlane(Plane plane)",summary:"Gets an oriented infinite plane.",since:5,returns:"Commands.Result.Success - got plane.Commands.Result.Nothing - user pressed enter.Commands.Result.Cancel - user cancel number getting."},{signature:"static Result GetPoint(string prompt,bool acceptNothing,Point3d point)",summary:"Gets a point coordinate from the document.",since:5,returns:"Commands.Result.Success - got point\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel point getting."},{signature:"static Result GetPointOnMesh(Guid meshObjectId,string prompt,bool acceptNothing,Point3d point)",summary:"Gets a point constrained to an existing mesh in the document.",since:5,returns:"A command result based on user choice."},{signature:"static Result GetPointOnMesh(MeshObject meshObject,string prompt,bool acceptNothing,Point3d point)",summary:"Gets a point constrained to an existing mesh in the document.",since:5,returns:"The command result based on user choice."},{signature:"static Result GetPolygon(int numberSides,bool inscribed,Polyline polyline)",since:6},{signature:"static Result GetPolyline(Polyline polyline)",since:5.9},{signature:"static Result GetPrintWindow(ViewCaptureSettings settings)",since:6.1},{signature:"static Result GetRectangle(GetBoxMode mode,Point3d firstPoint,IEnumerable<string> prompts,Point3d[] corners)",summary:"Gets a 3d rectangle made up of four points.",since:5,returns:"Commands.Result.Success if successful."},{signature:"static Result GetRectangle(Point3d[] corners)",summary:"Gets a 3d rectangle.",since:5,returns:"Commands.Result.Success if successful."},{signature:"static Result GetRectangle(string firstPrompt,Point3d[] corners)",summary:"Gets a 3d rectangle.",since:6,returns:"Commands.Result.Success if successful."},{signature:"static Result GetRectangleWithCounts(int xMin,int xCount,int yMin,int yCount,Point3d[] corners)",summary:"Gets a 3d rectangle with prompts for counts in X and Y directions.",since:6,returns:"Commands.Result.Success if successful."},{signature:"static Result GetSpiral(NurbsCurve spiral)",since:5},{signature:"static Result GetString(string prompt,bool acceptNothing,string outputString)",summary:"Easy to use string getter.",since:5,returns:"Commands.Result.Success - got string\n     Commands.Result.Nothing - user pressed enter\n     Commands.Result.Cancel - user cancel string getting."},{signature:"static Result GetView(string commandPrompt,RhinoView view)",summary:"Allows the user to interactively pick a viewport.",since:5,returns:"The result based on user choice."},{signature:"static bool InGet(RhinoDoc doc)",summary:'Returns True if the document is current in a "Get" operation.',since:5,returns:"True if a getter is currently active."},{signature:"static bool InGetObject(RhinoDoc doc)",summary:"Returns True if currently in a GetObject.GetObjects()",since:6},{signature:"static bool InGetPoint(RhinoDoc doc)",summary:"Returns True if currently in a GetPoint.Get()",since:6},{signature:"static string StringToCommandOptionName(string stringToConvert)",summary:"Convert some arbitrary string value to a valid command option name\n     removing any invalid characters.",since:6,returns:"Returns None if the string is None or empty or if it contains nothing\n     but invalid characters.  If the converted string is one or more\n     characters in length then the converted value is returned."},{signature:"static LocalizeStringPair StringToCommandOptionName(string englishString,string localizedString)",summary:"Convert some arbitrary string value to a valid command option name\n     removing any invalid characters.",since:6,returns:"Returns None if the strings are None or empty or if they contain\n     nothing but invalid characters.  If the converted string is one or more\n     charcters in length then a  is returned\n     characters the converted string values.  If the localized string is\n     None or empty then the English string is used as the localized value."}]},{name:"Rhino.Input.RhinoGet.BitmapFileTypes",dataType:3,summary:""},{name:"Rhino.Input.StringParser",dataType:1,summary:"Parse strings to numbers, distances and angles",methods:[{signature:"static int ParseAngleExpession(string expression,int start_offset,int expression_length,StringParserSettings parse_settings_in,AngleUnitSystem output_angle_unit_system,double value_out,StringParserSettings parse_results,AngleUnitSystem parsed_unit_system)",since:6},{signature:"static bool ParseAngleExpressionDegrees(string expression,double angle_degrees)",since:6},{signature:"static bool ParseAngleExpressionRadians(string expression,double angle_radians)",since:6},{signature:"static int ParseLengthExpession(string expression,int start_offset,int expression_length,StringParserSettings parse_settings_in,UnitSystem output_unit_system,double value_out,StringParserSettings parse_results,UnitSystem parsed_unit_system)",summary:"Parse a string for a length value.\n     Expression can include complex expressions\n     Most complex version of length parsing",since:6,returns:"Returns the count of characters that were parsed or 0 if the operation was unsuccesful"},{signature:"static int ParseLengthExpession(string expression,StringParserSettings parse_settings_in,UnitSystem output_unit_system,double value_out)",summary:"Parse a string for a length value.\n     Expression can include complex expressions\n     Simplest version of Length parsing",since:6,returns:"Count of characters parsed or 0 for failure"},{signature:"static int ParseNumber(string expression,int max_count,StringParserSettings settings_in,StringParserSettings settings_out,double answer)",summary:"Parse a string expression to get a number",since:6,returns:"Count of characters in expression parsed\n     if ParseNumber() returns 0, parse was unsuccesful"}]},{name:"Rhino.Input.StringParserSettings",dataType:1,summary:"Parameters for parsing strings",constructors:[{signature:"StringParserSettings()",since:6}],properties:[{signature:"static StringParserSettings DefaultParseSettings",summary:"- The default settings parse just about everything in\n       a reasonable way.  \n     - Any angle values with unspecified units will be\n       treated as radians. Angles without units can be\n       encountered while parsing formulas, lengths and \n       points and need to be thoughtfully considered in\n       most parsing situations.",since:6},{signature:"static StringParserSettings ParseSettingsDegrees",summary:"- The default settings parse just about everything in\n       a reasonable way.\n     - Any angle values with unspecified units will be\n       treated as degrees.Angles without units can be\n      encountered while parsing formulas, lengths and\n      points and need to be thoughtfully considered in\n       most parsing situations.",since:6},{signature:"static StringParserSettings ParseSettingsDoubleNumber",summary:"- The double number settings parse and optional unary + or unary -\n       and then parse a number that can be integer, decimal, or\n       scientific e notation.",since:6},{signature:"static StringParserSettings ParseSettingsEmpty",summary:"- ON_ParseSetting::FalseSettings has all parsing options\n       set to false.\n     - A common use of ON_ParseSettings FalseSettings is to intialize\n       ON_ParseSettings classes that are used to report what happened\n       during parsing.Any parsing results value set to True after\n       parsing indicates that type of parsing occured.",since:6},{signature:"static StringParserSettings ParseSettingsIntegerNumber",summary:"- The integer settings parse and optional unary + or unary - and\n       then parses one or more digits.Parsing stops after the last digit.",since:6},{signature:"static StringParserSettings ParseSettingsRadians",summary:"- The default settings parse just about everything in\n       a reasonable way.\n     - Any angle values with unspecified units will be\n       treated as radians.Angles without units can be\n       encountered while parsing formulas, lengths and\n       points and need to be thoughtfully considered in\n       most parsing situations.",since:6},{signature:"static StringParserSettings ParseSettingsRationalNumber",summary:"- The rational number settings parse and optional unary + or unary -\n       and then parse one or more digits.If a rational number fraction\n       bar follows the last digit in the numerator, then it is parsed\n       and an integer denominator is parsed.The denominator cannot\n       have a unary + or - preceding the digits.Parsing stops after\n       the last digit in the denominator.",since:6},{signature:"static StringParserSettings ParseSettingsRealNumber",summary:"- The real number settings parse and optional unary + or unary -\n       and then parse a number that can be integer, decimal, \n       scientific e notation or pi.",since:6},{signature:"AngleUnitSystem DefaultAngleUnitSystem",since:6},{signature:"UnitSystem DefaultLengthUnitSystem",since:6},{signature:"bool ParseAddition",since:6},{signature:"bool ParseArcDegreesMinutesSeconds",since:6},{signature:"bool ParseArithmeticExpression",since:6},{signature:"bool ParseCommaAsDecimalPoint",since:6},{signature:"bool ParseCommaAsDigitSeparator",since:6},{signature:"bool ParseDAsExponentInScientificENotation",since:6},{signature:"bool ParseDivision",since:6},{signature:"bool ParseExplicitFormulaExpression",since:6},{signature:"bool ParseFeetInches",since:6},{signature:"bool ParseFullStopAsDecimalPoint",since:6},{signature:"bool ParseFullStopAsDigitSeparator",since:6},{signature:"bool ParseHyphenAsNumberDash",since:6},{signature:"bool ParseHyphenMinusAsNumberDash",since:6},{signature:"bool ParseIntegerDashFraction",since:6},{signature:"bool ParseLeadingWhiteSpace",since:6},{signature:"bool ParseMathFunctions",since:6},{signature:"bool ParseMultiplication",since:6},{signature:"bool ParsePairedParentheses",since:6},{signature:"bool ParsePi",since:6},{signature:"bool ParseRationalNumber",since:6},{signature:"bool ParseScientificENotation",since:6},{signature:"bool ParseSignificandDigitSeparators",since:6},{signature:"bool ParseSignificandFractionalPart",since:6},{signature:"bool ParseSignificandIntegerPart",since:6},{signature:"bool ParseSpaceAsDigitSeparator",since:6},{signature:"bool ParseSubtraction",since:6},{signature:"bool ParseSurveyorsNotation",since:6},{signature:"bool ParseUnaryMinus",since:6},{signature:"bool ParseUnaryPlus",since:6},{signature:"uint PreferedLocaleId",since:6}],methods:[{signature:"void Dispose()",since:6},{signature:"void SetAllExpressionSettingsToFalse()",since:6},{signature:"void SetAllFieldsToFalse()",since:6}]},{name:"Rhino.IRhinoDocObserver",dataType:4,summary:"Implement this interface if you are a modeless interface to aid in\n   handling multiple document implementations"},{name:"Rhino.LengthValue",dataType:1,summary:'Represents a length with an associated unit system and a string\n   representation of that length. This allows for going back and\n   forth from numerical representation of a length and a string\n   representation without "guessing" at the initial string',properties:[{signature:"AngleUnitSystem ContextAngleUnitSystem",summary:"Returns the context AngleUnitSystem from this LengthValue's ParseSettings",since:6},{signature:"uint ContextLocaleId",summary:"returns the context LocaleId from this LengthValue",since:6},{signature:"string LengthString",summary:"Return length as a string",since:6},{signature:"StringFormat LengthStringFormat",summary:"Returns the StringFormat from this LengthValue",since:6},{signature:"StringParserSettings ParseSettings",summary:"Parse settings",since:6},{signature:"UnitSystem UnitSystem",summary:"UnitSystem used by this LengthValue",since:6}],methods:[{signature:"static LengthValue Create(double length,UnitSystem us,StringFormat format)",summary:"Create from Length and UnitSystem",since:6},{signature:"static LengthValue Create(double length,UnitSystem us,StringFormat format,uint localeId)",summary:"Create from Length and UnitSystem",since:6},{signature:"static LengthValue Create(string s,StringParserSettings ps,bool parsedAll)",summary:"Create from string",since:6},{signature:"LengthValue ChangeLength(double newLength)",summary:"Changes the numeric value in a LengthValue and leaves all of the other info unchanged\n     UnitSystem, ParseSettings and StringFormat stay as they were",since:6,returns:"A new LengthValue"},{signature:"LengthValue ChangeUnitSystem(UnitSystem newUnits)",summary:"Change the UnitSystem of a LengthValue\n     The numeric value of Length is scaled by new_us / current unit system\n     so that the absolute length stays the same",since:6},{signature:"void Dispose()",summary:"actively reclaim native allocated ON_LenghtValue*",since:6},{signature:"bool IsUnset()",summary:"Test IsUnset",since:6},{signature:"double Length()",summary:"Length value in this instance's current unit system",since:6},{signature:"double Length(UnitSystem units)",summary:"Length value in a given unit system",since:6}]},{name:"Rhino.NodeInCode.ComponentFunctionInfo",dataType:1,summary:"Defines the base class for a function representing a component.\n   This class is abstract.",properties:[{signature:"Guid ComponentGuid",summary:"The unique identifier of the Grasshopper component.\n     It is the original developer's responsibility to ensure that this ID is unique.",since:6},{signature:"Delegate Delegate",summary:"Returns a delegate that can be directly invoked using a list of arguments.\n     This flattens trees.",since:6},{signature:"Delegate DelegateNoWarnings",summary:"Returns a delegate that can be directly invoked using a list of arguments.\n     This flattens trees.",since:6},{signature:"Delegate DelegateTree",summary:"Returns a delegate that can be directly invoked using a list of arguments.\n     This considers trees and simplifies single-output components.",since:6},{signature:"Delegate DelegateTreeNoWarnings",summary:"Returns a delegate that can be directly invoked using a list of arguments.\n     This considers trees and simplifies single-output components.",since:6},{signature:"string Description",summary:"The function description.",since:6},{signature:"string FullName",summary:"Returns the name of the component prefixed by, if existing, the namespace.",since:6},{signature:"string FullScriptingName",summary:"Shows the full name of the component, including optional periods.\n     Removes spaces and common operator signs.",since:6},{signature:"IReadOnlyList<string> InputDescriptions",summary:"The function input parameter descriptions.",since:6},{signature:"IReadOnlyList<string> InputNames",summary:"The function input parameter names.",since:6},{signature:"IReadOnlyList<bool> InputsOptional",summary:"Indications for each function input parameter whether it is optional.",since:6},{signature:"IReadOnlyList<string> InputTypeNames",summary:"The function input type names.",since:6},{signature:"bool IsDefault",summary:"Determines if the component is a default one.",since:6},{signature:"string Name",summary:"The function name.",since:6},{signature:"string Namespace",summary:"The function namespace.",since:6},{signature:"IReadOnlyList<string> OutputDescriptions",summary:"Grasshopper returns several items in general. This property returns the output descriptions.",since:6},{signature:"IReadOnlyList<string> OutputNames",summary:"Grasshopper returns several items in general. This property returns the output names.",since:6},{signature:"IReadOnlyList<string> OutputTypeNames",summary:"Grasshopper returns several items in general. This property returns the output type names.",since:6}],methods:[{signature:"object[] Evaluate(IEnumerable args,bool keepTree,string[] warnings)",summary:"Evaluates the component with a set of arguments.\n     There needs to be an argument for each input param, and each output param gives an entry in the output array.",since:6,returns:"An array of objects, each representing an output result."},{signature:"object[] Invoke(object[] args)",summary:"Runs  with keepTree equal to false,\n     and raises an exception on the first warning.",since:7,returns:"Items."},{signature:"object[] InvokeKeepTree(object[] args)",summary:"Runs  with keepTree equal to True and raises an exception on the first warning.",since:7,returns:"Items."},{signature:"object[] InvokeKeepTreeSilenceWarnings(object[] args)",summary:"Runs  with keepTree equal to true,\n     and discards warnings (this is a dangerous operation!).",since:7,returns:"Array of items."},{signature:"object[] InvokeSilenceWarnings(object[] args)",summary:"Runs  with keepTree equal to false,\n     then simplifies output with  and discards warnings (this is a dangerous operation!).",since:7,returns:"Items."},{signature:"string ToString()",summary:"Returns a string representing this function.",returns:"The namespace and the name."}]},{name:"Rhino.NodeInCode.Components",dataType:1,summary:"Provides access to all Grasshopper runtime components.",properties:[{signature:"static NodeInCodeTable NodeInCodeFunctions",summary:"Returns a collection with all component functions.",since:6}],methods:[{signature:"static ComponentFunctionInfo FindComponent(string fullName)",summary:"Finds a component given its full name.",since:6}]},{name:"Rhino.NodeInCode.NodeInCodeTable",dataType:1,summary:"Permits rapid access to references to all Grasshopper functions.",constructors:[{signature:"NodeInCodeTable(IEnumerable<ComponentFunctionInfo> items)",summary:"Instantiates the table. Users of RhinoCommon do not typically need to call this constructor.",since:6}],properties:[{signature:"int Count",summary:"Returns the amount of items in this table.",since:6}],methods:[{signature:"void Add(ComponentFunctionInfo item)",summary:"Adds, or replaces a new instance of component function information.",since:6},{signature:"IEnumerable<string> GetDynamicMemberNames()",summary:"Returns all additional names in the table.",since:6},{signature:"bool TryGetIndex(GetIndexBinder binder,object[] indexes,object result)",summary:"Gets the ComponentFunctionInfo at",since:6},{signature:"bool TryGetMember(GetMemberBinder binder,object result)",summary:"Dynamically binds the table to property-like access via its item names.",since:6},{signature:"bool TryInvokeMember(InvokeMemberBinder binder,object[] args,object result)",summary:"Dynamically invokes a member of the table.",since:6,returns:"True on success."}]},{name:"Rhino.PersistentSettings",dataType:1,summary:"A dictionary of SettingValue items.",properties:[{signature:"static PersistentSettings RhinoAppSettings",since:6.14},{signature:"static string StringListRootKey",summary:"Adding this string to a string list when calling SetStringList will cause the ProgramData setting to\n     get inserted at that location in the list.",since:5},{signature:"ICollection<string> ChildKeys",summary:"Gets a collection containing the keys in the settings dictionary.",since:6},{signature:"bool HiddenFromUserInterface",summary:"If False then values will appear in the EditOptions window",since:6},{signature:"ICollection<string> Keys",summary:"Gets a collection containing the keys in the settings dictionary.",since:6}],methods:[{signature:"static PersistentSettings FromPlugInId(Guid pluginId)",since:5},{signature:"PersistentSettings AddChild(string key)",summary:"Call this method to add a new child key, if the key is exists then the\n     existing key is returned otherwise a new empty \n     child key is added and the new settings are returned.",since:6,returns:"If the key is exists then the existing key is returned otherwise a new\n     empty  child key is added and the new\n     settings are returned."},{signature:"void ClearChangedFlag()",since:6},{signature:"bool ContainsChangedValues()",since:6},{signature:"bool ContainsModifiedValues(PersistentSettings allUserSettings)",since:5},{signature:"void DeleteChild(string key)",summary:"Call this method to delete a child settings key.",since:6},{signature:"void DeleteItem(string key)",since:5},{signature:"bool GetBool(string key)",since:5},{signature:"bool GetBool(string key,bool defaultValue)",since:5},{signature:"bool GetBool(string key,bool defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"byte GetByte(string key)",since:5},{signature:"byte GetByte(string key,byte defaultValue)",since:5},{signature:"byte GetByte(string key,byte defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"char GetChar(string key)",since:5},{signature:"char GetChar(string key,char defaultValue)",since:5},{signature:"char GetChar(string key,char defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"PersistentSettings GetChild(string key)",summary:"Call this method to get a nested settings \n     instance, will throw a  exception if\n     the key does not exist.",since:6,returns:"Returns persistent settings for the specified key or throws an\n     exception if the key is invalid."},{signature:"Color GetColor(string key)",since:5},{signature:"Color GetColor(string key,Color defaultValue)",since:5},{signature:"Color GetColor(string key,Color defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"DateTime GetDate(string key)",since:5},{signature:"DateTime GetDate(string key,DateTime defaultValue)",since:5},{signature:"DateTime GetDate(string key,DateTime defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"double GetDouble(string key)",since:5},{signature:"double GetDouble(string key,double defaultValue)",since:5},{signature:"double GetDouble(string key,double defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"T GetEnumValue(String key)",summary:"Get a stored enum value using a custom key.",since:5.4},{signature:"T GetEnumValue(String key,T defaultValue)",summary:"Gets a stored enum value using a custom key, or return default value if not found.",since:5.4},{signature:"T GetEnumValue(T defaultValue)",summary:"Get a stored enum value, or return default value if not found",since:5.4},{signature:"Guid GetGuid(string key)",since:6},{signature:"Guid GetGuid(string key,Guid defaultValue)",since:6},{signature:"Guid GetGuid(string key,Guid defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"int GetInteger(string key)",since:5},{signature:"int GetInteger(string key,int defaultValue)",since:5},{signature:"int GetInteger(string key,int defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"int GetInteger(string key,int defaultValue,int bound,bool boundIsLower)",since:6},{signature:"int GetInteger(string key,int defaultValue,int lowerBound,int upperBound)",since:6},{signature:"System.Drawing.Point GetPoint(string key)",since:5},{signature:"System.Drawing.Point GetPoint(string key,Point defaultValue)",since:5},{signature:"System.Drawing.Point GetPoint(string key,Point defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"Point3d GetPoint3d(string key)",since:5},{signature:"Point3d GetPoint3d(string key,Point3d defaultValue)",since:5},{signature:"Point3d GetPoint3d(string key,Point3d defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"Rectangle GetRectangle(string key)",since:5},{signature:"Rectangle GetRectangle(string key,Rectangle defaultValue)",since:5},{signature:"Rectangle GetRectangle(string key,Rectangle defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool GetSettingIsHiddenFromUserInterface(string key)",summary:"Values read from all users settings files will be marked as read-only\n     which will cause any future calls to Set... to fail.",since:6,returns:"Returns True if the setting is read-only otherwise false."},{signature:"bool GetSettingIsHiddenFromUserInterface(string key,IEnumerable<string> legacyKeyList)",summary:"Values read from all users settings files will be marked as read-only\n     which will cause any future calls to Set... to fail.",since:6,returns:"Returns True if the setting is read-only otherwise false."},{signature:"bool GetSettingIsReadOnly(string key)",summary:"Values read from all users settings files will be marked as read-only\n     which will cause any future calls to Set... to fail.",since:6,returns:"Returns True if the setting is read-only otherwise false."},{signature:"Type GetSettingType(string key)",summary:"Gets the type of the last value passed to Set... or Get... for the\n     specified setting.",since:6,returns:"Type of the last value passed to Set... or Get... for the specified\n     setting."},{signature:"Size GetSize(string key)",since:5},{signature:"Size GetSize(string key,Size defaultValue)",since:5},{signature:"Size GetSize(string key,Size defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"string GetString(string key)",since:5},{signature:"string GetString(string key,string defaultValue)",since:5},{signature:"string GetString(string key,string defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"KeyValuePair<string, string>[] GetStringDictionary(string key)",since:6},{signature:"KeyValuePair<string, string>[] GetStringDictionary(string key,KeyValuePair<string, string>[] defaultValue)"},{signature:"KeyValuePair<string, string>[] GetStringDictionary(string key,KeyValuePair<string, string>[] defaultValue,IEnumerable<string> legacyKeyList)"},{signature:"string[] GetStringList(string key)",since:5},{signature:"string[] GetStringList(string key,string[] defaultValue)",since:5},{signature:"string[] GetStringList(string key,string[] defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"uint GetUnsignedInteger(string key)",since:5},{signature:"uint GetUnsignedInteger(string key,uint defaultValue)",since:5},{signature:"uint GetUnsignedInteger(string key,uint defaultValue,IEnumerable<string> legacyKeyList)",since:6},{signature:"EventHandler<PersistentSettingsEventArgs<T>> GetValidator(string key)",summary:"Provides a way to find a ready-to-use validator for the\n     PersistentSetting class for the given the key, or obtaining null.",since:5,returns:"A valid validator, or None if no validator was found."},{signature:"void HideSettingFromUserInterface(string key)",since:6},{signature:"void RegisterSettingsValidator(string key,EventHandler<PersistentSettingsEventArgs<T>> validator)",summary:"Sets a validator for a given key.\n     Note to implementers: parameter T should be one of the\n     supported types for the PersistentSettings class and should match the type associated with the key.This method allows to use anonymous methods and lambda expressions."},{signature:"void SetBool(string key,bool value)",since:5},{signature:"void SetByte(string key,byte value)",since:5},{signature:"void SetChar(string key,char value)",since:5},{signature:"void SetColor(string key,Color value)",since:5},{signature:"void SetDate(string key,DateTime value)",since:5},{signature:"void SetDefault(string key,bool value)",since:5},{signature:"void SetDefault(string key,byte value)",since:5},{signature:"void SetDefault(string key,char value)",since:5},{signature:"void SetDefault(string key,Color value)",since:5},{signature:"void SetDefault(string key,DateTime value)",since:5},{signature:"void SetDefault(string key,double value)",since:5},{signature:"void SetDefault(string key,Guid value)",since:6},{signature:"void SetDefault(string key,int value)",since:5},{signature:"void SetDefault(string key,KeyValuePair<string, string>[] value)"},{signature:"void SetDefault(string key,Point value)",since:5},{signature:"void SetDefault(string key,Point3d value)",since:5},{signature:"void SetDefault(string key,Rectangle value)",since:5},{signature:"void SetDefault(string key,Size value)",since:5},{signature:"void SetDefault(string key,string value)",since:5},{signature:"void SetDefault(string key,string[] value)",since:5},{signature:"void SetDouble(string key,double value)",since:5},{signature:"void SetEnumValue(String key,T value)",summary:"Set an enum value in the settings using a custom key",since:5.4},{signature:"void SetEnumValue(T enumValue)",summary:"Set an enum value in the settings.",since:5.4},{signature:"void SetGuid(string key,Guid value)",since:6},{signature:"void SetInteger(string key,int value)",since:5},{signature:"void SetPoint(string key,Point value)",since:5},{signature:"void SetPoint3d(string key,Point3d value)",since:5},{signature:"void SetRectangle(string key,Rectangle value)",since:5},{signature:"void SetSize(string key,Size value)",since:5},{signature:"void SetString(string key,string value)",since:5},{signature:"void SetStringDictionary(string key,KeyValuePair<string, string>[] value)"},{signature:"void SetStringList(string key,string[] value)",summary:"Including a item with the value of StringListRootKey will cause the ProgramData value to get inserted at\n     that location in the list when calling GetStringList.",since:5},{signature:"void SetUnsignedInteger(string key,uint value)",since:5},{signature:"bool TryGetBool(string key,bool value)",since:5},{signature:"bool TryGetBool(string key,bool value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetByte(string key,byte value)",since:5},{signature:"bool TryGetByte(string key,byte value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetChar(string key,char value)",since:5},{signature:"bool TryGetChar(string key,char value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetChild(string key,PersistentSettings value)",summary:"Call this method to get a nested settings \n     instance, will return True if the key exists and value was set\n     otherwise; will return False and value will be set to null.",since:6,returns:"Returns True if the key exists and value was set otherwise; returns\n     false."},{signature:"bool TryGetColor(string key,Color value)",since:5},{signature:"bool TryGetColor(string key,Color value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetDate(string key,DateTime value)",since:5},{signature:"bool TryGetDate(string key,DateTime value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetDefault(string key,bool value)",since:5},{signature:"bool TryGetDefault(string key,byte value)",since:5},{signature:"bool TryGetDefault(string key,char value)",since:5},{signature:"bool TryGetDefault(string key,Color value)",since:5},{signature:"bool TryGetDefault(string key,DateTime value)",since:5},{signature:"bool TryGetDefault(string key,double value)",since:5},{signature:"bool TryGetDefault(string key,int value)",since:5},{signature:"bool TryGetDefault(string key,Point3d value)",since:5},{signature:"bool TryGetDefault(string key,Rectangle value)",since:5},{signature:"bool TryGetDefault(string key,Size value)",since:5},{signature:"bool TryGetDefault(string key,string value)",since:5},{signature:"bool TryGetDefault(string key,string[] value)",since:5},{signature:"bool TryGetDouble(string key,double value)",since:5},{signature:"bool TryGetDouble(string key,double value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetEnumValue(String key,T enumValue)",summary:"Attempt to get the stored value for an enum setting using a custom key. Note: the enum value ALWAYS gets assigned!\n     Be sure to check for success of this method to prevent erroneous use of the value.",since:5.4,returns:"True if successful"},{signature:"bool TryGetGuid(string key,Guid value)",since:6},{signature:"bool TryGetGuid(string key,Guid value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetInteger(string key,int value)",since:5},{signature:"bool TryGetInteger(string key,int value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetPoint(string key,Point value)",since:5},{signature:"bool TryGetPoint(string key,Point value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetPoint3d(string key,Point3d value)",since:5},{signature:"bool TryGetPoint3d(string key,Point3d value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetRectangle(string key,Rectangle value)",since:5},{signature:"bool TryGetRectangle(string key,Rectangle value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetSettingIsHiddenFromUserInterface(string key,bool value)",summary:"Values read from all users settings files will be marked as read-only\n     which will cause any future calls to Set... to fail.",since:6},{signature:"bool TryGetSettingIsHiddenFromUserInterface(string key,bool value,IEnumerable<string> legacyKeyList)",summary:"Values read from all users settings files will be marked as read-only\n     which will cause any future calls to Set... to fail.",since:6},{signature:"bool TryGetSettingIsReadOnly(string key,bool value)",summary:"Values read from all users settings files will be marked as read-only\n     which will cause any future calls to Set... to fail.",since:6},{signature:"bool TryGetSettingType(string key,Type type)",summary:"Get the type of the last value passed to Set... or Get... for the\n     specified setting.",since:6},{signature:"bool TryGetSize(string key,Size value)",since:5},{signature:"bool TryGetSize(string key,Size value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetString(string key,string value)",since:5},{signature:"bool TryGetString(string key,string value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetStringDictionary(string key,KeyValuePair<string, string>[] value)"},{signature:"bool TryGetStringDictionary(string key,KeyValuePair<string, string>[] value,IEnumerable<string> legacyKeyList)"},{signature:"bool TryGetStringList(string key,string[] value)",since:5},{signature:"bool TryGetStringList(string key,string[] value,IEnumerable<string> legacyKeyList)",since:6},{signature:"bool TryGetUnsignedInteger(string key,uint value)",since:5},{signature:"bool TryGetUnsignedInteger(string key,uint value,IEnumerable<string> legacyKeyList)",since:6}]},{name:"Rhino.PersistentSettingsConverter",dataType:1,summary:"Used to convert string to string lists and string dictionaries and back\n   to strings again.",methods:[{signature:"static bool IsStringDictionary(string s)",summary:"Determines if the string value is formatted as a key value pair\n     string list.",since:6,returns:"Returns True if it is a XML key value pair list otherwise return false."},{signature:"static bool IsStringList(string s)",summary:"Determines if the string value is formatted as a string list.",since:6,returns:"Returns True if it is a XML string list otherwise return false."},{signature:"static string ToString(double value)",summary:"Converts a double value to a string.",since:6.1,returns:"Returns the double value as a settings file formatted string."},{signature:"static string ToString(KeyValuePair<string, string>[] value)",summary:"Converts a key value string pair array to a properly formatted string\n     dictionary XML string.",returns:"Returns a properly formatted XML string that represents the string\n     dictionary."},{signature:"static string ToString(string[] values)",summary:"Converts a string array to a properly formatted string list XML string.",since:6,returns:"Returns a properly formatted XML string that represents the list of\n     strings."},{signature:"static bool TryParseDouble(string s,double value)",summary:"Converts the string representation of a number to its double-precision\n     floating-point number equivalent. A return value indicates whether the\n     conversion succeeded or failed.\n     system culture.",since:6.1,returns:"Returns True if s was converted successfully; otherwise, false.."},{signature:"static bool TryParseEnum(Type type,string enumValueName,int value)",summary:"Converts an enum value name to its integer\n     equivalent.",since:6,returns:"Returns True if the the successfully converted or False if not."},{signature:"static bool TryParseEnum(Type type,string intValueAsString,string value)",summary:"Converts an enum value string (integer as string) to\n     a enum value name.",since:6,returns:"Returns True if the the successfully converted or False if not."},{signature:"static bool TryParseStringDictionary(string s,KeyValuePair<string, string>[] value)",summary:"Attempts to convert a string to a key value string pair array.",returns:"Returns True if the string is not empty and properly formatted as a\n     key value string pair list otherwise returns false."},{signature:"static bool TryParseStringList(string s,string[] value)",summary:"Attempts to convert a string to a string value list.",since:6,returns:"Returns True if the string is not empty and properly formatted as a\n     string list otherwise returns false."}]},{name:"Rhino.PersistentSettingsEventArgs",dataType:1,summary:"Represents the persistent settings modification event arguments.",constructors:[{signature:"PersistentSettingsEventArgs(T currentValue,T newValue)"}],properties:[{signature:"bool Cancel",since:5},{signature:"T CurrentValue"},{signature:"T NewValue"}]},{name:"Rhino.PersistentSettingsSavedEventArgs",dataType:1,summary:"Event argument passed to the  event.",properties:[{signature:"PersistentSettings PlugInSettings",summary:"The old PlugIn settings",since:6},{signature:"bool SavedByThisRhino",summary:"Will be True if this instance of Rhino is writing the settings file\n     or False if a different instance of Rhino has modified the settings\n     file.",since:6}],methods:[{signature:"PersistentSettings CommandSettings(string englishCommandName)",summary:"The new command settings",since:6}]},{name:"Rhino.PlugIns.CustomRenderSaveFileTypes",dataType:1,summary:"",methods:[{signature:"void RegisterFileType(IEnumerable<string> extensions,string description,SaveFileHandler saveFileHandler)",summary:"Call this method to register a custom file save type with the render\n     output window save dialog.",since:5.11}]},{name:"Rhino.PlugIns.DescriptionType",dataType:3,summary:""},{name:"Rhino.PlugIns.DigitizerPlugIn",dataType:1,summary:"",methods:[{signature:"void SendPoint(Point3d point,MouseButton mousebuttons,bool shiftKey,bool controlKey)",summary:"If the digitizer is enabled, call this function to send a point to Rhino.\n     Call this function as much as you like.  The digitizers that Rhino currently\n     supports send a point every 15 milliseconds or so. This function should be\n     called when users press or release any digitizer button.",since:6},{signature:"void SendRay(Ray3d ray,MouseButton mousebuttons,bool shiftKey,bool controlKey)",summary:"If the digitizer is enabled, call this function to send a point and direction to Rhino.\n     Call this function as much as you like.  The digitizers that Rhino currently\n     supports send a point every 15 milliseconds or so. This function should be\n     called when users press or release any digitizer button.",since:6}]},{name:"Rhino.PlugIns.FileExportPlugIn",dataType:1,summary:""},{name:"Rhino.PlugIns.FileImportPlugIn",dataType:1,summary:""},{name:"Rhino.PlugIns.FileTypeList",dataType:1,summary:"",constructors:[{signature:"FileTypeList()",since:5},{signature:"FileTypeList(string description,string extension)",since:6},{signature:"FileTypeList(string description,string extension,bool showOptionsButtonInFileDialog)",since:6}],methods:[{signature:"int AddFileType(string description,IEnumerable<string> extensions)",since:5},{signature:"int AddFileType(string description,IEnumerable<string> extensions,bool showOptionsButtonInFileDialog)",since:6},{signature:"int AddFileType(string description,string extension)",since:5},{signature:"int AddFileType(string description,string extension,bool showOptionsButtonInFileDialog)",since:6},{signature:"int AddFileType(string description,string extension1,string extension2)",since:5},{signature:"int AddFileType(string description,string extension1,string extension2,bool showOptionsButtonInFileDialog)",since:6}]},{name:"Rhino.PlugIns.LicenseBuildType",dataType:3,summary:"License build contentType enumerations."},{name:"Rhino.PlugIns.LicenseCapabilities",dataType:3,summary:'Controls the buttons that will appear on the license notification window\n   that is displayed if a license for the requesting product is not found.\n   Note, the "Close" button will always be displayed.'},{name:"Rhino.PlugIns.LicenseChangedEventArgs",dataType:1,summary:""},{name:"Rhino.PlugIns.LicenseData",dataType:1,summary:"Zoo plugin license data.",constructors:[{signature:"LicenseData()",summary:"Public constructor.",since:5},{signature:"LicenseData(string productLicense,string serialNumber,string licenseTitle)",summary:"Public constructor",since:5},{signature:"LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType)",summary:"Public constructor",since:5},{signature:"LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount)",summary:"Public constructor",since:5},{signature:"LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount,DateTime? expirationDate)",summary:"Public constructor"},{signature:"LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount,DateTime? expirationDate,Icon productIcon)",summary:"Public constructor"},{signature:"LicenseData(string productLicense,string serialNumber,string licenseTitle,LicenseBuildType buildType,int licenseCount,DateTime? expirationDate,Icon productIcon,bool requiresOnlineValidation,bool isUpgradeFromPreviousVersion)",summary:"Public constructor"}],properties:[{signature:"LicenseBuildType BuildType",summary:"The build of the product that this license work with.\n     When your product requests a license from the Zoo, it\n     will specify one of these build types.",since:5},{signature:"DateTime? DateToExpire",summary:"The date and time the license is set to expire.\n     This is provided by the plugin that validated the license.\n     This time value should be in Coordinated Universal Time (UTC).",since:5},{signature:"string ErrorMessage",summary:"Error message set by calls to callback functions",since:6},{signature:"bool IsUpgradeFromPreviousVersion",summary:"Set to True if this license requires a previous version license to be entered.\n     Caller must also pass VerifyPreviousVersionLicenseDelegate to GetLicense/AskUserForLicense.",since:6},{signature:"int LicenseCount",summary:"The number of instances supported by this license.\n     This is provided by the plugin that validated the license.",since:5},{signature:"bool LicenseExpires",since:6},{signature:"string LicenseTitle",summary:'The title of the license.\n     This is provided by the plugin that validated the license.\n     (e.g. "Rhinoceros 6.0 Commercial")',since:5},{signature:"Icon ProductIcon",summary:"The product's icon. This will displayed in the \"license\"\n     page in the Options dialog. Note, this can be null.\n     Note, LicenseData creates it's own copy of the icon.",since:5},{signature:"string ProductLicense",summary:"The actual product license. \n     This is provided by the plugin that validated the license.",since:5},{signature:"bool RequiresOnlineValidation",summary:"Set to True if this license requires online validation.\n     Caller must also pass VerifyOnlineValidationCodeDelegate to GetLicense/AskUserForLicense",since:6},{signature:"string SerialNumber",summary:'The "for display only" product license.\n     This is provided by the plugin that validated the license.',since:5}],methods:[{signature:"static bool IsNotValid(LicenseData data)",summary:"Indicates whether a LicenseData object is either None or invalid.",since:5},{signature:"static bool IsValid(LicenseData data)",summary:"Indicates whether a LicenseData object is not None and valid.",since:5},{signature:"void Dispose()",since:5},{signature:"bool IsValid()",summary:"Public validator.",since:5},{signature:"bool IsValid(bool ignoreExpirationDate)",since:6}]},{name:"Rhino.PlugIns.LicenseIdAttribute",dataType:1,summary:"",constructors:[{signature:"LicenseIdAttribute(string value)",since:6}],properties:[{signature:"string Value",since:6}]},{name:"Rhino.PlugIns.LicenseLease",dataType:1,summary:"LicenseLease represents a lease returned from the Cloud Zoo",constructors:[{signature:"LicenseLease(IntPtr unmanagedPointer)",since:6},{signature:"LicenseLease(string productId,string groupName,string groupId,string userName,string userId,string productTitle,string productVersion,string productEdition,string leaseId,DateTime iat,DateTime exp)",since:6},{signature:"LicenseLease(string productId,string groupName,string groupId,string userName,string userId,string productTitle,string productVersion,string productEdition,string leaseId,DateTime iat,DateTime exp,DateTime renewable_until)",since:6.4}],properties:[{signature:"DateTime Expiration",summary:"The date when this lease will expire",since:6},{signature:"string GroupId",summary:"ID of Rhino Accounts group that this lease came from",since:6},{signature:"string GroupName",summary:"Name of Rhino Accounts group that this lease came from",since:6},{signature:"DateTime IssuedAt",summary:"The date this lease was issued",since:6},{signature:"string LeaseId",summary:"The ID of this lease.",since:6},{signature:"string ProductEdition",summary:'Edition of product that this lease is issued to. For example, "Commercial" or "Beta"',since:6},{signature:"string ProductId",summary:"The ID of the product that this lease is issued to",since:6},{signature:"string ProductTitle",summary:'Title of product that this lease is issued to. For example, "Rhino 6"',since:6},{signature:"string ProductVersion",summary:'Version of product that this lease is issued to. For example, "6.0"',since:6},{signature:"string UserId",summary:"ID of Rhino Accounts user that was logged in when this lease was obtained",since:6},{signature:"string UserName",summary:"Name of Rhino Accounts user that was logged in when this lease was obtained",since:6}]},{name:"Rhino.PlugIns.LicenseLeaseChangedEventArgs",dataType:1,summary:"Arguments for OnLeaseChangedDelegate",constructors:[{signature:"LicenseLeaseChangedEventArgs(LicenseLease lease)",since:6}],properties:[{signature:"LicenseLease Lease",summary:"The lease returned by Rhino Accounts server",since:6}]},{name:"Rhino.PlugIns.LicenseStatus",dataType:1,summary:"LicenseStatus class.",constructors:[{signature:"LicenseStatus()",summary:"Public constructor.",since:5}],properties:[{signature:"LicenseBuildType BuildType",summary:"The build contentType of the product, where:\n       100 = A release build, either commercical, education, nfr, etc.\n       200 = A evaluation build\n       300 = A beta build, such as a wip.",since:5},{signature:"DateTime? CheckOutExpirationDate",summary:'The date and time the checked out license will expire.\n     Note, this is only set if m_license_type = Standalone or CloudZoo\n     and if "limited license checkout" was enabled on the Zoo server in the case of Standalone.\n     Note, date and time is in local time coordinates.',since:5},{signature:"DateTime? CloudZooLeaseExpiration",summary:"Returns the expiration date of the lease this instance represents.",since:6.4},{signature:"bool CloudZooLeaseIsValid",summary:"Returns True if the Cloud Zoo Lease represented by this instance is actively being managed by the Cloud Zoo Manager; else returns false.",since:6},{signature:"DateTime? ExpirationDate",summary:'The date and time the license will expire.\n     This value can be None if:\n       1.) The license contentType is "Standalone" and the license does not expire.\n       2.) The license contentType is "Network".\n       3.) The license contentType is "NetworkCheckedOut" and the checkout does not expire\n     Note, date and time is in local time coordinates.',since:5},{signature:"string LicenseTitle",summary:'The title of the license. (e.g. "Rhinoceros 6.0 Commercial")',since:5},{signature:"LicenseType LicenseType",summary:"The license contentType. (e.g. Standalone, Network, etc.)",since:5},{signature:"Guid PluginId",summary:"The ID of the plug-in that owns this license information",since:6},{signature:"Icon ProductIcon",summary:"The product's icon. Note, this can be null.",since:5},{signature:"Guid ProductId",summary:"The id of the product or plugin.",since:5},{signature:"string RegisteredOrganization",summary:'The registered organization of the product (e.g. "Robert McNeel and Associates")',since:5},{signature:"string RegisteredOwner",summary:'The registered owner of the product. (e.g. "Dale Fugier")',since:5},{signature:"string SerialNumber",summary:'The "for display only" product license or serial number.',since:5}]},{name:"Rhino.PlugIns.LicenseType",dataType:3,summary:"LicenseType enumeration."},{name:"Rhino.PlugIns.LicenseUtils",dataType:1,summary:"License Manager Utilities.",methods:[{signature:"static bool AskUserForLicense(int productType,bool standAlone,object parentWindow,string textMask,ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate onLeaseChangedDelegate,string product_path,string product_title,Guid pluginId,Guid licenseId,LicenseCapabilities capabilities)",summary:"This version of Rhino.PlugIns.LicenseUtils.AskUserForLicense\n     is used by Rhino C++ plug-ins.",since:6},{signature:"static bool AskUserForLicense(int productType,bool standAlone,object parentWindow,string textMask,ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate onLeaseChangedDelegate,VerifyLicenseKeyDelegate verifyLicenseKeyDelegate,VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate,string product_path,string product_title,Guid pluginId,Guid licenseId,LicenseCapabilities capabilities)",since:6},{signature:"static bool CheckInLicense(Guid productId)",summary:"Checks in a previously checked out license to\n     the Zoo server from which it was checked out.",since:5,returns:"True if the license was checked in successful.\n     False if not successful or on error."},{signature:"static bool CheckOutLicense(Guid productId)",summary:"Checks out a license that is on loan from a Zoo server\n     on a permanent basis.",since:5,returns:"True if the license was checked out successful.\n     False if not successful or on error."},{signature:"static bool ConvertLicense(Guid productId)",summary:"Converts a product license from a standalone node\n     to a network node.",since:5,returns:"True if the license was successfully converted.\n     False if not successful or on error."},{signature:"static bool DeleteLicense(Guid productId)",summary:"Deletes a license along with its license file.",since:6},{signature:"static string Echo(string message)",summary:"Test connectivity with the Zoo.",since:5},{signature:"static bool GetLicense(ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate leaseChangedDelegate,int product_type,int capabilities,string textMask,string product_path,string product_title,Guid pluginId,Guid licenseId)",summary:"This version of Rhino.PlugIns.LicenseUtils.GetLicense\n     is used by Rhino C++ plug-ins.",since:6},{signature:"static bool GetLicense(ValidateProductKeyDelegate validateProductKeyDelegate,OnLeaseChangedDelegate leaseChangedDelegate,VerifyLicenseKeyDelegate verifyLicenseKeyDelegate,VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate,int product_type,int capabilities,string textMask,string product_path,string product_title,Guid pluginId,Guid licenseId)",since:6},{signature:"static LicenseCapabilities GetLicenseCapabilities(int filter)",summary:"Converts an integer to a LicenseCapabilities flag",since:5.5},{signature:"static LicenseStatus[] GetLicenseStatus()",summary:"Returns the current status of every license for ui purposes.",since:5},{signature:"static int GetLicenseType(Guid productId)",summary:"Returns the contentType of a specified product license",since:5},{signature:"static LicenseStatus GetOneLicenseStatus(Guid productid)",summary:"Returns the current status of a license for ui purposes.",since:5.5},{signature:"static bool Initialize()",summary:"Initializes the license manager.",since:5},{signature:"static bool IsCheckOutEnabled()",summary:"Returns whether or not license checkout is enabled.",since:5},{signature:"static bool LicenseOptionsHandler(Guid pluginId,Guid licenseId,string productTitle,bool standAlone)",since:6},{signature:"static bool LoginToCloudZoo()",since:6},{signature:"static bool LogoutOfCloudZoo()",since:6},{signature:"static bool ReturnLicense(Guid productId)",summary:"OBSOLETE - REMOVE WHEN POSSIBLE.",since:5},{signature:"static void ShowBuyLicenseUi(Guid productId)",since:5.5},{signature:"static bool ShowLicenseValidationUi(string cdkey)",summary:"ShowLicenseValidationUi",since:5},{signature:"static bool ShowRhinoExpiredMessage(Mode mode,int result)",summary:"Show Rhino or Beta expired message",since:6}]},{name:"Rhino.PlugIns.LoadPlugInResult",dataType:3,summary:"Result of attempting to load a plug-in"},{name:"Rhino.PlugIns.LoadReturnCode",dataType:3,summary:""},{name:"Rhino.PlugIns.PlugIn",dataType:1,summary:"",properties:[{signature:"static bool AskOnLoadProtection",summary:"If true, Rhino will display a warning dialog when load-protected plug-ins are attempting to load. \n     If false, load-protected plug-ins will silently not load.",since:6},{signature:"static int InstalledPlugInCount",summary:"Returns the number of installed Rhino plug-ins.",since:5},{signature:"Assembly Assembly",summary:"Source assembly for this plug-in.",since:5},{signature:"string Description",summary:"Returns the description of the plug-in, as found in the plug-in's assembly attributes.",since:6},{signature:"Guid Id",summary:"Returns the Guid, or unique Id, of the plug-in.",since:5},{signature:"Guid LicenseId",since:6},{signature:"bool LoadAtStartup",since:5},{signature:"PlugInLoadTime LoadTime",summary:"Plug-ins are typically loaded on demand when they are first needed. You can change\n     this behavior to load the plug-in at during different stages in time by overriding\n     this property.",since:5},{signature:"string Name",summary:"Returns the name of the plug-in, as found in the plug-in's assembly attributes.",since:5},{signature:"PersistentSettings Settings",summary:"Persistent plug-in settings.",since:5},{signature:"string SettingsDirectory",since:5},{signature:"string SettingsDirectoryAllUsers",since:5},{signature:"string Version",summary:"Returns the version of the plug-in, as found in the plug-in's assembly attributes.",since:5},{signature:"PersistentSettings WindowPositionSettings",since:6}],methods:[{signature:"static PlugIn Find(Assembly pluginAssembly)",summary:"Finds the plug-in instance that was loaded from a given assembly.",since:5,returns:"The assembly plug-in instance if successful. Otherwise, null."},{signature:"static PlugIn Find(Guid plugInId)",summary:"Finds the plug-in instance that was loaded from a given plug-in Id.",since:5.5,returns:"The plug-in instance if successful. Otherwise, null."},{signature:"static void FlushSettingsSavedQueue()",since:6},{signature:"static string[] GetEnglishCommandNames(Guid pluginId)",summary:'Gets names of all "non-test" commands for a given plug-in.',since:5,returns:"An array with all plug-in names. This can be empty, but not null."},{signature:"static string[] GetInstalledPlugInFolders()",since:5},{signature:"static string[] GetInstalledPlugInNames()",summary:"Returns the names of all installed Rhino plug-ins.",since:5,returns:"The names if successful."},{signature:"static string[] GetInstalledPlugInNames(PlugInType typeFilter,bool loaded,bool unloaded)",summary:"Gets a list of installed plug-in names.  The list can be restricted by some filters.",since:5,returns:"An array of installed plug-in names. This can be empty, but not null."},{signature:"static Dictionary<Guid, string> GetInstalledPlugIns()",since:5},{signature:"static bool GetLoadProtection(Guid pluginId,bool loadSilently)",summary:"Get load protection state for a plug-in",since:5.5},{signature:"static PlugInInfo GetPlugInInfo(Guid pluginId)",summary:"Returns detailed information about an installed Rhino plug-in.",since:6,returns:"Detailed information about an installed Rhino plug-in if successful, None otherwise."},{signature:"static PersistentSettings GetPluginSettings(Guid plugInId,bool load)",since:6},{signature:"static Guid IdFromName(string pluginName)",summary:"Gets the id of an installed plug-in giving the plug-in's name.",since:5.5,returns:"The id if successful."},{signature:"static Guid IdFromPath(string pluginPath)",summary:"Gets the id of an installed plug-in giving the plug-in's file path.",since:5,returns:"The id if successful."},{signature:"static void LoadComputeExtensionPlugins()",summary:"Used by compute's startup code to load plugins that have registered custom endpoints",since:7},{signature:"static bool LoadPlugIn(Guid pluginId)",summary:"Loads an installed plug-in.",since:5,returns:"True if successful, False otherwise."},{signature:"static bool LoadPlugIn(Guid pluginId,bool loadQuietly,bool forceLoad)",summary:"Loads an installed plug-in.",since:6,returns:"True if successful, False otherwise."},{signature:"static LoadPlugInResult LoadPlugIn(string path,Guid plugInId)",summary:"Attempt to load a plug-in at a path. Loaded plug-ins are remembered by\n     Rhino between sessions, so this function can also be considered a plug-in\n     installation routine",since:6},{signature:"static string NameFromPath(string pluginPath)",summary:"Gets a plug-in name for an installed plug-in given the path to that plug-in.",since:5,returns:"The plug-in name."},{signature:"static string PathFromId(Guid pluginId)",summary:"Gets the path to an installed plug-in given the id of that plug-in",since:5.9},{signature:"static string PathFromName(string pluginName)",summary:"Gets the path to an installed plug-in given the name of that plug-in",since:5.9},{signature:"static bool PlugInExists(Guid id,bool loaded,bool loadProtected)",summary:"Verifies that a Rhino plug-in is installed.",since:5,returns:"Returns True if the plug-in exists, or is installed."},{signature:"static void RaiseOnPlugInSettingsSavedEvent()",summary:"Raise any pending OnPlugInSettingsSaved events, the events are normally\n     queued while a command is running and and fired while Rhino is in an\n     idle state.  Calling this method will raise any pending changed events\n     regardless of Rhino's current idle state or if a command is running.",since:6},{signature:"static void SavePluginSettings(Guid plugInId)",since:6},{signature:"static void SetLoadProtection(Guid pluginId,bool loadSilently)",summary:"Set load protection state for a certain plug-in",since:5.5},{signature:"PersistentSettings CommandSettings(string name)",since:5},{signature:"Commands.Command[] GetCommands()",summary:"All of the commands associated with this plug-in.",since:5},{signature:"object GetPlugInObject()",since:5},{signature:"System.Drawing.Bitmap Icon(Size size)",summary:"Returns the plug-in's icon in bitmap form.",since:6,returns:"The icon if successful, None otherwise."},{signature:"void SaveSettings()",summary:"Write settings to disk which will raise a \n     event.",since:6}]},{name:"Rhino.PlugIns.PlugInDescriptionAttribute",dataType:1,summary:"",constructors:[{signature:"PlugInDescriptionAttribute(DescriptionType descriptionType,string value)",since:5}],properties:[{signature:"DescriptionType DescriptionType",since:5},{signature:"string Value",since:5}]},{name:"Rhino.PlugIns.PlugInInfo",dataType:1,summary:"Contains detailed information about a Rhino plug-in.",properties:[{signature:"string Address",summary:"Returns the address of the organization or company that created the plug-in.",since:6},{signature:"string[] CommandNames",summary:"Returns a plug-in's English command names.",since:6},{signature:"string Country",summary:"Returns the country of the organization or company that created the plug-in.",since:6},{signature:"string Description",summary:"Returns the plug-in's description.",since:6},{signature:"string Email",summary:"Returns the email address of the organization or company that created the plug-in.",since:6},{signature:"string Fax",summary:"Returns the fax number of the organization or company that created the plug-in.",since:6},{signature:"string FileName",summary:"Returns the plug-in's file name.",since:6},{signature:"string[] FileTypeDescriptions",summary:"Returns the description of supported file types for file import and file export plug-in.",since:6},{signature:"string[] FileTypeExtensions",summary:"Returns the file types extensions supported for file import and file export plug-in.",since:7},{signature:"Guid Id",summary:"Returns the plug-in's Id.",since:6},{signature:"bool IsDotNet",summary:"Returns True if the plug-in is based on .NET, False otherwise.",since:6},{signature:"bool IsLoaded",summary:"Returns True if the plug-in is loaded, False otherwise.",since:6},{signature:"string Name",summary:"Returns the plug-in's name.",since:6},{signature:"string Organization",summary:"Returns the organization or company that created the plug-in.",since:6},{signature:"string Phone",summary:"Returns the phone number of the organization or company that created the plug-in.",since:6},{signature:"PlugInLoadTime PlugInLoadTime",summary:"Returns the plug-in's load time.",since:6},{signature:"PlugInType PlugInType",summary:"Returns the plug-in type.",since:6},{signature:"string RegistryPath",summary:"Returns the plug-in's Windows Registry path.",since:6},{signature:"bool ShipsWithRhino",summary:"Returns True if the plug-in ships with Rhino, False otherwise.",since:6},{signature:"string UpdateUrl",summary:"Returns the web site, or url, were an updated version of the plug-in can be found.",since:6},{signature:"string Version",summary:"Returns the plug-in's version.",since:6},{signature:"string WebSite",summary:"Returns the web site, or url, of the organization or company that created the plug-in.",since:6}],methods:[{signature:"System.Drawing.Bitmap Icon(Size size)",summary:"Returns the plug-in's icon in bitmap form.",since:6},{signature:"bool IsLoadProtected(bool loadSilently)",summary:"Returns the load protection state for a plug-in",since:6,returns:"True if the plug-in is load protected, False otherwise."}]},{name:"Rhino.PlugIns.PlugInLoadTime",dataType:3,summary:""},{name:"Rhino.PlugIns.PlugInType",dataType:3,summary:""},{name:"Rhino.PlugIns.PreviewNotification",dataType:1,summary:"",methods:[{signature:"void NotifyIntermediateUpdate(RenderWindow rw)",since:6}]},{name:"Rhino.PlugIns.RenderPlugIn",dataType:1,summary:"",properties:[{signature:"bool PerferBasicContent",summary:"Set to True if you would like Rhino to quickly create a basic render\n     content in response to 'Create New' commands. Set to False if you would\n     prefer Rhino to display the render content chooser dialog.",since:5.12}],methods:[{signature:"static bool CurrentRendererSupportsFeature(RenderFeature feature)",since:6.1},{signature:"bool EnableAssignMaterialButton()",summary:'Called to enable/disable the "Material" button located on the\n     "Material" tab in the Properties and Layer dialog boxes.  The default\n     return value is False which will disable the button.  If the button is\n     disabled then the OnAssignMaterial function is never called.',since:5.12},{signature:"bool EnableCreateMaterialButton()",summary:'Called to enable/disable the "New" button located on the "Material" in\n     the  Properties and Layer dialog boxes.  The default return value is\n     False which will disable the button.  If the button is disabled then\n     the OnEditMaterial function is never called.',since:5.12},{signature:"bool EnableEditMaterialButton(RhinoDoc doc,Material material)",summary:'Called to enable/disable the "Edit" button located on the "Material" in\n     the Properties and Layer dialog boxes.  The default return value is\n     False  which will disable the button.  If the button is disabled then\n     the OnEditMaterial function is never called.',since:5.12},{signature:"List<Guid> GetRenderSettingsSections()",summary:"This function returns a list of uuid for the render settings pages that should be displayed.",since:6.17,returns:"Return a Id list of of the Render settings sections that will be displayed"},{signature:"bool OnAssignMaterial(IntPtr parent,RhinoDoc doc,Material material)",summary:'This function is called by the Object Properties and Layer Control\n     dialogs when the "Material" button is pressed in the "Render" tab.\n     This is only called if EnableAssignMaterialButton returns true.',since:5.12},{signature:"bool OnCreateMaterial(IntPtr parent,RhinoDoc doc,Material material)",summary:'This function is called by the Object Properties and Layer Control\n     dialogs when the "New" button is pressed in the "Material" tab.  This\n     is only called if EnableCreateMaterialButton returns true.',since:5.12},{signature:"bool OnEditMaterial(IntPtr parent,RhinoDoc doc,Material material)",summary:'This function is called by the Object Properties and Layer Control\n     dialogs when the "Edit" button is pressed in the "Material" tab.  This\n     is only called if EnableEditMaterialButton returns true. A return value\n     of True means the material has been updated.',since:5.12},{signature:"void RenderSettingsCustomSections(List<ICollapsibleSection> sections)",summary:"Override this function to provide custom sections for the render settings panel that are displayed\n     when your plug-in is the current render plug-in.",since:6},{signature:"void SunCustomSections(List<ICollapsibleSection> sections)",summary:"Override this function to provide custom sections for the sun panel that are displayed\n     when your plug-in is the current render plug-in.",since:6}]},{name:"Rhino.PlugIns.RenderPlugIn.PreviewRenderTypes",dataType:3,summary:""},{name:"Rhino.PlugIns.RenderPlugIn.RenderFeature",dataType:3,summary:""},{name:"Rhino.PlugIns.ValidateResult",dataType:3,summary:"ValidateProductKeyDelegate result code."},{name:"Rhino.PlugIns.WriteFileResult",dataType:3,summary:""},{name:"Rhino.Render.AsyncRenderContext",dataType:1,summary:"\\ingroup rhino_render\n   Inherit from AsyncRenderContext to be able to create asynchronous\n   render engine implementations through RhinoCommon.",properties:[{signature:"Thread RenderThread",summary:"Holder for render thread, that gets set through\n     StartRenderThread()",since:6},{signature:"RenderWindow RenderWindow",summary:"Handle to the RenderWindow for the instance of this class. This\n     is a convenience property for implementors to use.",since:6}],methods:[{signature:"void Dispose()",since:6},{signature:"void JoinRenderThread()",summary:"Join the render thread, then set to null;",since:6},{signature:"bool StartRenderThread(ThreadStart threadStart,string threadName)",summary:"Start a new render thread with given function.",since:6},{signature:"void StopRendering()",summary:"Override StopRendering if you need to do additional tasks besides\n     having Cancel set to true.\n     \n     Note: you should always base.StopRendering() in your overriding\n     implementation.",since:6}]},{name:"Rhino.Render.CachedTextureCoordinates",dataType:1,summary:"Used for cached texture coordinates",properties:[{signature:"int Count",summary:"Number of cached coordinates.",since:5.1},{signature:"int Dim",summary:"Coordinate dimension: 2 = UV, 3 = UVW",since:5.1},{signature:"bool IsReadOnly",summary:"This collection is always read-only",since:5.1},{signature:"Guid MappingId",summary:"The texture mapping Id.",since:5.1}],methods:[{signature:"bool Contains(Point3d item)",summary:"Determines whether this collection contains a specific value.",since:5.1},{signature:"void CopyTo(Point3d[] array,int arrayIndex)",summary:"Copies the elements of the this collection to an System.Array,\n     starting at a particular System.Array index.",since:5.1},{signature:"IEnumerator<Point3d> GetEnumerator()",summary:"Returns an enumerator that iterates through this collection.",since:5.1,returns:"A enumerator that can be used to iterate through this collection."},{signature:"int IndexOf(Point3d item)",summary:"Determines the index of a specific point in this collection.",since:5.1,returns:"The index of item if found in the list; otherwise, -1."},{signature:"bool TryGetAt(int index,double u,double v,double w)",summary:"Use this method to iterate the cached texture coordinate array.",since:5.1,returns:"Returns True if index is valid; otherwise returns false."}]},{name:"Rhino.Render.ChangeQueue.ChangeQueue",dataType:1,summary:"Base class for ChangeQueue.\n   \n   Generally used by render plugins to build interactive updating of scenes that are being rendered.",properties:[{signature:"DisplayPipelineAttributes DisplayPipelineAttributes",summary:"Get the DisplayPipelineAttributes if available, None otherwise",since:6},{signature:"bool IsPreview",summary:"Return True if this ChangeQueue is created for preview rendering.\n     \n     No view was set for preview rendering.",since:6},{signature:"Guid ViewId",summary:"Return view ID for a RhinoDoc based ChangeQueue.\n     \n     Returns Guid.Empty if no view was associated with the changequeue,\n     i.e. preview rendering.",since:6}],methods:[{signature:"static void ConvertCameraBasedLightToWorld(ChangeQueue changequeue,Light light,ViewInfo vp)",summary:"Convert given (camera-based) light to a world-based light (in-place)",since:6},{signature:"static uint CrcFromGuid(Guid guid)",summary:"Helper function to get a CRC from a Guid.",since:6},{signature:"bool AreViewsEqual(ViewInfo aView,ViewInfo bView)",summary:"Compare to ViewInfo instances and decide whether they are equal or not.\n     \n     If you need to change the way the comparison is done you can override\n     this function and implement your custom comparison.",since:6,returns:"True if the views are considered equal"},{signature:"void CreateWorld()",summary:"Calls CreateWorld with True passed.",since:6},{signature:"void CreateWorld(bool bFlushWhenReady)",summary:"Signal the queue to do the initialisation of the queue, seeding it with the content currently available.",since:6},{signature:"void Dispose()",summary:"Dispose our ChangeQueue",since:6},{signature:"RenderEnvironment EnvironmentForid(uint crc)",summary:"Get RenderEnvironment for given RenderHash",since:6},{signature:"uint EnvironmentIdForUsage(Usage usage)",summary:"Get RenderEnvironment RenderHash for given usage.",since:6},{signature:"void Flush()",summary:"Tell the ChangeQueue to flush all collected events.\n    \n     This can trigger a host of Apply* calls.\n     \n     The following is the order in which those calls get\n     made if there are changes for that specific data type:\n     \n     ApplyViewChange\n     ApplyLinearWorkflowChanges\n     ApplyDynamicObjectTransforms\n     ApplyDynamicLightChanges\n     ApplyRenderSettingsChanges\n     ApplyEnvironmentChanges (background)\n     ApplyEnvironmentChanges (refl)\n     ApplyEnvironmentChanges (sky)\n     ApplySkylightChanges\n     ApplySunChanges\n     ApplyLightChanges\n     ApplyMaterialChanges\n     ApplyMeshChanges\n     ApplyMeshInstanceChanges\n     ApplyGroundPlaneChanges\n     ApplyClippingPlaneChanges",since:6},{signature:"GroundPlane GetQueueGroundPlane()",summary:"Get groundplane known to the queue at the time of the Flush",since:6},{signature:"RenderSettings GetQueueRenderSettings()",summary:"Get render settings known to the queue at the time of the Flush",since:6},{signature:"BoundingBox GetQueueSceneBoundingBox()",summary:"Get the scene bounding box",since:6,returns:"Scene bounding box"},{signature:"Skylight GetQueueSkylight()",summary:"Get skylight known to the queue at the time of the Flush",since:6},{signature:"Geometry.Light GetQueueSun()",summary:"Get sun known to the queue at the time of the Flush",since:6},{signature:"ViewInfo GetQueueView()",summary:"Get view known to the queue at the time of the Flush",since:6,returns:"ViewInfo"},{signature:"RenderMaterial MaterialFromId(uint crc)",summary:"Get the RenderMaterial from the ChangeQueue material cache based on RenderHash",since:6,returns:"RenderMaterial"},{signature:"void OneShot()",summary:"Call Flush() once, after that automatically dispose the queue.",since:6}]},{name:"Rhino.Render.ChangeQueue.ChangeQueue.BakingFunctions",dataType:3,summary:"Enumeration of functions for baking to conduct."},{name:"Rhino.Render.ChangeQueue.ClippingPlane",dataType:1,summary:"ChangeQueue clipping plane",properties:[{signature:"ObjectAttributes Attributes",summary:"Get the ClippingPlaneObject for this clipping plane",since:6},{signature:"Guid Id",summary:"Get Guid for this clipping plane",since:6},{signature:"bool IsEnabled",summary:"True if clipping plane is enabled",since:6},{signature:"Plane Plane",summary:"Get the plane that represents this clipping plane",since:6},{signature:"List<Guid> ViewIds",summary:"Get list of View IDs this clipping plane is supposed to clip.",since:6}]},{name:"Rhino.Render.ChangeQueue.DisplayRenderSettings",dataType:1,summary:"ChangeQueue DisplayRenderSettings",properties:[{signature:"bool CullBackFaces",summary:"True if backfaces should be culled",since:6},{signature:"bool ForceFlatShading",summary:"True if flat shading is forced",since:6},{signature:"bool SceneLightingOn",summary:"True if scene lighting is enabled",since:6}]},{name:"Rhino.Render.ChangeQueue.DynamicObjectTransform",dataType:1,summary:"ChangeQueue DynamicObject",properties:[{signature:"uint MeshInstanceId",summary:"Get the mesh instance id for this dynamic object.",since:6},{signature:"Transform Transform",summary:"Transform for the DynamicObject",since:6}],methods:[{signature:"string ToString()",summary:"String representation of DynamicObject"}]},{name:"Rhino.Render.ChangeQueue.Environment",dataType:1,summary:"ChangeQueue environment"},{name:"Rhino.Render.ChangeQueue.Environment.FrameBufferFillMode",dataType:3,summary:"Fillmode for background"},{name:"Rhino.Render.ChangeQueue.GroundPlane",dataType:1,summary:"ChangeQueue ground plane",properties:[{signature:"double Altitude",summary:"Get the altitude for ground plane",since:6},{signature:"uint Crc",summary:"Get the checksum of this groundplane object",since:6},{signature:"bool Enabled",summary:"Return True if ground plane is enabled",since:6},{signature:"bool IsShadowOnly",summary:"Get True if ground plane should be shadow-only",since:6},{signature:"uint MaterialId",summary:"The CRC / RenderHash of the material on this ground plane",since:6},{signature:"Vector2d TextureOffset",summary:"Get texture offset on the ground plane",since:6},{signature:"double TextureRotation",summary:"Get texture rotation on the ground plane",since:6},{signature:"Vector2d TextureScale",summary:"Get texture scale on the ground plane",since:6}]},{name:"Rhino.Render.ChangeQueue.Light",dataType:1,summary:"ChangeQueue Light change representation",properties:[{signature:"Event ChangeType",summary:"Get what type of light change this represents",since:6},{signature:"Light Data",summary:"Get the actual light data",since:6},{signature:"Guid Id",summary:"Get the light object id",since:6},{signature:"uint IdCrc",summary:"Get CRC computed from Id",since:6}]},{name:"Rhino.Render.ChangeQueue.Light.Event",dataType:3,summary:"Light change type"},{name:"Rhino.Render.ChangeQueue.MappingChannel",dataType:1,summary:"Mapping Channel for a ChangeQueue Mesh",properties:[{signature:"Transform Local",summary:"Local transform for the mapping",since:6},{signature:"TextureMapping Mapping",summary:"Return TexturMapping for this MappingChannel",since:6}]},{name:"Rhino.Render.ChangeQueue.MappingChannelCollection",dataType:1,summary:"MappingChannels for a Mesh",properties:[{signature:"IEnumerable<MappingChannel> Channels",summary:"Enumerate all available channels in this mapping",since:6},{signature:"int Count",summary:"Get count of MappingChannels in this collection",since:6}]},{name:"Rhino.Render.ChangeQueue.Material",dataType:1,summary:"Representation of a Material through the change queue",properties:[{signature:"uint Id",summary:"Get the material ID (crc)",since:6},{signature:"int MeshIndex",summary:"Get mesh index",since:6},{signature:"uint MeshInstanceId",summary:"Get the material InstanceAncestry",since:6}]},{name:"Rhino.Render.ChangeQueue.Mesh",dataType:1,summary:"Representation of ChangeQueue Mesh",properties:[{signature:"ObjectAttributes Attributes",summary:"Get object attributes of object associated to this mesh. This will be possible only \n     after returning True from ChangeQueue.ProvideOriginalObject()",since:6},{signature:"MappingChannelCollection Mapping",summary:"Get the mapping for this mesh.",since:6},{signature:"RhinoObject Object",summary:"Get a copy of the original RhinoObject this Mesh is created from. Possible only after\n     return True from ChangeQueue.ProvideOriginalObject().\n     \n     Access this only with a using(var o = mesh.Object) {} construct.\n     \n     Note that the object is free floating, i.e. not part of a document.",since:6.8},{signature:"MappingChannel SingleMapping",summary:"Get texture mapping info as single mapping",since:6}],methods:[{signature:"Geometry.Mesh[] GetMeshes()",summary:"Get a SimpleArrayMeshPointer containing all meshes for the related Mesh",since:6},{signature:"Guid Id()",summary:"Get the Object Guid this mesh is for.",since:6,returns:"Guid of parent object."}]},{name:"Rhino.Render.ChangeQueue.MeshInstance",dataType:1,summary:"Representation of ChangeQueue MeshInstance",properties:[{signature:"bool CastShadows",summary:"Return True if mesh instance should cast shadows",since:6},{signature:"uint GroupId",summary:"Get identifier that specifies the grouping of these mesh instances - usually based on the object that this originally comprised.",since:6},{signature:"uint InstanceId",summary:"Get the instance identifier for this mesh instance.",since:6},{signature:"uint MaterialId",summary:"The Material CRC / RenderHash",since:6},{signature:"Guid MeshId",summary:"Get the mesh identifier for this mesh instance.",since:6},{signature:"int MeshIndex",summary:"Get the mesh index for this mesh instance.",since:6},{signature:"Transform OcsTransform",summary:"OCS Transform for the MeshInstance (identity means no OCS, potentially just simple WCS/WCS Box)",since:7},{signature:"bool ReceiveShadows",summary:"Return True if mesh instance should receive shadows",since:6},{signature:"RenderMaterial RenderMaterial",summary:"RenderMaterial associated with mesh instance",since:6},{signature:"Transform Transform",summary:"Transform for the MeshInstance",since:6}]},{name:"Rhino.Render.ChangeQueue.Skylight",dataType:1,summary:"ChangeQueue skylight",properties:[{signature:"bool Enabled",summary:"Return True if skylight is enabled",since:6},{signature:"double ShadowIntensity",summary:"Get shadow intensity for skylight",since:6},{signature:"bool UsesCustomEnvironment",summary:"Return True if skylight uses custom environment",since:6}],methods:[{signature:"string ToString()",summary:"Textual representation of Skylight"}]},{name:"Rhino.Render.City",dataType:1,summary:"City",properties:[{signature:"double Latitude",summary:"Gets latitude of city.",since:6},{signature:"double Longitude",summary:"Gets longitude of city.",since:6},{signature:"String Name",summary:"Gets name of city.",since:6},{signature:"double TimeZone",summary:"Gets time zone of city.",since:6}],methods:[{signature:"static int Cities()",summary:"Returns number of available cities.",since:6,returns:"City count."},{signature:"static City CityAt(int index)",summary:"Returns city at given index.",since:6,returns:"City at index."},{signature:"static City FindNearest(double latitude,double longitude)",summary:"Finds nearest city of specified input parameters.",since:6,returns:"Nearest city."}]},{name:"Rhino.Render.ContentCollectionIterator",dataType:1,summary:"",constructors:[{signature:"ContentCollectionIterator(IntPtr pCollection)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"void DeleteThis()",since:6},{signature:"void Dispose()",since:6},{signature:"RenderContent First()",since:6},{signature:"RenderContent Next()",since:6}]},{name:"Rhino.Render.ContentUndoBlocker",dataType:1,summary:"",constructors:[{signature:"ContentUndoBlocker()",summary:"Constructs a ContentUndoBlocker object inside a using block to block undo when modifying a RenderContent\n     while a ContentUndoHelper is active. Alternatively - create the ContentUndoBlocker and explicitly call Dispose when you are done.",since:5.1}],methods:[{signature:"void Dispose()",since:5.1}]},{name:"Rhino.Render.ContentUndoHelper",dataType:1,summary:'Content undo helper to be used with "using {}" to enclose a block of changes.',constructors:[{signature:"ContentUndoHelper(RhinoDoc doc,String description)",summary:"Constructs a ContentUndoHelper object inside a using block to handle undo when modifying a RenderContent\n     or - alternatively - create the ContentUndoHelper and explicitly call Dispose when you are done.",since:6}],methods:[{signature:"bool AddContent(RenderContent content,RenderContent parent)",summary:"Call this *after* adding a content. Undo will cause the content to be deleted.",since:6,returns:"True if the content was added."},{signature:"void Dispose()",since:6},{signature:"bool ModifyContent(RenderContent content)",summary:"Call this before modifying or deleting a content. Undo will cause the content to be restored.",since:6,returns:"True if the content was modified."},{signature:"bool TweakContent(RenderContent content,String parameterName)",summary:"Call this before tweaking a single content parameter. Undo will cause the parameter to be restored.",since:6,returns:"True if the content was tweaked."}]},{name:"Rhino.Render.ContentUuids",dataType:1,summary:"Content Guids of RenderContent provided by the RDK SDK.\n   \n   These Guids can be used to check against RenderContent.TypeId.",properties:[{signature:"static Guid AdvancedDotTextureType",since:6},{signature:"static Guid BasicEnvironmentCCI",since:6},{signature:"static Guid BasicEnvironmentType",since:6},{signature:"static Guid BasicMaterialCCI",since:6},{signature:"static Guid BasicMaterialType",since:6},{signature:"static Guid BitmapTextureType",since:6},{signature:"static Guid BlendMaterialCCI",since:6},{signature:"static Guid BlendMaterialType",since:6},{signature:"static Guid BlendTextureType",since:6},{signature:"static Guid CompositeMaterialCCI",since:6},{signature:"static Guid CompositeMaterialType",since:6},{signature:"static Guid CrossHatchBumpTexture",since:6},{signature:"static Guid CubeMapTextureType",since:6},{signature:"static Guid DefaultEnvironmentInstance",since:6},{signature:"static Guid DefaultMaterialInstance",since:6},{signature:"static Guid DotBumpTexture",since:6},{signature:"static Guid DoubleSidedMaterialType",since:7},{signature:"static Guid ExposureTextureType",since:6},{signature:"static Guid EXRTextureType",since:6},{signature:"static Guid FBmTextureType",since:6},{signature:"static Guid GemMaterialType",since:6},{signature:"static Guid GlassMaterialType",since:6},{signature:"static Guid GradientTextureType",since:6},{signature:"static Guid GraniteTextureType",since:6},{signature:"static Guid GridTextureType",since:6},{signature:"static Guid GritBumpTexture",since:6},{signature:"static Guid HatchBumpTexture",since:6},{signature:"static Guid HDRTextureType",since:6},{signature:"static Guid LeatherBumpTexture",since:6},{signature:"static Guid MarbleTextureType",since:6},{signature:"static Guid MaskTextureType",since:6},{signature:"static Guid MetalMaterialType",since:6},{signature:"static Guid NoiseTextureType",since:6},{signature:"static Guid PaintMaterialType",since:6},{signature:"static Guid PerlinMarbleTextureType",since:6},{signature:"static Guid PerturbingTextureType",since:6},{signature:"static Guid PhysicallyBasedMaterialType",since:7},{signature:"static Guid PictureMaterialType",since:6},{signature:"static Guid PlasterMaterialType",since:6},{signature:"static Guid PlasticMaterialType",since:6},{signature:"static Guid ProjectionChangerTextureType",since:6},{signature:"static Guid RealtimeDisplayMaterialType",since:6},{signature:"static Guid ResampleTextureType",since:6},{signature:"static Guid SimpleBitmapTextureType",since:6},{signature:"static Guid SingleColorTextureType",since:6},{signature:"static Guid SpeckleBumpTexture",since:6},{signature:"static Guid StuccoTextureType",since:6},{signature:"static Guid Texture2DCheckerTextureType",since:6},{signature:"static Guid Texture3DCheckerTextureType",since:6},{signature:"static Guid TextureAdjustmentTextureType",since:6},{signature:"static Guid TileTextureType",since:6},{signature:"static Guid TurbulenceTextureType",since:6},{signature:"static Guid WavesTextureType",since:6},{signature:"static Guid WoodBumpTexture",since:6},{signature:"static Guid WoodTextureType",since:6}]},{name:"Rhino.Render.ConvertibleExtensions",dataType:1,summary:"Extension methods for IConvertible that work when\n   an object is a Variant.",methods:[{signature:"static Color4f ToColor4f(IConvertible variant)",since:6},{signature:"static Vector2d ToVector2d(IConvertible variant)",since:6},{signature:"static Vector3d ToVector3d(IConvertible variant)",since:6}]},{name:"Rhino.Render.CrcRenderHashFlags",dataType:3,summary:""},{name:"Rhino.Render.CreatePreviewEventArgs",dataType:1,summary:"Used in RenderPlugIn virtual CreatePreview function",properties:[{signature:"bool Cancel",summary:"Get set by Rhino if the preview generation should be canceled for this",since:5.1},{signature:"RenderContentKind ContentKind",summary:"Description of content that preview is being generated for.",since:6},{signature:"Guid ContentTypeId",summary:"The class Id of content that preview is being generated for.",since:6},{signature:"RenderEnvironment Environment",summary:"The environment that the previewed object is rendered in.",since:5.1},{signature:"int Id",summary:"Unique Id for this scene.",since:5.1},{signature:"Light> Lights",since:5.1},{signature:"List<SceneObject> Objects",since:5.1},{signature:"RenderContent PreviewContent",summary:"Obsolete, will return always null",since:5.1},{signature:"Bitmap PreviewImage",summary:"Initially null.  If this image is set, then this image will be used for\n     the preview.  If never set, the default internal simulation preview will\n     be used.",since:5.1},{signature:"Size PreviewImageSize",summary:"Pixel size of the image that is being requested for the preview scene",since:5.1},{signature:"PreviewNotification PreviewNotifier",since:6},{signature:"PreviewSceneQuality Quality",summary:"Quality of the preview image that is being requested for the preview scene",since:5.1},{signature:"CreatePreviewReason Reason",summary:"Reason the preview is getting generated",since:5.11},{signature:"ViewportInfo Viewport",since:5.1}],methods:[{signature:"void SkipInitialisation()",summary:"Call this if you don't want the argument to handle data initialisation.\n     \n     This is for use with the ChangeQueue",since:6}]},{name:"Rhino.Render.CreatePreviewEventArgs.SceneObject",dataType:1,summary:"",properties:[{signature:"RenderMaterial Material",since:5.1},{signature:"Mesh Mesh",since:5.1}]},{name:"Rhino.Render.CreatePreviewReason",dataType:3,summary:"Reason the content preview is being generated"},{name:"Rhino.Render.CreateTexture2dPreviewEventArgs",dataType:1,summary:"",properties:[{signature:"Bitmap PreviewImage",summary:"Initially null.  If this image is set, then this image will be used for\n     the preview.  If never set, the default internal simulation preview will\n     be used.",since:5.1},{signature:"Size PreviewImageSize",summary:"Pixel size of the image that is being requested for the preview scene",since:5.1}]},{name:"Rhino.Render.CustomEvent",dataType:1,summary:"This class contains the event for CustomEvents that are fired from RDK .",events:[{signature:"static OnCustomEvent",summary:"This event is raised when a Custom Event is triggered in rdk.",since:7}]},{name:"Rhino.Render.CustomRenderContentAttribute",dataType:1,summary:"",constructors:[{signature:"CustomRenderContentAttribute(string renderEngineGuid,bool imageBased,string category,bool is_elevated,bool is_built_in,bool is_private)",since:6},{signature:"CustomRenderContentAttribute(string renderEngineGuid,bool imageBased,string category,bool is_elevated,bool is_built_in,bool is_private,bool is_linear,bool is_hdrcapable,bool is_normalmap)",since:6.16}],properties:[{signature:"string Category",since:6},{signature:"bool ImageBased",since:6},{signature:"bool IsBuiltIn",since:6},{signature:"bool IsElevated",since:6},{signature:"bool IsHdrCapable",since:6.16},{signature:"bool IsLinear",since:6.16},{signature:"bool IsNormalMap",since:6.16},{signature:"bool IsPrivate",since:6},{signature:"Guid RenderEngineId",since:6}]},{name:"Rhino.Render.CustomRenderMeshProvider",dataType:1,summary:"You must call CustomRenderMeshProvider.RegisterProviders() from your\n   plug-ins OnLoad override for each assembly containing a custom mesh\n   provider.  Only publicly exported classes derived from\n   CustomRenderMeshProvider with a public constructor that has no parameters\n   will get registered.",properties:[{signature:"static Guid CurvePipingId",since:6},{signature:"static Guid DisplacementId",since:6},{signature:"static Guid EdgeSofteningId",since:6},{signature:"static Guid ShutLiningId",since:6},{signature:"static Guid ThickeningId",since:6},{signature:"String Name",summary:"The name of the provider for UI display.",since:5.7}],methods:[{signature:"static void AllObjectsChanged()",summary:"Call this method if your render meshes change.",since:5.7},{signature:"static void AllObjectsChanged(RhinoDoc doc)",summary:"Call this method if your render meshes change.",since:6},{signature:"static void DocumentBasedMeshesChanged(RhinoDoc doc)",since:6},{signature:"static void ObjectChanged(RhinoDoc doc,RhinoObject obj)",since:6},{signature:"static void RegisterProviders(Assembly assembly,Guid pluginId)",summary:"Call this method once from your plug-ins OnLoad override for each\n     assembly containing a custom mesh provider.  Only publicly exported\n     classes derived from CustomRenderMeshProvider with a public constructor\n     that has no parameters will get registered.",since:5.7},{signature:"BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)",summary:"Returns a bounding box for the custom render meshes for the given object.",since:5.7,returns:"A bounding box value."},{signature:"BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,RhinoDoc doc,Guid requestingPlugIn,DisplayPipelineAttributes attrs)",since:6},{signature:"bool BuildCustomMeshes(ViewportInfo vp,RenderPrimitiveList objMeshes,Guid requestingPlugIn,bool meshType)",summary:"Build custom render mesh(es).",since:5.7,returns:"True if operation was successful."},{signature:"bool WillBuildCustomMeshes(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)",summary:"Determines if custom render meshes will be built for a particular object.",since:5.7,returns:"True if custom meshes will be built."}]},{name:"Rhino.Render.CustomRenderMeshProvider2",dataType:1,summary:"",methods:[{signature:"BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)",since:6.4},{signature:"BoundingBox BoundingBox(ViewportInfo vp,RhinoObject obj,RhinoDoc doc,Guid requestingPlugIn,DisplayPipelineAttributes attrs)",since:6},{signature:"bool BuildCustomMeshes(ViewportInfo vp,RenderPrimitiveList objMeshes,Guid requestingPlugIn,bool preview)",since:6.4},{signature:"bool BuildCustomMeshes(ViewportInfo vp,RhinoDoc doc,RenderPrimitiveList objMeshes,Guid requestingPlugIn,DisplayPipelineAttributes attrs)",since:6},{signature:"bool WillBuildCustomMeshes(ViewportInfo vp,RhinoObject obj,Guid requestingPlugIn,bool preview)",since:6.4},{signature:"bool WillBuildCustomMeshes(ViewportInfo vp,RhinoObject obj,RhinoDoc doc,Guid requestingPlugIn,DisplayPipelineAttributes attrs)",since:6}]},{name:"Rhino.Render.DataSources.AssignBys",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ContentDatabaseEventInfo.AttachReason",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ContentDatabaseEventInfo.DetachReason",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ContentDatabaseEventInfo.Types",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ContentEditorSettings.Layouts",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ContentEditorSettings.Splitters",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ContentFactories",dataType:1,summary:"",constructors:[{signature:"ContentFactories(IntPtr pRdkContentFactories)",since:6.1}],properties:[{signature:"IntPtr CppPointer",since:6.1}],methods:[{signature:"void Dispose()",since:6.1},{signature:"ContentFactory FindFactory(Guid uuid)",since:6.7},{signature:"ContentFactory FirstFactory()",since:6.1},{signature:"ContentFactory NextFactory()",since:6.1}]},{name:"Rhino.Render.DataSources.ContentFactory",dataType:1,summary:"",constructors:[{signature:"ContentFactory(IntPtr pRdkContentFactory)",since:6.1}],properties:[{signature:"IntPtr CppPointer",since:6.1}],methods:[{signature:"Guid ContentTypeId()",since:6.7},{signature:"void Dispose()",since:6.1},{signature:"RenderContentKind Kind()",since:6.3},{signature:"RenderContent NewContent()",summary:"New Content returns a new content, which is Initialized with the Initialize() function.\n     The content should be unitilized after use with the Unitialize function.",since:6.1}]},{name:"Rhino.Render.DataSources.ContentParamEventInfo.Types",dataType:3,summary:""},{name:"Rhino.Render.DataSources.DecalEventInfo.Operations",dataType:3,summary:""},{name:"Rhino.Render.DataSources.MetaData",dataType:1,summary:"",constructors:[{signature:"MetaData(IntPtr pMetaData)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"Guid ContentInstanceId()",since:6.7},{signature:"void Dispose()",since:6},{signature:"string Geometry()",since:6}]},{name:"Rhino.Render.DataSources.Modes",dataType:3,summary:""},{name:"Rhino.Render.DataSources.NamedItemCommand.States",dataType:3,summary:""},{name:"Rhino.Render.DataSources.NamedItems.CommandFilters",dataType:3,summary:""},{name:"Rhino.Render.DataSources.NamedItems.DisplayModes",dataType:3,summary:""},{name:"Rhino.Render.DataSources.ParamBlock.UiHints",dataType:3,summary:""},{name:"Rhino.Render.DataSources.RdkEdit",dataType:1,summary:"",constructors:[{signature:"RdkEdit(IntPtr pRdkEdit)",since:6.5}],properties:[{signature:"IntPtr CppPointer",since:6.5}],methods:[{signature:"void Dispose()",since:6.5},{signature:"bool Execute(RenderContentCollection collection)",since:6.5}]},{name:"Rhino.Render.DataSources.RdkModalEditContentBucket",dataType:1,summary:"",constructors:[{signature:"RdkModalEditContentBucket(IntPtr pRdkModalEditContentBucket)",since:6.5}],properties:[{signature:"IntPtr CppPointer",since:6.5}],methods:[{signature:"RenderContentCollection ContentsIn()",since:6.5},{signature:"void Dispose()",since:6.5},{signature:"void SetContentsOut(RenderContentCollection collection)",since:6.5}]},{name:"Rhino.Render.DataSources.RdkSelectionNavigator",dataType:1,summary:"",constructors:[{signature:"RdkSelectionNavigator(IntPtr pRhinoSettings)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"void Add(RenderContentCollection selectedContentArray)",summary:"Add a selection of contents at the current position.\n   Clears the navigator ahead of the current position.",since:6},{signature:"bool CanGoBackwards()",summary:"Check the backwards status of the navigator",since:6,returns:"True if it is possible to navigate backwards, else false"},{signature:"bool CanGoForwards()",summary:"Check the forwards status of the navigator",since:6,returns:"True if it is possible to navigate forwards, else false"},{signature:"void Clear()",summary:"Clear the navigator.",since:6},{signature:"void Dispose()",since:6},{signature:"bool GoBackwards(RenderContentCollection selectedContentArray)",summary:"Navigate backwards if possible",since:6,returns:"True on success, else false"},{signature:"bool GoForwards(RenderContentCollection selectedContentArray)",summary:"Navigate forwards if possible",since:6,returns:"True on success, else false"}]},{name:"Rhino.Render.DataSources.RhinoSettings",dataType:1,summary:"",constructors:[{signature:"RhinoSettings(IntPtr pRhinoSettings)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"RhinoView ActiveView()",since:6},{signature:"void Dispose()",since:6},{signature:"List<System.Drawing.Size> GetCustomRenderSizes()",since:6},{signature:"RenderSettings GetRenderSettings()",since:6},{signature:"bool GroundPlaneOnInViewDisplayMode(RhinoView view)",since:6.14},{signature:"Rhino.DocObjects.ViewInfo RenderingView()",since:6.12},{signature:"void SetGroundPlaneOnInViewDisplayMode(RhinoView view,bool bOn)",since:6.14},{signature:"void SetRenderSettings(RenderSettings renderSettings)",since:6},{signature:"bool ViewSupportsShading(RhinoView view)",since:6.14}]},{name:"Rhino.Render.DataSources.Shapes",dataType:3,summary:""},{name:"Rhino.Render.DataSources.Sizes",dataType:3,summary:""},{name:"Rhino.Render.Decal",dataType:1,summary:"Represents a decal, or a picture that can be moved on an object.",properties:[{signature:"int CRC",summary:"The decal CRC identifies a decal by its state. Multiple decals which would be\n     exactly the same would have the same CRC and are culled from the system.\n     If you store this value with the intention of using it to find the decal again\n     later, you must update your stored value whenever the decal state changes.\n     You can detect when a decal changes by watching for the OnUserDataTransformed event.",since:6},{signature:"DecalMapping DecalMapping",summary:"Gets the mapping of the decal.",since:5.1},{signature:"DecalProjection DecalProjection",summary:"Gets the decal's projection. Used only when mapping is planar.",since:5.1},{signature:"double EndLatitude",summary:"Gets the end angle of the decal's arc of latitude or 'horizontal sweep'. This is actually a LONGITUDINAL angle. Only used when mapping is cylindrical or spherical.",since:5.1},{signature:"double EndLongitude",summary:"Gets the end angle of the decal's arc of longitude or 'vertical sweep'. This is actually a LATITUDINAL angle. Only used when mapping is spherical.",since:5.1},{signature:"double Height",summary:"Gets the height of the decal. Only used when mapping is cylindrical.",since:5.1},{signature:"bool MapToInside",summary:"Used only when mapping is cylindrical or spherical.",since:5.1},{signature:"Point3d Origin",summary:"Gets the origin of the decal in world space.",since:5.1},{signature:"double Radius",summary:"Gets the radius of the decal. Only used when mapping is cylindrical or spherical.",since:5.1},{signature:"double StartLatitude",summary:"Gets the start angle of the decal's arc of latitude or 'horizontal sweep'. This is actually a LONGITUDINAL angle. Only used when mapping is cylindrical or spherical.",since:5.1},{signature:"double StartLongitude",summary:"Gets the start angle of the decal's arc of longitude or 'vertical sweep'. This is actually a LATITUDINAL angle. Only used when mapping is spherical.",since:5.1},{signature:"Guid TextureInstanceId",summary:"Gets the texture ID for this decal.",since:5.1},{signature:"double Transparency",summary:"Gets the decal's transparency in the range 0 to 1.",since:5.1},{signature:"Vector3d VectorAcross",summary:"Gets the vector across. For cylindrical and spherical mapping, the vector is unitized.",since:5.1},{signature:"Vector3d VectorUp",summary:"For cylindrical and spherical mapping, the vector is unitized.",since:5.1}],methods:[{signature:"static Decal Create(DecalCreateParams createParams)",since:5.1},{signature:"IntPtr ConstPointer()",since:5.1},{signature:"List<Rhino.Render.NamedValue> CustomData()",summary:"Gets custom data associated with this decal - see Rhino.Plugins.RenderPlugIn.ShowDecalProperties.",since:6,returns:"The return value can be None if there is no data associated with this decal."},{signature:"void Dispose()",since:5.1},{signature:"void Dispose(bool isDisposing)",since:5.1},{signature:"IntPtr NonConstPointer()",since:5.1},{signature:"bool TryGetColor(Point3d point,Vector3d normal,Color4f colInOut,Point2d uvOut)",summary:"Blend color with the decal color at a given point.",since:5.1,returns:"True if the given point hits the decal, else false."},{signature:"void UVBounds(double minUOut,double minVOut,double maxUOut,double maxVOut)",summary:"The UV bounds of the decal. Only used when mapping is UV.",since:5.1}]},{name:"Rhino.Render.DecalCreateParams",dataType:1,summary:"Used by RhinoObject.AddDecal() to create and add a decal",properties:[{signature:"DecalMapping DecalMapping",since:6},{signature:"DecalProjection DecalProjection",since:6},{signature:"double EndLatitude",since:6},{signature:"double EndLongitude",since:6},{signature:"double Height",since:6},{signature:"bool MapToInside",since:6},{signature:"double MaxU",since:6},{signature:"double MaxV",since:6},{signature:"double MinU",since:6},{signature:"double MinV",since:6},{signature:"Point3d Origin",since:6},{signature:"double Radius",since:6},{signature:"double StartLatitude",since:6},{signature:"double StartLongitude",since:6},{signature:"Guid TextureInstanceId",since:6},{signature:"double Transparency",since:6},{signature:"Vector3d VectorAcross",since:6},{signature:"Vector3d VectorUp",since:6}]},{name:"Rhino.Render.DecalMapping",dataType:3,summary:""},{name:"Rhino.Render.DecalProjection",dataType:3,summary:""},{name:"Rhino.Render.Decals",dataType:1,summary:"Represents all the decals of an object.",methods:[{signature:"uint Add(Decal decal)",summary:"Add a new Decal to the decals list, use Decal.Create to create\n     a new decal instance to add.",since:5.1},{signature:"void Clear()",since:5.1},{signature:"IEnumerator<Decal> GetEnumerator()",since:5.1},{signature:"bool Remove(Decal decal)",since:5.1}]},{name:"Rhino.Render.Dithering",dataType:1,summary:"This is the interface to linear workflow settings.",constructors:[{signature:"Dithering()",summary:"Create an utility object not associated with any document",since:6},{signature:"Dithering(Dithering d)",summary:"Create an utility object not associated with any document from another object",since:6}],properties:[{signature:"Methods Method",since:6}],methods:[{signature:"void CopyFrom(FreeFloatingBase src)",since:6}]},{name:"Rhino.Render.DocumentOrFreeFloatingBase",dataType:1,summary:"Base class for Rhino.Render objects that are owned by the document, or can be delivered separately\n   from other functions.  In general, you cannot create these objects yourself.",methods:[{signature:"void BeginChange(ChangeContexts cc)",summary:"Call this function before making any change to this object (calling a setter) otherwise undo will not work correctly.  Calls to BeginChange must be paired with a call to EndChange.",since:6},{signature:"bool EndChange()",summary:"See BeginChange",since:6,returns:"True if the object has returned to no-changes mode."}]},{name:"Rhino.Render.DynamicIconUsage",dataType:3,summary:""},{name:"Rhino.Render.Fields.BoolField",dataType:1,summary:"bool field value class",properties:[{signature:"bool Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.ByteArrayField",dataType:1,summary:"ByteArray field value class",properties:[{signature:"byte[] Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Color4fField",dataType:1,summary:"Color4f field value class",properties:[{signature:"Color SystemColorValue",summary:"Gets or sets the field value",since:5.1},{signature:"Color4f Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.DateTimeField",dataType:1,summary:"DateTime field value class",properties:[{signature:"DateTime Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.DoubleField",dataType:1,summary:"double field value class",properties:[{signature:"double Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Field",dataType:1,summary:"Generic data fields used to add publicly accessible properties to\n   RenderContent.FieldDictionary.  These should be created by calling a\n   FieldDictaionary.Add() method on a Render content object.  These are\n   allocated after the RenderContent object's C++ object is created and\n   added to the underlying C++ objects content dictionary, who ever\n   allocates a field is responsible for deleting it so these objects clean\n   up the C++ pointers when they are disposed of.",properties:[{signature:"string Key",summary:"Field name value string passed to the constructor",since:5.1},{signature:"string Name",summary:"Field name value string passed to the constructor.",since:6},{signature:"object Tag",summary:"Gets or sets an object that contains data to associate with the field.",since:5.1},{signature:"int TextureAmountMax",summary:"Set Max value for Texture amount",since:7},{signature:"int TextureAmountMin",summary:"Set Min value for Texture amount",since:7}],methods:[{signature:"T GetValue()",summary:"Parametrized version of GetValue calling appropriate ValueAs* methods.",since:6.12,returns:"Value of type T of the field"},{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.FieldDictionary",dataType:1,summary:"Dictionary containing RenderContent data fields, add fields to this\n   dictionary in your derived RenderContent classes constructor.  Get field\n   values using the TryGet[data type]() methods and set them using the Set()\n   method.",methods:[{signature:"BoolField Add(string key,bool value)",summary:"Add a new BoolField to the dictionary. This will be a data only field\n     and not show up in the content browsers.",since:5.1},{signature:"BoolField Add(string key,bool value,string prompt)",summary:"Add a new BoolField to the dictionary.",since:5.1},{signature:"ByteArrayField Add(string key,byte[] value)",summary:"AddField a new ByteArrayField to the dictionary. This will be a data\n     only field and not show up in the content browsers.",since:5.1},{signature:"Color4fField Add(string key,Color value)",summary:"Add a new Color4fField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Color4fField Add(string key,Color value,string prompt)",summary:"Add a new Color4fField to the dictionary.",since:5.1},{signature:"Color4fField Add(string key,Color4f value)",summary:"Add a new Color4fField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Color4fField Add(string key,Color4f value,string prompt)",summary:"Add a new Color4fField to the dictionary.",since:5.1},{signature:"DateTimeField Add(string key,DateTime value)",summary:"Add a new DateTimeField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"DateTimeField Add(string key,DateTime value,string prompt)",summary:"Add a new DateTimeField to the dictionary.",since:5.1},{signature:"DoubleField Add(string key,double value)",summary:"AddField a new DoubleField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"DoubleField Add(string key,double value,string prompt)",summary:"Add a new DoubleField to the dictionary.",since:5.1},{signature:"FloatField Add(string key,float value)",summary:"Add a new FloatField to the dictionary. This will be a data only field\n     and not show up in the content browsers.",since:5.1},{signature:"FloatField Add(string key,float value,string prompt)",summary:"AddField a new FloatField to the dictionary.",since:5.1},{signature:"GuidField Add(string key,Guid value)",summary:"Add a new GuidField to the dictionary. This will be a data only field\n     and not show up in the content browsers.",since:5.1},{signature:"GuidField Add(string key,Guid value,string prompt)",summary:"Add a new GuidField to the dictionary.",since:5.1},{signature:"IntField Add(string key,int value)",summary:"Add a new IntField to the dictionary. This will be a data only field\n     and not show up in the content browsers.",since:5.1},{signature:"IntField Add(string key,int value,string prompt)",summary:"Add a new IntField to the dictionary.",since:5.1},{signature:"Point2dField Add(string key,Point2d value)",summary:"Add a new Point2dField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Point2dField Add(string key,Point2d value,string prompt)",summary:"Add a new Point2dField to the dictionary.",since:5.1},{signature:"Point3dField Add(string key,Point3d value)",summary:"Add a new Point3dField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Point3dField Add(string key,Point3d value,string prompt)",summary:"Add a new Point3dField to the dictionary.",since:5.1},{signature:"Point4dField Add(string key,Point4d value)",summary:"Add a new Point4dField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Point4dField Add(string key,Point4d value,string prompt)",summary:"Add a new Point4dField to the dictionary.",since:5.1},{signature:"StringField Add(string key,string value)",summary:"Add a new StringField to the dictionary.  This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"StringField Add(string key,string value,string prompt)",summary:"Add a new StringField to the dictionary.",since:5.1},{signature:"TransformField Add(string key,Transform value)",summary:"Add a new TransformField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"TransformField Add(string key,Transform value,string prompt)",summary:"Add a new TransformField to the dictionary.",since:5.1},{signature:"Vector2dField Add(string key,Vector2d value)",summary:"Add a new Vector2dField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Vector2dField Add(string key,Vector2d value,string prompt)",summary:"Add a new Vector2dField to the dictionary.",since:5.1},{signature:"Vector3dField Add(string key,Vector3d value)",summary:"Add a new Vector3dField to the dictionary. This will be a data only\n     field and not show up in the content browsers.",since:5.1},{signature:"Vector3dField Add(string key,Vector3d value,string prompt)",summary:"Add a new Vector3dField to the dictionary.",since:5.1},{signature:"BoolField AddTextured(string key,bool value,string prompt)",since:5.7},{signature:"BoolField AddTextured(string key,bool value,string prompt,bool treatAsLinear)",summary:'Add a new BoolField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"Color4fField AddTextured(string key,Color value,string prompt)",since:5.7},{signature:"Color4fField AddTextured(string key,Color value,string prompt,bool treatAsLinear)",summary:'Add a new Color4fField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"Color4fField AddTextured(string key,Color4f value,string prompt)",since:5.7},{signature:"Color4fField AddTextured(string key,Color4f value,string prompt,bool treatAsLinear)",summary:'Add a new Color4fField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"DateTimeField AddTextured(string key,DateTime value,string prompt)",since:5.7},{signature:"DateTimeField AddTextured(string key,DateTime value,string prompt,bool treatAsLinear)",summary:'Add a new DateTimeField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"DoubleField AddTextured(string key,double value,string prompt)",since:5.7},{signature:"DoubleField AddTextured(string key,double value,string prompt,bool treatAsLinear)",summary:'Add a new DoubleField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"FloatField AddTextured(string key,float value,string prompt)",since:5.7},{signature:"FloatField AddTextured(string key,float value,string prompt,bool treatAsLinear)",summary:'Add a new FloatField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"GuidField AddTextured(string key,Guid value,string prompt)",since:5.7},{signature:"GuidField AddTextured(string key,Guid value,string prompt,bool treatAsLinear)",summary:'Add a new GuidField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"IntField AddTextured(string key,int value,string prompt)",since:5.7},{signature:"IntField AddTextured(string key,int value,string prompt,bool treatAsLinear)",summary:'Add a new IntField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"Point2dField AddTextured(string key,Point2d value,string prompt)",since:5.7},{signature:"Point2dField AddTextured(string key,Point2d value,string prompt,bool treatAsLinear)",summary:'Add a new Point2dField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"Point3dField AddTextured(string key,Point3d value,string prompt)",since:5.7},{signature:"Point3dField AddTextured(string key,Point3d value,string prompt,bool treatAsLinear)",summary:'Add a new Point3dField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"Point4dField AddTextured(string key,Point4d value,string prompt)",since:5.7},{signature:"Point4dField AddTextured(string key,Point4d value,string prompt,bool treatAsLinear)",summary:'Add a new Point4dField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"StringField AddTextured(string key,string value,string prompt)",since:5.7},{signature:"StringField AddTextured(string key,string value,string prompt,bool treatAsLinear)",summary:'Add a new StringField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"TransformField AddTextured(string key,Transform value,string prompt)",since:5.7},{signature:"TransformField AddTextured(string key,Transform value,string prompt,bool treatAsLinear)",summary:'Add a new TransformField to the dictionary. This overload will cause\n     the field to be tagged as "textured" so that the texturing UI will\n     appear in automatic UIs.',since:7},{signature:"Vector2dField AddTextured(string key,Vector2d value,string prompt)",since:5.7},{signature:"Vector2dField AddTextured(string key,Vector2d value,string prompt,bool treatAsLinear)",summary:'Add a new Vector2dField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"Vector3dField AddTextured(string key,Vector3d value,string prompt)",since:5.7},{signature:"Vector3dField AddTextured(string key,Vector3d value,string prompt,bool treatAsLinear)",summary:'Add a new Vector3dField to the dictionary. This overload will cause the\n     field to be tagged as "textured" so that the texturing UI will appear\n     in automatic UIs.',since:7},{signature:"bool ContainsField(string fieldName)",summary:"Call this method to determine if a this FieldsList contains a field\n     with the specified field name.",since:5.1,returns:"Returns True if a field with that matches fieldName is found or false\n     if it is not found."},{signature:"IEnumerator<Field> GetEnumerator()",since:6},{signature:"Field GetField(string fieldName)",summary:"Call this method to get the field with the matching name.",since:5.3,returns:"If the field exists in the Fields dictionary then the field is returned\n     otherwise; None is returned."},{signature:"void RemoveField(string fieldName)",since:6},{signature:"void Set(string key,bool value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,bool value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,byte[] value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,byte[] value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Color value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Color value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Color4f value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Color4f value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,DateTime value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,DateTime value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,double value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,double value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,float value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,float value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Guid value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Guid value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,int value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,int value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Point2d value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Point2d value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Point3d value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Point3d value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Point4d value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Point4d value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,string value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,string value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Transform value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Transform value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Vector2d value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Vector2d value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Vector3d value)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"void Set(string key,Vector3d value,ChangeContexts changeContext)",summary:"Set the field value and send the appropriate change notification to the\n     render SDK.  Will throw a InvalidOperationException exception if the key\n     name is not valid.",since:5.1},{signature:"bool SetTag(string key,object tag)",summary:"Sets an object that contains data to associate with the field.  THIS IS NOW OBSOLETE - if you were using this, please email andy@mcneel.com and let me know why.",since:5.1,returns:"True if the field is found and the tag was set otherwise False is returned."},{signature:"bool TryGetTag(string key,object tag)",summary:"Gets object that contains data associate with a field. THIS IS NOW OBSOLETE - if you were using this, please email andy@mcneel.com and let me know why.",since:5.1,returns:"Returns True if the field is found and its tag was retrieved otherwise;\n     returns false."},{signature:"bool TryGetValue(string key,bool value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,byte[] value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Color value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Color4f value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,DateTime value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,double value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,float value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Guid value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,int value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Point2d value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Point3d value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Point4d value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,string value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,T value)",summary:"Parametrized version of TryGetValue.",since:6.12,returns:"True if field was found. If False out parameter value will be set to default(T)."},{signature:"bool TryGetValue(string key,Transform value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Vector2d value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."},{signature:"bool TryGetValue(string key,Vector3d value)",summary:"Find a field with the specified key and get its value if found.",since:5.1,returns:"Returns True if the key is found and the value parameter is set to the\n     field value.  Returns False if the field was not found."}]},{name:"Rhino.Render.Fields.FloatField",dataType:1,summary:"float field value class",properties:[{signature:"float Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.GuidField",dataType:1,summary:"Guid field value class",properties:[{signature:"Guid Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.IntField",dataType:1,summary:"Integer field value class",properties:[{signature:"int Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Point2dField",dataType:1,summary:"Point2d field value class",properties:[{signature:"Point2d Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Point3dField",dataType:1,summary:"Point3d field value class",properties:[{signature:"Point3d Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Point4dField",dataType:1,summary:"Point4d field value class",properties:[{signature:"Point4d Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.StringField",dataType:1,summary:"String field value class",properties:[{signature:"string Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.TransformField",dataType:1,summary:"Transform field value class",properties:[{signature:"Transform Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Vector2dField",dataType:1,summary:"Vector2d field value class",properties:[{signature:"Vector2d Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.Fields.Vector3dField",dataType:1,summary:"Vector3d field value class",properties:[{signature:"Vector3d Value",summary:"Gets or sets the field value",since:5.1}],methods:[{signature:"object ValueAsObject()",since:5.7}]},{name:"Rhino.Render.FilterContentByUsage",dataType:3,summary:"Content collection filter value"},{name:"Rhino.Render.FreeFloatingBase",dataType:1,summary:"Base class for Rhino.Render objects that are owned by the document, or can be delivered separately\n   from other functions.  In general, you cannot create these objects yourself.",methods:[{signature:"void CopyFrom(FreeFloatingBase src)",summary:"Copy from another object",since:6}]},{name:"Rhino.Render.GroundPlane",dataType:1,summary:"Represents an infinite plane for implementation by renderers.\n   See SupportsFeature.",constructors:[{signature:"GroundPlane()",summary:"Create an utility object not associated with any document",since:6},{signature:"GroundPlane(GroundPlane g)",summary:"Create an utility object not associated with any document from another object",since:6}],properties:[{signature:"double Altitude",summary:"Height above world XY plane in model units.",since:5},{signature:"bool AutoAltitude",summary:"Determines whether the ground plane is fixed by the Altitude property, or whether it is automatically placed at the lowest point in the model.",since:6},{signature:"bool Enabled",summary:"Determines whether the document ground plane is enabled.",since:5},{signature:"Guid MaterialInstanceId",summary:"Id of material in material table for this ground plane.",since:5},{signature:"bool ShadowOnly",summary:"Determines whether the ground plane shows the material assigned, or whether it is transparent, but captures shadows.",since:6},{signature:"bool ShowUnderside",summary:"If this is off, the ground plane will not be visible when seen from below.",since:6},{signature:"Vector2d TextureOffset",summary:"Texture mapping offset in world units.",since:5},{signature:"bool TextureOffsetLocked",summary:"Texture offset locked.",since:6},{signature:"double TextureRotation",summary:"Texture mapping rotation around world origin + offset in degrees.",since:5},{signature:"Vector2d TextureSize",summary:"Texture mapping single UV span size in world units.",since:5},{signature:"bool TextureSizeLocked",summary:"Texture size locked.",since:6}],methods:[{signature:"void CopyFrom(FreeFloatingBase src)",since:6}],events:[{signature:"static Changed",summary:"This event is raised when a GroundPlane property value is changed.",since:5.1}]},{name:"Rhino.Render.ICurrentEnvironment",dataType:4,summary:""},{name:"Rhino.Render.ICurrentEnvironment_Get",dataType:4,summary:""},{name:"Rhino.Render.ImageFile",dataType:1,summary:"Controls interaction with RDK render image files",events:[{signature:"static Deleted",summary:"Called when the RDK is cleaning up old render image files, a\n       plug-in should delete any plug-in specific image files at this\n       time.",since:5.11},{signature:"static Loaded",summary:'Generally called when the "RenderOpenLastRender" command is run,\n       this event is raised after the render window has been created and the\n       saved scene has been loaded.',since:5.11},{signature:"static Saved",summary:"Render image file saved, happens when a rendering completes.\n       If a plug-in needs to save additional file information it should\n       write it to the same folder as the Rhino render image file.  Rhino\n       will take care of deleting old data.",since:5.11}]},{name:"Rhino.Render.ImageFileEvent",dataType:3,summary:""},{name:"Rhino.Render.ImageFileEventArgs",dataType:1,summary:"",properties:[{signature:"int EllapsedTime",since:5.11},{signature:"ImageFileEvent Event",since:5.11},{signature:"string FileName",since:5.11},{signature:"string RenderEngine",since:5.11},{signature:"Guid RenderEngineId",since:5.11},{signature:"Guid SessionId",since:5.11}]},{name:"Rhino.Render.IRhRdkPreviewSceneServer_eRotationType",dataType:3,summary:"c# version of IRhRdkPreviewSceneServer eRotationType enum"},{name:"Rhino.Render.it_strategy",dataType:3,summary:"Defines the collection type to iterate."},{name:"Rhino.Render.LightArray",dataType:1,summary:"",constructors:[{signature:"LightArray()",since:6},{signature:"LightArray(IntPtr pLightArray)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"void Append(Light light)",since:6},{signature:"int Count()",since:6},{signature:"void Dispose()",since:6},{signature:"Rhino.Geometry.Light ElementAt(int index)",since:6}]},{name:"Rhino.Render.LightManagerSupport",dataType:1,summary:"Base class for implementing custom light managers in .NET",methods:[{signature:"static void RegisterLightManager(PlugIn plugin)",summary:"Find and register classes that derive from LightManagerSupport\n     from the given plug-in.",since:6},{signature:"static void RegisterProviders(Assembly assembly,Guid pluginId)",summary:"Find and register classes that derive from RealtimeDisplayMode\n     from the given plug-in. The plug-in is found in the given assembly",since:6},{signature:"bool DeleteLight(RhinoDoc doc,Light light,bool bUndelete)",summary:"Delete light",since:6,returns:"If delete is successful, then return true, else return false"},{signature:"void GetLights(RhinoDoc doc,LightArray light_array)",summary:"Get all the lights that are associated to the light manager. The lights are added \n      to the LightArray parameter passed to the GetLights method",since:6},{signature:"bool GetLightSolo(RhinoDoc doc,Guid uuid_light)",summary:'Returns the value of "ON_LIght::m_bOn" if the light is in solo storage, or \n      False if not in solo storage (ie - this is the checkbox state on the light manager dialog)',since:6,returns:"Returns True if the light is in solo storage, or False if not in solo storage"},{signature:"void GroupLights(RhinoDoc doc,LightArray light_array)",summary:"Creates a new group with the lights",since:6},{signature:"string LightDescription(RhinoDoc doc,Light light)",summary:"Gets the string representation of the light description",since:6,returns:"Returns the string representation of the light description"},{signature:"bool LightFromId(RhinoDoc doc,Guid uuid,Light light)",summary:"Get Rhino.Geometry.Light object associated to Guig uuid",since:6},{signature:"int LightsInSoloStorage(RhinoDoc doc)",summary:'Returns the number of lights in solo storage - any number other than 0 means "in solo mode"',since:6,returns:'Returns the number of lights in solo storage - any number other than 0 means "in solo mode"'},{signature:"void ModifyLight(RhinoDoc doc,Light light)",summary:"Modify properties of the light",since:6},{signature:"int ObjectSerialNumberFromLight(RhinoDoc doc,Light light)",summary:"Get the object serial number of the light",since:6},{signature:"void OnCustomLightEvent(RhinoDoc doc,LightMangerSupportCustomEvent le,Light light)",summary:"Generates LightMangerSupportCustomEvent: \n        light_added,\n        light_deleted,\n        light_undeleted,\n        light_modified,\n        light_sorted,\n      The event triggers a Light table event that the rdk lightmanager listens too",since:6,returns:"Returns the string representation of the light description"},{signature:"bool OnEditLight(RhinoDoc doc,LightArray light_array)",summary:"The default implementation of OnEditLight selects the lights and opens\n      the Lights Properties page",since:6,returns:"Returns True if successful, else false"},{signature:"Guid PluginId()",summary:"The Guid of the plugin",since:6,returns:"Returns the Guid of the plugin"},{signature:"Guid RenderEngineId()",summary:"The Guid of the render engine",since:6,returns:"Returns the Guid of the render engine that is associated with this light manager"},{signature:"bool SetLightSolo(RhinoDoc doc,Guid uuid_light,bool bSolo)",summary:'First checks to see if we are in "solo mode" - which means that there are any lights that respond "true" to IsInSoloStorage.\n     If in solo mode:\n      If bSolo = true\n       Sets this light on.\n      If bSolo = false\n       If this is the last light "on", forces all lights out of solo mode.\n       If there are other lights on, turns this light off.\n     If not in solo mode:\n      If bSolo = true\n       Forces all lights into solo storage and sets this light on.\n      If bSolo = false\n       This shouldn\'t happen.  Will cause an ASSERT',since:6,returns:"Returns True if action is successful"},{signature:"void UnGroup(RhinoDoc doc,LightArray light_array)",summary:"UnGroups the lights",since:6}]},{name:"Rhino.Render.LightManagerSupportClient",dataType:1,summary:"",constructors:[{signature:"LightManagerSupportClient(uint doc_uuid)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"void DeleteLight(Light light)",since:6},{signature:"void Dispose()",since:6},{signature:"Rhino.Geometry.Light GetLightFromId(Guid uuid)",since:6},{signature:"LightArray GetLights()",since:6},{signature:"bool GetLightSolo(Light light)",since:6},{signature:"void GroupLights(LightArray lights)",since:6},{signature:"string LightDescription(Light light)",since:6},{signature:"int LightsInSoloStorage()",since:6},{signature:"void ModifyLight(Light light)",since:6},{signature:"Rhino.DocObjects.RhinoObject ObjectFromLight(Light light)",since:6},{signature:"void OnEditLight(LightArray lights)",since:6},{signature:"bool SetLightSolo(Light light,bool bSolo)",since:6},{signature:"void UnGroup(LightArray lights)",since:6}]},{name:"Rhino.Render.LightMangerSupportCustomEvent",dataType:3,summary:"LightMangerSupportCustomEvent"},{name:"Rhino.Render.LinearWorkflow",dataType:1,summary:"This is the interface to linear workflow settings.",constructors:[{signature:"LinearWorkflow()",summary:"Create an utility object not associated with any document",since:6},{signature:"LinearWorkflow(LinearWorkflow src)",summary:"Create utility object not associated with any document from another object",since:6}],properties:[{signature:"uint Hash",summary:"Linear workflow CRC",since:6},{signature:"bool PostProcessFrameBuffer",summary:"Linear workflow active state",since:6},{signature:"float PostProcessGamma",summary:"Linear workflow gamma",since:6},{signature:"float PostProcessGammaReciprocal",summary:"Linear workflow gamma",since:6},{signature:"bool PreProcessColors",summary:"Linear workflow active state",since:6},{signature:"float PreProcessGamma",summary:"Linear workflow gamma",since:6},{signature:"bool PreProcessTextures",summary:"Linear workflow active state",since:6}],methods:[{signature:"void CopyFrom(FreeFloatingBase src)",summary:"Create a copy of linearworkflow",since:6},{signature:"bool Equals(object obj)",summary:"Compare two LinearWorkflow objects. They are considered equal when\n     their Hashes match."},{signature:"int GetHashCode()",summary:"Get hash code for this object. It is the Hash property cast to int."}]},{name:"Rhino.Render.MappingTag",dataType:1,summary:"Holds texture mapping information.",properties:[{signature:"Guid Id",summary:"Gets or sets a map globally unique identifier.",since:5},{signature:"uint MappingCRC",summary:"Gets or sets the cyclic redundancy check on the mapping.\n     See also .",since:5},{signature:"TextureMappingType MappingType",summary:"Gets or sets a texture mapping type: linear, cylinder, etc...",since:5},{signature:"Transform MeshTransform",summary:"Gets or sets a 4x4 matrix transform.",since:5}]},{name:"Rhino.Render.MetaDataProxy",dataType:1,summary:"ProxyClass for MetaData",constructors:[{signature:"MetaDataProxy()",summary:"Constructor for MetaDataProxy",since:6.8}],properties:[{signature:"IntPtr CppPointer",summary:"MetaDataProxy c++ pointer",since:6.8}],methods:[{signature:"void Dispose()",summary:"Dispose for MetaDataProxy",since:6.8},{signature:"void SetContentInstanceId(Guid uuid)",summary:"Set Content instance id for meta data",since:6.8}]},{name:"Rhino.Render.NamedValue",dataType:1,summary:"",constructors:[{signature:"NamedValue(string name,object value)",since:5.1}],properties:[{signature:"string Name",since:5.1},{signature:"object Value",since:5.1}]},{name:"Rhino.Render.PhysicallyBasedMaterial",dataType:1,summary:"",properties:[{signature:"double Anisotropic",since:7},{signature:"double AnisotropicRotation",since:7},{signature:"Color4f BaseColor",since:7},{signature:"BRDFs BRDF",since:7},{signature:"double Clearcoat",since:7},{signature:"double ClearcoatRoughness",since:7},{signature:"Color4f Emission",since:7},{signature:"Material Material",since:7},{signature:"double Metallic",since:7},{signature:"double Opacity",since:7},{signature:"double OpacityIOR",since:7},{signature:"double OpacityRoughness",since:7},{signature:"double ReflectiveIOR",since:7},{signature:"double Roughness",since:7},{signature:"double Sheen",since:7},{signature:"double SheenTint",since:7},{signature:"double Specular",since:7},{signature:"double SpecularTint",since:7},{signature:"double Subsurface",since:7},{signature:"Color4f SubsurfaceScatteringColor",since:7},{signature:"double SubsurfaceScatteringRadius",since:7},{signature:"bool Supported",since:7}],methods:[{signature:"DocObjects.Texture GetTexture(TextureType which)",summary:"Get the texture that corresponds with the specified texture type for this material.",since:7},{signature:"DocObjects.Texture[] GetTextures()",summary:"Get array of textures that this material uses",since:7},{signature:"bool SetTexture(Texture texture,TextureType which)",summary:"Set the texture that corresponds with the specified texture type for this material.",since:7},{signature:"void SynchronizeLegacyMaterial()",since:7}]},{name:"Rhino.Render.PhysicallyBasedMaterial.BRDFs",dataType:3,summary:""},{name:"Rhino.Render.PhysicallyBasedMaterial.ParametersNames",dataType:1,summary:"Helper class with fields containing the names of fields available in our PBR implementation.",properties:[{signature:"static string AmbientOcclusion",since:6.12},{signature:"static string Anisotropic",since:6.12},{signature:"static string AnisotropicRotation",since:6.12},{signature:"static string BaseColor",since:6.12},{signature:"static string BRDF",since:6.12},{signature:"static string Bump",since:6.12},{signature:"static string Clearcoat",since:6.12},{signature:"static string ClearcoatBump",since:6.16},{signature:"static string ClearcoatRoughness",since:6.12},{signature:"static string Displacement",since:6.12},{signature:"static string Emission",since:6.12},{signature:"static string Metallic",since:6.12},{signature:"static string Normal",since:6.12},{signature:"static string Opacity",since:6.12},{signature:"static string OpacityIor",since:6.12},{signature:"static string OpacityRoughness",since:6.12},{signature:"static string Roughness",since:6.12},{signature:"static string Sheen",since:6.12},{signature:"static string SheenTint",since:6.12},{signature:"static string Smudge",since:6.12},{signature:"static string Specular",since:6.12},{signature:"static string SpecularTint",since:6.12},{signature:"static string Subsurface",since:6.12},{signature:"static string SubsurfaceScatteringColor",since:6.12},{signature:"static string SubsurfaceScatteringRadius",since:6.12}],methods:[{signature:"static string FromTextureType(TextureType tt)",since:7}]},{name:"Rhino.Render.PixelBuffer",dataType:1,summary:"",constructors:[{signature:"PixelBuffer(IntPtr bufferPointer)",summary:"Create a new PixelBuffer pointing to the\n     (unmanaged) pixel data buffer behind IntPtr",since:6}],properties:[{signature:"IntPtr Buffer",since:6}]},{name:"Rhino.Render.PreviewAppearance",dataType:1,summary:"PreviewAppearance class",constructors:[{signature:"PreviewAppearance(IntPtr pRenderContent)",summary:"Constructor for previewappearance",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"Previewappearances c++ pointer",since:6},{signature:"MetaData MetaData",summary:"Previewappearance MetaData",since:6}],methods:[{signature:"PreviewBackground Background()",summary:"Background",since:6},{signature:"void Dispose()",summary:"Dispose for previewappearance",since:6},{signature:"void FromMetaData(MetaData md)",summary:"Copy data from MetaData to PreviewAppearance",since:6},{signature:"PreviewGeometry Geometry()",summary:"Geometry",since:6},{signature:"PreviewLighting Lighting()",summary:"Lighting",since:6},{signature:"IRhRdkPreviewSceneServer_eRotationType RotationType()",summary:"RotationType",since:6},{signature:"double RotationX()",summary:"RotationX",since:6},{signature:"double RotationY()",summary:"RotationY",since:6},{signature:"void SetRotationType(IRhRdkPreviewSceneServer_eRotationType type)",summary:"SetRotationType",since:6},{signature:"void SetRotationX(double d)",summary:"SetRotationX",since:6},{signature:"void SetRotationY(double d)",summary:"SetRotationY",since:6},{signature:"void SetSize(double d)",summary:"SetSize",since:6},{signature:"double Size()",summary:"Size",since:6},{signature:"void ToMetaData()",summary:"Copy PreviewAppearance to MetaData",since:6},{signature:"void ToMetaData(MetaDataProxy mdp)",summary:"Copy PreviewAppearance to MetaData",since:6.8}]},{name:"Rhino.Render.PreviewBackground",dataType:1,summary:"PreviewBackGround takes care of constucting and desctrutction of PreviewLight",constructors:[{signature:"PreviewBackground(IntPtr pPreviewBackground)",summary:"Constructor for PreivewLighting",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"CppPointer for PreivewLighting",since:6}],methods:[{signature:"string ElementKind()",summary:"ElementKind",since:6},{signature:"Guid EnvironmentInstanceId()",summary:"EnvironmentInstanceId",since:6},{signature:"void SetEnvironmentInstanceId(Guid guid)",summary:"SetEnvironmentInstanceId",since:6},{signature:"void SetUpPreview(IntPtr sceneServerPointer,Guid guid)",summary:"SetUpPreview",since:6}]},{name:"Rhino.Render.PreviewGeometry",dataType:1,summary:"PreviewAppearance takes care of constucting and desctrutction of PreivewGeometry",constructors:[{signature:"PreviewGeometry(IntPtr pPreviewGeometry)",summary:"Constructor for PreviewGeometry",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"CppPointer for PreviewGeometry",since:6}],methods:[{signature:"string ElementKind()",summary:"ElementKind",since:6},{signature:"void SetUpPreview(IntPtr sceneServerPointer,IntPtr pRenderContent,bool bCopy)",summary:"SetUpPreview",since:6}]},{name:"Rhino.Render.PreviewLighting",dataType:1,summary:"PreviewAppearance takes care of constucting and desctrutction of PreviewLight",constructors:[{signature:"PreviewLighting(IntPtr pPreviewLighting)",summary:"Constructor for PreivewLighting",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"CppPointer for PreivewLighting",since:6}],methods:[{signature:"string ElementKind()",summary:"ElementKind",since:6},{signature:"void SetUpPreview(IntPtr sceneServerPointer)",summary:"SetUpPreview",since:6}]},{name:"Rhino.Render.PreviewSceneQuality",dataType:3,summary:"Quality levels when creating preview images"},{name:"Rhino.Render.PreviewSceneServer",dataType:1,summary:"PreviewSceneServer",constructors:[{signature:"PreviewSceneServer(IntPtr pPreviewSceneServer)",summary:"Constructor for PreviewSceneServer",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"The CppPointer of PreviewSceneServer",since:6}],methods:[{signature:"void ApplyRotation(double X,double Y,IRhRdkPreviewSceneServer_eRotationType type)",summary:"Set Scene Server Rotation",since:6},{signature:"void Dispose()",summary:"Dispose for PreviewSceneServer",since:6}]},{name:"Rhino.Render.ProxyTypes",dataType:3,summary:"Defines the proxy type of the render content"},{name:"Rhino.Render.RdkUndo",dataType:1,summary:"RdkUndo class, which is used to get the \n   RdkUndoRecord",constructors:[{signature:"RdkUndo(IntPtr pUndoRecord)",summary:"Constructor for RdkUndo",since:6.11}],methods:[{signature:"void Dispose()",summary:"Dispose for RdkUndo",since:6.11},{signature:"RdkUndoRecord NewUndoRecord()",summary:"Get a new UndoRecord",since:6.11}]},{name:"Rhino.Render.RdkUndoRecord",dataType:1,summary:"RdkUndoRecord class",constructors:[{signature:"RdkUndoRecord(IntPtr pUndoRecord)",summary:"Constructor for RdkUndoRecord",since:6}],methods:[{signature:"void Dispose()",summary:"Dispose for RdkUndoRecord",since:6},{signature:"void SetDescription(String description)",summary:"Set description for RdkUndoRecord",since:6}]},{name:"Rhino.Render.RealtimeDisplayMode",dataType:1,summary:"Base class for implementing real-time display modes in .NET.\n   \n   Pay special attention that in StartRenderer the RenderWindow.SetSize()\n   function is called if the implementation relies on the RenderWindow to\n   do the drawing to the viewport. If i.e. OpenGL is used to draw render\n   results to the viewport then SetSize() doesn't have to be called, nor\n   should the implementation then access channels on the RenderWindow, as\n   those then don't exist. For OpenGL-based drawing the RenderWindow is\n   used as a container for ViewInfo management, nothing else.",properties:[{signature:"LinearWorkflow LinearWorkflow",summary:"Returns the LinearWorkflow data for this realitime display mode.",since:6},{signature:"bool Locked",since:6.6},{signature:"int MaxPasses",since:6.6},{signature:"bool Paused",since:6.6}],methods:[{signature:"static RealtimeDisplayMode GetRealtimeViewport(IntPtr realtimeViewport)",summary:"Retrieve RealtimeDisplayMode instance that the IntPtr refers to.",since:6},{signature:"static RealtimeDisplayMode GetRealtimeViewport(IntPtr realtimeViewport,bool create)",summary:"Retrieve RealtimeDisplayMode instance. If create is set to true\n     then a new instance is created if not found, None is returned for false.",since:6},{signature:"static RealtimeDisplayModeClassInfo[] RegisterDisplayModes(Assembly assembly,Guid pluginId)",summary:"Find and register classes that derive from RealtimeDisplayMode\n     from the given plug-in. The plug-in is found in the given assembly",since:6},{signature:"static RealtimeDisplayModeClassInfo[] RegisterDisplayModes(PlugIn plugin)",summary:"Find and register classes that derive from RealtimeDisplayMode\n     from the given plug-in.",since:6},{signature:"static void RemoveRealtimeViewport(IntPtr realtimeViewport)",summary:"Remove RealtimeDisplayMode instance from internal dictionary.",since:6},{signature:"static void UnregisterDisplayModes(Assembly assembly,Guid pluginId)",since:6},{signature:"static void UnregisterDisplayModes(PlugIn plugin)",since:6},{signature:"double CaptureProgress()",summary:"Override to communicate the progress of a capture.",since:6,returns:"A number between 0.0 and 1.0 inclusive. 1.0 means 100%."},{signature:"uint ComputeViewportCrc(ViewInfo view)",summary:"Compute viewport CRC for the given ViewInfo",since:6,returns:"the CRC for the given view"},{signature:"void CreateWorld(RhinoDoc doc,ViewInfo viewInfo,DisplayPipelineAttributes displayPipelineAttributes)",summary:"Implement if you need to handle the initial CreateWorld call initiated by the display pipeline system. Note\n     that this is not the same as the CreateWorld call in Rhino.Render.ChangeQueue.ChangeQueue, although\n     related.",since:6},{signature:"bool DrawOpenGl()",since:6},{signature:"void GetRenderSize(int width,int height)",summary:"Get the current render resolution for the running render session.",since:6},{signature:"ViewInfo GetView()",summary:"Get ViewInfo that has been registered with this RealtimeDisplayMode instance.",since:6},{signature:"bool HudAllowEditMaxPasses()",summary:"Override to allow maximum pass editing. By default disabled.",since:6,returns:"Return True to allow users to edit the maximum pass count."},{signature:"string HudCustomStatusText()",summary:"Override to display status of the render engine.",since:6,returns:"Status text to display"},{signature:"int HudLastRenderedPass()",summary:"Override to communicate the last completed pass. Can be shown in the HUD",since:6,returns:"Last completed pass"},{signature:"int HudMaximumPasses()",summary:"Override to communicate the maximum passes count currently in use for the render session.\n     Can be shown in the HUD",since:6,returns:"Maximum passes"},{signature:"string HudProductName()",summary:"Override to return the name of your product. This will be printed in\n     the HUD.",since:6,returns:"Name of the product."},{signature:"bool HudRendererLocked()",summary:"Implement to support locking in the viewport",since:6,returns:"Return True if the render engine is locked."},{signature:"bool HudRendererPaused()",summary:"Implement to support pausing and resuming in the viewport",since:6,returns:"Return True if the render engine is paused."},{signature:"bool HudShow()",summary:"Override if you want to hide the HUD. Shown by default",since:6,returns:"Return False to hide the HUD."},{signature:"bool HudShowControls()",summary:"Show control buttons on the realtime display HUD.\n     \n     By default these are shown, override this function and\n     return False if HUD controls aren't needed.",since:6},{signature:"bool HudShowCustomStatusText()",summary:"Override to show status text in HUD. By default disabled.",since:6,returns:"Return True to show status text in HUD"},{signature:"bool HudShowMaxPasses()",summary:"Override to show maximum passes in HUD. By default disabled.",since:6,returns:"Return True to show maximum passes."},{signature:"bool HudShowPasses()",summary:"Override to show current pass in HUD. By default disabled.",since:6,returns:"Return True to show current pass in HUD."},{signature:"DateTime HudStartTime()",since:6},{signature:"bool IsCompleted()",summary:"Implement to tell if your render engine has completed a frame for drawing into the viewport",since:6},{signature:"bool IsFrameBufferAvailable(ViewInfo view)",summary:"Implement to tell the render pipeline that a framebuffer is ready",since:6,returns:"Return True when a framebuffer is ready. This is generally the\n     case when StartRenderer as returned successfully."},{signature:"bool IsRendererStarted()",summary:"Override to tell the started state of your render engine.",since:6,returns:"True if render engine is ready and rendering"},{signature:"int LastRenderedPass()",summary:"Implement to communicate last completed pass to the underlying system.",since:6,returns:"the last completed pass"},{signature:"bool OnRenderSizeChanged(int width,int height)",summary:"Override to restart your render engine",since:6},{signature:"int OpenGlVersion()",since:6},{signature:"void PostConstruct()",summary:"Override PostConstruct if you need to initialize where\n     the underlying RealtimeDisplayMode is available.\n     \n     The connection is made right after RealtimeDisplayMode\n     has been instantiated, but just before PostConstruct is called.\n     \n     For instance finding out OpenGL information can be done in\n     PostConstruct.",since:6},{signature:"void SetUseDrawOpenGl(bool use)",summary:"During run-time change whether to use OpenGL drawing of results or not. For instance\n     offline rendering (viewcapture* with different resolution than viewport) could use\n     RenderWindow instead of direct OpenGL drawing.",since:6},{signature:"void SetView(ViewInfo view)",summary:"Set ViewInfo for this RealtimeDisplayMode instance.",since:6},{signature:"bool ShowCaptureProgress()",summary:"Override if you want to i.e. hide the progress dialog for capture progress.",since:6,returns:"Return True to show, False to hide"},{signature:"void ShutdownRenderer()",summary:"Override to shutdown your render engine",since:6},{signature:"void SignalRedraw()",summary:"Use to signal the underlying pipeline a redraw is wanted. This can be used\n     for instance when a renderer has completed a pass which should be\n     updated in the associated viewport.",since:6},{signature:"bool StartRenderer(int w,int h,RhinoDoc doc,ViewInfo view,ViewportInfo viewportInfo,bool forCapture,RenderWindow renderWindow)",summary:"Override to start your render engine.\n     \n     Note that before using the RenderWindow you *must* call SetSize\n     to properly initialize the underlying DIB.",since:6,returns:"Return True when your render engine started correctly, False when that failed"},{signature:"bool UseFastDraw()",summary:"Implement and return True if you want the display pipeline to not\n     wait for IsFramebufferAvailable during the MiddleGround draw phase.\n     This will also tell the pipeline to draw a complete middleground pass in OpenGL.",since:6}]},{name:"Rhino.Render.RealtimeDisplayMode.DisplayPipelineSettingsChangedEventArgs",dataType:1,summary:"",constructors:[{signature:"DisplayPipelineSettingsChangedEventArgs(DisplayPipelineAttributes dpa)",since:6}],properties:[{signature:"DisplayPipelineAttributes Attributes",since:6}]},{name:"Rhino.Render.RealtimeDisplayMode.DrawMiddlegroundEventArgs",dataType:1,summary:"",constructors:[{signature:"DrawMiddlegroundEventArgs(DisplayPipeline dp)",since:6}],properties:[{signature:"DisplayPipeline Pipeline",since:6}]},{name:"Rhino.Render.RealtimeDisplayMode.HudMaxPassesChangedEventArgs",dataType:1,summary:"",constructors:[{signature:"HudMaxPassesChangedEventArgs(int mp)",since:6}],properties:[{signature:"int MaxPasses",since:6}]},{name:"Rhino.Render.RealtimeDisplayMode.InitFramebufferEventArgs",dataType:1,summary:"",constructors:[{signature:"InitFramebufferEventArgs(DisplayPipeline dp)",since:6}],properties:[{signature:"DisplayPipeline Pipeline",since:6}]},{name:"Rhino.Render.RealtimeDisplayModeClassInfo",dataType:1,summary:"Class information obligatory for registering RealtimeDisplayMode\n   implementations.",properties:[{signature:"bool DontRegisterAttributesOnStart",summary:"Override and return True when you don't want your class info\n     to cause display attributes to be registered with the system.",since:6},{signature:"bool DrawOpenGl",summary:"Return True if the RealtimeDisplayMode draws its result\n     using OpenGL. RenderWindow usage will then be skipped.",since:6},{signature:"Guid GUID",summary:"Get the RealtimeDisplayMode implementation GUID",since:6},{signature:"string Name",summary:"Get human-facing class description for RealtimeDisplayMode\n     implementation. This string might show up in the Rhino\n     UI.",since:6},{signature:"Type RealtimeDisplayModeType",summary:"Get the type being registered.",since:6}]},{name:"Rhino.Render.RenderContent",dataType:1,summary:"",properties:[{signature:"bool CanBeEdited",summary:"Determines if the content can be edited.",since:6},{signature:"String Category",summary:"Category for this content.",since:6.7},{signature:"String ChildSlotDisplayName",summary:"Returns the localized display name of the child slot name",since:7},{signature:"String ChildSlotName",since:5.1},{signature:"IntPtr CppPointer",since:6},{signature:"RhinoDoc Document",summary:"If this content is in a document content list, the document will be returned.  Otherwise null.",since:5.1},{signature:"RhinoDoc DocumentAssoc",summary:"If this content is associated by a document in any way, the document will be returned.  This includes copies of\n     contents that were initially in the document. Otherwise null.",since:6},{signature:"RhinoDoc DocumentRegistered",summary:"If this content is used by a document, including not in the content lists (for example, as a decal),\n     the document will be returned.  Otherwise null.",since:6},{signature:"FieldDictionary Fields",summary:"Rhino.Render.Fields FieldDictionary which provides access to setting\n     and retrieving field values.",since:5.1},{signature:"IEnumerable<string> FilesToEmbed",summary:"A string array of full paths to files used by the content that may be\n     embedded in .3dm files and library files (.rmtl, .renv, .rtex). The\n     default implementation returns an empty string list. Override this to\n     return the file name or file names used by your content. This is\n     typically used by textures that reference files containing the texture\n     imagery.",since:5.12},{signature:"RenderContent FirstChild",summary:"Return First child of this content or nullptr if none.",since:6},{signature:"bool Hidden",summary:"Determines if the content has the hidden flag set.",since:5.1},{signature:"Guid Id",summary:"Instance identifier for this content.",since:5.1},{signature:"bool IsDefaultInstance",summary:"Checks if render content is default instance.",since:6},{signature:"bool IsHiddenByAutoDelete",summary:"Contents can be created as 'auto-delete' by certain commands such as 'PictureFrame'.\n     These contents are automatically hidden from the user when the associated Rhino object\n     is deleted. They are later deleted when the document is saved.",since:6.15},{signature:"bool IsLocked",summary:"Set this property to True prior to adding content to the document to\n     lock the content browser editing UI methods.  Setting this to True will\n     keep the browser from allowing things like deleting, renaming or\n     changing content.  This is useful for custom child content that you\n     want to be editable but persistent.  Setting this after adding content\n     to the document will cause an exception to be thrown.",since:5.12},{signature:"String Name",summary:"Instance name for this content.",since:5.1},{signature:"RenderContent NextSibling",summary:"Return First sibling of this content or nullptr if none.",since:6},{signature:"String Notes",summary:"Notes for this content.",since:5.1},{signature:"RenderContent Parent",summary:"Returns the top content in this parent/child chain.",since:5.11},{signature:"ProxyTypes ProxyType",summary:"Gets the proxy type of the render content",since:6},{signature:"uint RenderHash",summary:"Render hash for the content hierarchy. It iterates children and includes\n     a caching mechanism which means the hash value can be retrieved quickly\n     if it hasn't changed. The cache is invalidated when Changed() is called.\n     \n     You can override the  method to provide\n     a custom hash value.",since:6},{signature:"String Tags",summary:"Tags for this content.",since:6.4},{signature:"bool TopLevel",summary:"Returns True if this content has no parent, False if it is the child of another content.",since:5.1},{signature:"RenderContent TopLevelParent",summary:"Returns the top content in this parent/child chain.",since:5.1},{signature:"String TypeDescription",summary:'Description for your content type.  ie.  "Procedural checker pattern"',since:5.1},{signature:"Guid TypeId",summary:"Type identifier for this content",since:6},{signature:"String TypeName",summary:'Name for your content type.  ie. "My .net Texture"',since:5.1},{signature:"String Xml",since:6}],methods:[{signature:"static bool AddPersistentRenderContent(RenderContent renderContent)",summary:"Add a material, environment or texture to the internal RDK document lists as\n     top level content.  The content must have been returned from\n     RenderContent::MakeCopy, NewContentFromType or a similar function that returns\n     a non-document content.",since:5.1,returns:"True on success."},{signature:"static bool AddPersistentRenderContent(RhinoDoc document,RenderContent renderContent)",summary:"Add a material, environment or texture to the internal RDK document lists as\n     top level content.  The content must have been returned from\n     RenderContent::MakeCopy, NewContentFromType or a similar function that returns\n     a non-document content.",since:6,returns:"True on success."},{signature:"static RenderContent Create(Guid type,RenderContent parent,String childSlotName,ShowContentChooserFlags flags,RhinoDoc doc)",summary:"Constructs a new content of the specified type and add it to the persistent content list.\n     This function cannot be used to create temporary content that you delete after use.\n     Content created by this function is owned by RDK and appears in the content editor.\n     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().",since:5.1,returns:"A new persistent render content."},{signature:"static RenderContent Create(Guid type,ShowContentChooserFlags flags,RhinoDoc doc)",summary:"Constructs a new content of the specified type and add it to the persistent content list.\n     This function cannot be used to create temporary content that you delete after use.\n     Content created by this function is owned by RDK and appears in the content editor.\n     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().",since:5.1,returns:"A new persistent render content."},{signature:"static RenderContent Create(Type type,RenderContent parent,String childSlotName,ShowContentChooserFlags flags,RhinoDoc doc)",summary:"Constructs a new content of the specified type and add it to the persistent content list.\n     This function cannot be used to create temporary content that you delete after use.\n     Content created by this function is owned by RDK and appears in the content editor.\n     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().",since:5.1,returns:"A new persistent render content."},{signature:"static RenderContent Create(Type type,ShowContentChooserFlags flags,RhinoDoc doc)",summary:"Constructs a new content of the specified type and add it to the persistent content list.\n     This function cannot be used to create temporary content that you delete after use.\n     Content created by this function is owned by RDK and appears in the content editor.\n     To create a temporary content which is owned by you, call RenderContentType.NewContentFromType().",since:5.1,returns:"A new persistent render content."},{signature:"static RenderContent FromId(RhinoDoc document,Guid id)",summary:"Search for a content object based on its Id",since:5.7,returns:"Returns the content object with the specified Id if it is found\n     otherwise it returns null."},{signature:"static RenderContent FromXml(String xml)",since:6},{signature:"static RenderContent FromXml(String xml,RhinoDoc doc)",since:6.4},{signature:"static RenderContent LoadFromFile(String filename)",summary:"Loads content from a library file.  Does not add the content to the persistent content list.\n     Use AddPersistantContent to add it to the list.",since:5.1,returns:"The loaded content or None if an error occurred."},{signature:"static Type[] RegisterContent(Assembly assembly,Guid pluginId)",summary:"Call RegisterContent in your plug-in's OnLoad function in order to register all of the\n     custom RenderContent classes in your assembly.",since:5.1,returns:"array of render content types registered on success. None on error."},{signature:"static Type[] RegisterContent(PlugIn plugin)",summary:"Call RegisterContent in your plug-in's OnLoad function in order to register all of the\n     custom RenderContent classes in your assembly.",since:5.1,returns:"array of render content types registered on success. None on error."},{signature:"bool AddAutomaticUserInterfaceSection(string caption,int id)",summary:"Add a new automatic user interface section, Field values which include\n     prompts will be automatically added to this section.",since:5.1,returns:"Returns True if the automatic tab section was added otherwise; returns\n     False on error."},{signature:"bool AddChild(RenderContent renderContent)",since:5.6},{signature:"bool AddChild(RenderContent renderContent,String childSlotName)",since:6},{signature:"bool AddUserInterfaceSection(ICollapsibleSection section)",since:6},{signature:"UI.UserInterfaceSection AddUserInterfaceSection(Type classType,string caption,bool createExpanded,bool createVisible)",summary:"Add a new .NET control to an content expandable tab section, the height\n     of the createExpanded tabs client area will be the initial height of the\n     specified control.",since:5.1,returns:"Returns the UserInterfaceSection object used to manage the new \n     user control object."},{signature:"void BeginChange(ChangeContexts changeContext)",summary:"Begins a change or batch of changes. This returns a reference to the\n     content which you should use to make your changes. It may also make a\n     copy of the content state allowing  to send an\n     event with the old and new contents. Calls to this method are counted;\n     you must call EndChange() once for every call to BeginChange().\n     Note:\n       If Changed() was called between the calls to BeginChange() and\n       EndChange(), the last call to EndChange() may cause the ContentChanged\n       event to be sent.",since:6},{signature:"void BindParameterToField(string parameterName,Field field,ChangeContexts setEvent)",summary:"Use bindings to automatically wire parameters to fields",since:5.7},{signature:"void BindParameterToField(string parameterName,string childSlotName,Field field,ChangeContexts setEvent)",summary:"Use bindings to automatically wire parameters to fields",since:5.7},{signature:"bool ChangeChild(RenderContent oldContent,RenderContent newContent)",since:5.6},{signature:"double ChildSlotAmount(String childSlotName)",summary:"Gets the amount property for the texture in the specified child slot.  Values are typically from 0.0 - 100.0",since:5.7},{signature:"string ChildSlotNameFromParamName(String paramName)",summary:'A "child slot" is the specific "slot" that a child (usually a texture) occupies.\n     This is generally the "use" of the child - in other words, the thing the child\n     operates on.  Some examples are "color", "transparency".',since:5.1,returns:"The default behavior for these functions is to return the input string.\n     Sub-classes may (in the future) override these functions to provide different mappings."},{signature:"bool ChildSlotOn(String childSlotName)",summary:"Gets the on-ness property for the texture in the specified child slot.",since:5.7},{signature:"void DeleteAllChildren(ChangeContexts changeContexts)",since:5.1},{signature:"bool DeleteChild(string childSlotName,ChangeContexts changeContexts)",since:5.1},{signature:"void Dispose()",since:5.1},{signature:"bool DynamicIcon(Size size,Bitmap bitmap,DynamicIconUsage usage)",since:6},{signature:"RenderContent Edit()",summary:"Call this method to open the content in the a modal version of the editor.\n     The content must be in the document or the call will fail.",since:6.13,returns:"Returns the edited content on succees or None on error."},{signature:"void EndChange()",summary:"Ends a change or batch of changes. Calls to this method are counted;\n     you must call this method once for every call to .\n     Note:\n       If  was called with ChangeContexts.UI,\n       ChangeContexts.Program, ChangeContexts.Drop or ChangeContexts.UI.Tree\n       and Changed() was called between the calls to  and\n       EndChange(), the last call to EndChange() will raise the\n        event.",since:6},{signature:"DataSources.ContentFactory Factory()",since:6.1},{signature:"RenderContent FindChild(String childSlotName)",since:5.1},{signature:"RenderContent ForDisplay()",summary:"**** This method is for proxies and will be marked obsolete in V7 ****\n    \n     The only place a single proxy can be displayed is in the\n     New Content Control main thumbnail. All other attempts to\n     use a single proxy in a UI require it to be replaced with\n     the corresponding multi proxy. Single proxies override this\n     to find the corresponding multi proxy.",since:6.9,returns:"The cotnent."},{signature:"object GetChildSlotParameter(String parameterName,String childSlotName)",summary:"Extra requirements are a way of specifying extra functionality on parameters in the automatic UI.\n     Implement this function to specify additional functionality for automatic UI sections or the texture summary.\n     See IAutoUIExtraRequirements.h in the C++ RDK for string definitions for the parameter names.",since:5.7,returns:"Call the base class if you do not support the extra requirement parameter.\n     Current supported return values are (int, bool, float, double, string, Guid, Color, Vector3d, Point3d, DateTime)"},{signature:"string[] GetEmbeddedFilesList()",since:6},{signature:"object GetParameter(String parameterName)",summary:"Query the content instance for the value of a given named parameter.\n     If you do not support this parameter, call the base class.",since:5.7,returns:"IConvertible. Note that you can't directly cast from object, instead you have to use the Convert mechanism."},{signature:"bool GetUnderlyingInstances(RenderContentCollection collection)",since:7},{signature:"bool Icon(Size size,Bitmap bitmap)",since:6},{signature:"bool Initialize()",since:6.1},{signature:"bool IsCompatible(Guid renderEngineId)",since:6},{signature:"bool IsContentTypeAcceptableAsChild(Guid type,String childSlotName)",since:6},{signature:"bool IsFactoryProductAcceptableAsChild(ContentFactory factory,String childSlotName)",since:6.1},{signature:"bool IsFactoryProductAcceptableAsChild(Guid kindId,string factoryKind,string childSlotName)",summary:"Override this method to restrict the type of acceptable child content.\n     The default implementation of this method just returns true.",since:5.11,returns:"Return True only if content with the specified kindId can be  accepted\n     as a child in the specified child slot."},{signature:"bool IsReference()",summary:"Query whether or not the content or any of its ancestors is a reference content.",since:6.9,returns:"True if the content is a reference, else false"},{signature:"bool IsRenderHashCached()",summary:"This method is deprecated and no longer called. For more information\n     see",since:6,returns:"bool"},{signature:"RenderContent MakeCopy()",summary:"Create a copy of the render content. All content is the same, except for the\n     instance Id.",since:6,returns:"The new RenderContent"},{signature:"MatchDataResult MatchData(RenderContent oldContent)",summary:"Implement to transfer data from another content to this content during creation.",since:6,returns:"Information about how much data was matched."},{signature:"PreviewSceneServer NewPreviewSceneServer(SceneServerData ssd)",summary:"Gets the PreviewSceneServer of the content",since:6},{signature:"bool OpenInEditor()",summary:"Call this method to open the content in the relevant thumbnail editor\n     and select it for editing by the user. The content must be in the\n     document or the call will fail.",since:5.7,returns:"Returns True on success or False on error."},{signature:"bool OpenInModalEditor()",summary:"Call this method to open the content in the a modal version of the editor.\n     The content must be in the document or the call will fail.",since:5.7,returns:"Returns True on success or False on error."},{signature:"string ParamNameFromChildSlotName(String childSlotName)",summary:'A "child slot" is the specific "slot" that a child (usually a texture) occupies.\n     This is generally the "use" of the child - in other words, the thing the child\n     operates on.  Some examples are "color", "transparency".',since:5.1,returns:"The default behavior for these functions is to return the input string.  Sub-classes may (in the future) override these functions to provide different mappings."},{signature:"uint RenderHashExclude(CrcRenderHashFlags flags,string excludeParameterNames)",summary:"As RenderHash, but ignore parameter names given.",since:6.2,returns:"Render hash"},{signature:"uint RenderHashExclude(TextureRenderHashFlags flags,string excludeParameterNames)",summary:"As RenderHash, but ignore parameter names given.",since:6,returns:"Render hash"},{signature:"bool Replace(RenderContent newcontent)",since:6.13},{signature:"bool SetChild(RenderContent renderContent,String childSlotName)",summary:"Set another content as a child of this content. This content may or may\n     not be attached to a document.  If this content already has a child\n     with the specified child slot name, that child will be deleted.  If\n     this content is not attached to a document, the child will be added\n     without sending any events.  If this content is attached to a document,\n     the necessary events will be sent to update the UI.\n     Note:\n       Do not call this method to add children in your constructor. If you\n       want to add default children, you should override Initialize() and add\n       them there.",since:6,returns:"Returns True if the content was added or the child slot with this name\n     was modified otherwise; returns false."},{signature:"bool SetChild(RenderContent renderContent,String childSlotName,ChangeContexts changeContexts)",summary:"Set another content as a child of this content. This content may or may\n     not be attached to a document.  If this content already has a child\n     with the specified child slot name, that child will be deleted.  If\n     this content is not attached to a document, the child will be added\n     without sending any events.  If this content is attached to a document,\n     the necessary events will be sent to update the UI.\n     Note:\n       Do not call this method to add children in your constructor. If you\n       want to add default children, you should override Initialize() and add\n       them there.",since:5.1,returns:"Returns True if the content was added or the child slot with this name\n     was modified otherwise; returns false."},{signature:"void SetChildSlotAmount(String childSlotName,double amount,ChangeContexts cc)",summary:"Sets the amount property for the texture in the specified child slot.  Values are typically from 0.0 - 100.0",since:5.7},{signature:"void SetChildSlotOn(String childSlotName,bool bOn,ChangeContexts cc)",summary:"Sets the on-ness property for the texture in the specified child slot.",since:5.7},{signature:"bool SetChildSlotParameter(String parameterName,String childSlotName,object value,ExtraRequirementsSetContexts sc)",summary:"Extra requirements are a way of specifying extra functionality on parameters in the automatic UI.\n     Implement this function to support values being set from automatic UI sections or the texture summary.\n     See IAutoUIExtraRequirements.h in the C++ RDK for string definitions for the parameter names.",since:5.7,returns:"Null variant if not supported.  Call the base class if you do not support the extra requirement paramter."},{signature:"void SetName(string name,bool bRenameEvents,bool bEnsureNameUnique)",summary:"Set instance name for this content",since:7},{signature:"bool SetParameter(String parameterName,object value)",summary:"Set the named parameter value for this content instance.\n     If you do not support this parameter, call the base class.",since:6},{signature:"bool SetParameter(String parameterName,object value,ChangeContexts changeContext)",summary:"Set the named parameter value for this content instance.\n     If you do not support this parameter, call the base class.",since:5.7},{signature:"void SetRenderHash(uint hash)",summary:"This method is deprecated and no longer called. For more information\n     see",since:6},{signature:"void Uninitialize()",since:6.1},{signature:"int UseCount()",summary:"UseCount returns how many times the content is used",since:6.9},{signature:"bool VirtualIcon(Size size,Bitmap bitmap)",summary:"Icon to display in the content browser, this bitmap needs to be valid for\n     the life of this content object, the content object that returns the bitmap\n     is responsible for disposing of the bitmap.",since:6,returns:"Return Icon to display in the content browser."}],events:[{signature:"static ContentAdded",summary:"Used to monitor render content addition to the document.",since:5.7},{signature:"static ContentChanged",summary:"Used to monitor render content modifications.",since:5.7},{signature:"static ContentDeleted",summary:"Used to monitor render content deletion from the document.",since:6},{signature:"static ContentDeleting",summary:"Used to monitor render content deletion from the document.",since:5.7},{signature:"static ContentFieldChanged",summary:"This event is raised when a field value is modified.",since:5.11},{signature:"static ContentRenamed",summary:"Used to monitor render content renaming in the document.",since:5.7},{signature:"static ContentReplaced",summary:"Used to monitor render content replacing in the document.",since:5.7},{signature:"static ContentReplacing",summary:"Used to monitor render content replacing in the document.",since:5.7},{signature:"static ContentUpdatePreview",summary:"Used to monitor render content preview updates.",since:5.7},{signature:"static CurrentEnvironmentChanged",summary:"Event fired when changes to current environments have been made.\n     This will be one of Background, ReflectionAndRefraction or Skylighting\n     Since 6.11",since:6.11}]},{name:"Rhino.Render.RenderContent.ChangeContexts",dataType:3,summary:"Context of a change to content parameters."},{name:"Rhino.Render.RenderContent.ExtraRequirementsSetContexts",dataType:3,summary:""},{name:"Rhino.Render.RenderContent.MatchDataResult",dataType:3,summary:"Return values for MatchData function"},{name:"Rhino.Render.RenderContent.ShowContentChooserFlags",dataType:3,summary:""},{name:"Rhino.Render.RenderContentChangedEventArgs",dataType:1,summary:"",properties:[{signature:"ChangeContexts ChangeContext",since:5.7},{signature:"RenderContent OldContent",since:6}]},{name:"Rhino.Render.RenderContentChangeReason",dataType:3,summary:"Enumeration denoting type of change for attach or detach"},{name:"Rhino.Render.RenderContentCollection",dataType:1,summary:"",constructors:[{signature:"RenderContentCollection()",since:6},{signature:"RenderContentCollection(IntPtr nativePtr)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"void Add(RenderContentCollection collection)",since:6},{signature:"void Append(RenderContent content)",since:6},{signature:"void Clear()",since:6},{signature:"RenderContent ContentAt(int index)",since:6},{signature:"bool ContentNeedsPreviewThumbnail(RenderContent c)",since:7},{signature:"bool ContentNeedsPreviewThumbnail(RenderContent c,bool bIncludeChildren)",since:7},{signature:"int Count()",since:6},{signature:"void Dispose()",since:6},{signature:"RenderContent Find_Sel(Guid uuid)",since:6},{signature:"string FirstTag()",since:6.13},{signature:"IEnumerator GetEnumerator()",since:6},{signature:"FilterContentByUsage GetFilterContentByUsage()",since:6.9},{signature:"bool GetForcedVaries()",since:6.9},{signature:"string GetSearchPattern()",since:6},{signature:"ContentCollectionIterator Iterator()",since:6},{signature:"string NextTag()",since:6.13},{signature:"void Remove(RenderContentCollection collection)",since:6},{signature:"void Set(RenderContentCollection collection)",since:6},{signature:"void SetForcedVaries(bool b)",since:6.9},{signature:"void SetSearchPattern(string pattern)",since:6}]},{name:"Rhino.Render.RenderContentEventArgs",dataType:1,summary:"",properties:[{signature:"RenderContent Content",since:5.7},{signature:"RhinoDoc Document",since:6},{signature:"Usage EnvironmentUsage",summary:"Meaningful for CurrentEnvironmentChanged event. Will be one of Background, ReflectionAndRefraction or Skylighting.\n     \n     Since 6.11",since:6.11},{signature:"RenderContentChangeReason Reason",summary:"Not when used in CurrentEnvironmentChanged (defaults to None).",since:6}]},{name:"Rhino.Render.RenderContentFieldChangedEventArgs",dataType:1,summary:"",properties:[{signature:"string FieldName",since:5.11}]},{name:"Rhino.Render.RenderContentKind",dataType:3,summary:"Defines constant values for all render content kinds, such as material,\n   environment or texture."},{name:"Rhino.Render.RenderContentKindList",dataType:1,summary:"",constructors:[{signature:"RenderContentKindList()",since:6.7},{signature:"RenderContentKindList(IntPtr pRdkRenderContentKindList)",since:6.1},{signature:"RenderContentKindList(RenderContentKindList kind_list)",since:6.7}],properties:[{signature:"IntPtr CppPointer",since:6.1}],methods:[{signature:"void Add(RenderContentKind kind)",since:6.7},{signature:"bool Contains(RenderContentKind kind)",since:6.3},{signature:"int Count()",since:6.1},{signature:"void Dispose()",since:6.1},{signature:"RenderContentKind SingleKind()",since:6.1}]},{name:"Rhino.Render.RenderContentManager",dataType:1,summary:"RenderContentManager's RestoreRenderContents method unpacks the \n   default render contents from the from the application and places them \n   in the User's folder.  Only available on Mac at the moment.",properties:[{signature:"static string UserRenderContentPath",summary:"Get the path to: \n     Windows: C:\\Users\\user\\AppData\\Roaming\\McNeel\\Rhinoceros\\6.0\\Localization\\en-US\\Render Content\n     macOS: ~/Library/Application Support/McNeel/Rhinoceros/6.0/Render Content\n     If a CustomLibraryPath is set, this is returned",since:6.1}],methods:[{signature:"static bool RestoreRenderContent()",summary:"Unpacks the default render contents from the from the application and places them in the User's folder.\n     This will restore the default versions if the version of Rhino that is running is newer than the contents\n     of the last Rhino that wrote the version.txt file.  If the version.txt file is not present, it will\n     automatically restore the default contents.  This does not overwrite files that the user has changed.",since:6.1}]},{name:"Rhino.Render.RenderContentSerializer",dataType:1,summary:"Used to import and export custom render content types such as\n   materials, environments and textures.  You must override\n   RenderPlugIn.RenderContentSerializers() and return an array of\n   derived RenderContentSerializer class types to add to the content\n   browsers.",properties:[{signature:"bool CanRead",summary:"If True then the file type can be imported and will be included in the\n     file open box when importing the specified render content type.",since:5.7},{signature:"bool CanWrite",summary:"If True then the file type can be exported and will be included in the\n     file save box when exporting the specified render content type.",since:5.7},{signature:"RenderContentKind ContentType",summary:"Type of content created when importing or exporting this file type.",since:5.7},{signature:"String EnglishDescription",summary:"English string describing this plug-in",since:5.7},{signature:"string FileExtension",summary:"File extension associated with this serialize object",since:5.7},{signature:"String LocalDescription",summary:"Localized plug-in description",since:5.7}],methods:[{signature:"RenderContent Read(String pathToFile)",summary:"Called to when importing a file, file should be parsed and converted to\n     a valid RenderContent object.",since:5.7,returns:"Returns a valid RenderContent object such as RenderMaterial if the file\n     was successfully parsed otherwise returns null."},{signature:"bool RegisterSerializer(Guid id)",summary:"Register the RenderContentSerializer",since:6},{signature:"bool Write(String pathToFile,RenderContent renderContent,CreatePreviewEventArgs previewArgs)",summary:"Called to save a custom RenderContent object as an external file.",since:5.7}]},{name:"Rhino.Render.RenderContentStyles",dataType:3,summary:""},{name:"Rhino.Render.RenderContentTableEventForwarder.RenderContentTableEventArgs",dataType:1,summary:""},{name:"Rhino.Render.RenderContentType",dataType:1,summary:"Represents one of the render content types registered with Rhino.",constructors:[{signature:"RenderContentType(Guid typeId)",since:6}],properties:[{signature:"Guid Id",summary:"Returns the type identifier associated with this type.",since:6},{signature:"String InternalName",summary:"Returns the internal name identifier associated with this type.",since:6},{signature:"Guid PlugInId",since:6},{signature:"Guid RenderEngineId",since:6}],methods:[{signature:"static RenderContentType[] GetAllAvailableTypes()",summary:"Gets an array of all available render content types registered with Rhino.",since:6,returns:"An array with all types."},{signature:"static RenderContent NewContentFromTypeId(Guid typeId)",summary:"Create a new content specified by the Guid.\n    \n     This function can be used to create temporary content, as it calls\n     ::RhRdkContentFactories().NewContentFromType().",since:6},{signature:"static RenderContent NewContentFromTypeId(Guid typeId,RhinoDoc doc)",since:6.4},{signature:"void Dispose()",since:6},{signature:"RenderContent NewRenderContent()",summary:"Returns a new instance of the render content of this type.  This content can be added to a persistant list.",since:6,returns:"A new render content instance."}]},{name:"Rhino.Render.RenderCustomEventArgs",dataType:1,summary:"Used as Rhino.Render Custom Events args.",properties:[{signature:"IntPtr Argument",summary:"The pointer to the custom event args.",since:7},{signature:"Guid EventType",summary:"The type of the event.",since:7}]},{name:"Rhino.Render.RenderEndEventArgs",dataType:1,summary:"Contains information about why OnRenderEnd was called"},{name:"Rhino.Render.RenderEnvironment",dataType:1,summary:"",properties:[{signature:"static RenderEnvironment CurrentEnvironment",since:5.1},{signature:"String TextureChildSlotName",since:6}],methods:[{signature:"static RenderEnvironment NewBasicEnvironment(SimulatedEnvironment environment)",summary:"Constructs a new  from a .",since:5.3,returns:"A new basic environment."},{signature:"static RenderEnvironment NewBasicEnvironment(SimulatedEnvironment environment,RhinoDoc doc)",since:6.4},{signature:"SimulatedEnvironment SimulateEnvironment(bool isForDataOnly)",since:6},{signature:"void SimulateEnvironment(SimulatedEnvironment simulation,bool isForDataOnly)",since:5.1}]},{name:"Rhino.Render.RenderEnvironment.Usage",dataType:3,summary:""},{name:"Rhino.Render.RenderEnvironmentTable",dataType:1,summary:"",properties:[{signature:"int Count",since:5.7}],methods:[{signature:"bool Add(RenderEnvironment c)",since:6},{signature:"void BeginChange(ChangeContexts changeContext)",since:7},{signature:"void EndChange()",since:7},{signature:"IEnumerator<RenderEnvironment> GetEnumerator()",since:5.7},{signature:"bool Remove(RenderEnvironment c)",since:6}]},{name:"Rhino.Render.Rendering.CommandFilters",dataType:3,summary:""},{name:"Rhino.Render.Rendering.StatusTexts",dataType:3,summary:""},{name:"Rhino.Render.RenderingCommand.MenuCategories",dataType:3,summary:""},{name:"Rhino.Render.RenderingCommand.States",dataType:3,summary:""},{name:"Rhino.Render.RenderingHistogram.HistogramFlags",dataType:3,summary:""},{name:"Rhino.Render.RenderingHistogram.HistogramType",dataType:3,summary:""},{name:"Rhino.Render.RenderingPostEffectCommand.States",dataType:3,summary:""},{name:"Rhino.Render.RenderingPostEffects.Disposition",dataType:3,summary:""},{name:"Rhino.Render.RenderMaterial",dataType:1,summary:"",properties:[{signature:"static Guid GemMaterialGuid",since:6},{signature:"static Guid GlassMaterialGuid",since:6},{signature:"static Guid MetalMaterialGuid",since:6},{signature:"static Guid PaintMaterialGuid",since:6},{signature:"static Guid PictureMaterialGuid",since:6},{signature:"static Guid PlasterMaterialGuid",since:6},{signature:"static Guid PlasticMaterialGuid",since:6},{signature:"PreviewBackgroundType DefaultPreviewBackgroundType",summary:"Set or get the default scene background for the image that appears in\n     preview panes",since:5.11},{signature:"PreviewGeometryType DefaultPreviewGeometryType",summary:"Set or get the default geometry that appears in preview panes",since:5.11},{signature:"double DefaultPreviewSize",summary:"The default preview geometry size",since:5.11},{signature:"bool SmellsLikeGem",since:6},{signature:"bool SmellsLikeGlass",since:6},{signature:"bool SmellsLikeMetal",since:6},{signature:"bool SmellsLikePaint",since:6},{signature:"bool SmellsLikePlaster",since:6},{signature:"bool SmellsLikePlastic",since:6},{signature:"bool SmellsLikeTexturedGem",since:6},{signature:"bool SmellsLikeTexturedGlass",since:6},{signature:"bool SmellsLikeTexturedMetal",since:6},{signature:"bool SmellsLikeTexturedPaint",since:6},{signature:"bool SmellsLikeTexturedPlaster",since:6},{signature:"bool SmellsLikeTexturedPlastic",since:6}],methods:[{signature:"static RenderMaterial CreateBasicMaterial(Material material)",summary:"Constructs a new basic material from a Material.",since:5.1,returns:"A new basic material."},{signature:"static RenderMaterial CreateBasicMaterial(Material material,RhinoDoc doc)",since:6.4},{signature:"static RenderMaterial CreateImportedMaterial(Material material,RhinoDoc doc,bool bReference)",since:7},{signature:"double GetTextureAmountFromUsage(StandardChildSlots which)",since:6},{signature:"RenderTexture GetTextureFromUsage(StandardChildSlots which)",since:6},{signature:"bool GetTextureOnFromUsage(StandardChildSlots which)",since:6},{signature:"bool HandleTexturedValue(string slotname,TexturedValue<T> tc)",summary:"Handle a textured content field. Values will be read into an\n     instance of TexturedColor",since:6.12,returns:"True if reading the base value succeeded"},{signature:"DocObjects.Material SimulatedMaterial(bool isForDataOnly)",since:7},{signature:"DocObjects.Material SimulatedMaterial(TextureGeneration tg)",since:7},{signature:"Rhino.Render.PhysicallyBasedMaterial SimulatedPhysicallyBasedMaterial(TextureGeneration tg)",since:7},{signature:"DocObjects.Material SimulateMaterial(bool isForDataOnly)",summary:"Call this function to receive the simulation for a RenderMaterial used by the display and other rendering engines.",since:6,returns:"The simulation of the render material"},{signature:"void SimulateMaterial(Material simulation,bool isForDataOnly)",summary:"Override this function to provide a Rhino.DocObjects.Material definition for this material\n     to be used by other rendering engines including the display.",since:5.1},{signature:"void SimulateMaterial(Material simulation,TextureGeneration tg)",summary:"Override this function to provide a Rhino.DocObjects.Material definition for this material\n     to be used by other rendering engines including the display.",since:7},{signature:"string TextureChildSlotName(StandardChildSlots slot)",summary:"Override this function to provide information about which texture is used for\n     the standard (ie - defined in ON_Texture) texture channels.",since:5.1,returns:"The texture used for the channel."}]},{name:"Rhino.Render.RenderMaterial.BasicMaterialParameterNames",dataType:1,summary:"Parameter names for use in GetNamedParameter and SetNamedParameter with basic materials."},{name:"Rhino.Render.RenderMaterial.PhysicallyBased",dataType:1,summary:"Helper class with fields containing the names of fields available in our PBR implementation."},{name:"Rhino.Render.RenderMaterial.PhysicallyBased.ChildSlotNames",dataType:1,summary:"",properties:[{signature:"static string AmbientOcclusion",since:7},{signature:"static string Anisotropic",since:7},{signature:"static string AnisotropicRotation",since:7},{signature:"static string BaseColor",since:7},{signature:"static string Bump",since:7},{signature:"static string Clearcoat",since:7},{signature:"static string ClearcoatBump",since:7},{signature:"static string ClearcoatRoughness",since:7},{signature:"static string Displacement",since:7},{signature:"static string Emission",since:7},{signature:"static string Metallic",since:7},{signature:"static string Opacity",since:7},{signature:"static string OpacityIor",since:7},{signature:"static string OpacityRoughness",since:7},{signature:"static string Roughness",since:7},{signature:"static string Sheen",since:7},{signature:"static string SheenTint",since:7},{signature:"static string Specular",since:7},{signature:"static string SpecularTint",since:7},{signature:"static string Subsurface",since:7},{signature:"static string SubsurfaceScatteringColor",since:7},{signature:"static string SubsurfaceScatteringRadius",since:7}],methods:[{signature:"static string FromTextureType(TextureType tt)",since:7}]},{name:"Rhino.Render.RenderMaterial.PhysicallyBased.ParametersNames",dataType:1,summary:"",properties:[{signature:"static string AmbientOcclusion",since:7},{signature:"static string Anisotropic",since:7},{signature:"static string AnisotropicRotation",since:7},{signature:"static string BaseColor",since:7},{signature:"static string BRDF",since:7},{signature:"static string Bump",since:7},{signature:"static string Clearcoat",since:7},{signature:"static string ClearcoatBump",since:7},{signature:"static string ClearcoatRoughness",since:7},{signature:"static string Displacement",since:7},{signature:"static string Emission",since:7},{signature:"static string Metallic",since:7},{signature:"static string Opacity",since:7},{signature:"static string OpacityIor",since:7},{signature:"static string OpacityRoughness",since:7},{signature:"static string Roughness",since:7},{signature:"static string Sheen",since:7},{signature:"static string SheenTint",since:7},{signature:"static string Specular",since:7},{signature:"static string SpecularTint",since:7},{signature:"static string Subsurface",since:7},{signature:"static string SubsurfaceScatteringColor",since:7},{signature:"static string SubsurfaceScatteringRadius",since:7}]},{name:"Rhino.Render.RenderMaterial.PreviewBackgroundType",dataType:3,summary:"The default scene background for the image that appears in\n     preview panes"},{name:"Rhino.Render.RenderMaterial.PreviewGeometryType",dataType:3,summary:"Geometry that appears in preview panes"},{name:"Rhino.Render.RenderMaterial.StandardChildSlots",dataType:3,summary:"Defines enumerated constant values for use in  method."},{name:"Rhino.Render.RenderMaterialTable",dataType:1,summary:"",properties:[{signature:"int Count",since:5.7}],methods:[{signature:"bool Add(RenderMaterial c)",since:6},{signature:"void BeginChange(ChangeContexts changeContext)",since:7},{signature:"void EndChange()",since:7},{signature:"IEnumerator<RenderMaterial> GetEnumerator()",since:5.7},{signature:"bool Remove(RenderMaterial c)",since:6}]},{name:"Rhino.Render.RenderPanels",dataType:1,summary:"This class is used to extend the standard Render user interface",methods:[{signature:"static object FromRenderSessionId(PlugIn plugIn,Type panelType,Guid renderSessionId)",summary:"Get the instance of a render panel associated with a specific render\n     session, this is useful when it is necessary to update a control from a",since:5.11,returns:"Returns the custom panel object if found; otherwise None is returned."},{signature:"void RegisterPanel(PlugIn plugin,RenderPanelType renderPanelType,Type panelType,string caption,bool alwaysShow,bool initialShow)",summary:"Register custom render user interface with Rhino.  This should only be\n     done in .  Panels\n     registered after  is called\n     will be ignored.",since:5.11},{signature:"void RegisterPanelEx(PlugIn plugin,RenderPanelType renderPanelType,Type panelType,Guid renderEngineId,string caption,bool alwaysShow,bool initialShow)",summary:"Register custom render user interface with Rhino.  This should only be\n     done in .  Panels\n     registered after  is called\n     will be ignored.",since:7}]},{name:"Rhino.Render.RenderPanelType",dataType:3,summary:"Contains the custom user interfaces that may be provided"},{name:"Rhino.Render.RenderPipeline",dataType:1,summary:'Provides facilities to a render plug-in for integrating with the standard\n   Rhino render window. Also adds helper functions for processing a render\n   scene. This is the suggested class to use when integrating a renderer with\n   Rhino and maintaining a "standard" user interface that users will expect.',properties:[{signature:"int ConfirmationSeconds",summary:"Sets the number of seconds that need to elapse during rendering before\n     the user is asked if the rendered image should be saved.",since:5},{signature:"PlugIn PlugIn",since:5},{signature:"Guid RenderSessionId",summary:"Get the Id associated with this render session, this is useful when\n     looking up Rhino.Render.RenderPanels.",since:5.11}],methods:[{signature:"static Size RenderSize()",since:5},{signature:"static Size RenderSize(RhinoDoc doc)",summary:"Get the render size as specified in the ON_3dmRenderSettings. Will automatically return the correct size based on the ActiveView or custom settings.",since:6,returns:"The render size."},{signature:"static Size RenderSize(RhinoDoc doc,bool fromRenderSources)",summary:"Get the render size as specified in the ON_3dmRenderSettings, and from RenderSources when\n     fromRenderSources is true.",since:6,returns:"The render size."},{signature:"bool CloseWindow()",summary:"Closes the render window associated with this render instance.",since:5.11,returns:"Return True if successful or False if not."},{signature:"Rhino.Commands.Result CommandResult()",since:5},{signature:"void Dispose()",since:5},{signature:"RenderWindow GetRenderWindow()",summary:"Get the RenderWindow associated with this RenderPipeline instance.  This is virtual rather than abstract for V5 compat",since:5,returns:"RenderWindow if one exists, None otherwise (i.e. rendering\n     has already completed)."},{signature:"RenderWindow GetRenderWindow(bool withWireframeChannel)",summary:"As GetRenderWindow(), but if withWireframeChannel is true\n     the returned RenderWindow will have the channel added.",since:6,returns:"RenderWindow with wireframe channel enabled, or null\n     if no RenderWindow can be found (i.e. rendering has completed\n     already)"},{signature:"RenderWindow GetRenderWindow(bool withWireframeChannel,bool fromRenderViewSource)",summary:"As GetRenderWindow().\n     The parameter withWireframeChannel controls whether\n     the returned RenderWindow will have the channel added.\n     The parameter fromRenderViewSource controls from where\n     the RenderSize is queried.",since:6,returns:"RenderWindow if one exists, None otherwise (i.e. rendering\n     has already completed)."},{signature:"RenderWindow GetRenderWindowFromRenderViewSource(bool fromRenderViewSource)",summary:"Like GetRenderWindow(), but with the size for RenderWindow\n     set from RenderViewSources if fromRenderViewSource is set to true",since:6,returns:"RenderWindow if one exists, None otherwise (i.e. rendering\n     has already completed)."},{signature:"void PauseRendering()",summary:"Implement to pause the current render session",since:6},{signature:"RenderReturnCode Render()",summary:"Call this function to render the scene normally. The function returns when rendering is complete (or cancelled).",since:5,returns:"A code that explains how rendering completed."},{signature:"RenderReturnCode RenderWindow(RhinoView view,Rectangle rect,bool inWindow)",summary:"Call this function to render the scene in a view window. The function returns when rendering is complete (or cancelled).",since:5,returns:"A code that explains how rendering completed."},{signature:"void ResumeRendering()",summary:"Implement to resume current render session",since:6},{signature:"bool SaveImage(string fileName,bool saveAlpha)",summary:"Saves the rendered image to a file. Does not prompt the user in any way.",since:5.14},{signature:"void SetAsyncRenderContext(AsyncRenderContext aRC)",since:6},{signature:"bool SupportsPause()",summary:"Override and return True if the renderer supports pausing",since:6,returns:"True if pausing is supported, False otherwise"}]},{name:"Rhino.Render.RenderPipeline.RenderReturnCode",dataType:3,summary:""},{name:"Rhino.Render.RenderPlugInInfo",dataType:1,summary:"",properties:[{signature:"string Name",since:6},{signature:"Guid PlugInId",since:6}]},{name:"Rhino.Render.RenderPlugInList",dataType:1,summary:"",constructors:[{signature:"RenderPlugInList()",since:6}]},{name:"Rhino.Render.RenderPrimitive",dataType:1,summary:"",properties:[{signature:"BoundingBox BoundingBox",summary:"The bounding box for this primitive.",since:5.7},{signature:"Transform InstanceTransform",summary:"Instance reference transform or Identity if not an instance reference.",since:5.7},{signature:"RenderPrimitiveType PrimitiveType",summary:"Call this before extracting meshes if you support render primitives to\n     get the  of this mesh then call the\n     associated , , , or\n      method.  Calling the  property\n     will mesh the primitive and return a mesh always.",since:5.7},{signature:"RenderMaterial RenderMaterial",summary:"The  associated with this mesh or None if there is not one.",since:5.7},{signature:"RhinoObject RhinoObject",summary:"The Rhino object associated with this render primitive.",since:5.7}],methods:[{signature:"void Dispose()",since:5.7},{signature:"Mesh Mesh()",summary:"Returns the mesh associated with the object, this will mesh primitives\n     and always return a mesh.",since:5.7},{signature:"bool TryGetBox(Box box)",summary:"Call this method to get a  primitive for this mesh.  If this\n     meshes  is not a \n     then the box parameter is set to .",since:5.7,returns:"Returns True if  is  and\n     the box parameter was initialized otherwise returns false."},{signature:"bool TryGetCone(Cone cone,Plane truncation)",summary:"Call this method to get a  primitive for this mesh.  If this\n     meshes  is not a \n     then the cone parameter is set to  and the truncation\n     parameter is set to .",since:5.7,returns:"Returns True if  is  and\n     the cone and truncation parameters were initialized otherwise returns false."},{signature:"bool TryGetPlane(PlaneSurface plane)",summary:"Call this method to get a  primitive for this mesh.  If this\n     meshes  is not a \n     then the plane parameter is set to null.",since:5.7,returns:"Returns True if  is  and\n     the plane parameter was initialized otherwise returns false."},{signature:"bool TryGetSphere(Sphere sphere)",summary:"Call this method to get a sphere primitive for this mesh.  If this\n     meshes  is not a \n     then the sphere parameter is set to .",since:5.7,returns:"Returns True if  is  and\n     the sphere parameter was initialized otherwise returns false."}]},{name:"Rhino.Render.RenderPrimitiveList",dataType:1,summary:"",properties:[{signature:"int Count",summary:"Number of meshes in this list",since:5.7},{signature:"RhinoObject RhinoObject",summary:"The Rhino object associated with this list",since:5.7},{signature:"bool UseObjectsMappingChannels",summary:"Returns True if the texture mapping will be taken from the Rhino\n     object otherwise; the texture mapping will use the texture coordinates\n     on the mesh only.",since:5.7}],methods:[{signature:"void Add(Box box,RenderMaterial material)",summary:"Add primitive box and material.",since:5.7},{signature:"void Add(Cone cone,Plane truncation,RenderMaterial material)",summary:"Add primitive cone and material.",since:5.7},{signature:"void Add(Mesh mesh,RenderMaterial material)",summary:"Add mesh and material.",since:5.7},{signature:"void Add(Mesh mesh,RenderMaterial material,Transform t)",summary:"Add mesh and material.",since:6.12},{signature:"void Add(PlaneSurface plane,RenderMaterial material)",summary:"Add primitive plane and material.",since:5.7},{signature:"void Add(Sphere sphere,RenderMaterial material)",summary:"Add primitive sphere and material.",since:5.7},{signature:"bool AutoDeleteMaterialsOn()",since:6},{signature:"bool AutoDeleteMeshesOn()",since:6},{signature:"void Clear()",summary:"Remove all primitives from this list",since:5.7},{signature:"void ConvertMeshesToTriangles()",summary:"Convert mesh quad faces to triangle faces.",since:5.7},{signature:"void Dispose()",since:5.7},{signature:"Transform GetInstanceTransform(int index)",since:6},{signature:"RenderMaterial Material(int index)",summary:"Call this method to get the render material associated with the mesh at\n     the specified index.  Will return None if there is no\n     material associated with the requested mesh.",since:5.7,returns:"If there is a render material associated at the requested index then\n     the material is returned otherwise None is returned."},{signature:"Mesh Mesh(int index)",summary:"Get the mesh for the primitive at the specified index. If the item at\n     this index is a primitive type other than a mesh then it mesh\n     representation is returned.",since:5.7,returns:"Returns the mesh for the primitive at the specified index. If the item\n     at this index is a primitive type other than a mesh then it mesh\n     representation is returned."},{signature:"Mesh MeshInstance(int index,Transform instance_transform)",summary:"Get the mesh for the primitive at the specified index. If the item at\n     this index is a primitive type other than a mesh then it mesh\n     representation is returned.",since:6.12,returns:"Returns the mesh for the primitive at the specified index. If the item\n     at this index is a primitive type other than a mesh then it mesh\n     representation is returned."},{signature:"RenderPrimitiveType PrimitiveType(int index)",summary:"Type of primitive object at this index.",since:5.7,returns:"Primitive type of the item at this index."},{signature:"void SetInstanceTransform(int index,Transform xform)",since:6},{signature:"RenderMaterial[] ToMaterialArray()",summary:"Call this method to see if there are any RenderMaterials associated\n     with the meshes.  Each primitive can optionally have a RenderMaterial\n     associated with it, if the RenderMaterial is None then check for a\n     RhinoObject.RenderMaterial.",since:5.7,returns:"Return an array that of the same size as the ToMeshArray() containing\n     the RenderMaterial associated with the mesh, may contain None entries\n     if there is no RenderMaterial associated with the custom mesh."},{signature:"Mesh[] ToMeshArray()",summary:"Call this method to get a array of meshes, all primitives will get\n     meshed and the meshes will get included in the returned array.",since:5.7,returns:"Return an array of meshes from this list, this will convert all\n     primitives to meshes."},{signature:"bool TryGetBox(int index,Box box)",summary:"Call this method to get a box at the specified index.",since:5.7,returns:"Return True if the index is in range and the primitive at the requested\n     index is a box otherwise returns false."},{signature:"bool TryGetCone(int index,Cone cone,Plane truncation)",summary:"Call this method to get a box at the specified index.",since:5.7,returns:"Return True if the index is in range and the primitive at the requested\n     index is a box otherwise returns false."},{signature:"bool TryGetPlane(int index,PlaneSurface plane)",summary:"Call this method to get a box at the specified index.",since:5.7,returns:"Return True if the index is in range and the primitive at the requested\n     index is a plane otherwise returns false."},{signature:"bool TryGetSphere(int index,Sphere sphere)",summary:"Call this method to get a box at the specified index.",since:5.7,returns:"Return True if the index is in range and the primitive at the requested\n     index is a box otherwise returns false."}]},{name:"Rhino.Render.RenderPrimitiveType",dataType:3,summary:""},{name:"Rhino.Render.RenderPropertyChangedEvent",dataType:1,summary:"Used by Rhino.Render object property value has changed events.",properties:[{signature:"int Context",summary:"Optional argument which may specify the property being modified.",since:5.1},{signature:"RhinoDoc Document",summary:"The document triggering the event.",since:5.1}]},{name:"Rhino.Render.RenderSettings",dataType:1,summary:"Contains settings used in rendering.",constructors:[{signature:"RenderSettings()",summary:"Initialize a new instance of the RenderSettings class.",since:5},{signature:"RenderSettings(RenderSettings source)",summary:"Initialize new instance of the RenderSettings class.",since:6}],properties:[{signature:"Color AmbientLight",summary:"Gets or sets the ambient light color used in rendering.",since:5},{signature:"AntialiasLevel AntialiasLevel",summary:"Gets or sets antialias level, used for render quality",since:5},{signature:"Color BackgroundColorBottom",summary:"Gets or sets the background bottom color used in rendering.",since:5},{signature:"Color BackgroundColorTop",summary:"Gets or sets the background top color used in rendering.\n     Sets also the background color if a solid background color is set.",since:5},{signature:"BackgroundStyle BackgroundStyle",summary:"How the viewport's backgroun should be filled.",since:5},{signature:"bool DepthCue",summary:"Gets or sets a value indicating whether to render using depth cues.\n     These are clues to help the perception of position and orientation of objects in the image.",since:5},{signature:"Dithering Dithering",summary:"Get the document dithering interface",since:6},{signature:"bool FlatShade",summary:"Gets or sets a value indicating whether to render using flat shading.",since:5},{signature:"double ImageDpi",summary:"Number of dots/inch (dots=pixels) to use when printing and saving\n     bitmaps. The default is 72.0 dots/inch.",since:5.11},{signature:"Size ImageSize",summary:"Gets or sets a value indicating the size of the rendering result if\n     UseViewportSize is set to false.  If UseViewportSize is set to true,\n     then this value is ignored.",since:5},{signature:"UnitSystem ImageUnitSystem",summary:"unit system to use when converting image pixel size and dpi information\n     into a print size.  Default = inches",since:5.11},{signature:"LinearWorkflow LinearWorkflow",summary:"Get the document linear workflow interface",since:6},{signature:"string NamedView",summary:"Get or set the given named view",since:6.1},{signature:"bool RenderAnnotations",summary:"Gets or sets a value indicating whether to instruct the rendering engine to show annotations,\n     such as linear dimensions or angular dimensions.",since:5},{signature:"bool RenderBackfaces",summary:"Gets or sets a value indicating whether to render back faces.",since:5},{signature:"bool RenderCurves",summary:"Gets or sets a value indicating whether to instruct the rendering engine to show curves.",since:5},{signature:"bool RenderIsoparams",summary:"Gets or sets a value indicating whether to instruct the rendering engine to show isocurves.",since:5},{signature:"bool RenderMeshEdges",summary:"Gets or sets a value indicating whether to instruct the rendering engine to show mesh edges.",since:5},{signature:"bool RenderPoints",summary:"Gets or sets a value indicating whether to instruct the rendering engine to show points.",since:5},{signature:"RenderingSources RenderSource",summary:"Gets or sets the render source  enumeration.",since:6.1},{signature:"bool ScaleBackgroundToFit",summary:"Gets or sets a value indicating whether to scale the wallpaper in the\n     background or not. This is meaningful only if the viewport has a wallpaper\n     and render settings are set to render Wallpaper into the background.",since:6},{signature:"int ShadowmapLevel",summary:"0=none, 1=normal, 2=best.",since:5},{signature:"string Snapshot",summary:"Set os get the given snapshot view",since:6.1},{signature:"string SpecificViewport",summary:"Set or get the given specific viewport",since:6.1},{signature:"bool TransparentBackground",summary:"Gets or sets whether rendering should be done with transparent background.",since:6},{signature:"bool UseHiddenLights",summary:"Gets or sets a value indicating whether to render using lights that are on layers that are off.",since:5},{signature:"bool UseViewportSize",summary:"Gets or sets a value indicating whether to use the resolution of the\n     viewport being rendered or ImageSize when rendering",since:5}]},{name:"Rhino.Render.RenderSettings.RenderingSources",dataType:3,summary:"Rendering source (render directly from a NamedView or Snapshot)"},{name:"Rhino.Render.RenderSourceView",dataType:1,summary:"Helper class to get the correct view from the Render View Source settings.\n   \n   An instance of this class is supposed to be used with the using() {} construct.",constructors:[{signature:"RenderSourceView(RhinoDoc doc)",summary:"Create a new RenderSourceView for the given doc.\n     \n     Note that this should be done with using(var rsv = new RenderSourceView(doc)) {}\n     \n     If the RenderSettings have the source view set to for instance a SnapShot this\n     construct will ensure that the (active) view is set to the correct snapshot, and\n     reverted back to the original once this instance goes out of scope.",since:6}],methods:[{signature:"void Dispose()",since:6},{signature:"Rhino.DocObjects.ViewInfo GetViewInfo()",summary:"Get the ViewInfo as specified by the render source view settings.",since:6,returns:"ViewInfo if view was found, None otherwise"}]},{name:"Rhino.Render.RenderTabs",dataType:1,summary:"",methods:[{signature:"static object FromRenderSessionId(PlugIn plugIn,Type tabType,Guid renderSessionId)",summary:"Get the instance of a render tab associated with a specific render\n     session, this is useful when it is necessary to update a control from a",since:5.11,returns:"Returns the custom tab object if found; otherwise None is returned."},{signature:"static Guid SessionIdFromTab(object tab)",summary:"Get the session Id that created the specified tab object.",since:5.11},{signature:"void RegisterTab(PlugIn plugin,Type tabType,string caption,Icon icon)",summary:'Register custom render user interface with Rhino.  This should only be\n     done in .  Panels\n     registered after  is called\n     will be ignored.  If the class includes a public method "void DoHelp()"\n     the method will get called when F1 is pressed and the custom tab is active.',since:5.11},{signature:"void RegisterTabEx(PlugIn plugin,Type tabType,Guid renderEngineId,string caption,Icon icon)",since:7}]},{name:"Rhino.Render.RenderTexture",dataType:1,summary:"",properties:[{signature:"Transform LocalMappingTransform",summary:"Gets the transformation that can be applied to the UVW vector to convert it\n     from normalized texture space into locally mapped space (ie - with repeat,\n     offset and rotation applied.)",since:5.1},{signature:"uint RenderHashWithoutLocalMapping",summary:"Render hash for texture excluding local mapping.",since:6}],methods:[{signature:"static bool GetEnvironmentMappingProjection(TextureEnvironmentMappingMode mode,Vector3d reflectionVector,float u,float v)",since:5.7},{signature:"static Point3d GetWcsBoxMapping(Point3d worldXyz,Vector3d normal)",since:5.7},{signature:"static RenderTexture NewBitmapTexture(Bitmap bitmap,RhinoDoc doc)",summary:"Constructs a new basic texture from a Bitmap.",since:7,returns:"A new render texture."},{signature:"static RenderTexture NewBitmapTexture(SimulatedTexture texture)",summary:"Constructs a new basic texture from a SimulatedTexture.",since:5.3,returns:"A new render texture."},{signature:"static RenderTexture NewBitmapTexture(SimulatedTexture texture,RhinoDoc doc)",summary:"Constructs a new basic texture from a SimulatedTexture.",since:6.4,returns:"A new render texture."},{signature:"TextureEvaluator CreateEvaluator()",summary:"Constructs a texture evaluator. This is an independent lightweight object\n     capable of evaluating texture color throughout uvw space. May be called\n     from within a rendering shade pipeline.",since:5.1,returns:"A texture evaluator instance."},{signature:"TextureEvaluator CreateEvaluator(TextureEvaluatorFlags evaluatorFlags)",summary:"Constructs a texture evaluator. This is an independent lightweight object\n     capable of evaluating texture color throughout uvw space. May be called\n     from within a rendering shade pipeline.",since:6,returns:"A texture evaluator instance."},{signature:"bool GetDisplayInViewport()",since:5.7},{signature:"TextureEnvironmentMappingMode GetEnvironmentMappingMode()",since:5.7},{signature:"TextureEnvironmentMappingMode GetInternalEnvironmentMappingMode()",since:5.7},{signature:"eLocalMappingType GetLocalMappingType()",since:6.3},{signature:"int GetMappingChannel()",since:5.7},{signature:"Vector3d GetOffset()",summary:"Get offset value across UVW space. If the projection type is WCS or\n     other type specified in model units, then this is the offset in meters.",since:5.7},{signature:"bool GetOffsetLocked()",since:5.7},{signature:"bool GetPreviewIn3D()",since:5.7},{signature:"bool GetPreviewLocalMapping()",since:5.7},{signature:"TextureProjectionMode GetProjectionMode()",since:5.7},{signature:"Vector3d GetRepeat()",summary:"Get repeat value across UVW space. If the projection type is WCS or\n     other type specified in model units, then this is the repeat across 1\n     meter of the model.",since:5.7},{signature:"bool GetRepeatLocked()",since:5.7},{signature:"Vector3d GetRotation()",since:5.7},{signature:"TextureWrapType GetWrapType()",since:5.7},{signature:"void GraphInfo(TextureGraphInfo tgi)",since:6.3},{signature:"bool IsHdrCapable()",summary:"Return True if the texture is HDR capable.\n     \n     When creating a custom RenderTexture implementation that is HDR capable\n     set the appropriate property on the CustomRenderContentAttribute decorator on that clas.",since:5.7},{signature:"bool IsImageBased()",summary:"Query if the texture is image based.\n    \n     When creating a custom RenderTexture implementation of an image-based texture\n     set the appropriate property on the CustomRenderContentAttribute decorator on that class.\n     \n     Do not override this function",since:6,returns:"True if the texture is image-based."},{signature:"bool IsLinear()",summary:"Return True if the texture color data is linear.\n      \n      NOTE: this function is marked as virtual, but the correct way to make a custom RenderTexture linear is by\n      setting the correct property for the CustomRenderContentAttribute decorator on the class.",since:6},{signature:"bool IsNormalMap()",summary:"Return True if the texture is a normalmap.\n     \n     When creating a custom RenderTexture implementation of a normal map\n     set the appropriate property on the CustomRenderContentAttribute decorator on that clas.",since:6.16},{signature:"void PixelSize(int u,int v,int w)",summary:"Get the texture dimensions for the RenderTexture.",since:6},{signature:"bool SaveAsImage(string FullPath,int width,int height,int depth)",summary:"Save texture as image",since:6.15,returns:"returns True if file was saved, otherwise false"},{signature:"void SetDisplayInViewport(bool value)",since:6},{signature:"void SetDisplayInViewport(bool value,ChangeContexts changeContext)",since:5.7},{signature:"void SetEnvironmentMappingMode(TextureEnvironmentMappingMode value)",since:6},{signature:"void SetEnvironmentMappingMode(TextureEnvironmentMappingMode value,ChangeContexts changeContext)",since:5.7},{signature:"void SetGraphInfo(TextureGraphInfo tgi)",since:6.3},{signature:"void SetMappingChannel(int value,ChangeContexts changeContext)",since:5.7},{signature:"void SetOffset(Vector3d value,ChangeContexts changeContext)",summary:"Set offset value across UVW space. If the projection type is WCS or\n     other type specified in model units, then this is the offset in meters.",since:5.7},{signature:"void SetOffsetLocked(bool value,ChangeContexts changeContext)",since:5.7},{signature:"void SetPreviewIn3D(bool value,ChangeContexts changeContext)",since:5.7},{signature:"void SetPreviewLocalMapping(bool value)",since:6},{signature:"void SetPreviewLocalMapping(bool value,ChangeContexts changeContext)",since:5.7},{signature:"void SetProjectionMode(TextureProjectionMode value,ChangeContexts changeContext)",since:5.7},{signature:"void SetRepeat(Vector3d value,ChangeContexts changeContext)",summary:"Set repeat value across UVW space. If the projection type is WCS or\n     other type specified in model units, then this is the repeat across 1\n     meter of the model.",since:5.7},{signature:"void SetRepeatLocked(bool value,ChangeContexts changeContext)",since:5.7},{signature:"void SetRotation(Vector3d value,ChangeContexts changeContext)",since:5.7},{signature:"void SetWrapType(TextureWrapType value,ChangeContexts changeContext)",since:5.7},{signature:"SimulatedTexture SimulatedTexture(TextureGeneration tg,int size,RhinoObject obj)",since:6},{signature:"void SimulateTexture(SimulatedTexture simulation,bool isForDataOnly)",since:5.1},{signature:"void SimulateTexture(SimulatedTexture simulation,TextureGeneration tg,int size,RhinoObject obj)",since:6}]},{name:"Rhino.Render.RenderTexture.eLocalMappingType",dataType:3,summary:""},{name:"Rhino.Render.RenderTexture.TextureEvaluatorFlags",dataType:3,summary:""},{name:"Rhino.Render.RenderTexture.TextureGeneration",dataType:3,summary:""},{name:"Rhino.Render.RenderTextureTable",dataType:1,summary:"",properties:[{signature:"int Count",since:5.7}],methods:[{signature:"bool Add(RenderTexture c)",since:6},{signature:"void BeginChange(ChangeContexts changeContext)",since:7},{signature:"void EndChange()",since:7},{signature:"IEnumerator<RenderTexture> GetEnumerator()",since:5.7},{signature:"bool Remove(RenderTexture c)",since:6}]},{name:"Rhino.Render.RenderWindow",dataType:1,summary:"",properties:[{signature:"Guid SessionId",since:5.11}],methods:[{signature:"static Guid ChannelId(StandardChannels ch)",since:5},{signature:"static RenderWindow Create(Size szSize)",since:6},{signature:"static RenderWindow FromSessionId(Guid sessionId)",since:5.11},{signature:"bool AddChannel(StandardChannels channel)",summary:"Add a channel to the frame buffer in addition to the fixed Red, Green, Blue and Alpha channels.",since:5,returns:"If the channel existed then True is returned otherwise; returns True if the channel was added or False if not."},{signature:"bool AddWireframeChannel(RhinoDoc doc,ViewportInfo viewport,Size size,Rectangle region)",summary:"A wireframe channel will not be added if none of the document properties settings\n     indicate that one is needed. In other words, Rhino will not generate an empty wireframe channel\n     just for the fun of it.",since:5,returns:"Returns True if the wireframe channel was successfully added."},{signature:"void Dispose()",since:6},{signature:"void EndAsyncRender(RenderSuccessCode successCode)",summary:"Must be called when an asynchronous render has finished or ended for any reason.",since:6},{signature:"ImageAdjust GetAdjust()",summary:"Get an ImageAdjust instance containing current image adjusting settings\n     for this RenderWindow",since:6,returns:"ImageAdjust"},{signature:"Bitmap GetBitmap()",since:6},{signature:"void Invalidate()",summary:"Invalidate the entire view window so that the pixels get painted.",since:5},{signature:"void InvalidateArea(Rectangle rect)",since:5},{signature:"Channel OpenChannel(StandardChannels id)",since:5},{signature:"void SaveDibAsBitmap(string filename)",summary:"Save current Dib of RenderWindow as file\n     Helper function for debugging purposes.",since:6},{signature:"void SaveRenderImageAs(string filename,bool saveAlpha)",summary:"Like RenderWindow.SaveRenderImageAs(string,Guid,bool), but with\n   Guid set to Guid.Empty.",since:6},{signature:"void SaveRenderImageAs(string filename,Guid renderEngineGuid,bool saveAlpha)",summary:"Save current RenderWindow contents as\n   an image file with the given name. The\n   filetype will be determine. \n   \n   Pass in render engine Guid if an engine\n   implements saving to a format that is not\n   supported by Rhino. Guid.Empty if there is no need for that.",since:6},{signature:"void SetAdjust(ImageAdjust imageAdjust)",summary:"Set new ImageAdjust to use. An ImageAdjust instance can be obtained by first\n     querying for one using GetAdjust()",since:6},{signature:"void SetProgress(string text,float progress)",summary:"Accepts a rendering progress value to inform the user of the rendering advances.",since:5},{signature:"void SetRGBAChannelColors(Rectangle rectangle,Color4f[] colors)",summary:"Call this method to open the RenderWindow.StandardChannels.RGBA channel and set a block of color values",since:5},{signature:"void SetRGBAChannelColors(Size size,Color4f[] colors)",summary:"Call this method to open the RenderWindow.StandardChannels.RGBA channel and set a block of color values",since:5},{signature:"void SetSize(Size size)",since:5},{signature:"void SetView(ViewInfo view)",since:6},{signature:"System.Drawing.Size Size()",since:5}],events:[{signature:"static Cloned",since:5.11}]},{name:"Rhino.Render.RenderWindow.Channel",dataType:1,summary:"",methods:[{signature:"void AddValue(int x,int y,Color4f value)",summary:"Add value to existing values at point x, y.\n       If x or y are out of range, the function will fail and may crash Rhino.",since:6},{signature:"void Dispose()",since:5},{signature:"int PixelSize()",summary:"Returns the size of the data in one pixel in the channel. For RDK standard channels, this value is always sizeof(float). \n       For the special chanRGBA collective channel,\n       this value is 4 * sizeof(float).",since:5,returns:"The size of a pixel."},{signature:"void SetValue(int x,int y,Color4f value)",summary:"If x or y are out of range, the function will fail and may crash Rhino.",since:5},{signature:"void SetValue(int x,int y,float value)",summary:"If x or y are out of range, the function will fail and may crash Rhino.",since:5},{signature:"void SetValues(Rectangle rectangle,Size bufferResolution,PixelBuffer colorBuffer)",summary:"Set a pixel buffer",since:6}]},{name:"Rhino.Render.RenderWindow.ImageAdjust",dataType:1,summary:"Class to set image adjusting settings to a RenderWindow. This can't be\n     directly created. Instead, one should use RenderWindow.GetAdjust() to\n     get an ImageAdjust instance that can be modified, then passed into\n     RenderWindow.SetAdjust() to update image adjusting settings.1",properties:[{signature:"Methods Dither",summary:"Set the Dithering method to use when adjusting the RenderWindow\n       content.",since:6},{signature:"float Gamma",summary:"Set the gamma value. The inverse of this will be used to apply\n       gamma correction to the RenderWindow RGBA channel when necessary.",since:6}]},{name:"Rhino.Render.RenderWindow.RenderSuccessCode",dataType:3,summary:""},{name:"Rhino.Render.RenderWindow.StandardChannels",dataType:3,summary:""},{name:"Rhino.Render.RenderWindowClonedEventArgs",dataType:1,summary:"",properties:[{signature:"RenderWindow NewRenderWindow",since:5.11},{signature:"Guid NewSessionId",since:5.11},{signature:"RenderWindow OldRenderWindow",since:5.11},{signature:"Guid OldSessionId",since:5.11}]},{name:"Rhino.Render.SceneServerData",dataType:1,summary:"The Scene Server Data used by the PreviewSceneServer",constructors:[{signature:"SceneServerData(PreviewGeometry geo,PreviewBackground back,PreviewLighting light,SceneServerDataUsage usage)",summary:"Constructor for SceneServerData",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"The CppPointer of SceneServerData",since:6}],methods:[{signature:"void Dispose()",summary:"Dispose for SceneServerData",since:6}]},{name:"Rhino.Render.SceneServerDataUsage",dataType:3,summary:"SceneServerData Usage (Synchronous or Asynchronous)"},{name:"Rhino.Render.SimulatedEnvironment",dataType:1,summary:"",constructors:[{signature:"SimulatedEnvironment()",since:5.1}],properties:[{signature:"Color BackgroundColor",since:5.1},{signature:"SimulatedTexture BackgroundImage",since:5.1},{signature:"BackgroundProjections BackgroundProjection",since:5.1}],methods:[{signature:"static BackgroundProjections ProjectionFromString(String projection)",since:5.1},{signature:"static string StringFromProjection(BackgroundProjections projection)",since:5.1},{signature:"IntPtr ConstPointer()",since:5.1},{signature:"void Dispose()",since:5.1}]},{name:"Rhino.Render.SimulatedEnvironment.BackgroundProjections",dataType:3,summary:""},{name:"Rhino.Render.SimulatedTexture",dataType:1,summary:"",constructors:[{signature:"SimulatedTexture()",since:5.1}],properties:[{signature:"static int BitmapSize",since:5.1},{signature:"String Filename",since:5.1},{signature:"bool Filtered",since:5.1},{signature:"bool HasTransparentColor",since:5.1},{signature:"Transform LocalMappingTransform",since:5.1},{signature:"int MappingChannel",since:5.1},{signature:"Vector2d Offset",since:5.1},{signature:"String OriginalFilename",since:5.1},{signature:"ProjectionModes ProjectionMode",since:5.1},{signature:"Vector2d Repeat",since:5.1},{signature:"bool Repeating",since:5.1},{signature:"double Rotation",since:5.1},{signature:"Color4f TransparentColor",since:5.1},{signature:"double TransparentColorSensitivity",since:5.1}],methods:[{signature:"IntPtr ConstPointer()",since:5.1},{signature:"void Dispose()",since:5.1},{signature:"double MetersToUnits(double units)",since:5.1},{signature:"double MetersToUnits(RhinoDoc doc,double units)",since:6},{signature:"void SetMappingChannelAndProjectionMode(ProjectionModes pm,int mappingChannel,EnvironmentMappingModes emm)",since:6},{signature:"Rhino.DocObjects.Texture Texture()",since:5.1},{signature:"double UnitsToMeters(double units)",since:5.1},{signature:"double UnitsToMeters(RhinoDoc doc,double units)",since:6}]},{name:"Rhino.Render.SimulatedTexture.EnvironmentMappingModes",dataType:3,summary:""},{name:"Rhino.Render.SimulatedTexture.ProjectionModes",dataType:3,summary:""},{name:"Rhino.Render.Skylight",dataType:1,summary:"",constructors:[{signature:"Skylight()",summary:"Create an utility object not associated with any document",since:6},{signature:"Skylight(Skylight src)",summary:"Create an utility object not associated with any document from another object",since:6}],properties:[{signature:"Guid CustomEnvironment",since:6},{signature:"bool CustomEnvironmentOn",since:6},{signature:"bool Enabled",since:6},{signature:"double ShadowIntensity",since:6}],methods:[{signature:"void CopyFrom(FreeFloatingBase src)",since:6}],events:[{signature:"static Changed",summary:"This event is raised when a Skylight property value is changed.",since:6}]},{name:"Rhino.Render.Sun",dataType:1,summary:"Represents the Sun on a little portion of Earth.",constructors:[{signature:"Sun()",summary:"Create a non-document controlled Sun",since:5}],properties:[{signature:"double Altitude",summary:"Get the altitude for the sun. To set use SetPosition(azimuth, altitude)",since:5},{signature:"double Azimuth",summary:"Get the azimuth for the sun. To set use SetPosition(azimuth, altitude)",since:5},{signature:"bool DaylightSaving",summary:"Daylight savings time",since:5.1},{signature:"int DaylightSavingMinutes",summary:"Daylight saving minutes",since:6},{signature:"bool Enabled",summary:"Turn the sun on/off in this document.",since:5},{signature:"double Intensity",summary:"Sun intensity.",since:7},{signature:"double Latitude",since:5},{signature:"Light Light",summary:"Get a Light which represents the sun. If manual control is in effect, no sun calculation\n     is performed; the function uses the values last used in calls to Azimuth, Altitude\n     or Vector. If manual control is not in effect, the observer's position, date, time,\n     time zone and daylight saving values are used to calculate the position of the sun.",since:6},{signature:"double Longitude",since:5},{signature:"bool ManualControl",summary:"Set angles directly or use place/date/time",since:5.1},{signature:"double North",summary:"Angle in degrees on world X-Y plane that should be considered north in the model. Angle is\n     measured starting at X-Axis and travels counterclockwise. Y-Axis would be a north angle of 90\n     degrees.",since:5},{signature:"bool SkylightOn",summary:"Turn skylight on or off.",since:5.1},{signature:"double TimeZone",summary:"Measured in hours += UTC",since:5.1},{signature:"Vector3d Vector",since:5}],methods:[{signature:"static double AltitudeFromValues(double latitude,double longitude,double timezoneHours,int daylightMinutes,DateTime when,double hours,bool fast)",since:6},{signature:"static System.Drawing.Color ColorFromAltitude(double altitudeDegrees)",summary:"Get sun color based on altitude.",since:6,returns:"Returns color for altitude."},{signature:"static bool Here(double latitude,double longitude)",since:6},{signature:"static double JulianDay(double timezoneHours,int daylightMinutes,DateTime when,double hours)",since:6},{signature:"static Geometry.Vector3d SunDirection(double latitude,double longitude,DateTime when)",since:5},{signature:"static double TwilightZone()",since:6},{signature:"void CopyFrom(FreeFloatingBase src)",since:6},{signature:"void Dispose()",since:5},{signature:"DateTime GetDateTime(DateTimeKind kind)",since:5},{signature:"void SetDateTime(DateTime time,DateTimeKind kind)",since:6},{signature:"void SetPosition(DateTime when,double latitudeDegrees,double longitudeDegrees)",summary:"Sets position of the sun based on physical location and time.",since:5},{signature:"void SetPosition(double azimuthDegrees,double altitudeDegrees)",summary:"Sets position of the Sun based on azimuth and altitude values.\n     Using this function will also set sun to manual.",since:5},{signature:"void ShowDialog()",summary:"Show the tabbed sun dialog.",since:5}],events:[{signature:"static Changed",summary:"This event is raised when a Sun property value is changed.",since:5.1}]},{name:"Rhino.Render.SupportOptions",dataType:1,summary:"",methods:[{signature:"static bool AlwaysShowSunPreview()",since:6},{signature:"static int AutoSaveKeepAmount()",since:6},{signature:"static bool AutoSaveRenderings()",since:6},{signature:"static bool CheckSupportFilesBeforeRendering()",since:6},{signature:"static bool CombineEditors()",since:6},{signature:"static string CustomLibraryPath()",since:6},{signature:"static string CustomPaths()",since:6},{signature:"static int DarkPreviewCheckerColor()",since:6},{signature:"static bool EnablePreviewJobLog()",since:6},{signature:"static bool HarvestContentParameters()",since:6},{signature:"static int LabelFormatLoc()",since:6},{signature:"static int LabelFormatUtc()",since:6},{signature:"static string LastNavigatedLocation()",since:6.1},{signature:"static RdkInitialLocation LibrariesInitialLocation()",since:6},{signature:"static string LibrariesInitialLocationCustomFolder()",since:6},{signature:"static int LightPreviewCheckerColor()",since:6},{signature:"static int MaxPreviewCacheMB()",since:6},{signature:"static int MaxPreviewSeconds()",since:6},{signature:"static bool MultithreadedTextureEvaluation()",since:6},{signature:"static bool PreferNativeRenderer()",since:6},{signature:"static string PreferredUnpackFolder()",since:6},{signature:"static bool PreviewCustomRenderMeshes()",since:6},{signature:"static void SetAlwaysShowSunPreview(bool b)",since:6},{signature:"static void SetAutoSaveKeepAmount(int value)",since:6},{signature:"static void SetAutoSaveRenderings(bool b)",since:6},{signature:"static void SetCheckSupportFilesBeforeRendering(bool b)",since:6},{signature:"static void SetCombineEditors(bool b)",since:6},{signature:"static void SetCustomLibraryPath(string path)",since:6},{signature:"static void SetCustomPaths(string path)",since:6},{signature:"static void SetHarvestContentParameters(bool b)",since:6},{signature:"static void SetLabelFormatLoc(int value)",since:6},{signature:"static void SetLabelFormatUtc(int value)",since:6},{signature:"static void SetLastNavigatedLocation(string folder)",since:6.1},{signature:"static void SetLibrariesInitialLocation(RdkInitialLocation l)",since:6},{signature:"static void SetLibrariesInitialLocationCustomFolder(string path)",since:6},{signature:"static void SetMultithreadedTextureEvaluation(bool b)",since:6},{signature:"static void SetPreferNativeRenderer(bool b)",since:6},{signature:"static void SetPreferredUnpackFolder(string path)",since:6},{signature:"static void SetPreviewCustomRenderMeshes(bool b)",since:6},{signature:"static void SetShowCustom(bool b)",since:6},{signature:"static void SetShowDetailsPanel(bool b)",since:6},{signature:"static void SetShowDocuments(bool b)",since:6},{signature:"static void SetShowRenderContent(bool b)",since:6},{signature:"static void SetSupportSharedUIs(bool b)",since:6},{signature:"static void SetTextureSize(RdkTextureSize size,bool bSendEvent)",since:6},{signature:"static void SetUseDefaultLibraryPath(bool b)",since:6},{signature:"static void SetUsePreviewCache(bool b)",since:6},{signature:"static void SetUseQuickInitialPreview(bool b)",since:6},{signature:"static bool ShowCustom()",since:6},{signature:"static bool ShowDetailsPanel()",since:6},{signature:"static bool ShowDocuments()",since:6},{signature:"static bool ShowRenderContent()",since:6},{signature:"static bool SupportSharedUIs()",since:6},{signature:"static bool SupportSharedUIsNoCache()",since:6},{signature:"static int TextureSize()",since:6},{signature:"static bool UseDefaultLibraryPath()",since:6},{signature:"static bool UsePreview()",since:6},{signature:"static bool UsePreviewCache()",since:6},{signature:"static bool UseQuickInitialPreview()",since:6},{signature:"static bool UseRenderedPreview()",since:6}]},{name:"Rhino.Render.SupportOptions.RdkInitialLocation",dataType:3,summary:""},{name:"Rhino.Render.SupportOptions.RdkTextureSize",dataType:3,summary:""},{name:"Rhino.Render.TexturedColor",dataType:1,summary:"Color4f specialization of TexturedValue.",constructors:[{signature:"TexturedColor(string name,Color4f value,bool on,float amount)",since:6.12}]},{name:"Rhino.Render.TexturedFloat",dataType:1,summary:"float specialization of TexturedValue.",constructors:[{signature:"TexturedFloat(string name,float value,bool on,float amount)",since:6.12}]},{name:"Rhino.Render.TexturedValue",dataType:1,summary:"Generic class to help holding on to related values. This can be\n   used to get data from textured content fields with the\n   HandleTexturedValue function.",constructors:[{signature:"TexturedValue(string name,T value,bool on,float amount)"}]},{name:"Rhino.Render.TextureEnvironmentMappingMode",dataType:3,summary:""},{name:"Rhino.Render.TextureEvaluator",dataType:1,summary:"This is the interface to a lightweight object capable of evaluating texture color throughout uvw space.  Derive from this class to create your own texture evaluator to return from a custom RenderTexture.",methods:[{signature:"static void FreeByteArray(IntPtr p)",since:7},{signature:"static byte GetByteArrayValue(IntPtr p,int offset)",since:7},{signature:"static IntPtr NewByteArray(int width,int height)",since:7},{signature:"static void Rdk_TextureEvaluator_ApplyGamma(IntPtr p,int width,int height,float gamma)",since:7},{signature:"static void SetByteArrayValue(IntPtr p,int offset,byte value)",since:7},{signature:"bool CanBeDumpedToBytes(int width,int height)",summary:'Fast access to bitmap evaluator for Cycles - supply size (which you will probably have received from CRhRdkTexture::PixelSize) to see\n     if the data can be extracted direct to a width*height*4 array of unsigned chars.\n     This is implemented by EVF(L"CanBeDumpedToBytes", ON_2iSize*) != nullptr;',since:7,returns:"True if the evaluator returned a valid color.  Otherwise false."},{signature:"void Dispose()",summary:"For Dispose pattern",since:5.1},{signature:"void DumpToBytes(int width,int height,IntPtr buffer)",summary:'Fast access to bitmap evaluator for Cycles - supply size (which you will probably have received from CRhRdkTexture::PixelSize) to see\n     if the data can be extracted direct to a width*height*4 array of unsigned chars.\n     This is implemented by EVF(L"CanBeDumpedToBytes", ON_2iSize*) != nullptr;',since:7,returns:"True if the evaluator returned a valid color.  Otherwise false."},{signature:"Display.Color4f GetColor(Point3d uvw,Vector3d duvwdx,Vector3d duvwdy)",summary:'Get the color of the texture at a particular point in uvw space.\n   May be called from within a rendering shade pipeline.\n   note For ray differentials see Pharr Humphreys, "Physically Based Rendering", chapter 11.',since:5.1,returns:"The texture color at this point in UV space."},{signature:"bool GetColor(Point3d uvw,Vector3d duvwdx,Vector3d duvwdy,Color4f color)",summary:"Optimized version of GetColor for callers.  Much faster in the case of a native (C++) evaluator.",since:7,returns:"True if the evaluator returned a valid color.  Otherwise false."},{signature:"bool Initialize()",summary:"Call this function before calling GetColor for the first time. Ideally, this should\n   be on the main thread, but you can also call it on a worker thread as long as you\n     are sure that Initialize() or GetColor() cannot be called at the same time on another thread.",since:6}]},{name:"Rhino.Render.TextureGeneration",dataType:3,summary:""},{name:"Rhino.Render.TextureGraphInfo",dataType:1,summary:"",constructors:[{signature:"TextureGraphInfo()",since:6.3}],properties:[{signature:"IntPtr CppPointer",since:6.3}],methods:[{signature:"Axis ActiveAxis()",since:6.3},{signature:"Channel ActiveChannel()",since:6.3},{signature:"double AmountU()",since:6.3},{signature:"double AmountV()",since:6.3},{signature:"double AmountW()",since:6.3},{signature:"void Dispose()",since:6.3},{signature:"void SetActiveAxis(Axis axis)",since:6.3},{signature:"void SetActiveChannel(Channel channel)",since:6.3},{signature:"void SetAmountU(double d)",since:6.3},{signature:"void SetAmountV(double d)",since:6.3},{signature:"void SetAmountW(double d)",since:6.3}]},{name:"Rhino.Render.TextureGraphInfo.Axis",dataType:3,summary:""},{name:"Rhino.Render.TextureGraphInfo.Channel",dataType:3,summary:""},{name:"Rhino.Render.TextureMapping",dataType:1,summary:"Represents a texture mapping.",properties:[{signature:"ModelComponentType ComponentType",summary:"Returns .",since:6},{signature:"Guid Id",summary:"The unique Id for this texture mapping object.",since:5.1},{signature:"TextureMappingType MappingType",summary:"Texture mapping type associated with this Mapping object.",since:5.1},{signature:"Transform NormalTransform",summary:"For primitive based mappings, these transformations are used to map\n     the world coordinate (x,y,z) point P and  surface normal N before it is\n     projected to the normalized mapping primitive. The surface normal\n     transformation, m_Nxyz, is always calculated from m_Pxyz.  It is a\n     runtime setting that is not saved in 3dm files. If m_type is\n     srfp_mapping, then m_Pxyz and m_Nxyz are ignored.",since:5.1},{signature:"Transform PrimativeTransform",summary:"For primitive based mappings, these transformations are used to map\n     the world coordinate (x,y,z) point P and  surface normal N before it is\n     projected to the normalized mapping primitive. The surface normal\n     transformation, m_Nxyz, is always calculated from m_Pxyz.  It is a\n     runtime setting that is not saved in 3dm files. If m_type is\n     srfp_mapping, then m_Pxyz and m_Nxyz are ignored.",since:5.1},{signature:"Transform UvwTransform",summary:"Transform applied to mapping coordinate (u,v,w) to convert it into a\n     texture coordinate.",since:5.1}],methods:[{signature:"static TextureMapping CreateBoxMapping(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)",summary:"Create a box projection texture mapping.",since:5,returns:"TextureMapping instance if input is valid"},{signature:"static TextureMapping CreateCustomMeshMapping(Mesh mesh)",summary:"Create custom mesh mapping",since:6.15,returns:"TextureMapping instance"},{signature:"static TextureMapping CreateCylinderMapping(Cylinder cylinder,bool capped)",summary:"Create a cylindrical projection texture mapping.",since:5,returns:"TextureMapping instance if input is valid"},{signature:"static TextureMapping CreatePlaneMapping(Plane plane,Interval dx,Interval dy,Interval dz)",summary:"Create a planar UV projection texture mapping",since:5,returns:"TextureMapping instance if input is valid"},{signature:"static TextureMapping CreatePlaneMapping(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)",summary:"Create a planar projection texture mapping",since:6.7,returns:"TextureMapping instance if input is valid"},{signature:"static TextureMapping CreateSphereMapping(Sphere sphere)",summary:"Create a spherical projection texture mapping.",since:5,returns:"TextureMapping instance if input is valid"},{signature:"int Evaluate(Point3d p,Vector3d n,Point3d t)",summary:"Evaluate the mapping to get a texture coordinate",since:6.17,returns:"Nonzero if evaluation is successful.  When the mapping is a box or\n     capped cylinder mapping, the value indicates which side was evaluated.\n     Cylinder mapping: 1 = cylinder wall, 2 = bottom cap, 3 = top cap\n     Box mapping: 1 = front, 2 = right, 3 = back, 4 = left, 5 = bottom, 6 = top"},{signature:"int Evaluate(Point3d p,Vector3d n,Point3d t,Transform pXform,Transform nXform)",summary:"Evaluate the mapping to get a texture coordinate",since:6.17,returns:"Nonzero if evaluation is successful.  When the mapping is a box or\n     capped cylinder mapping, the value indicates which side was evaluated.\n     Cylinder mapping: 1 = cylinder wall, 2 = bottom cap, 3 = top cap\n     Box mapping: 1 = front, 2 = right, 3 = back, 4 = left, 5 = bottom, 6 = top"},{signature:"bool TryGetMappingBox(Plane plane,Interval dx,Interval dy,Interval dz)",summary:"Get a box projection from the texture mapping.",since:5.1,returns:"Returns True if a valid box is returned."},{signature:"bool TryGetMappingBox(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)",summary:"Get a box projection from the texture mapping, including capped information",since:6.7,returns:"Returns True if a valid box is returned."},{signature:"bool TryGetMappingCylinder(Cylinder cylinder)",summary:"Get a cylindrical projection parameters from this texture mapping.",since:5.1,returns:"Returns True if a valid cylinder is returned."},{signature:"bool TryGetMappingCylinder(Cylinder cylinder,bool capped)",summary:"Get a cylindrical projection parameters from this texture mapping.",since:6.7,returns:"Returns True if a valid cylinder is returned."},{signature:"bool TryGetMappingMesh(Mesh mesh)",summary:"Get custom mapping mesh from this texture mapping.",since:6.18,returns:"True if custom mapping mesh was returned."},{signature:"bool TryGetMappingPlane(Plane plane,Interval dx,Interval dy,Interval dz)",summary:"Get plane mapping parameters from this texture mapping.",since:5.1,returns:"Return True if valid plane mapping parameters were returned."},{signature:"bool TryGetMappingPlane(Plane plane,Interval dx,Interval dy,Interval dz,bool capped)",summary:"Get plane mapping parameters from this texture mapping, including capping information",since:6.7,returns:"Return True if valid plane mapping parameters were returned."},{signature:"bool TryGetMappingSphere(Sphere sphere)",summary:"Get a spherical projection parameters from this texture mapping.",since:5.1,returns:"Returns True if a valid sphere is returned."}]},{name:"Rhino.Render.TextureMappingType",dataType:3,summary:"Defines enumerated constants for mapping types such as planar, cylindrical or spherical."},{name:"Rhino.Render.TextureMode",dataType:3,summary:""},{name:"Rhino.Render.TextureProjectionMode",dataType:3,summary:""},{name:"Rhino.Render.TextureRenderHashFlags",dataType:3,summary:""},{name:"Rhino.Render.TextureWrapType",dataType:3,summary:""},{name:"Rhino.Render.TimeZone",dataType:1,summary:"TimeZone",properties:[{signature:"double Hours",summary:"Gets hours of a time zone.",since:6},{signature:"double Latitude",summary:"Returns the latitude of a major city nearby",since:6.15},{signature:"double Longitude",summary:"Returns the Longitude of a major city nearby",since:6.15},{signature:"String Name",summary:"Gets name of a time zone.",since:6}],methods:[{signature:"static TimeZone TimeZoneAt(int index)",summary:"Returns a time zone at given index.",since:6,returns:"Time zone at index."},{signature:"static int TimeZones()",summary:"Returns number of available time zones.",since:6,returns:"Time zone count."}]},{name:"Rhino.Render.TwoColorRenderTexture",dataType:1,summary:"",properties:[{signature:"Color4f Color1",since:5.1},{signature:"Color4f Color2",since:5.1},{signature:"bool SuperSample",since:5.1},{signature:"bool SwapColors",since:5.1},{signature:"double Texture1Amount",since:5.1},{signature:"bool Texture1On",since:5.1},{signature:"double Texture2Amount",since:5.1},{signature:"bool Texture2On",since:5.1}]},{name:"Rhino.Render.UI.IUserInterfaceSection",dataType:4,summary:"Implement this interface in your user control to get UserInterfaceSection\n   event notification."},{name:"Rhino.Render.UI.UserInterfaceSection",dataType:1,summary:"Custom user interface section manager",properties:[{signature:"RenderContent RenderContent",summary:"The RenderContent object that created this user interface object.",since:5.1},{signature:"object Window",summary:"The user control associated with this user interface object.",since:5.1}],methods:[{signature:"static UserInterfaceSection FromWindow(object window)",summary:"Find the UserInterfaceSection that created the specified instance of a\n     window.",since:6,returns:"If a UserInterfaceSection object is found containing a reference to\n     the requested window then return the object otherwise return null."},{signature:"void Expand(bool expand)",summary:"Expand or collapse this content section.",since:5.1},{signature:"RenderContent[] GetContentList()",summary:"Returns a list of currently selected content items to be edited.",since:5.1,returns:"Returns a list of currently selected content items to be edited."},{signature:"void Show(bool visible)",summary:"Show or hide this content section.",since:5.1}]},{name:"Rhino.Render.UI.WorldMapDayNight",dataType:1,summary:"",constructors:[{signature:"WorldMapDayNight()",since:6}],methods:[{signature:"void Dispose()",since:6},{signature:"bool HasMapForCurrentSettings()",since:6},{signature:"System.Drawing.Point LocationToMap(Point2d latlong)",since:6},{signature:"void MakeMapBitmap()",since:6},{signature:"System.Drawing.Image Map()",since:6},{signature:"Rhino.Geometry.Point2d MapToLocation(Point mapPoint)",since:6},{signature:"void SetDayNightDisplay(bool bOn)",since:6},{signature:"void SetEnabled(bool bEnabled)",since:6},{signature:"void SetTimeInfo(DateTime dt,double timezone,int daylightSavingMinutes,bool bDaylightSavingsOn)",since:6}]},{name:"Rhino.Render.UndoRedo",dataType:1,summary:"This class contains the event for UndoRedoChanged that is fired from RDK .",events:[{signature:"static UndoRedoChanged",summary:"Called after undo or redo has occurred for document settings.",since:6},{signature:"static UndoRedoEndedChanged",summary:"This event is raised when undo/redo ends in rdk.",since:7}]},{name:"Rhino.Render.Utilities",dataType:1,summary:"",properties:[{signature:"static Guid DefaultRenderPlugInId",summary:"Get the plug-in Id for the default render plug-in",since:5.3},{signature:"static bool ShowIncompatibleEnvironments",summary:"Specifies whether incompatible content should be shown in the corresponding editor.",since:5.3},{signature:"static bool ShowIncompatibleMaterials",summary:"Specifies whether incompatible content should be shown in the corresponding editor.",since:5.3},{signature:"static bool ShowIncompatibleTextures",summary:"Specifies whether incompatible content should be shown in the corresponding editor.",since:5.3},{signature:"static UiFrameworks UiFramework",since:7}],methods:[{signature:"static RenderContent ChangeContentType(RenderContent oldContent,Guid newType,bool harvestParameters)",summary:"Changes the type of a content. This deletes the content and creates a replacement\n    of the specified type allowing the caller to decide about harvesting.",since:6,returns:"A new persistent render content."},{signature:"static string FindFile(RhinoDoc doc,string fullPathToFile)",summary:"Finds a file and also handles network shares.\n     This is a replacement for CRhinoFileUtilities::FindFile().",since:6,returns:"The found file."},{signature:"static string FindFile(RhinoDoc doc,string fullPathToFile,bool unpackFromBitmapTableIfNecessary)",summary:"Finds a file and also handles network shares.\n     This is a replacement for CRhinoFileUtilities::FindFile().",since:6,returns:"The found file."},{signature:"static bool IsCachedTextureFileInUse(string textureFileName)",summary:"Determines if any texture in any persistent content list is using the specified file name for caching.",since:6,returns:"True if the texture is present."},{signature:"static RenderContent LoadPersistentRenderContentFromFile(uint docSerialNumber,String filename)",summary:"Loads a content from a library file and adds it to the persistent content list of a particular document.",since:6,returns:"The loaded content or None if an error occurred."},{signature:"static void MoveWindow(IntPtr hwnd,Rectangle rect,bool bRepaint,bool bRepaintNC)",since:6},{signature:"static string PromptForSaveImageFileParameters(string filename,int width,int height,int colorDepth)",summary:"Prompts the user for a save file name and the width, height and depth of an image to be saved.",since:6,returns:"The new file name."},{signature:"static bool SafeFrameEnabled(RhinoDoc doc)",summary:"Queries whether or not the Safe Frame is visible.",since:6},{signature:"static bool SetDefaultRenderPlugIn(Guid pluginId)",summary:"Set default render application",since:5.3,returns:"True if plug-in found and loaded successfully.  False if pluginId is\n      invalid or was unable to load plug-in"},{signature:"static ShowContentChooserResults ShowContentChooser(Guid defaultType,Guid defaultInstanceId,RenderContentKind kinds,Guid instanceIdOut,ShowContentChooserFlags flags,RhinoDoc doc)",summary:"Shows the content chooser to allow the user to select a new or existing content.",since:6.25,returns:"The result."},{signature:"static bool ShowIORMenu(IntPtr hwnd,Point pt,double outIOR,string outString)",summary:"Display and track the context menu.",since:6,returns:"True if the function showed the IOR menu and something was picked."}]},{name:"Rhino.Render.Utilities.ShowContentChooserResults",dataType:3,summary:""},{name:"Rhino.Render.Utilities.UiFrameworks",dataType:3,summary:""},{name:"Rhino.Render.Variant.VariantTypes",dataType:3,summary:""},{name:"Rhino.RhinoApp",dataType:1,summary:".NET RhinoApp is parallel to C++ CRhinoApp.",properties:[{signature:"static DateTime BuildDate",summary:"Gets the build date.",since:5},{signature:"static bool CanSave",summary:"Returns True when Rhino is allowed to save, False otherwise\n     Conditions where Rhino is not allowed to save are: when evaluation licenses are expired;\n     when a Cloud Zoo lease is expired; when a license is shared by a single user on multiple\n     computers, and the current computer is not active.",since:7},{signature:"static string CommandHistoryWindowText",summary:"Text in Rhino's command history window.",since:5},{signature:"static CommandLineTextWriter CommandLineOut",summary:"Provides a TextWriter that can write to the command line.",since:6},{signature:"static string CommandPrompt",summary:"Rhino command prompt.",since:5},{signature:"static bool CommandWindowCaptureEnabled",summary:"Enable or disable capturing of the strings sent to the CommandWindow through\n     Write and WriteLine calls",since:7},{signature:"static Guid CurrentRhinoId",summary:"Gets the current ID of Rhino.",since:5},{signature:"static int DaysUntilExpiration",summary:"Returns number of days until license expires. Zero when\n       license is expired.\n     Raises InvalidLicenseTypeException if LicenseExpires\n     would return false.",since:5.6},{signature:"static Font DefaultUiFont",summary:"Default font used to render user interface",since:6},{signature:"static int ExeServiceRelease",summary:'Service release version of Rhino executable (0, 1, 2, ...)  \n    The integer is the service release number of Rhino.  For example,\n    this function returns "0" if Rhino V4SR0 is running and returns\n    "1" if Rhino V4SR1 is running.',since:5},{signature:"static int ExeVersion",summary:"Major version of Rhino executable 4, 5, ...",since:5},{signature:"static Installation InstallationType",summary:"Gets the product installation type, as seen in Rhino's ABOUT dialog box.",since:5},{signature:"static string InstallationTypeString",summary:"Gets the type of installation (product edition) of the license or lease.",since:6},{signature:"static bool InvokeRequired",summary:"Returns True if we are currently not running on the main user interface thread",since:6},{signature:"static bool IsClosing",summary:"Returns True if Rhino is in the process of closing, False otherwise.\n     This can be True even before the Closing event fires, such as when RhinoDoc.CloseDocument event is called."},{signature:"static bool IsCloudZooNode",summary:"Returns \n       True if rhino is currently using the Cloud Zoo\n       False otherwise",since:6},{signature:"static bool IsExiting",summary:"Returns True if Rhino is in the process of exiting, False otherwise.\n     This can be True even before the Closing event fires, such as when RhinoDoc.CloseDocument event is called."},{signature:"static bool IsInternetAccessAllowed",summary:"Returns True when Rhino is allowed to access the internet, False otherwise",since:6.15},{signature:"static bool IsLicenseValidated",summary:"Returns \n       True if the license is validated\n       False otherwise",since:5.6},{signature:"static bool IsPreRelease",summary:"Returns\n       True if Rhino is compiled a s Pre-release build (Beta, WIP)\n       False otherwise",since:6},{signature:"static bool IsRunningAutomated",summary:"Is Rhino currently being executed through automation",since:5},{signature:"static bool IsRunningHeadless",summary:"Is Rhino currently being executed in headless mode",since:6.1},{signature:"static bool IsSkinned",summary:"Is Rhino currently using custom, user-interface Skin.",since:6.2},{signature:"static bool LicenseExpires",summary:"Returns \n       True if the license will expire\n       False otherwise",since:5.6},{signature:"static string LicenseUserName",summary:"Gets the name of the user that owns the license or lease.",since:6},{signature:"static string LicenseUserOrganization",summary:"Gets the name of the organization of the user that owns the license or lease.",since:6},{signature:"static Image LoggedInUserAvatar",summary:"Returns the logged in user's avatar picture. \n     Returns a default avatar if the user does not have an avatar or if the avatar could not be fetched.",since:6},{signature:"static string LoggedInUserName",summary:"Returns the name of the logged in user, or None if the user is not logged in.",since:6},{signature:"static RhinoWindow MainApplicationWindow",summary:"Same as MainWindow function, but provides the concrete class instead of an interface",since:5},{signature:"static string Name",summary:"Gets the application name.",since:5},{signature:"static LicenseNode NodeType",summary:"Gets license the node type.",since:5},{signature:"static Guid Rhino2Id",summary:"Gets the ID of Rhino 2.",since:5},{signature:"static Guid Rhino3Id",summary:"Gets the ID of Rhino 3.",since:5},{signature:"static Guid Rhino4Id",summary:"Gets the ID of Rhino 4.",since:5},{signature:"static Guid Rhino5Id",summary:"Gets the ID of Rhino 5.",since:5},{signature:"static Guid Rhino6Id",summary:"Gets the ID of Rhino 6.",since:7},{signature:"static string SchemeName",summary:"Gets the current Registry scheme name.",since:6},{signature:"static int SdkServiceRelease",summary:'Rhino SDK 9 digit SDK service release number in the form YYYYMMDDn\n    \n    Service service release of the Rhino SDK supported by this executable. Rhino will only\n    load plug-ins that require a service release of <= this release number.\n    For example, SR1 will load all plug-ins made with any SDK released up through and including\n    the SR1 SDK. But, SR1 will not load a plug-in built using the SR2 SDK. If an "old" Rhino\n    tries to load a "new" plug-in, the user is told that they have to get a free Rhino.exe\n    update in order for the plug-in to load. Rhino.exe updates are available from http://www.rhino3d.com.',since:5},{signature:"static int SdkVersion",summary:"Rhino SDK 9 digit SDK version number in the form YYYYMMDDn\n    \n    Rhino will only load plug-ins that were build with exactly the\n    same version of the SDK.",since:5},{signature:"static string SerialNumber",summary:"Gets the product serial number, as seen in Rhino's ABOUT dialog box.",since:5},{signature:"static ToolbarFileCollection ToolbarFiles",summary:"Collection of currently open toolbar files in the application",since:5},{signature:"static int UpdatesAndStatisticsStatus",summary:"Returns True when Rhino is allowed to access the internet, False otherwise",since:6.15},{signature:"static bool UserIsLoggedIn",summary:"Returns True if the user is logged in; else returns false.\n     A logged in user does not guarantee that the auth tokens managed by the CloudZooManager instance are valid.",since:6},{signature:"static int ValidationGracePeriodDaysLeft",summary:"Returns number of days within which validation must occur. Zero when\n       validation grace period has expired.\n     Raises InvalidLicenseTypeException if LicenseType is one of:\n       EvaluationSaveLimited\n       EvaluationTimeLimited\n       Viewer\n       Unknown",since:5.6},{signature:"static Version Version",summary:"File version of the main Rhino process",since:5.9},{signature:"static string VersionControlRevision",summary:"McNeel version control revision identifier at the time this version\n     of Rhino was built.",since:5}],methods:[{signature:"static bool AskUserForRhinoLicense(bool standAlone,object parentWindow)",summary:"Display UI asking the user to enter a license for Rhino or use one from the Zoo.",since:6},{signature:"static string[] CapturedCommandWindowStrings(bool clearBuffer)",summary:"Get list of strings sent to the command window through calls to Write or WriteLine\n     when capturing has been enabled",since:7,returns:"array of captured strings"},{signature:"static bool ChangeLicenseKey(Guid pluginId)",summary:"Display UI asking the user to enter a license for the product specified by licenseId.",since:6,returns:"True on success, False otherwise"},{signature:"static void ClearCommandHistoryWindow()",summary:"Clear the text in Rhino's command history window.",since:5},{signature:"static void DisableContinuousMainLoop()",summary:"This function makes it so that Rhino's main loop is not executed continuously.\n     This is default behavior.",since:7},{signature:"static bool EnableContinuousMainLoop()",summary:"This function makes it so that Rhino's main loop is executed continuously.\n     This is useful when Rhino needs to be doing something as often as possible, \n     such as rendering a view at interactive frame rates.",since:7,returns:"True if the functionality was enabled successfully, False otherwise."},{signature:"static Commands.Result ExecuteCommand(RhinoDoc document,string commandName)",summary:"Execute a Rhino command.",since:6,returns:"Returns the reult of the command."},{signature:"static void Exit()",summary:"Exits, or closes, Rhino.",since:5},{signature:"static string GetDataDirectory(bool localUser,bool forceDirectoryCreation)",summary:"Gets the data directory.",since:6,returns:"The data directory."},{signature:"static string GetDataDirectory(bool localUser,bool forceDirectoryCreation,string subDirectory)",summary:"Gets the data directory.",since:6,returns:"The data directory."},{signature:"static System.IO.DirectoryInfo GetExecutableDirectory()",summary:"directory",since:6.7},{signature:"static object GetPlugInObject(Guid pluginId)",summary:"Gets the object that is returned by PlugIn.GetPlugInObject for a given\n     plug-in. This function attempts to find and load a plug-in with a given Id.\n     When a plug-in is found, it's GetPlugInObject function is called and the\n     result is returned here.\n     Note the plug-in must have already been installed in Rhino or the plug-in manager\n     will not know where to look for a plug-in with a matching id.",since:5,returns:"Result of PlugIn.GetPlugInObject for a given plug-in on success."},{signature:"static object GetPlugInObject(string plugin)",summary:"Gets the object that is returned by PlugIn.GetPlugInObject for a given\n     plug-in. This function attempts to find and load a plug-in with a given name.\n     When a plug-in is found, it's GetPlugInObject function is called and the\n     result is returned here.\n     Note the plug-in must have already been installed in Rhino or the plug-in manager\n     will not know where to look for a plug-in with a matching name.",since:5,returns:"Result of PlugIn.GetPlugInObject for a given plug-in on success."},{signature:"static bool InFullScreen()",summary:"Verifies that Rhino is running in full screen mode.",since:6,returns:"True if Rhino is running full screen, False otherwise."},{signature:"static void InvokeAndWait(Action action)",summary:"Work-In-Progess. Testing this with our unit test framework",since:6},{signature:"static void InvokeOnUiThread(Delegate method,object[] args)",summary:"Execute a function on the main UI thread.",since:6},{signature:"static bool IsInstallationBeta(Installation licenseType)",summary:"If licenseType is a beta license, returns true. A beta license grants\n     full use of the product during the pre-release development period.",since:5.6,returns:"True if licenseType is a beta license. False otherwise"},{signature:"static bool IsInstallationCommercial(Installation licenseType)",summary:"If licenseType is a commercial license, returns true. A commercial license grants\n     full use of the product.",since:5.6,returns:"True if licenseType is a commercial license. False otherwise"},{signature:"static bool IsInstallationEvaluation(Installation licenseType)",summary:"If licenseType is an evaluation license, returns true. An evaluation license limits the ability of\n     Rhino to save based on either the number of saves or a fixed period of time.",since:5.6,returns:"True if licenseType is an evaluation license. False otherwise"},{signature:"static bool LoginToCloudZoo()",summary:"Logs in to the cloud zoo.",since:6},{signature:"static System.Windows.Forms.IWin32Window MainWindow()",summary:"Main Rhino Window",since:5},{signature:"static IntPtr MainWindowHandle()",summary:"Gets the HWND of the Rhino main window.",since:5},{signature:"static void OutputDebugString(string str)",summary:"Print a string to the Visual Studio Output window, if a debugger is attached.\n    \n     Note that the developer needs to add a newline manually if the next output should\n     come on a separate line.",since:6},{signature:"static string ParseTextField(string formula,RhinoObject obj,RhinoObject topParentObject)",since:6},{signature:"static bool RefreshRhinoLicense()",summary:"Refresh the license used by Rhino. This allows any part of Rhino to ensure that the most current version of the license file on disk is in use.",since:6},{signature:"static bool ReleaseMouseCapture()",summary:"Releases the mouse capture.",since:5},{signature:"static bool RunMenuScript(string script)",summary:"Run a Rhino menu item script.  Will add the selected menu string to the MRU command menu.",since:6},{signature:"static bool RunningInRdp()",summary:"Find out if Rhino is running in a remote session",since:6,returns:"True if Rhino is running in a RDP session, False otherwise"},{signature:"static bool RunningOnVMWare()",summary:"Verifies that Rhino is running on VMWare",since:6,returns:"True if Rhino is running in Windows on VMWare, False otherwise"},{signature:"static bool RunScript(string script,bool echo)",summary:"Runs a Rhino command script.",since:5},{signature:"static bool RunScript(string script,string mruDisplayString,bool echo)",summary:"Runs a Rhino command script.",since:5},{signature:"static void SendKeystrokes(string characters,bool appendReturn)",summary:"Sends a string of printable characters, including spaces, to Rhino's command line.",since:5},{signature:"static void SetCommandPrompt(string prompt)",summary:"Set Rhino command prompt.",since:5},{signature:"static void SetCommandPrompt(string prompt,string promptDefault)",summary:"Sets the command prompt in Rhino.",since:5},{signature:"static void SetCommandPromptMessage(string prompt)",summary:"Set the text that appears in the Rhino command prompt.\n     In general, you should use the SetCommandPrompt functions. \n     In rare cases, like worker thread messages, the message that \n     appears in the prompt has non-standard formatting. In these \n     rare cases, SetCommandPromptMessage can be used to literally \n     specify the text that appears in the command prompt window.",since:6},{signature:"static void SetFocusToMainWindow()",summary:"Sets the focus to the main window. This function attempts to use the\n     ActiveDoc on Mac to figure out which window to set focus to.",since:5},{signature:"static void SetFocusToMainWindow(RhinoDoc doc)",summary:"Sets the focus to the main windows for a given document",since:6.16},{signature:"static void Wait()",summary:"Pauses to keep Windows message pump alive so views will update\n     and windows will repaint.",since:5},{signature:"static void Write(string message)",summary:"Print formatted text in the command window.",since:5},{signature:"static void Write(string format,object arg0)",summary:"Print formatted text in the command window.",since:5},{signature:"static void Write(string format,object arg0,object arg1)",summary:"Print formatted text in the command window.",since:5},{signature:"static void Write(string format,object arg0,object arg1,object arg2)",summary:"Print formatted text in the command window.",since:5},{signature:"static void WriteLine()",summary:"Print a newline in the command window.",since:5},{signature:"static void WriteLine(string message)",summary:"Print text in the command window.",since:5},{signature:"static void WriteLine(string format,object arg0)",summary:"Print formatted text with a newline in the command window.",since:5},{signature:"static void WriteLine(string format,object arg0,object arg1)",summary:"Print formatted text with a newline in the command window.",since:5},{signature:"static void WriteLine(string format,object arg0,object arg1,object arg2)",summary:"Print formatted text with a newline in the command window.",since:5}],events:[{signature:"static AppSettingsChanged",summary:"Is raised when settings are changed.",since:5},{signature:"static Closing",summary:"Is raised when the application is about to close.",since:5},{signature:"static EscapeKeyPressed",summary:"Can add or removed delegates that are raised when the escape key is clicked.",since:5},{signature:"static Idle",summary:"Occurs when the application finishes processing and is about to enter the idle state",since:5.1},{signature:"static Initialized",summary:"Is raised when the apllication is fully initialized.",since:5},{signature:"static KeyboardEvent",summary:"Can add or removed delegates that are raised by a keyboard event.",since:5.2},{signature:"static MainLoop",summary:"Gets called every loop iteration inside Rhino's main message loop.",since:7},{signature:"static RdkCacheImageChanged",summary:"Monitors when the RDK thumbnail cache images are changed.",since:5.1},{signature:"static RdkGlobalSettingsChanged",summary:"Monitors when RDK global settings are modified.",since:5.1},{signature:"static RdkNewDocument",summary:"Monitors when RDK document information is rebuilt.",since:5.1},{signature:"static RdkPlugInUnloading",summary:"Monitors when RDK client plugins are unloaded.",since:5.1},{signature:"static RdkUpdateAllPreviews",summary:"Monitors when RDK thumbnails are updated.",since:5.1},{signature:"static RendererChanged",summary:"Monitors when Rhino's current renderer changes.",since:5.1}]},{name:"Rhino.RhinoApp.CommandLineTextWriter",dataType:1,summary:"Provides a text writer that writes to the command line.",properties:[{signature:"Encoding Encoding",summary:"Returns Encoding Unicode.",since:6}],methods:[{signature:"void Write(char value)",summary:"Writes a char to the command line.",since:6},{signature:"void Write(char[] buffer,int index,int count)",summary:"Writes a char buffer to the command line.",since:6},{signature:"void write(string str)",summary:"Provided to give a simple way to IronPython to call this class.",since:6},{signature:"void Write(string value)",summary:"Writes a string to the command line.",since:6}]},{name:"Rhino.RhinoDoc",dataType:1,summary:"Represents an active model.",properties:[{signature:"static RhinoDoc ActiveDoc",summary:"WARNING!! Do not use the ActiveDoc if you don't have to. Under Mac Rhino the ActiveDoc\n     can change while a command is running. Use the doc that is passed to you in your RunCommand\n     function or continue to use the same doc after the first call to ActiveDoc.",since:5},{signature:"AnimationProperties AnimationProperties",since:6.11},{signature:"BitmapTable Bitmaps",summary:"bitmaps used in textures, backgrounds, wallpapers, ...",since:5},{signature:"ICurrentEnvironment CurrentEnvironment",summary:"Access to the current environment for various uses",since:6},{signature:"uint CurrentUndoRecordSerialNumber",summary:">0: undo recording is active and being saved on the undo record with\n         the specified serial number.\n     0: undo recording is not active. (Disabled or nothing is being\n        recorded.)",since:6},{signature:"Size> CustomRenderSizes",since:6},{signature:"DateTime DateCreated",since:5},{signature:"DateTime DateLastEdited",since:5},{signature:"DimStyleTable DimStyles",since:5},{signature:"int DistanceDisplayPrecision",since:5},{signature:"int DocumentId",summary:"Gets the Document Id.",since:5},{signature:"EarthAnchorPoint EarthAnchorPoint",since:5},{signature:"FontTable Fonts",since:5},{signature:"GroundPlane GroundPlane",summary:"Gets the ground plane of this document.",since:5},{signature:"GroupTable Groups",since:5},{signature:"HatchPatternTable HatchPatterns",since:5},{signature:"InstanceDefinitionTable InstanceDefinitions",since:5},{signature:"bool IsAvailable",since:6},{signature:"bool IsClosing",since:6},{signature:"bool IsCommandRunning",summary:"Returns True if Rhino is currently running a command.",since:7},{signature:"bool IsCreating",since:6},{signature:"bool IsHeadless",since:7},{signature:"bool IsInitializing",since:6},{signature:"bool IsLocked",summary:"Check to see if the file associated with this document is locked.  If it is\n     locked then this is the only document that will be able to write the file.  Other\n     instances of Rhino will fail to write this document.",since:5},{signature:"bool IsOpening",since:6},{signature:"bool IsReadOnly",summary:"Current read-only mode for this document.\n     True if the document can be viewed but NOT saved.\n     False if document can be viewed and saved.",since:5},{signature:"bool IsSendingMail",summary:"True if Rhino is in the process of sending this document as an email attachment.",since:5},{signature:"LayerTable Layers",summary:"Layers in the document.",since:5},{signature:"bool LayoutSpaceAnnotationScalingEnabled",summary:"If LayoutSpaceAnnotationScaling is on, sizes in dimstyles are multiplied by \n     dimscale when the annotation is displayed in a detail viewport not in a detail",since:6},{signature:"LightTable Lights",since:5},{signature:"LinetypeTable Linetypes",summary:"Linetypes in the document.",since:5},{signature:"ManifestTable Manifest",since:6},{signature:"MaterialTable Materials",summary:"Materials in the document.",since:5},{signature:"MeshingParameterStyle MeshingParameterStyle",summary:"Type of MeshingParameters currently used by the document to mesh objects",since:5.1},{signature:"double ModelAbsoluteTolerance",summary:"Model space absolute tolerance.",since:5},{signature:"double ModelAngleToleranceDegrees",summary:"Model space angle tolerance.",since:5},{signature:"double ModelAngleToleranceRadians",summary:"Model space angle tolerance.",since:5},{signature:"Point3d ModelBasepoint",summary:"The base point in the model that is used when inserting the model into another as a block definition.\n     By default the base point in any model is 0,0,0.",since:6.1},{signature:"int ModelDistanceDisplayPrecision",since:5.8},{signature:"double ModelRelativeTolerance",summary:"Model space relative tolerance.",since:5},{signature:"bool ModelSpaceAnnotationScalingEnabled",summary:"If ModelSpaceAnnotationScaling is on, sizes in dimstyles are multiplied by \n     dimscale when the annotation is displayed in a model space viewport not in a detail",since:6},{signature:"double ModelSpaceHatchScale",summary:"The scale factor for hatches in model space when Hatch Scaling is enabled",since:6.1},{signature:"bool ModelSpaceHatchScalingEnabled",summary:"True if hatch scaling is enabled, False if not.",since:6.16},{signature:"double ModelSpaceTextScale",summary:"The scale factor for text in model space when Annotation Scaling is enabled",since:6.1},{signature:"UnitSystem ModelUnitSystem",since:5},{signature:"bool Modified",summary:"Returns or sets the document's modified flag.",since:5},{signature:"string Name",summary:"Returns the name of the currently loaded Rhino document (3DM file).",since:5},{signature:"NamedConstructionPlaneTable NamedConstructionPlanes",summary:"Collection of named construction planes.",since:5},{signature:"NamedLayerStateTable NamedLayerStates",summary:"Collection of named layer states.",since:6.14},{signature:"NamedPositionTable NamedPositions",summary:"Collection of named positions.",since:6},{signature:"NamedViewTable NamedViews",summary:"Collection of named views.",since:5},{signature:"uint NextUndoRecordSerialNumber",summary:"The serial number that will be assigned to the next undo record that is\n     constructed.",since:6},{signature:"string Notes",summary:"Returns or sets the document's notes.",since:5},{signature:"ObjectTable Objects",since:5},{signature:"double PageAbsoluteTolerance",summary:"Page space absolute tolerance.",since:5},{signature:"double PageAngleToleranceDegrees",summary:"Page space angle tolerance.",since:5},{signature:"double PageAngleToleranceRadians",summary:"Page space angle tolerance.",since:5},{signature:"int PageDistanceDisplayPrecision",since:5.8},{signature:"double PageRelativeTolerance",summary:"Page space relative tolerance.",since:5},{signature:"UnitSystem PageUnitSystem",since:5},{signature:"string Path",summary:"Returns the path of the currently loaded Rhino document (3DM file).",since:5},{signature:"bool RedoActive",summary:"Returns True if Redo is currently active.",since:6},{signature:"RenderEnvironmentTable RenderEnvironments",since:5.7},{signature:"RenderMaterialTable RenderMaterials",since:5.7},{signature:"RenderSettings RenderSettings",since:5},{signature:"RenderTextureTable RenderTextures",since:5.7},{signature:"RuntimeDocumentDataTable RuntimeData",summary:"Collection of document runtime data. This is a good place to\n     put non-serializable, per document data, such as panel view models.  \n     Note well: This data will be dispose with the document and does not\n     get serailzed.",since:6.3},{signature:"uint RuntimeSerialNumber",summary:"Unique serialNumber for the document while the application is running.\n     This is not a persistent value.",since:6},{signature:"SnapshotTable Snapshots",summary:"Collection of snapshots.",since:6.7},{signature:"StringTable Strings",summary:"Collection of document user data strings in this document",since:5},{signature:"string TemplateFileUsed",summary:"name of the template file used to create this document. This is a runtime value\n     only present if the document was newly created.",since:5},{signature:"bool UndoActive",summary:"Returns True if Undo is currently active.",since:6},{signature:"bool UndoRecordingEnabled",since:5},{signature:"bool UndoRecordingIsActive",summary:"True if undo recording is actually happening now.",since:5},{signature:"ViewTable Views",since:5},{signature:"Worksession Worksession",summary:"Provides access to the document's worksession.",since:6}],methods:[{signature:"static RhinoDoc Create(string modelTemplateFileName)",summary:"Creates a new RhinoDoc",since:6.4},{signature:"static RhinoDoc CreateHeadless(string file3dmTemplatePath)",summary:"Create a new headless RhinoDoc from a template file",since:7,returns:'New RhinoDoc on success. Note that this is a "headless" RhinoDoc and it\'s\n     lifetime is under your control.'},{signature:"static System.Drawing.Bitmap ExtractPreviewImage(string path)",summary:"Extracts the bitmap preview image from the specified model (3DM).",since:5,returns:"True on success."},{signature:"static RhinoDoc FromFilePath(string filePath)",summary:"Search the open document list for a document with a Path equal\n     to the specified file path.",since:6,returns:"The file name to search for"},{signature:"static RhinoDoc FromId(int docId)",since:5},{signature:"static RhinoDoc FromRuntimeSerialNumber(uint serialNumber)",since:6},{signature:"static RhinoDoc Load(string file3dmPath)",summary:"Loads a 3DM file into a new headless RhinoDoc. Load is different than New in that\n     load sets the document path",since:7},{signature:"static RhinoDoc New(string file3dmTemplatePath)",summary:"Create a new headless RhinoDoc from a template file",since:7,returns:'New RhinoDoc on success. Note that this is a "headless" RhinoDoc and it\'s\n     lifetime is under your control.'},{signature:"static RhinoDoc Open(string filePath,bool wasAlreadyOpen)",summary:"Opens a 3dm file and makes it the active document. If called on\n     windows the active document will be saved and closed and the new\n     document will be opened and become the active document.  If called\n     on the Mac the file will be opened in a new document window.",since:6,returns:"Returns the newly opened document on success or None on error."},{signature:"static RhinoDoc[] OpenDocuments()",summary:"Returns a list of currently open Rhino documents",since:6},{signature:"static bool OpenFile(string path)",since:5},{signature:"static RhinoDoc OpenHeadless(string file3dmPath)",summary:"Opens a 3DM file into a new headless RhinoDoc.",since:7},{signature:"static bool ReadFile(string path,FileReadOptions options)",since:5},{signature:"bool AddCustomUndoEvent(string description,EventHandler<CustomUndoEventArgs> handler)",since:5},{signature:"bool AddCustomUndoEvent(string description,EventHandler<CustomUndoEventArgs> handler,object tag)",summary:"Add a custom undo event so you can undo private plug-in data\n     when the user performs an undo or redo",since:5},{signature:"void AdjustModelUnitSystem(UnitSystem newUnitSystem,bool scale)",since:5},{signature:"void AdjustPageUnitSystem(UnitSystem newUnitSystem,bool scale)",since:5},{signature:"uint BeginUndoRecord(string description)",summary:"Instructs Rhino to begin recording undo information when the document\n     is changed outside of a command. We use this, e.g., to save changes\n     caused by the modeless layer or object properties dialogs\n     when commands are not running.",since:5,returns:"Serial number of record.  Returns 0 if record is not started\n     because undo information is already being recorded or\n     undo is disabled."},{signature:"void ClearRedoRecords()",since:5},{signature:"void ClearUndoRecords(bool purgeDeletedObjects)",since:5},{signature:"void ClearUndoRecords(uint undoSerialNumber,bool purgeDeletedObjects)",since:6},{signature:"DocObjects.ObjectAttributes CreateDefaultAttributes()",summary:"Gets the default object attributes for this document. \n     The attributes will be linked to the currently active layer \n     and they will inherit the Document WireDensity setting.",since:5},{signature:"void Dispose()",since:7},{signature:"bool EndUndoRecord(uint undoRecordSerialNumber)",summary:"Ends the undo record.",since:5,returns:"True if successful, False otherwise."},{signature:"bool Equals(object obj)"},{signature:"bool Export(string filePath)",summary:"Export the entire document to a file. All file formats that Rhino can export to\n     are supported by this function.",since:7,returns:"True on success"},{signature:"bool ExportSelected(string filePath)",summary:"Export selected geometry to a file. All file formats that Rhino can export\n     to are supported by this function.",since:7,returns:"True on success"},{signature:"string FindFile(string filename)",summary:"Search for a file using Rhino's search path.  Rhino will look in the\n     following places:\n     1. Current model folder\n     2. Path specified in options dialog/File tab\n     3. Rhino system folders\n     4. Rhino executable folder",since:5,returns:"Path to existing file if found, an empty string if no file was found"},{signature:"MeshingParameters GetAnalysisMeshingParameters()",summary:"Get analysis meshing parameters currently used by the document",since:6},{signature:"MeshingParameters GetCurrentMeshingParameters()",summary:"Get the custom meshing parameters that this document will use.",since:6},{signature:"string[] GetEmbeddedFilesList(bool missingOnly)",since:6},{signature:"bool GetGumballPlane(Plane plane)",summary:"Returns the active plane of Rhino's auto-gumball widget.\n     Note, when calling from a Rhino command, make sure the command \n     class has the Rhino.Commands.Style.Transparent command style attribute.",since:6,returns:"True if the auto-gumball widget is enabled and visible. False otherwise."},{signature:"int GetHashCode()"},{signature:"MeshingParameters GetMeshingParameters(MeshingParameterStyle style)",summary:"Get MeshingParameters currently used by the document",since:5.1},{signature:"RenderPrimitiveList GetRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)",summary:"Build custom render mesh(es) for this document (ie - GH meshes).",since:6.9,returns:"Returns a RenderPrimitiveList if successful otherwise returns null."},{signature:"IEnumerable<RenderPrimitive> GetRenderPrimitives(bool forceTriangleMeshes,bool quietly)",summary:"Get a enumerable list of custom mesh primitives",since:6},{signature:"IEnumerable<RenderPrimitive> GetRenderPrimitives(Guid plugInId,ViewportInfo viewport,bool forceTriangleMeshes,bool quietly)",summary:"Get a enumerable list of custom mesh primitives",since:6},{signature:"IEnumerable<RenderPrimitive> GetRenderPrimitives(ViewportInfo viewport,bool forceTriangleMeshes,bool quietly)",summary:"Get a enumerable list of custom mesh primitives",since:6},{signature:"string GetUnitSystemName(bool modelUnits,bool capitalize,bool singular,bool abbreviate)",since:5},{signature:"bool Import(string filePath)",summary:"Import geometry into a RhinoDoc from a file. This can be any file format\n     that Rhino can import",since:7,returns:"True on success"},{signature:"int ReadFileVersion()",summary:"Returns the file version of the current document.  \n    Use this function to determine which version of Rhino last saved the document.",since:5,returns:"The file version (e.g. 1, 2, 3, 4, etc.) or -1 if the document has not been read from disk."},{signature:"bool Redo()",summary:'Redo the last action that was "undone"',since:6.16,returns:"True on success"},{signature:"bool Save()",summary:"Save doc to disk using the document's Path",since:7},{signature:"bool SaveAs(string file3dmPath)",summary:"Save doc as a 3dm to a specified path using the current Rhino file version",since:7,returns:"True on success"},{signature:"bool SaveAs(string file3dmPath,int version)",summary:"Save doc as a 3dm to a specified path",since:7,returns:"True on success"},{signature:"bool SaveAsTemplate(string file3dmTemplatePath)",summary:"Save this document as a template",since:7,returns:"True on success"},{signature:"bool SaveAsTemplate(string file3dmTemplatePath,int version)",summary:"Save this document as a template to a specific Rhino file version",since:7,returns:"True on success"},{signature:"void SetCustomMeshingParameters(MeshingParameters mp)",summary:"Set the custom meshing parameters that this document will use. You must also modify the\n     MeshingParameterStyle property on the document to Custom if you want these meshing\n     parameters to be used",since:5.1},{signature:"bool SupportsRenderPrimitiveList(ViewportInfo viewport,DisplayPipelineAttributes attrs)",summary:"Determines if custom render meshes will be built for this document (ie - GH meshes).",since:6.9,returns:"Returns True if custom render mesh(es) will get built for this document."},{signature:"bool TryGetRenderPrimitiveBoundingBox(ViewportInfo viewport,DisplayPipelineAttributes attrs,BoundingBox boundingBox)",summary:"Get the bounding box for the custom render meshes associated with this\n     document (ie - GH meshes).",since:6.9,returns:"Returns True if the bounding box was successfully calculated otherwise\n     returns False on error."},{signature:"bool Undo()",summary:"Undo the last action",since:6.16,returns:"True on success"},{signature:"bool Write3dmFile(string path,FileWriteOptions options)",summary:"Write information in this document to a .3dm file. \n     Note, the active document's name will not be changed.",since:6.5,returns:"True if successful, False on failure."},{signature:"bool WriteFile(string path,FileWriteOptions options)",summary:"Write information in this document to a file. \n     Note, the active document's name will be changed to that\n     of the path provided.",since:5,returns:"True if successful, False on failure."}],events:[{signature:"static ActiveDocumentChanged",summary:"This event is raised when the active document used by modeless user\n     interface changes.  On Mac Rhino this will get raised before the\n     ,  and\n      events.  Mac Rhino will also raise this\n     event with 0 for the document Id and a None document pointer when the\n     last document is closed.  Windows Rhino will raise this event after the\n     ,  and\n      events when a new or existing model is\n     opened.",since:6},{signature:"static AddRhinoObject",summary:"Called if a new object is added to the document.",since:5},{signature:"static BeforeTransformObjects",summary:"Called before objects are being transformed",since:5.1},{signature:"static BeginOpenDocument",summary:"This event is raised when the document open operation begins.\n     NOTE: On Windows, this event will be fired when a clipboard paste \n     operation occurs, as Rhino opens a .tmp file in the User's\n     Local folder with the contents of the pasted document.",since:5},{signature:"static BeginSaveDocument",since:5},{signature:"static CloseDocument",since:5},{signature:"static DeleteRhinoObject",summary:"Called if an object is deleted. At some later point the object can be un-deleted.",since:5},{signature:"static DeselectAllObjects",summary:"Called when all objects are deselected.",since:5},{signature:"static DeselectObjects",summary:"Called when object(s) are deselected.",since:5},{signature:"static DimensionStyleTableEvent",summary:"Called when any modification happens to a document's dimension style table.",since:6},{signature:"static DocumentPropertiesChanged",since:5},{signature:"static EndOpenDocument",since:5},{signature:"static EndOpenDocumentInitialiViewUpdate",summary:"This event is raised after  when the\n     documents initial views have been created and initialized.",since:5.11},{signature:"static EndOpenDocumentInitialViewUpdate",summary:"This event is raised after  when the\n     documents initial views have been created and initialized.",since:6.18},{signature:"static EndSaveDocument",since:5},{signature:"static GroupTableEvent",summary:"Called when any modification happens to a document's group table.",since:5},{signature:"static InstanceDefinitionTableEvent",summary:"Called when any modification happens to a document's light table.",since:5.3},{signature:"static LayerTableEvent",summary:"Called when any modification happens to a document's layer table.",since:5},{signature:"static LightTableEvent",summary:"Called when any modification happens to a document's light table.",since:5.3},{signature:"static MaterialTableEvent",summary:"Called when any modification happens to a document's material table.",since:5},{signature:"static ModifyObjectAttributes",summary:"Called when all object attributes are changed.",since:5},{signature:"static NewDocument",since:5},{signature:"static PurgeRhinoObject",summary:"Called if an object is being purged from a document. The object will cease to exist forever.",since:5},{signature:"static RenderEnvironmentTableEvent",since:5.7},{signature:"static RenderMaterialsTableEvent",since:5.7},{signature:"static RenderTextureTableEvent",summary:"Called when the  has been loaded, is\n     about to be cleared or has been cleared.  See  for more\n     information.",since:5.7},{signature:"static ReplaceRhinoObject",summary:"Called if an object is about to be replaced.\n     If both RhinoDoc.UndoActive() and RhinoDoc.RedoActive() return false,\n     then immediately after the ReplaceObject event, there will be a DeleteObject\n     event followed by an AddObject event.\n    \n     If either RhinoDoc.UndoActive() or RhinoDoc::RedoActive() return true,\n     then immediately after the ReplaceObject event, there will be a DeleteObject\n     event followed by an UndeleteObject event.",since:5},{signature:"static SelectObjects",summary:"Called when object(s) are selected.",since:5},{signature:"static TextureMappingEvent",summary:"Called when any modification happens to a document objects texture mapping.",since:5.8},{signature:"static UndeleteRhinoObject",summary:"Called if an object is un-deleted.",since:5}]},{name:"Rhino.RhinoDoc.RenderContentTableEventArgs",dataType:1,summary:"Passed to the ,  and the\n      events.",properties:[{signature:"RhinoDoc Document",summary:"Document the table belongs to",since:5.7},{signature:"RenderContentTableEventType EventType",summary:"Event type",since:5.7}]},{name:"Rhino.RhinoDoc.RenderContentTableEventType",dataType:3,summary:"Type of content table event"},{name:"Rhino.RhinoDoc.RenderMaterialAssignmentChangedEventArgs",dataType:1,summary:"",properties:[{signature:"bool IsLayer",since:5.1},{signature:"bool IsObject",since:5.1},{signature:"Guid LayerId",since:5.1},{signature:"Guid NewRenderMaterial",since:5.1},{signature:"Guid ObjectId",since:5.1},{signature:"Guid OldRenderMaterial",since:5.1}]},{name:"Rhino.RhinoDoc.TextureMappingEventArgs",dataType:1,summary:"Event arguments passed to the RhinoDoc.TextureMappingEvent.",properties:[{signature:"RhinoDoc Document",since:5.8},{signature:"TextureMappingEventType EventType",since:5.8},{signature:"TextureMapping NewMapping",since:5.8},{signature:"TextureMapping OldMapping",since:5.8}]},{name:"Rhino.RhinoDoc.TextureMappingEventType",dataType:3,summary:""},{name:"Rhino.RhinoDocObserverArgs",dataType:1,summary:"Arguments passed to  methods.",constructors:[{signature:"RhinoDocObserverArgs(RhinoDoc doc)",since:6}],properties:[{signature:"RhinoDoc Doc",summary:"Document",since:6},{signature:"uint RuntimeSerialNumber",summary:"Document runtime serial number, will be different across Rhino sessions.",since:6}]},{name:"Rhino.RhinoMath",dataType:1,summary:"Provides constants and static methods that are additional to\n   .",methods:[{signature:"static double Clamp(double value,double bound1,double bound2)",summary:"Restricts a  to be specified within an interval of two numbers.",since:5,returns:"The clamped value."},{signature:"static int Clamp(int value,int bound1,int bound2)",summary:"Restricts a  to be specified within an interval of two integers.",since:5,returns:"The clamped value."},{signature:"static uint CRC32(uint currentRemainder,byte[] buffer)",summary:"Advances the cyclic redundancy check value remainder given a byte array.\n     http://en.wikipedia.org/wiki/Cyclic_redundancy_check.",since:5,returns:"The new current remainder."},{signature:"static uint CRC32(uint currentRemainder,double value)",summary:"Advances the cyclic redundancy check value remainder given a .\n     http://en.wikipedia.org/wiki/Cyclic_redundancy_check.",since:5,returns:"The new current remainder."},{signature:"static uint CRC32(uint currentRemainder,int value)",summary:"Advances the cyclic redundancy check value remainder given a .\n     http://en.wikipedia.org/wiki/Cyclic_redundancy_check.",since:5,returns:"The new current remainder."},{signature:"static bool EpsilonEquals(double x,double y,double epsilon)",summary:'Compare two doubles for equality within some "epsilon" range',since:5.4},{signature:"static bool EpsilonEquals(float x,float y,float epsilon)",summary:'Compare to floats for equality within some "epsilon" range',since:5.4},{signature:"static bool EvaluateNormal(int limitDirection,Vector3d ds,Vector3d dt,Vector3d dss,Vector3d dst,Vector3d dtt,Vector3d n)",summary:"Expert tool to evaluate surface unit normal.",since:7,returns:"True if successful, False otherwise."},{signature:"static bool EvaluateNormalPartials(Vector3d ds,Vector3d dt,Vector3d dss,Vector3d dst,Vector3d dtt,Vector3d ns,Vector3d nt)",summary:"Expert tool to evaluate partial derivatives of surface unit normal.",since:7,returns:"True if Jacobian is non-degenerate, False if Jacobian is degenerate."},{signature:"static string IntIndexToString(int index)",summary:"Portrays an  index in text.",since:6,returns:"The text representation of the int index."},{signature:"static bool IsValidDouble(double x)",summary:"Determines whether a  value is valid within the RhinoCommon context.\n     Rhino does not use Double.NaN by convention, so this test evaluates to True if:x is not equal to RhinoMath.UnsetValueSystem.Double.IsNaN(x) evaluates to falseSystem.Double.IsInfinity(x) evaluates to false",since:5,returns:"True if the number if valid, False if the number is NaN, Infinity or Unset."},{signature:"static bool IsValidSingle(float x)",summary:"Determines whether a  value is valid within the RhinoCommon context.\n     Rhino does not use Single.NaN by convention, so this test evaluates to True if:x is not equal to RhinoMath.UnsetValue,System.Single.IsNaN(x) evaluates to falseSystem.Single.IsInfinity(x) evaluates to false",since:5,returns:"True if the number if valid, False if the number is NaN, Infinity or Unset."},{signature:"static double ParseNumber(string expression)",summary:"Evaluates command line math expression.",since:6,returns:"result"},{signature:"static double ToDegrees(double radians)",summary:"Convert an angle from radians to degrees.",since:5},{signature:"static double ToRadians(double degrees)",summary:"Convert an angle from degrees to radians.",since:5},{signature:"static bool TryParseNumber(string expression,double result)",summary:"Evaluates command line math expression.",since:6,returns:"True if successfull otherwise false"},{signature:"static double UnitScale(UnitSystem from,UnitSystem to)",summary:"Computes the scale factor for changing the measurements unit systems.",since:5,returns:"A scale multiplier."}]},{name:"Rhino.RhinoWindow",dataType:1,summary:"Represents the top level window in Rhino",properties:[{signature:"IntPtr Handle",since:5},{signature:"bool InvokeRequired",summary:"See Control.InvokeRequired",since:5}],methods:[{signature:"void Invoke(Delegate method)",since:5}]},{name:"Rhino.Runtime.Analytics",dataType:1,summary:"Provides tools for sending Google Analytics events using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.",constructors:[{signature:"Analytics(string TrackingID,string Name)",summary:"Construct Analytics class",since:6},{signature:"Analytics(string TrackingID,string Name,string Platform,string InstallerId,string Version)",summary:"Construct Analytics class",since:6}],properties:[{signature:"static bool UsageStatisticsEnabled",summary:"Determine if user allows automatic data collection from Rhino",since:6},{signature:"static Guid UserId",summary:"Returns a GUID that allows events to be aggregated by user. There is no way to determine who the\n     end user is based on this GUID, unless the user tells you their ID.  On Windows, this uses the \n     registry to store the ID.  On Mac, the Hardware UUID is used as the ID.",since:6},{signature:"string AppInstallerId",summary:'App Installer Id. In Rhino, we use this to differentiate between different builds such as "WIP" and "Commercial".\n     Maps to Google Analytics parameter \'aiid\'',since:6},{signature:"string AppName",summary:"Name of Application. For example, \"Ocelot\". Do not include version numbers.\n     Maps to Google Analytics parameter 'an'",since:6},{signature:"string AppPlatform",summary:'Platform application is running on. For example "Mac", "Windows". Again, don\'t include version numbers.\n     Maps to Google Analytics parameter \'ai\'',since:6},{signature:"string AppVersion",summary:"Application version string.\n     Maps to Google Analytics parameter 'av'",since:6},{signature:"string GoogleAnalyticsTrackingID",summary:"Google Analytics Tracking ID",since:6}],methods:[{signature:"void Send(NameValueCollection data)",summary:'Advanced method for sending Google Analytics data.\n     It is the caller\'s responsibility to make sure that all parameters passed will result in a valid Google Analytics hit. Failure to do so will result in Google Analytics ignoring your hit, and the caller will get no data.\n     The Analytics class will populate data from the Application, the GoogleAnalyticsTrackingID, the User ID, and set the hit type "t" to "event". It also sets other information about the system.',since:6},{signature:"void Send(string Category)",summary:"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.",since:6},{signature:"void Send(string Category,string Action)",summary:"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.",since:6},{signature:"void Send(string Category,string Action,string Label)",summary:"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.",since:6},{signature:"void Send(string Category,string Action,string Label,uint Value)",summary:"Sends a Google Analytics event using the Measurement Protocol. See https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event for details.\n     This method is asyncrhonous and the return code is completely ignored. Validate the data you send",since:6}]},{name:"Rhino.Runtime.AssemblyResolver",dataType:1,summary:"Assembly Resolver for the Rhino App Domain.",methods:[{signature:"static void AddSearchFile(string file)",summary:"Register another file with the Assembly Resolver. File must be a .NET assembly, \n     so it should probably be a dll, rhp or exe.",since:5},{signature:"static void AddSearchFolder(string folder)",summary:"Register a custom folder with the Assembly Resolver. Folders will be \n     searched recursively, so this could potentially be a very expensive operation. \n     If at all possible, you should consider only registering individual files.",since:5}]},{name:"Rhino.Runtime.CommonObject",dataType:1,summary:"Base class for .NET classes that wrap C++ unmanaged Rhino classes.",properties:[{signature:"static bool PerformCorruptionTesting",summary:"Used to test ON_Object* pointers to see if they are a brep or mesh that is corrupt enough to crash Rhino.",since:6.1},{signature:"bool Disposed",summary:"Indicates if this object has been disposed or the\n     document it originally belonged to has been disposed.",since:6},{signature:"bool HasUserData",summary:"Gets True if this class has any custom information attached to it through UserData.",since:5},{signature:"bool IsDocumentControlled",summary:'If True this object may not be modified. Any properties or functions that attempt\n     to modify this object when it is set to "IsReadOnly" will throw a NotSupportedException.',since:5},{signature:"bool IsValid",summary:"Tests an object to see if it is valid.",since:5},{signature:"UserDataList UserData",summary:"List of custom information that is attached to this class.",since:5},{signature:"ArchivableDictionary UserDictionary",summary:"Dictionary of custom information attached to this class. The dictionary is actually user\n     data provided as an easy to use sharable set of information.",since:5}],methods:[{signature:"static CommonObject FromBase64String(int archive3dm,int opennurbs,string base64Data)",summary:"Create a CommonObject instance from a Base64 encoded string. This is typically the values\n     used when passing common objects around as JSON data",since:7},{signature:"static CommonObject FromJSON(Dictionary<string,string> jsonDictionary)",summary:"Create a CommonObject instance from a JSON dictionary",since:7},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"void EnsurePrivateCopy()",summary:"If you want to keep a copy of this class around by holding onto it in a variable after a command\n     completes, call EnsurePrivateCopy to make sure that this class is not tied to the document. You can\n     call this function as many times as you want.",since:5},{signature:"void GetObjectData(SerializationInfo info,StreamingContext context)",summary:"Populates a System.Runtime.Serialization.SerializationInfo with the data needed to serialize the target object.",since:5},{signature:"bool IsValidWithLog(string log)",summary:"Determines if an object is valid. Also provides a report on errors if this\n     object happens not to be valid.",since:5,returns:"True if this object is valid; False otherwise."},{signature:"string ToJSON(SerializationOptions options)",summary:"Create a JSON string representation of this object",since:7}]},{name:"Rhino.Runtime.CorruptGeometryException",dataType:1,summary:"Thrown when Rhino finds a brep or mesh that will cause a crash if used for calculations.",properties:[{signature:"CommonObject CommonObject",summary:"Corrupt geometry .NET class",since:6.1},{signature:"IntPtr Pointer",summary:"pointer to base geometry (ON_Object*)",since:6.1}]},{name:"Rhino.Runtime.DocumentCollectedException",dataType:1,summary:"Represents the error that happen when a class user attempts to execute a modifying operation\n   on an object that has been added to a document.",constructors:[{signature:"DocumentCollectedException()",summary:"Initializes a new instance of the document controlled exception class.",since:5},{signature:"DocumentCollectedException(string message)",summary:"Initializes a new instance of the document collected exception class.",since:6}]},{name:"Rhino.Runtime.HostUtils",dataType:1,summary:"Contains static methods to deal with teh runtime environment.",properties:[{signature:"static string ComputerSerialNumber",summary:"Gets the serial number of the computer running Rhino.",since:6},{signature:"static uint CurrentOSLanguage",summary:"Get the current operating system language.",since:6.8},{signature:"static Guid DeviceId",summary:"The DeviceId is a unique, stable ID that anonymously identifies the device\n     that Rhino is running on. It is computed based on hardware information that\n     should not change when the OS is upgraded, or if commonly modified hardware\n     are added or removed from the computer. The machine-specific information is\n     hashed using a cryptographic hash to make it anonymous.",since:6},{signature:"static string DeviceName",summary:'Name of the computer running Rhino. If the computer is part of a\n     Windows Domain, the computer name has "@[DOMAIN]" appended.',since:6},{signature:"static string OperatingSystemBuildNumber",summary:'Returns Operating System Build Number "11763" | "7601" | ... | "Unknown"',since:6.15},{signature:"static string OperatingSystemEdition",summary:'Returns Operating System Edition: "Professional" | "ServerDatacenter" | ... | "Unknown"',since:6.15},{signature:"static string OperatingSystemInstallationType",summary:'Returns Operating System Installation Type: "Client" | "Server" | "Unknown"',since:6.15},{signature:"static string OperatingSystemProductName",summary:'Returns Operating System Edition: "Professional" | "ServerDatacenter" | ... | "Unknown"',since:6.15},{signature:"static string OperatingSystemVersion",summary:'Returns Operating System Version "6.1" | "6.3" | ... | "Unknown"',since:6.15},{signature:"static bool RunningInDarkMode",summary:"Returns True if the host operating system is in dark mode and Rhino\n     supports dark mode.",since:6.19},{signature:"static bool RunningInMono",summary:"Tests if this process is currently executing under the Mono runtime.",since:5},{signature:"static bool RunningInRhino",summary:"Tests if RhinoCommon is currently executing inside of the Rhino.exe process.\n     There are other cases where RhinoCommon could be running; specifically inside\n     of Visual Studio when something like a windows form is being worked on in the\n     resource editor or running stand-alone when compiled to be used as a version\n     of OpenNURBS.",since:5},{signature:"static bool RunningOnOSX",summary:"Tests if this process is currently executing on the Mac OSX platform.",since:5},{signature:"static bool RunningOnWindows",summary:"Tests if this process is currently executing on the Windows platform.",since:5},{signature:"static bool SendDebugToCommandLine",summary:"Gets or sets whether debug messages are printed to the command line.",since:5}],methods:[{signature:"static string AutoInstallPlugInFolder(bool currentUser)",summary:"Gets the auto install plug-in folder for machine or current user.",since:6,returns:"The full path to the revelant auto install plug-in directory."},{signature:"static int CallFromCoreRhino(string task)",summary:"Don't change this function in ANY way unless you chat with Steve first!\n     This function is called by Rhino on initial startup and the signature\n     must be exact",since:6},{signature:"static bool CheckForRdk(bool throwOnFalse,bool usePreviousResult)",summary:"Determines if the RDK is loaded.",since:5,returns:"True if the RDK is loaded; False if the RDK is not loaded. Note that the\n      will hinder the retrieval of any return value."},{signature:"static void ClearFpuExceptionStatus()",summary:"Clear FPU exception and busy flags (Intel assembly fnclex)",since:6},{signature:"static int CreateCommands(IntPtr pPlugIn,Assembly pluginAssembly)",summary:"Parses a plugin and create all the commands defined therein.",since:5,returns:"The number of newly created commands."},{signature:"static void CreateCommands(PlugIn plugin)",summary:"Parses a plugin and create all the commands defined therein.",since:5},{signature:"static PlugIn CreatePlugIn(Type pluginType,bool printDebugMessages)",summary:"Instantiates a plug-in type and registers the associated commands and classes.",since:5,returns:"A new plug-in instance."},{signature:"static string DebugDumpToString(BezierCurve bezierCurve)",summary:"Gets the debug dumps. This is a text description of the geometric contents.\n     DebugDump() is intended for debugging and is not suitable for creating high\n     quality text descriptions of an object.",since:5,returns:"A debug dump text."},{signature:"static string DebugDumpToString(GeometryBase geometry)",summary:"Gets the debug dumps. This is a text description of the geometric contents.\n     DebugDump() is intended for debugging and is not suitable for creating high\n     quality text descriptions of an object.",since:5,returns:"A debug dump text."},{signature:"static void DebugString(string msg)",summary:"Prints a debug message to the Rhino Command Line.\n     The message will only appear if the SendDebugToCommandLine property is set to true.",since:5},{signature:"static void DebugString(string format,object[] args)",summary:"Prints a debug message to the Rhino Command Line.\n     The message will only appear if the SendDebugToCommandLine property is set to true.",since:5},{signature:"static void DisplayOleAlerts(bool display)",summary:'Defines if Ole alerts ("Server busy") alerts should be visualized.\n     This function makes no sense on Mono.',since:5},{signature:"static void ExceptionReport(Exception ex)",summary:"Informs RhinoCommon of an exception that has been handled but that the developer wants to screen.",since:5},{signature:"static void ExceptionReport(string source,Exception ex)",summary:"Informs RhinoCommon of an exception that has been handled but that the developer wants to screen.",since:5},{signature:"static void ExecuteNamedCallback(string name,NamedParametersEventArgs args)",summary:"Execute a named callback",since:7},{signature:"static bool FileNameEndsWithRhinoBackupExtension(string fileName)",summary:"Strip file extension from file name and check to see if it is a valid\n     Rhino backup file extension.",since:6,returns:"Returns True if the file name has an extension like 3dmbak."},{signature:"static bool FileNameEndsWithRhinoExtension(string fileName)",summary:"Strip file extension from file name and check to see if it is a valid\n     Rhino file extension.",since:6,returns:"Returns True if the file name has an extension like 3dm."},{signature:"static bool GetAbsolutePath(string relativePath,bool bRelativePathisFileName,string relativeTo,bool bRelativeToIsFileName,string pathOut)",summary:"Call this method to convert a relative path to an absolute path\n     relative to the specified path.",since:6,returns:"Returns True if parameters are valid and lpsRelativePath is indeed\n     relative to lpsRelativeTo otherwise returns false"},{signature:"static IEnumerable<System.IO.DirectoryInfo> GetActivePlugInVersionFolders(bool currentUser)",summary:'Recurses through the auto install plug-in folders and returns the directories containing "active" versions of plug-ins.',since:6},{signature:"static string[] GetAssemblySearchPaths()",summary:"Returns list of directory names where additional assemblies (plug-ins, DLLs, Grasshopper components)\n     may be located",since:5},{signature:"static void GetCurrentProcessInfo(string processName,Version processVersion)",summary:'Returns information about the current process. If Rhino is the top level process,\n     processName is "Rhino". Otherwise, processName is the name, without extension, of the main\n     module that is executing. For example, "compute.backend" or "Revit".\n     \n     processVersion is the System.Version of the running process. It is the FileVersion\n     of the executable.',since:6.15},{signature:"static Tuple<string, Type>[] GetCustomComputeEndpoints()",summary:"Used by compute to define custom endpoints",since:7},{signature:"static T GetPlatformService(string assemblyPath,string typeFullName)",summary:"For internal use only. Loads an assembly for dependency injection via IPlatformServiceLocator.",since:6,returns:"An instance, or null."},{signature:"static System.Reflection.Assembly GetRhinoDotNetAssembly()",summary:"Only works on Windows. Returns None on Mac.",since:5,returns:"An assembly."},{signature:"static void InitializeRhinoCommon()",summary:"Makes sure all static RhinoCommon components is set up correctly.\n     This happens automatically when a plug-in is loaded, so you probably won't\n     have to call this method.",since:5},{signature:"static void InitializeRhinoCommon_RDK()",summary:"Makes sure all static RhinoCommon RDK components are set up correctly.\n     This happens automatically when the RDK is loaded, so you probably won't\n     have to call this method.",since:6},{signature:"static void InitializeZooClient()",summary:"Initializes the ZooClient and Rhino license manager, this should get\n     called automatically when RhinoCommon is loaded so you probably won't\n     have to call this method.",since:5.6},{signature:"static void InPlaceConstCast(GeometryBase geometry,bool makeNonConst)",summary:"DO NOT USE UNLESS YOU ARE CERTAIN ABOUT THE IMPLICATIONS.\n     This is an expert user function which should not be needed in most\n     cases. This function is similar to a const_cast in C++ to allow an object\n     to be made temporarily modifiable without causing RhinoCommon to convert\n     the class from const to non-const by creating a duplicate.You must call this function with a True parameter, make your\n     modifications, and then restore the const flag by calling this function\n     again with a False parameter. If you have any questions, please\n     contact McNeel developer support before using!",since:5},{signature:"static bool IsManagedDll(string path)",summary:"Inspects a dll to see if it is compiled as native code or as a .NET assembly",since:6},{signature:"static bool IsRhinoBackupFileExtension(string fileExtension)",summary:"Check to see if the file extension is a valid Rhino file extension.",since:6,returns:'Return True if fileExtension is ".3dmbak", "3dmbak", ".3dm.bak", "3dm.bak",\n     ".3dx.bak" or "3dx.bak", ignoring case.'},{signature:"static bool IsRhinoFileExtension(string fileExtension)",summary:"Check to see if the file extension is a valid Rhino file extension.",since:6,returns:'Returns True if fileExtension is ".3dm", "3dm", ".3dx" or "3dx",\n     ignoring case.'},{signature:"static void RecordInitInstanceTime(string description)",summary:"Used to help record times at startup with the -stopwatch flag to help\n     determine bottlenecks in start up speed",since:6},{signature:"static void RegisterComputeEndpoint(string endpointPath,Type t)",summary:"Register a class that can participate as a compute endpoint",since:7},{signature:"static bool RegisterDynamicCommand(PlugIn plugin,Command cmd)",summary:"Adds a new dynamic command to Rhino.",since:5,returns:"True on success, False on failure."},{signature:"static void RegisterNamedCallback(string name,EventHandler<NamedParametersEventArgs> callback)",summary:"Register a named callback",since:6.15},{signature:"static void RhinoCommonExceptionHandler(string title,object sender,Exception ex)",summary:"For internal use only!!!\n     Unhanded exception handler, writes stack trace to RhinoDotNet.txt file",since:6},{signature:"static void SendLogMessageToCloudCallbackProc(LogMessageType msg_type,IntPtr pwStringClass,IntPtr pwStringDesc,IntPtr pwStringMessage)",summary:"Informs RhinoCommon of an message that has been handled but that the developer wants to screen.",since:6.4},{signature:"static void SetInShutDown()",summary:"Informs the runtime that the application is shutting down.",since:5},{signature:"static void ShutDownRhinoCommon_RDK()",summary:"Makes sure all static RhinoCommon RDK components are de-initialized so they aren't calling into space when the RDK is unloaded.",since:6},{signature:"static void UnhandledThreadException(object sender,ThreadExceptionEventArgs e)",summary:"Exception handler for exceptions occurring on the UI thread",since:6}]},{name:"Rhino.Runtime.HostUtils.LogMessageType",dataType:3,summary:"Represents the type of message that is being sent to the OnSendLogMessageToCloud event"},{name:"Rhino.Runtime.InProcess.RhinoCore",dataType:1,summary:"Represents an instance of RhinoCore.DLL.",constructors:[{signature:"RhinoCore()",summary:"Initializes a new instance of the  class.",since:7},{signature:"RhinoCore(string[] args)",summary:"Initializes a new instance of the  class.",since:7},{signature:"RhinoCore(string[] args,WindowStyle windowStyle)",summary:"Initializes a new instance of the  class.",since:7},{signature:"RhinoCore(string[] args,WindowStyle windowStyle,IntPtr hostWnd)",summary:"Initializes a new instance of the  class.",since:7}],methods:[{signature:"void Dispose()",summary:"IDisposable implementation",since:7},{signature:"bool DoEvents()",summary:"If a Rhino owned window is active processes all Windows messages currently in the message queue.",since:7,returns:"Returns True if a Rhino owned window is still active or Idle tasks are pending."},{signature:"bool DoIdle()",summary:"Processes all Rhino Idle tasks.",since:7,returns:"True if Idle tasks are still pending."},{signature:"void InvokeInHostContext(Action action)",summary:"Invokes action in Host context",since:7},{signature:"T InvokeInHostContext(Func<T> func)",summary:"Invokes function in Host context",since:7,returns:"Returns argument function return value."},{signature:"void RaiseIdle()",summary:"Raises the Idle event.",since:7},{signature:"int Run()",summary:"Runs RhinoApp Message loop",since:7}]},{name:"Rhino.Runtime.InProcess.WindowStyle",dataType:3,summary:"Specified how a new window should appear when Rhino starts."},{name:"Rhino.Runtime.Interop",dataType:1,summary:"Contains static methods to marshal objects between RhinoCommon and legacy Rhino_DotNet or C++.",methods:[{signature:"static Geometry.GeometryBase CreateFromNativePointer(IntPtr pGeometry)",summary:"Constructs a RhinoCommon Geometry class from a given ON_Geomety*. The ON_Geometry*\n     must be declared on the heap and its lifetime becomes controlled by RhinoCommon.",since:5,returns:"The appropriate geometry class in RhinoCommon on success."},{signature:"static IntPtr FileReadOptionsConstPointer(FileReadOptions options)",summary:"Returns the underlying const CRhinoFileReadOptions* for a Rhino.FileIO.FileReadOptions object.\n     You should only be interested in using this function if you are writing C++ code.",since:6,returns:"A pointer to the Rhino const object."},{signature:"static IntPtr FileWriteOptionsConstPointer(FileWriteOptions options)",summary:"Returns the underlying const CRhinoFileWriteOptions* for a Rhino.FileIO.FileWriteOptions object. \n     You should only be interested in using this function if you are writing C++ code.",since:6,returns:"A pointer to the Rhino const object."},{signature:"static DocObjects.Font FontFromPointer(IntPtr ptrManagedFont)",summary:"Create managed Font from native ON_Font*",since:6},{signature:"static Geometry.Brep FromOnBrep(object source)",summary:"Copies a Rhino_DotNet brep to a RhinoCommon brep class.",since:5,returns:"RhinoCommon object on success. This will be an independent copy."},{signature:"static Geometry.Curve FromOnCurve(object source)",summary:"Copies a Rhino_DotNet curve to a RhinoCommon curve class.",since:5,returns:"RhinoCommon object on success. This will be an independent copy."},{signature:"static Geometry.Mesh FromOnMesh(object source)",summary:"Copies a Rhino_DotNet mesh to a RhinoCommon mesh class.",since:5,returns:"RhinoCommon object on success. This will be an independent copy."},{signature:"static Geometry.Surface FromOnSurface(object source)",summary:"Copies a Rhino_DotNet surface to a RhinoCommon Surface class.",since:5,returns:"RhinoCommon object on success. This will be an independent copy."},{signature:"static IntPtr NativeGeometryConstPointer(GeometryBase geometry)",summary:"Returns the underlying const ON_Geometry* for a RhinoCommon class. You should only\n     be interested in using this function if you are writing C++ code.",since:5,returns:"A pointer to the const geometry."},{signature:"static IntPtr NativeGeometryNonConstPointer(GeometryBase geometry)",summary:"Returns the underlying non-const ON_Geometry* for a RhinoCommon class. You should\n     only be interested in using this function if you are writing C++ code.",since:5,returns:"A pointer to the non-const geometry."},{signature:"static IntPtr NativeNonConstPointer(DisplayPipeline pipeline)",summary:"Get CRhinoDisplayPipeline* for a DisplayPipeline instance",since:6},{signature:"static IntPtr NativeNonConstPointer(GetPoint getPoint)",summary:"Get CRhinoGetPoint* from a GetPoint instance",since:6},{signature:"static IntPtr NativeNonConstPointer(RhinoViewport viewport)",summary:"Get CRhinoViewport* from a RhinoViewport instance",since:6},{signature:"static IntPtr NativeNonConstPointer(ViewCaptureSettings settings)",summary:"Get a CRhinoPrintInfo* for a given ViewCaptureSettings class",since:6},{signature:"static IntPtr NativeNonConstPointer(ViewportInfo viewport)",summary:"Get ON_Viewport* from a ViewportInfo instance",since:5.1},{signature:"static IntPtr NativeRhinoDocPointer(RhinoDoc doc)",summary:"Gets the C++ CRhinoDoc* for a given RhinoCommon RhinoDoc class.",since:5,returns:"A pointer value."},{signature:"static IntPtr NSFontFromFont(Font font)",summary:"Get native NSFont* from a Rhino Font. Only works on Mac",since:6.9,returns:"NSFont* on success. IntPtr.Zero on failure"},{signature:"static IntPtr NSFontFromFont(Font font,double pointSize)",summary:"Get native NSFont* from a Rhino Font. Only works on Mac",since:6.9,returns:"NSFont* on success. IntPtr.Zero on failure"},{signature:"static IntPtr PlugInPointer(PlugIn plugin)",summary:"Gets a C++ plug-in pointer for a given RhinoCommon plug-in.\n     This is a Rhino SDK function.",since:5,returns:"A pointer."},{signature:"static IntPtr RhinoObjectConstPointer(RhinoObject rhinoObject)",summary:"Returns the underlying const CRhinoObject* for a RhinoCommon class. You should only\n     be interested in using this function if you are writing C++ code.",since:5,returns:"A pointer to the Rhino const object."},{signature:"static DocObjects.RhinoObject RhinoObjectFromPointer(IntPtr pRhinoObject)",summary:"Constructs a RhinoCommon Rhino object from an unmanaged C++ RhinoObject pointer.",since:5,returns:"A new Rhino object, or None if the pointer was invalid or ."},{signature:"static object ToIRhinoViewport(RhinoViewport source)",summary:"Convert a Rhino.Display.Viewport to an RMA.Rhino.IRhinoViewport.",since:5,returns:"Rhino_DotNet IRhinoViewport object on success. This will be an independent copy."},{signature:"static object ToOnBrep(Brep source)",summary:"Constructs a Rhino_DotNet OnBrep that is a copy of a given brep.",since:5,returns:"Rhino_DotNet object on success. This will be an independent copy."},{signature:"static object ToOnCurve(Curve source)",summary:"Constructs a Rhino_DotNet OnCurve that is a copy of a given curve.",since:5,returns:"Rhino_DotNet object on success. This will be an independent copy."},{signature:"static object ToOnMesh(Mesh source)",summary:"Constructs a Rhino_DotNet OnMesh that is a copy of a given mesh.",since:5,returns:"Rhino_DotNet object on success. This will be an independent copy."},{signature:"static object ToOnSurface(Surface source)",summary:"Constructs a Rhino_DotNet OnSurface that is a copy of a given curve.",since:5,returns:"Rhino_DotNet object on success. This will be an independent copy."},{signature:"static object ToOnXform(Transform source)",summary:"Constructs a Rhino_DotNet OnXform from a given RhinoCommon Transform.",since:5,returns:"Rhino_DotNet object on success. This will be an independent copy."},{signature:"static bool TryCopyFromOnArc(object source,Arc destination)",summary:"Attempts to copy the contents of a RMA.OpenNURBS.OnArc to a Rhino.Geometry.Arc.",since:5,returns:"True if the operation succeeded; False otherwise."},{signature:"static bool TryCopyToOnArc(Arc source,object destination)",summary:"Attempts to copy the contents of a Rhino.Geometry.Arc to a RMA.OpenNURBS.OnArc.",since:5,returns:"True if the operation succeeded; False otherwise."},{signature:"static Display.ViewCaptureSettings ViewCaptureFromPointer(IntPtr ptrViewCapture)",summary:"Create a ViewCaptureSettings class from a native const CRhinoPrintInfo*\n     The pointer values are copied",since:6}]},{name:"Rhino.Runtime.InteropWrappers.ClassArrayObjRef",dataType:1,summary:'Represents a wrapper to an unmanaged "array" (list) of CRhinoObjRef instances.\n   Wrapper for a C++ ON_ClassArray of CRhinoObjRef',constructors:[{signature:"ClassArrayObjRef()",summary:"Initializes a new  instance.",since:5},{signature:"ClassArrayObjRef(IEnumerable<ObjRef> objrefs)",summary:"Initializes a new instances from a set of ObjRefs",since:5}],properties:[{signature:"int Count",summary:"Gets the number of CRhinoObjRef instances in this array.",since:5}],methods:[{signature:"void Add(ObjRef objref)",summary:"Adds an ObjRef to the list.",since:5},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Rhino.DocObjects.ObjRef[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.ClassArrayOnObjRef",dataType:1,summary:'Represents a wrapper to an unmanaged "array" (list) of ON_ObjRef instances.\n   Wrapper for a C++ ON_ClassArray of ON_ObjRef',constructors:[{signature:"ClassArrayOnObjRef()",summary:"Initializes a new  instance.",since:5.8},{signature:"ClassArrayOnObjRef(IEnumerable<ObjRef> objrefs)",summary:"Initializes a new instances from a set of ObjRefs",since:5.8}],properties:[{signature:"int Count",summary:"Gets the number of ObjRef instances in this array.",since:5.8}],methods:[{signature:"void Add(ObjRef objref)",summary:"Adds an ObjRef to the list.",since:5.8},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5.8,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.8},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5.8,returns:"The non-const pointer."},{signature:"DocObjects.ObjRef[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5.8,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.ClassArrayString",dataType:1,summary:"Wrapper for a C++ ON_ClassArray<ON_wString>\n   If you are not writing C++ code then this class is not for you.",constructors:[{signature:"ClassArrayString()",summary:"Initializes a new  instance.",since:6}],properties:[{signature:"int Count",summary:"Gets the number of strings in this array.",since:6}],methods:[{signature:"void Add(string s)",summary:"Adds a string to the list.",since:6},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."},{signature:"string[] ToArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.CurveSegment",dataType:2,summary:"For internal use only.",properties:[{signature:"int Index",summary:"The index of the curve used by this boundary element.",since:7},{signature:"bool Reversed",summary:"True if this piece of the curve should be reversed.",since:7},{signature:"Interval SubDomain",summary:"The subdomain of the curve used by this boundary element.",since:7}]},{name:"Rhino.Runtime.InteropWrappers.MeshPointDataStruct",dataType:2,summary:"This is only needed when passing values to the Rhino C++ core, ignore\n   for .NET plug-ins."},{name:"Rhino.Runtime.InteropWrappers.SimpleArray2dex",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_2dex>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArray2dex()",summary:"Initializes a new  class.",since:6},{signature:"SimpleArray2dex(IEnumerable<IndexPair> values)",summary:"Initializes a new  class",since:6}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:6}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."},{signature:"IndexPair[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayArrayPoint3d",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_PolyLine*>, ON_SimpleArray<ON_3dPointArray*>\n   If you are not writing C++ code then this class is not for you.",constructors:[{signature:"SimpleArrayArrayPoint3d()",summary:"Initializes a new empty  instance.",since:7}],properties:[{signature:"int Count",summary:"Gets the amount of polylines in this array.",since:7}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:7,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:7},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:7,returns:"The non-const pointer."},{signature:"int PointCountAt(int index)",summary:"Gets the amount of points in a polyline.",since:7}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayBinaryArchiveReader",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_BinaryArchive>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayBinaryArchiveReader()",summary:"Initializes a new  class.",since:6},{signature:"SimpleArrayBinaryArchiveReader(IntPtr p)",summary:"Initializes a new  class.",since:6}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:6}],methods:[{signature:"void Add(BinaryArchiveReader reader)",summary:"Adds a new  at the end of this array.",since:6},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"BinaryArchiveReader Get(int index)",summary:"Get the Guid at index",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayBrepPointer",dataType:1,summary:"Wrapper for a C++ ON_SimpleArray<ON_Brep*> or ON_SimpleArray<const ON_Brep*>\n   If you are not writing C++ code then this class is not for you.",constructors:[{signature:"SimpleArrayBrepPointer()",summary:"Initializes a new  instance.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of breps in this array.",since:5}],methods:[{signature:"void Add(Brep brep,bool asConst)",summary:"Adds a brep to the list.",since:5},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Geometry.Brep[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayClippingPlaneObjectPointer",dataType:1,summary:"ON_SimpleArray of CRhinoClippingPlaneObject*",constructors:[{signature:"SimpleArrayClippingPlaneObjectPointer()",summary:"Initializes a new  instance.",since:6.7}],properties:[{signature:"int Count",summary:"Gets the amount of clipping planes in this array.",since:6.7}],methods:[{signature:"void Add(ClippingPlaneObject clippingplane,bool asConst)",summary:"Adds a clipping plane to the list.",since:6.7},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6.7,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6.7},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6.7,returns:"The non-const pointer."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayCurvePointer",dataType:1,summary:"Wrapper for a C++ ON_SimpleArray of ON_Curve* or const ON_Curve*.  If you are not\n   writing C++ code, then you can ignore this class.",constructors:[{signature:"SimpleArrayCurvePointer()",summary:"Initializes a new  instance.",since:5},{signature:"SimpleArrayCurvePointer(IEnumerable<Curve> curves)",summary:"Initializes a new  instance, from a set of input curves.",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Curve[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayDouble",dataType:1,summary:"Wrapper for ON_SimpleArray<double>. If you are not writing C++ code,\n   then this class is not for you.",constructors:[{signature:"SimpleArrayDouble()",summary:"Initializes a new  instance.",since:5},{signature:"SimpleArrayDouble(IEnumerable<double> items)",summary:"Initializes a new  instance, with items.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"double[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayExtrusionPointer",dataType:1,summary:"Wrapper for a C++ ON_SimpleArray<ON_Extrusion*> or ON_SimpleArray<const ON_Extrusion*>\n   If you are not writing C++ code then this class is not for you.",constructors:[{signature:"SimpleArrayExtrusionPointer()",summary:"Initializes a new  instance.",since:6}],properties:[{signature:"int Count",summary:"Gets the amount of Extrusions in this array.",since:6}],methods:[{signature:"void Add(Extrusion extrusion,bool asConst)",summary:"Adds a extrusion to the list.",since:6},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."},{signature:"Geometry.Extrusion[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayGeometryPointer",dataType:1,summary:"Wrapper for a C++ ON_SimpleArray<ON_Geometry*>* or ON_SimpleArray<const ON_Geometry*>.\n   If you are not writing C++ code, then this class is not for you.",constructors:[{signature:"SimpleArrayGeometryPointer()",summary:"Initializes a new  instance.",since:5},{signature:"SimpleArrayGeometryPointer(IEnumerable geometry)",summary:"Expects all of the items in the IEnumerable to be GeometryBase types",since:5},{signature:"SimpleArrayGeometryPointer(IEnumerable<GeometryBase> geometry)",summary:"Create an ON_SimpleArray<ON_Geometry*> filled with items in geometry",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"GeometryBase[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayGuid",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayGuid()",summary:"Initializes a new  class.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:5}],methods:[{signature:"void Append(Guid uuid)",summary:"Appends a new  at the end of this array.",since:6},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Guid[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayGuidPointer",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_UUID>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayGuidPointer()",summary:"Initializes a new  class.",since:6}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:6}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."},{signature:"Guid[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayInt",dataType:1,summary:"Wrapper for ON_SimpleArray<int>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayInt()",summary:"Initializes a new  class.",since:5},{signature:"SimpleArrayInt(IEnumerable<int> values)",summary:"Initializes a new  class",since:5.9}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"int[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayInterval",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_Interval>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayInterval()",summary:"Initializes a new  class.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of elements in this array.",since:5}],methods:[{signature:"void Add(Interval interval)",summary:"Adds a new  at the end of this array.",since:6},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Interval[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayLine",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_Line>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayLine()",summary:"Initializes a new  instance.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of lines in this array.",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Line[] ToArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayLinetypePointer",dataType:1,summary:"Wrapper for a C++ ON_SimpleArray<ON_Linetype*>\n   If you are not writing C++ code then this class is not for you.",constructors:[{signature:"SimpleArrayLinetypePointer()",summary:"Initializes a new  instance.",since:6.6}],properties:[{signature:"int Count",summary:"Gets the amount of linetypes in this array.",since:6.6}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6.6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6.6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6.6,returns:"The non-const pointer."},{signature:"DocObjects.Linetype[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:6.6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayMeshPointer",dataType:1,summary:"Represents a wrapper to an unmanaged array of mesh pointers.\n   Wrapper for a C++ ON_SimpleArray of ON_Mesh* or const ON_Mesh*. If you are not\n   writing C++ code then this class is not for you.",constructors:[{signature:"SimpleArrayMeshPointer()",summary:"Initializes a new  instance.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of meshes in this array.",since:5}],methods:[{signature:"void Add(Mesh mesh,bool asConst)",summary:"Adds a mesh to the list.",since:5},{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Geometry.Mesh[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayPlane",dataType:1,summary:"Wrapper for ON_SimpleArray<ON_Plane>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayPlane()",summary:"Initializes a new  instance.",since:6}],properties:[{signature:"int Count",summary:"Gets the amount of lines in this array.",since:6}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."},{signature:"Plane[] ToArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayPoint2d",dataType:1,summary:"ON_SimpleArray<ON_2dPoint> class wrapper.  If you are not writing\n   C++ code then this class is not for you.",constructors:[{signature:"SimpleArrayPoint2d()",summary:"Initializes a new empty  instance.",since:5.6}],properties:[{signature:"int Count",summary:"Gets the amount of points in this array.",since:5.6}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5.6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5.6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5.6,returns:"The non-const pointer."},{signature:"Point2d[] ToArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5.6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayPoint3d",dataType:1,summary:"ON_SimpleArray<ON_3dPoint>, ON_3dPointArray, ON_PolyLine all have the same size\n   This class wraps all of these C++ versions.  If you are not writing C++ code then this\n   class is not for you.",constructors:[{signature:"SimpleArrayPoint3d()",summary:"Initializes a new empty  instance.",since:5}],properties:[{signature:"int Count",summary:"Gets the amount of points in this array.",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Point3d[] ToArray()",summary:"Copies the unmanaged array to a managed counterpart.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArraySurfacePointer",dataType:1,summary:"Wrapper for a C++ ON_SimpleArray of ON_Surface* or const ON_Surface*.  If\n   you are not writing C++ code then this class is not for you.",constructors:[{signature:"SimpleArraySurfacePointer()",summary:"Initializes a new  instance.",since:5}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:5,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:5,returns:"The non-const pointer."},{signature:"Surface[] ToNonConstArray()",summary:"Copies the unmanaged array to a managed counterpart.\n     Elements are made non-const.",since:5,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.SimpleArrayUint",dataType:1,summary:"Wrapper for ON_SimpleArray<unsigned int>. If you are not writing C++ code\n   then this class is not for you.",constructors:[{signature:"SimpleArrayUint()",summary:"Initializes a new  class.",since:6},{signature:"SimpleArrayUint(IEnumerable<uint> values)",summary:"Initializes a new  class.",since:6}],properties:[{signature:"int Count",summary:"Gets the number of elements in this array.",since:6},{signature:"uint UnsignedCount",summary:"Gets the number of elements in this array.",since:6}],methods:[{signature:"IntPtr ConstPointer()",summary:"Gets the const (immutable) pointer of this array.",since:6,returns:"The const pointer."},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:6},{signature:"IntPtr NonConstPointer()",summary:"Gets the non-const pointer (for modification) of this array.",since:6,returns:"The non-const pointer."},{signature:"uint[] ToArray()",summary:"Returns the managed counterpart of the unmanaged array.",since:6,returns:"The managed array."}]},{name:"Rhino.Runtime.InteropWrappers.StringHolder",dataType:1,summary:"This class is used to pass strings back and forth between managed\n   and unmanaged code.  This should not be be needed by plug-ins.\n   If you are just dealing with an ON_wString*,\n   use",constructors:[{signature:"StringHolder()",summary:"Constructor",since:5.8}],methods:[{signature:"static string GetString(IntPtr pStringHolder)",summary:"Gets managed string from unmanaged ON_wString pointer.",since:5.8,returns:"Null if pStringHolder has no reference, otherwise, the string. This may be an empty string, if setting an empty string is possible."},{signature:"IntPtr ConstPointer()",summary:"C++ pointer used to access the ON_wString, managed plug-ins should\n     never need this.",since:5.8},{signature:"void Dispose()",summary:"IDispose implementation",since:5.8},{signature:"IntPtr NonConstPointer()",summary:"C++ pointer used to access the ON_wString, managed plug-ins should\n     never need this.",since:5.8},{signature:"string ToString()",summary:"Marshals unmanaged ON_wString to a managed .NET string"}]},{name:"Rhino.Runtime.InteropWrappers.StringWrapper",dataType:1,summary:"Represents a wrapper to an unmanaged OpenNurbs string.\n   Wraps a C++ ON_wString*.",constructors:[{signature:"StringWrapper()",summary:"Initializes a new empty unmanaged string (ON_wString*).",since:5},{signature:"StringWrapper(string s)",summary:"Initializes a new unmanaged string with an initial value.\n     The string s can be null.",since:5}],properties:[{signature:"IntPtr ConstPointer",summary:"Gets the const pointer (const ON_wString*).",since:5},{signature:"IntPtr NonConstPointer",summary:"Gets the non-const pointer (ON_wString*).",since:5}],methods:[{signature:"static string GetStringFromPointer(IntPtr pConstON_wString)",summary:"Get string from an ON_wString*",since:5},{signature:"static void SetStringOnPointer(IntPtr pON_wString,string s)",summary:"Set contents of an ON_wString*",since:5},{signature:"void Dispose()",summary:"Actively reclaims unmanaged resources that this instance uses.",since:5},{signature:"void SetString(string s)",summary:"Set contents of this string.",since:5},{signature:"string ToString()",summary:"Returns the string contents of this wrapper.",returns:"A managed string."}]},{name:"Rhino.Runtime.IPlatformServiceLocator",dataType:4,summary:"Get platform specific services that are used internally for\n   general cross platform funtions in RhinoCommon. This includes\n   services like localization and GUI components that have concrete\n   implementations in the RhinoWindows or RhinoMac assemblies"},{name:"Rhino.Runtime.IZooClientUtilities",dataType:4,summary:"Interface implemented in ZooClient and added to Rhino via dependency injection"},{name:"Rhino.Runtime.LicenseStateChangedEventArgs",dataType:1,summary:"Passed to LicenseStateChanged event on RhinoApp",constructors:[{signature:"LicenseStateChangedEventArgs(bool callingRhinoCommonAllowed)",summary:"LicenseStateChangedEventArgs constructor",since:7}],properties:[{signature:"bool CallingRhinoCommonAllowed",summary:"True if RhinoCommon calls will never raise Rhino.Runtime.NotLicensedException.\n     False otherwise",since:7}]},{name:"Rhino.Runtime.LicenseTypes",dataType:3,summary:"Different licensing modes that Rhino can run in"},{name:"Rhino.Runtime.NamedParametersEventArgs",dataType:1,summary:"Dictionary style class used for named callbacks from C++ -> .NET",constructors:[{signature:"NamedParametersEventArgs()",summary:"Construct a new named parameter even args. You should dispose this class when you are done with it",since:7}],methods:[{signature:"void Dispose()",summary:"Dispose native resources",since:7},{signature:"void Set(string name,bool value)",summary:"Set a bool value for a given key name",since:7},{signature:"void Set(string name,double value)",summary:"Set a double value for a given key name",since:7},{signature:"void Set(string name,GeometryBase value)",summary:"Set geometry for a given key name",since:7},{signature:"void Set(string name,IEnumerable<GeometryBase> values)",summary:"Set a list of geometry for a given key name",since:7},{signature:"void Set(string name,IEnumerable<string> strings)",summary:"Set a list of strings as a value for a given key name",since:7},{signature:"void Set(string name,int value)",summary:"Set an int value for a given key name",since:7},{signature:"void Set(string name,Point3d value)",summary:"Set a Point3d value for a given key name",since:7},{signature:"void Set(string name,string value)",summary:"Set a string value for a given key name",since:7},{signature:"void Set(string name,uint value)",summary:"Set an unsigned int for a given key name",since:7},{signature:"void SetWindowHandle(string name,IntPtr value)",summary:"Set a HWND on Windows or NSView* on Mac",since:7},{signature:"bool TryGetBool(string name,bool value)",summary:"Try to get a bool value for a given key name",since:6.15},{signature:"bool TryGetDouble(string name,double value)",summary:"Try to get a double value for a given key name",since:6.15},{signature:"bool TryGetGeometry(string name,GeometryBase[] values)",since:7},{signature:"bool TryGetInt(string name,int value)",summary:"Try to get an int value for a given key name",since:6.15},{signature:"bool TryGetPoint(string name,Point3d value)",summary:"Try to get a Point3d value for a given key name",since:7},{signature:"bool TryGetRhinoObjects(string key,RhinoObject[] values)",summary:"Get array of RhinoObject for the specified key",since:7},{signature:"bool TryGetString(string name,string value)",summary:"Try to get a string value for a given key name",since:6.15},{signature:"bool TryGetStrings(string name,string[] value)",summary:"Try to get a string value for a given key name",since:7},{signature:"bool TryGetUnsignedInt(string name,uint value)",summary:"Try to get an unsigned int for a given key name",since:7},{signature:"bool TryGetWindowHandle(string name,IntPtr value)",summary:"Gets a HWND on Windows or NSVIew* on Mac",since:7}]},{name:"Rhino.Runtime.Notifications.ButtonType",dataType:3,summary:"The type of button in a notification."},{name:"Rhino.Runtime.Notifications.IAssemblyRestrictedObject",dataType:4,summary:"A class that implements this interface signals its clients that its instances can\n   only be modified by certain assemblies. This is useful in cases where only\n   certain assemblies should be able to modify an object. The actual members of an \n   instance that are restricted are left to the discretion of the instance's class,\n   and should be documented."},{name:"Rhino.Runtime.Notifications.Notification",dataType:1,summary:"A Notification instance can be used to inform the user about various events. For\n   a Notification instance to be displayed in Rhino, it must be added to the\n   . When added, it will be displayed in the\n   Notifications panel in Rhino. A Notification contains 1 to 3 buttons that are \n   automatically wired to its  Action if it is not null. \n   The buttons are displayed when the Notification is shown modally by either the user \n   clicking on a particular notification in the Notifications panel, or by programatically \n   showing it using .\n   \n   Currently, only process-wide notifications are\n   supported; document specific notifications are not possible.\n   \n   Notification instances contain metadata that can be added, modified, or removed during\n   its life. The metadata is important for LINQ queries and other patterns.\n   For example, a particular action may require that multiple notifications be modified. \n   Thus, a LINQ query can be performed on the  using metadata\n   to retrieve related Notification objects and modify them as a batch.\n   \n   Notification objects implement . By default, a \n   Notification can be editedby any assembly, but explicitly specifing allowed assemblies \n   in the constructor changes this behavior.\n   \n   Notification objects are not thread-safe and should only be manipulated in UI thread.",constructors:[{signature:"Notification()",summary:"Creates a new instance that can be edited by any assembly.",since:6},{signature:"Notification(IEnumerable<Assembly> allowedAssemblies)",summary:"Creates a new instance that can be edited by the given assemblies.",since:6}],properties:[{signature:"ICollection<Assembly> AllowedAssemblies",summary:"The assemblies that can modify this instance.",since:6},{signature:"string AlternateButtonTitle",summary:"The localized title of the Alternate button.",since:6},{signature:"Action<ButtonType> ButtonClicked",summary:"An Action that will be invoked whenever a button for the notification is clicked or the notification is closed.",since:6},{signature:"string CancelButtonTitle",summary:"The localized title of the Cancel button.",since:6},{signature:"string ConfirmButtonTitle",summary:"The localized title of the Confirm button.",since:6},{signature:"DateTime DateUpdated",summary:"The date the notification was last modified.",since:6},{signature:"string Description",summary:"The description of the notification. The description is displayed in the Notifications panel in Rhino.",since:6},{signature:"string Message",summary:"The message of the notification. The message is shown only when the instance is displayed modally. It should contain details about the notification.",since:6},{signature:"IDictionary<string, string> MetadataCopy",summary:"A copy of all the metadata for this class.",since:6},{signature:"Severity SeverityLevel",summary:"The severity of the notification. Changing the severity of the notification may change the way Rhino chooses to display the Notifications panel.",since:6},{signature:"Guid? ShowEventId",summary:"A field used by Rhino for displaying notifications. Not intended for public use.",since:6},{signature:"string Title",summary:"The title of the notification. The title is displayed when the notification is displayed modally in Rhino.",since:6}],methods:[{signature:"static void ExecuteAssemblyProtectedCode(Action action)",summary:"If a  object is only allowed to be modified by certain\n     assemblies, then any code that interacts with it must be wrapped around this method,\n     or a  will be thrown. For performance reasons,\n     the code wrapped by this method should be kept as simple as possible.",since:6.3},{signature:"static TResult ExecuteAssemblyProtectedCode(Func<TResult> func)",summary:"If a  object is only allowed to be modified by certain\n     assemblies, then any code that interacts with it must be wrapped around this method,\n     or a  will be thrown. For performance reasons,\n     the code wrapped by this method should be kept as simple as possible.",since:6.3},{signature:"bool Editable()",summary:"Determines whether an assembly can modify the instance. Any code that modifies an assembly protected\n     notification must be wrapped in a  method.",since:6.3},{signature:"void HideModal()",summary:"Tells Rhino to hide the notification if it is being currently shown as a modal.",since:6},{signature:"bool RemoveMetadata(string key)",summary:"Removes metadata from this instance.",since:6,returns:"True if the metada was removed; otherwise false."},{signature:"void ShowModal()",summary:"Tells Rhino to display the notification modally.",since:6},{signature:"string ToString()",summary:"Returns a readable string representation of the instance."}]},{name:"Rhino.Runtime.Notifications.Notification.Severity",dataType:3,summary:"Determines the severity of a notification."},{name:"Rhino.Runtime.Notifications.NotificationButtonClickedArgs",dataType:1,summary:"Used when a button is clicked for a notification.",constructors:[{signature:"NotificationButtonClickedArgs(Notification notification,ButtonType buttonClicked)",summary:"Creates a new instance.",since:6}],properties:[{signature:"ButtonType ButtonClicked",summary:"The button that was clicked.",since:6},{signature:"Notification Notification",summary:"The notification whose button was clicked.",since:6}]},{name:"Rhino.Runtime.Notifications.NotificationCenter",dataType:1,summary:"The NotificationCenter holds all  objects that are displayed in the Notifications panel by Rhino.\n   \n   The NotificationCenter is not thread-safe and should only be used in the UI thread."},{name:"Rhino.Runtime.Notifications.TrulyObservableOrderedSet",dataType:1,summary:"An ordered set that notifies its subscribers whenever one of its INotifyPropertyChanged elements raises its PropertyChanged event.",constructors:[{signature:"TrulyObservableOrderedSet()",summary:"Creates an empty instance."},{signature:"TrulyObservableOrderedSet(IEnumerable<T> items)",summary:"Creates an instance with the given items."}],properties:[{signature:"int Count",summary:"Returns the total number of items in the set."},{signature:"bool IsReadOnly",summary:"Always returns false."}],methods:[{signature:"void Add(T item)",summary:"Adds an object to the end of the ordered set if the set does not already contain the item."},{signature:"void Clear()",summary:"Clears the ordered set."},{signature:"bool Contains(T item)",summary:"Determines whether an element is in the set.",returns:"True if the item is in the set; otherwise false."},{signature:"void CopyTo(T[] array,int arrayIndex)",summary:"Copies the values of the set to an array."},{signature:"IEnumerator<T> GetEnumerator()",summary:"Returns an enumerator that iterates through the set."},{signature:"int IndexOf(T item)",summary:"Searches for the specified object and returns the zero-based index of the first occurrence.",returns:"The zero-based index of the first occurrence of item if found; otherwise -1."},{signature:"void Insert(int index,T item)",summary:"Inserts an element at the specified index."},{signature:"bool Remove(T item)",summary:"Removes an element from the set.",returns:"Returns True if the element was removed; otherwise returns false."},{signature:"void RemoveAt(int index)",summary:"Removes an element at the specified index from the set."},{signature:"void Sort(Func<T, TKey> keySelector,bool descending)",summary:"Sorts the set."}]},{name:"Rhino.Runtime.NotLicensedException",dataType:1,summary:"Exception thrown when calling functions in RhinoCommon and the\n   application is executing without a license",constructors:[{signature:"NotLicensedException()",summary:"Default constructor",since:7},{signature:"NotLicensedException(string message)",summary:"Create a new instance with a custom message",since:7},{signature:"NotLicensedException(string message,Exception inner)",summary:"Create a new instance with a custom message and an inner exception",since:7}]},{name:"Rhino.Runtime.PythonCompiledCode",dataType:1,summary:"Represents scripting compiled code.",methods:[{signature:"void Execute(PythonScript scope)",summary:"Executes the script in a specific scope.",since:5}]},{name:"Rhino.Runtime.PythonScript",dataType:1,summary:"Represents a Python script.",properties:[{signature:"int ContextId",summary:"Gets or sets a context unique identified.",since:5},{signature:"Action<string> Output",summary:'Gets or sets the Python script "print()" target.\n     By default string output goes to the Rhino.RhinoApp.Write function.\n     Set Output if you want to redirect the output from python to a different function\n     while this script executes.',since:5},{signature:"Command ScriptContextCommand",summary:"Command associated with this script. Used for localiation",since:6},{signature:"object ScriptContextDoc",summary:"object set to variable held in scriptcontext.doc.",since:5}],methods:[{signature:"static void AddRuntimeAssembly(Assembly assembly)",summary:"Add assembly to list of assemblies used by python",since:7},{signature:"static PythonScript Create()",summary:"Constructs a new Python script context.",since:5,returns:"A new Python script, or None if none could be created. Rhino 4 always returns null."},{signature:"static System.Reflection.Assembly[] RuntimeAssemblies()",summary:"Get list of assemblies used by python for library browser and\n     inclusion into the runtime",since:7},{signature:"PythonCompiledCode Compile(string script)",summary:"Compiles a class in a quick-to-execute proxy.",since:5,returns:"A Python compiled code instance."},{signature:"bool ContainsVariable(string name)",summary:"Determines if the main scripting context has a variable with a name.",since:5,returns:"True if the variable is present."},{signature:"object CreateTextEditorControl(string script,Action<string> helpcallback)",summary:"Creates a control where the user is able to type Python code.",since:5,returns:"A Windows Forms control."},{signature:"object EvaluateExpression(string statements,string expression)",summary:"Evaluates statements and an expression in the main scripting context.",since:5,returns:"The expression result."},{signature:"bool ExecuteFile(string path)",summary:"Executes a Python file. The file is executed in a new, __main__ scope.",since:5,returns:"True if the file executed. This method can throw scripting-runtime based exceptions."},{signature:"bool ExecuteFileInScope(string path)",summary:"Executes a Python file in the calling script scope. All old variables are kept.",since:7,returns:"True if the file executed. This method can throw scripting-runtime based exceptions."},{signature:"bool ExecuteScript(string script)",summary:"Executes a Python string.",since:5,returns:"True if the file executed. This method can throw scripting-runtime based exceptions."},{signature:"string GetStackTraceFromException(Exception ex)",summary:"Retrieves a meaningful representation of the call stack.",since:5,returns:"A string that represents the Python exception."},{signature:"object GetVariable(string name)",summary:"Gets the object associated with a variable name in the main scripting context.",since:5,returns:"The variable object."},{signature:"System.Collections.Generic.IEnumerable<string> GetVariableNames()",summary:"Retrieves all variable names in the script.",since:5,returns:"An enumerable set with all names of the variables."},{signature:"void RemoveVariable(string name)",summary:"Removes a defined variable from the main scripting context.",since:5},{signature:"void SetIntellisenseVariable(string name,object value)",summary:"Sets a variable for runtime introspection.",since:5},{signature:"void SetupScriptContext(object doc)",summary:"Setups the script context. Use a RhinoDoc instance unless unsure.",since:6},{signature:"void SetVariable(string name,object value)",summary:"Sets a variable with a name and an object. Object can be None (Nothing in Visual Basic).",since:5}]},{name:"Rhino.Runtime.RdkNotLoadedException",dataType:1,summary:"Is thrown when the RDK is not loaded.",constructors:[{signature:"RdkNotLoadedException()",summary:"Initializes a new instance of the RDK not loaded exception with a standard message.",since:5}]},{name:"Rhino.Runtime.RiskyAction",dataType:1,summary:"Defines risky actions that need to be reported in crash exceptions",constructors:[{signature:"RiskyAction(string description,string file,string member,int line)",summary:"Always create this in a using block",since:6}],methods:[{signature:"void Dispose()",summary:"IDisposable implementation",since:6}]},{name:"Rhino.Runtime.Skin",dataType:1,summary:"Represents a customized environment that changes the appearance of Rhino.\n   Skin DLLs must contain a single class that derives from the Skin class.",properties:[{signature:"static Skin ActiveSkin",summary:"Any time Rhino is running there is at most one skin being used (and\n     possibly no skin).  If a RhinoCommon based Skin class is being used, use\n     ActiveSkin to get at the instance of this Skin class. May return null\n     if no Skin is being used or if the skin is not a RhinoCommon based skin.",since:5},{signature:"PersistentSettings Settings",summary:"Gets access to the skin persistent settings.",since:5}]},{name:"Rhino.Runtime.TextFields",dataType:1,summary:"This Class Processes Text Field Functions",methods:[{signature:"static double Area(string id)",summary:"Returns the area value for a selected object id",since:7},{signature:"static double Area(string id,string unitSystem)",summary:"Returns the area value for a selected object id in a specified unit system",since:7},{signature:"static string BlockAttributeText(string key,string prompt,string defaultValue)",summary:"User text associated with a block",since:7},{signature:"static int BlockInstanceCount(string instanceDefinitionNameOrId)",summary:"Returns the number of block instances found in the document\n       with the specified block definition name or the instance reference id.",since:7},{signature:"static string BlockInstanceName(string blockId)",summary:"Returns the block definition name of a block instance",since:7},{signature:"static double CurveLength(string id)",summary:"Get length of a curve given a string id",since:7},{signature:"static double CurveLength(string id,string unitSystem)",summary:"Get length of a curve given a string id in a specified unit system.\n       UnitSystem enum as string",since:7},{signature:"static string Date()",summary:"Current date",since:7},{signature:"static string Date(string dateFormat)",summary:"Current date in a specified format",since:7},{signature:"static string Date(string dateFormat,string languageId)",summary:"Current Date in a specific format and language",since:7},{signature:"static string DateModified()",summary:"Date the document was last edited",since:7},{signature:"static string DateModified(string dateFormat)",summary:"Date the document was last edited in a specified format",since:7},{signature:"static string DateModified(string dateFormat,string languageId)",summary:"Date the document was last edited in a specific format and language",since:7},{signature:"static string DetailScale(string detailId,string scaleFormat)",summary:"Returns a detail views scale",since:7},{signature:"static string DocumentText(string key)",summary:"Return document user string for a given key",since:7},{signature:"static string FileName()",summary:"Return full path to the document",since:7},{signature:"static string FileName(string options)",summary:"Return path to the document",since:7},{signature:"static InstanceAttributeField[] GetInstanceAttributeFields(InstanceDefinition idef)",since:7},{signature:"static InstanceAttributeField[] GetInstanceAttributeFields(string str)",summary:"Gets an array of block attribute definitions associated with a\n     TextObject.",since:7,returns:"Will return a empty array if text is None or there is no attributes\n     otherwise; returns a list of one or more attribute definitions embedded\n     in the text string."},{signature:"static InstanceAttributeField[] GetInstanceAttributeFields(TextObject text)",summary:"Gets an array of block attribute definitions associated with a\n     TextObject.",since:7,returns:"Will return a empty array if text is None or there is no attributes\n     otherwise; returns a list of one or more attribute definitions embedded\n     in the text string."},{signature:"static string LayerName(string layerId)",summary:"Returns the name of a layer based on the layers guid",since:7},{signature:"static string LayoutUserText(string key)",summary:"Returns a value from the active layouts user text strings for the specified key.",since:7},{signature:"static string LayoutUserText(string layoutId,string key)",summary:"Returns user text value from a layout id Key",since:7},{signature:"static string ModelUnits()",since:7},{signature:"static string Notes()",summary:"Notes for a RhinoDoc",since:7},{signature:"static int NumPages()",summary:"Number of layout pages in a document",since:7},{signature:"static string ObjectLayer(string id)",summary:"Return an object's layer name",since:7},{signature:"static string ObjectName(string id)",summary:"Return an object's name",since:7},{signature:"static double PageHeight()",summary:"Return the current layout page height in the layout units",since:7},{signature:"static string PageName()",summary:"Return the current layout page name",since:7},{signature:"static string PageName(string id)",summary:"Return the page name for the specified View ID",since:7},{signature:"static int PageNumber()",summary:"Returns the current layouts page number",since:7},{signature:"static double PageWidth()",summary:"Return the current layout page width in the layout units",since:7},{signature:"static string PaperName()",summary:"Returns the layouts selected paper name\n       example Letter / A4 / A6",since:7},{signature:"static string PointCoordinate(string pointId,string axis)",summary:"returns the location of a 3d point",since:7},{signature:"static string UserText(string id,string key)",summary:"User text associated with an object, block or layout",since:7},{signature:"static string UserText(string id,string key,string prompt)",summary:"User text associated with an object, block or layout",since:7},{signature:"static string UserText(string id,string key,string prompt,string defaultValue)",summary:"User text associated with an object, block or layout",since:7},{signature:"static double Volume(string id)",summary:"Returns the volume for the selected object id",since:7},{signature:"static double Volume(string id,string unitSystem)",summary:"Returns volume for selected object id in the specified unit system",since:7}]},{name:"Rhino.Runtime.TextFields.InstanceAttributeField",dataType:1,summary:"",constructors:[{signature:"InstanceAttributeField(string key,string prompt,string defaultValue)",summary:"Block attribute defintion.",since:7}],properties:[{signature:"string DefaultValue",summary:"Default value used when inserting a block",since:7},{signature:"string Key",summary:"Attribute key",since:7},{signature:"string Prompt",summary:"Prompt displayed by the UI when inserting a block",since:7}]},{name:"Rhino.Runtime.ViewCaptureWriter",dataType:1,summary:"Callback system used by SVG and PDF exporter to generate documents",constructors:[{signature:"ViewCaptureWriter(double dpi,Size pageSize)",since:6}],methods:[{signature:"void Draw(IntPtr constPtrPrintInfo,RhinoDoc doc)",since:6.15}]},{name:"Rhino.Runtime.ViewCaptureWriter.PathPoint",dataType:2,summary:"",properties:[{signature:"PointF Location",since:6},{signature:"PointType PointType",since:6}]},{name:"Rhino.Runtime.ViewCaptureWriter.Pen",dataType:1,summary:"",properties:[{signature:"Color Color",since:6},{signature:"float Width",since:6}]},{name:"Rhino.Runtime.ViewCaptureWriter.PointType",dataType:3,summary:""},{name:"Rhino.Runtime.ZooClientParameters",dataType:1,summary:"ZooClientParameters is a read-only set of parameters that control\n   the flow of licensing inside ZooClient. Because this class flows through a number of\n   other classes, functions, and UI, it is read-only so that inadvertent changes are not\n   made to the data as it propagates from the caller.",constructors:[{signature:"ZooClientParameters(Guid productGuid,Guid licenseGuid,string productTitle,int productBuildType,LicenseCapabilities capabilities,string licenseEntryTextMask,string productPath,object parentWindow,LicenseTypes selectedLicenseType,ValidateProductKeyDelegate validateProductKey,OnLeaseChangedDelegate onLeaseChangedDelegate,VerifyLicenseKeyDelegate verifyLicenseKeyDelegate,VerifyPreviousVersionLicenseDelegate verifyPreviousVersionLicenseKeyDelegate)",summary:"ZooClientParameters Constructor",since:6}],properties:[{signature:"LicenseCapabilities Capabilities",summary:"LicenseCapabilities flags that set options for how licenses can be obtained for this product",since:6},{signature:"string LicenseEntryTextMask",summary:'Text mask in the form @"RH4A-AAAA-AAAA-AAAA-AAAA-AAAA" that informs the user what numbers they are looking for',since:6},{signature:"Guid LicenseGuid",summary:"Guid used by ZooClient to identify the license saved by ZooClient. This differs from ProductGuid because different versions of a plug-in\n     with the same Plug-in ID may need different licenses.",since:6},{signature:"OnLeaseChangedDelegate OnLeaseChanged",summary:"Delegate called by ZooClient when a cloud zoo lease is changed",since:6},{signature:"object ParentWindow",summary:"Parent window assigned to any licensing dialogs that appear. If null, the Rhino main window is used.",since:6},{signature:"int ProductBuildType",summary:"Product build type. Must be one of LicenseBuildType values.",since:6},{signature:"Guid ProductGuid",summary:"Guid used by ZooClient to identify the plug-in requesting a license from ZooClient. This Guid may be used by different versions of the\n     plug-in. If different licenses are used by different versions of the plug-in, the plug-in must also specify a LicenseGuid.",since:6},{signature:"string ProductPath",summary:"Path to the application calling ZooClient",since:6},{signature:"string ProductTitle",summary:'Title of the product, "Rhinoceros 6" for example.',since:6},{signature:"LicenseTypes SelectedLicenseType",summary:"License type selected by default when user is prompted to enter a license key",since:6}],methods:[{signature:"ValidateResult VerifyLicenseKey(string licenseKey,string validationCode,DateTime validationCodeInstallDate,bool gracePeriodExpired,LicenseData licenseData)",summary:"Called by GetLicense to ensure that the license key entered by the user is legitimate and can be used.",since:6},{signature:"bool VerifyPreviousVersionLicense(string license,string previousVersionLicense,string errorMessage)",summary:"When a caller calls GetLicense, ZooClient may call VerifyPreviousVersionLicense to ensure \n     previousVersionLicense is legitimate and can be used to upgrade license.",since:6}]},{name:"Rhino.ScaleValue",dataType:1,summary:'Represents a scale with associated LengthValues and string representations\n   of the scale. This allows for going back and forth from numerical\n   representations of a scale and a string representation without "guessing"\n   at the initial scale.',constructors:[{signature:"ScaleValue()",summary:"Default constructor",since:6}],properties:[{signature:"double LeftToRightScale",summary:"LeftLengthValue / RightLengthValue",since:6},{signature:"double RightToLeftScale",summary:"RightLengthValue / LeftLengthValue",since:6}],methods:[{signature:"static ScaleValue Create(LengthValue left,LengthValue right,ScaleStringFormat format)",summary:"Create from 2 length values",since:6},{signature:"static ScaleValue Create(string s,StringParserSettings ps)",summary:"Create from string",since:6},{signature:"static ScaleValue OneToOne()",summary:"Make a new ScaleValue set to OneToOne",since:6},{signature:"void Dispose()",summary:"actively reclaim native allocated ON_SacleValue*",since:6},{signature:"bool IsUnset()",summary:"Test IsUnset",since:6},{signature:"LengthValue LeftLengthValue()",summary:"Get the Left LengthValue from Scale",since:6},{signature:"LengthValue RightLengthValue()",summary:"Get the Right LengthValue from Scale",since:6}]},{name:"Rhino.Symbols",dataType:1,summary:"Characters used for different 'drafting style' symbols",properties:[{signature:"static char DegreeSymbol",summary:"Degree symbol used for angles",since:6},{signature:"static char DiameterSymbol",summary:"Diameter symbol",since:6},{signature:"static char PlusMinusSymbol",summary:"Plus-Minus tolerance symbol",since:6},{signature:"static char RadiusSymbol",summary:"Radius symbol",since:6}]},{name:"Rhino.UI.Controls.CollapsibleSectionHolderImpl",dataType:1,summary:"",constructors:[{signature:"CollapsibleSectionHolderImpl(ICollapsibleSectionHolder client)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"static ICollapsibleSectionHolder Find(IntPtr cpp)",since:6},{signature:"static ICollapsibleSectionHolder NewNativeWrapper(IntPtr cpp)",since:6},{signature:"void Dispose()",since:6},{signature:"bool IsSameObject(IntPtr cpp)",since:6}]},{name:"Rhino.UI.Controls.CollapsibleSectionImpl",dataType:1,summary:"",constructors:[{signature:"CollapsibleSectionImpl(ICollapsibleSection section)",since:6}],properties:[{signature:"IntPtr CppPointer",since:6},{signature:"IRdkViewModel ViewModel",since:6}],methods:[{signature:"static void CreateHostedSection(ICollapsibleSection section)",since:6},{signature:"static ICollapsibleSection Find(IntPtr cpp)",since:6},{signature:"static ICollapsibleSection GetSibling(ICollapsibleSection section,Guid siblingSectionId)",since:6},{signature:"static ICollapsibleSection[] GetSiblings(ICollapsibleSection section)",since:6},{signature:"static ICollapsibleSection NewNativeWrapper(IntPtr cpp)",since:6},{signature:"void __InternalSetParent(IntPtr parent)",since:6},{signature:"void Dispose()",since:6},{signature:"bool IsSameObject(IntPtr cpp)",since:6},{signature:"void ReplaceClient(ICollapsibleSection client)",since:6}],events:[{signature:"DataChanged",since:6},{signature:"ViewModelActivated",since:6}]},{name:"Rhino.UI.Controls.CollapsibleSectionImpl.Factory",dataType:1,summary:""},{name:"Rhino.UI.Controls.CollapsibleSectionViewModel",dataType:1,summary:"Derive from this class to implement your own view model that wraps around a built\n   in implementation of IRdkViewModel.  Use GetData etc to implement your properties.",constructors:[{signature:"CollapsibleSectionViewModel(ICollapsibleSection section)",summary:"Construct from your section - the view model should be a member of the section",since:6}],properties:[{signature:"IntPtr CppPointer",since:6}],methods:[{signature:"void Commit(Guid uuidDataType)",since:6},{signature:"void Discard(Guid uuidDataType)",since:6},{signature:"object GetData(Guid uuidDataType,bool bForWrite,bool bAutoChangeBracket)",summary:"Call for an interface to data",since:6},{signature:"UndoRecord UndoHelper(string description)",summary:"Helper function to ease the use of undo records",since:6,returns:"Return the undo record"}]},{name:"Rhino.UI.Controls.DataSource.EventArgs",dataType:1,summary:"",properties:[{signature:"Guid DataType",since:6}]},{name:"Rhino.UI.Controls.DataSource.EventInfoArgs",dataType:1,summary:"",properties:[{signature:"Guid DataType",since:6},{signature:"IntPtr EventInfoPtr",since:6}]},{name:"Rhino.UI.Controls.DataSource.ProviderIds",dataType:1,summary:"",properties:[{signature:"static Guid ContentChildSlot",since:6.1},{signature:"static Guid ContentDatabase",since:6},{signature:"static Guid ContentDisplayCollection",since:6},{signature:"static Guid ContentEditorSettings",since:6},{signature:"static Guid ContentLookup",since:6},{signature:"static Guid ContentParam",since:6},{signature:"static Guid ContentPreviewRendered",since:6},{signature:"static Guid ContentSelection",since:6},{signature:"static Guid ContentUIs",since:6},{signature:"static Guid ContentUpdatePreviewMarkersEventInfo",since:6},{signature:"static Guid CurrentEnvironment",since:6},{signature:"static Guid Decals",since:6.5},{signature:"static Guid Dithering",since:6},{signature:"static Guid GroundPlane",since:6},{signature:"static Guid ImageFileInfo",since:6.2},{signature:"static Guid LinearWorkflow",since:6},{signature:"static Guid NamedItem",since:6.1},{signature:"static Guid NewContentControlAssignBy",since:6},{signature:"static Guid NullGuid",since:6},{signature:"static Guid PreviewSettings",since:6},{signature:"static Guid RdkEdit",since:6.5},{signature:"static Guid RdkRendering",since:6.8},{signature:"static Guid RdkRenderingGamma",since:6.8},{signature:"static Guid RdkRenderingPostEffectDOF",since:6.1},{signature:"static Guid RdkRenderingPostEffectFog",since:6.1},{signature:"static Guid RdkRenderingPostEffectGlare",since:6.1},{signature:"static Guid RdkRenderingPostEffectGlow",since:6.1},{signature:"static Guid RdkRenderingPostEffects",since:6.8},{signature:"static Guid RdkRenderingProgress",since:6.8},{signature:"static Guid RdkRenderingToneMapping",since:6.8},{signature:"static Guid RhinoSettings",since:6},{signature:"static Guid SelectionNavigator",since:6},{signature:"static Guid Skylight",since:6},{signature:"static Guid Sun",since:6},{signature:"static Guid Undo",since:6.11},{signature:"static Guid UndoRecord",since:6}]},{name:"Rhino.UI.Controls.Delegates",dataType:1,summary:""},{name:"Rhino.UI.Controls.FactoryBase",dataType:1,summary:"Base class for CollapsibleSection and ViewModel factories used by the RDK UI",methods:[{signature:"static Type[] Register()",summary:"Call this function during startup of current assembly to load classes with factory creation support\n         are registed",since:6},{signature:"static Type[] Register(PlugIn plugin)",summary:"Call this function during the startup of your plug-in to ensure that all classes that support factory creation\n         are registed",since:6},{signature:"IntPtr Get(Guid id)",summary:"Override this method to return a new instance of your class for the given ID",since:6}]},{name:"Rhino.UI.Controls.ICollapsibleSection",dataType:4,summary:""},{name:"Rhino.UI.Controls.ICollapsibleSectionHolder",dataType:4,summary:""},{name:"Rhino.UI.Controls.IHasCppImplementation",dataType:4,summary:""},{name:"Rhino.UI.Controls.InternalRdkViewModel.EventPriority",dataType:3,summary:""},{name:"Rhino.UI.Controls.InternalRdkViewModel.NewUndoRecord",dataType:1,summary:""},{name:"Rhino.UI.Controls.InternalRdkViewModel.UndoHelper",dataType:1,summary:""},{name:"Rhino.UI.Controls.InternalRdkViewModelFactory",dataType:1,summary:""},{name:"Rhino.UI.Controls.IRdkViewModel",dataType:4,summary:""},{name:"Rhino.UI.Controls.IWindow",dataType:4,summary:""},{name:"Rhino.UI.Controls.Thumbnaillist.ThumbnailList",dataType:1,summary:"",constructors:[{signature:"ThumbnailList()"}],properties:[{signature:"ContentEditingContext CEC"},{signature:"bool Created"},{signature:"bool Enabled"},{signature:"string EnglishCaption"},{signature:"bool Hidden"},{signature:"IntPtr HolderParent"},{signature:"string LocalCaption"},{signature:"bool Shown"},{signature:"RdkThumbnaillistViewModel ViewModel"}],methods:[{signature:"void Add(IRhRdkThumbnail t)"},{signature:"void Clear()"},{signature:"Rhino.Render.RenderContent ContentFromThumbId(Guid uuidThumb)"},{signature:"IRhRdkThumbnail Get(Guid u)"},{signature:"void GetGridMetrics(int w,int h,int ox,int oy)"},{signature:"IRhRdkContentThumbnailList_Sizes GetSize()"},{signature:"void GetStatisticsHeaderHeight()"},{signature:"IRhRdkThumbnailList_Modes Mode()"},{signature:"void Move(Rectangle rect,bool bRepaint,bool bRepaintNC)"},{signature:"bool PropagateSelectedAppearance()"},{signature:"void SaveMetaDataToDocument()"},{signature:"Rhino.Render.PreviewAppearance SelectedAppearance()"},{signature:"void SetClientText(string w)"},{signature:"void SetCustomBitmapSize(int w,int h)"},{signature:"void SetMode(IRhRdkThumbnailList_Modes m,bool b)"},{signature:"void SetSearchPattern(string w)"},{signature:"void SetSettingsPath(string w)"},{signature:"void SetShowLabels(bool b)"},{signature:"IRhRdkThumbnailList_Shapes Shape()"},{signature:"bool ShowLabels()"},{signature:"Guid UUID()"},{signature:"void ViewModelActivated()"}]},{name:"Rhino.UI.Controls.Thumbnaillist.ThumbnailList.IHandler",dataType:4,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.IRhRdkContentThumbnail",dataType:4,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.IRhRdkContentThumbnailList_Sizes",dataType:3,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.IRhRdkThumbnail",dataType:4,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.IRhRdkThumbnailList",dataType:4,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.IRhRdkThumbnailList_Modes",dataType:3,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.IRhRdkThumbnailList_Shapes",dataType:3,summary:""},{name:"Rhino.UI.Controls.ThumbnailUI.ThumbData",dataType:1,summary:"",properties:[{signature:"List<ThumbData> Children",since:6},{signature:"RenderContent Content",since:6},{signature:"Guid Id",since:6},{signature:"Bitmap Image",since:6},{signature:"string Intensity",since:6},{signature:"bool InUse",since:6},{signature:"Color4f> InUseColor",since:6},{signature:"string Name",since:6},{signature:"ThumbData Parent",since:6},{signature:"PreviewAppearance PreviewAppearance",since:6},{signature:"bool Selected",since:6},{signature:"List<string> Tags",since:6},{signature:"bool TopLevel",since:6},{signature:"string Type",since:6}],methods:[{signature:"static int GetPreviewHeigth(Sizes thumb_size,Shapes shape)",since:6},{signature:"static int GetPreviewWidth(Sizes thumb_size,Shapes shape)",since:6}]},{name:"Rhino.UI.Controls.ThumbnailUI.Thumbnail",dataType:1,summary:"",constructors:[{signature:"Thumbnail(IntPtr pRdkThumbnail)",summary:"Constructor for Thumbnail",since:6}],properties:[{signature:"IntPtr CppPointer",summary:"Thumbnail c++ pointer",since:6}],methods:[{signature:"void Dib(Bitmap dibOut)",since:6},{signature:"void Dispose()",summary:"Dispose for Thumbnail",since:6},{signature:"System.Drawing.Bitmap GetDib()",since:6},{signature:"void GetDisplayRect(RectangleF rectOut)",since:6},{signature:"Guid Id()",since:6},{signature:"bool IsHot()",since:6},{signature:"bool IsSelected()",since:6},{signature:"string Label()",since:6}]},{name:"Rhino.UI.Controls.ThumbnailUI.ThumbnailViewModelFactory",dataType:1,summary:"",constructors:[{signature:"ThumbnailViewModelFactory()",since:6}],methods:[{signature:"IntPtr Get(Guid id)",since:6}]},{name:"Rhino.UI.Controls.UndoRecord",dataType:1,summary:"Undo Record",constructors:[{signature:"UndoRecord(string description,IRdkViewModel viewModel)",summary:"UndoRecord Constructor",since:6}],methods:[{signature:"void Dispose()",summary:"UndoRecord Dispose",since:6}]},{name:"Rhino.UI.Dialogs",dataType:1,summary:"",methods:[{signature:"static void KillSplash()",summary:"Destroy the splash screen if it is being displayed.",since:5},{signature:"static void SetCustomColorDialog(EventHandler<GetColorEventArgs> handler)",since:5},{signature:"static void ShowAboutDialog(bool forceSimpleDialog)",since:6},{signature:"static bool[] ShowCheckListBox(string title,string message,IList items,IList<bool> checkState)",summary:"Displays Rhino's check list box.",since:5,returns:"An array or boolean values determining if the user checked the corresponding box. On error, null."},{signature:"static bool ShowColorDialog(Color color)",summary:"Display Rhino's color selection dialog.",since:5,returns:"True if the color changed. False if the color has not changed or the user pressed cancel."},{signature:"static bool ShowColorDialog(Color color,bool includeButtonColors,string dialogTitle)",summary:"Display Rhino's color selection dialog.",since:5,returns:"True if the color changed. False if the color has not changed or the user pressed cancel."},{signature:"static bool ShowColorDialog(Color4f color,bool allowAlpha)",summary:"Displays the standard modal color picker dialog for floating point colors.",since:5,returns:"True if a color was picked, False if the user canceled the picker dialog."},{signature:"static bool ShowColorDialog(IWin32Window parent,Color4f color,bool allowAlpha)",summary:"Displays the standard modal color picker dialog for floating point colors.",since:5,returns:"True if a color was picked, False if the user canceled the picker dialog."},{signature:"static bool ShowColorDialog(object parent,Color4f color,bool allowAlpha)",summary:"Displays the standard modal color picker dialog for floating point colors.",since:6,returns:"True if a color was picked, False if the user canceled the picker dialog."},{signature:"static bool ShowColorDialog(object parent,Color4f color,bool allowAlpha,OnColorChangedEvent colorCallback)",summary:"Displays the standard modal color picker dialog for floating point colors.",since:6,returns:"True if a color was picked, False if the user canceled the picker dialog."},{signature:"static object ShowComboListBox(string title,string message,IList items)",summary:"Displays Rhino's combo list box.",since:5,returns:"selected item.None if the user canceled."},{signature:"static int ShowContextMenu(IEnumerable<string> items,Point screenPoint,IEnumerable<int> modes)",summary:"Creates an ETO ContextMenu from an array of strings. Use the modes array to enable/disable menu items",since:5},{signature:"static bool ShowEditBox(string title,string message,string defaultText,bool multiline,string text)",summary:"Displays Rhino's string edit box.",since:5,returns:"True of OK was clicked, False otherwise."},{signature:"static object ShowLineTypes(string title,string message,RhinoDoc doc)",summary:"Displays Rhino's LineType list box.",since:6.7,returns:"The id of the selected item if successful, None on cancel."},{signature:"static object ShowListBox(string title,string message,IList items)",summary:"Displays Rhino's list box.",since:5,returns:"The selected item if successful, None on cancel."},{signature:"static object ShowListBox(string title,string message,IList items,object selectedItem)",summary:"Displays Rhino's list box.",since:5,returns:"The selected item if successful, None on cancel."},{signature:"static ShowMessageResult ShowMessage(object parent,string message,string title,ShowMessageButton buttons,ShowMessageIcon icon,ShowMessageDefaultButton defaultButton,ShowMessageOptions options,ShowMessageMode mode)",summary:"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.",since:6,returns:"One of the ShowMessageBoxResult values."},{signature:"static ShowMessageResult ShowMessage(string message,string title)",summary:"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.",since:6,returns:"One of the ShowMessageBoxResult values."},{signature:"static ShowMessageResult ShowMessage(string message,string title,ShowMessageButton buttons,ShowMessageIcon icon)",summary:"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.",since:6,returns:"One of the ShowMessageBoxResult values."},{signature:"static System.Windows.Forms.DialogResult ShowMessageBox(string message,string title)",summary:"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.",since:5},{signature:"static System.Windows.Forms.DialogResult ShowMessageBox(string message,string title,MessageBoxButtons buttons,MessageBoxIcon icon)",summary:"Same as System.Windows.Forms.MessageBox.Show but using a message box tailored to Rhino.",since:5},{signature:"static string[] ShowMultiListBox(string title,string message,IList<string> items,IList<string> defaults)",summary:"Displays Rhino's multiple selection list box.",since:5.12,returns:"The selected items if successful, None on cancel."},{signature:"static bool ShowNumberBox(string title,string message,double number)",summary:"Displays Rhino's number edit box.",since:5,returns:"True of OK was clicked, False otherwise."},{signature:"static bool ShowNumberBox(string title,string message,double number,double minimum,double maximum)",summary:"Displays Rhino's number edit box.",since:5,returns:"True of OK was clicked, False otherwise."},{signature:"static string[] ShowPropertyListBox(string title,string message,IList items,IList<string> values)",summary:"Displays Rhino's property list box.",since:5,returns:"A list of property values if successful, None otherwise."},{signature:"static bool ShowSelectLayerDialog(int layerIndex,string dialogTitle,bool showNewLayerButton,bool showSetCurrentButton,bool initialSetCurrentState)",summary:"Displays Rhino's single layer selection dialog.",since:5,returns:"True if the dialog was closed with the OK button. False if the dialog was closed with escape."},{signature:"static bool ShowSelectLinetypeDialog(int linetypeIndex,bool displayByLayer)",summary:"Displays Rhino's single linetype selection dialog.",since:6,returns:"True if the dialog was closed with the OK button. False if the dialog was closed with escape."},{signature:"static bool ShowSelectMultipleLayersDialog(IEnumerable<int> defaultLayerIndices,string dialogTitle,bool showNewLayerButton,int[] layerIndices)",since:5.9,returns:"True if the dialog was closed with the OK button. False if the dialog was closed with escape."},{signature:"static System.Windows.Forms.DialogResult ShowSemiModal(Form form)",summary:"Show a windows form that is modal in the sense that this function does not return until\n       the form is closed, but also allows for interaction with other elements of the Rhino\n       user interface.",since:5,returns:"One of the System.Windows.Forms.DialogResult values."},{signature:"static bool ShowSunDialog(Sun sun)",summary:"Show the tabbed sun dialog.",since:6,returns:"Returns True if the user clicked OK, or False if the user cancelled."},{signature:"static void ShowTextDialog(string message,string title)",summary:'Display a text dialog similar to the dialog used for the "What" command.',since:5}]},{name:"Rhino.UI.DistanceDisplayMode",dataType:3,summary:""},{name:"Rhino.UI.DrawingUtilities",dataType:1,summary:"RhinoCommon Drawing Utilities",methods:[{signature:"static Bitmap BitmapFromIconResource(string resourceName,Assembly assembly)",summary:"Load a Icon from an embedded resource and convert it to a bitmap of the\n     specified size.  Will look for a icon image that is greater than or\n     equal to the requested size, if all images are less than the requested\n     size the largest image will be used.",since:6.12},{signature:"static Bitmap BitmapFromIconResource(string resourceName,Size bitmapSize,Assembly assembly)",summary:"Load a Icon from an embedded resource and convert it to a bitmap of the\n     specified size.  Will look for a icon image that is greater than or\n     equal to the requested size, if all images are less than the requested\n     size the largest image will be used.",since:6},{signature:"static Bitmap CreateMeshPreviewImage(IEnumerable<Mesh> meshes,IEnumerable<Color> colors,Size size)",summary:"Creates a preview image of one or more meshs.",since:6,returns:"A bitmap if successful, None othewise."},{signature:"static Bitmap CreateMeshPreviewImage(Mesh mesh,Color color,Size size)",summary:"Creates a preview image of a mesh.",since:6,returns:"A bitmap if successful, None othewise."},{signature:"static Icon IconFromResource(string resourceName,Assembly assembly)",summary:"Load a Icon from an embedded resource.",since:6,returns:"The Icon resource if found and loaded otherwise null."},{signature:"static Icon IconFromResource(string resourceName,Size size,Assembly assembly)",summary:"Load a Icon from an embedded resource.",since:6,returns:"The Icon resource if found and loaded otherwise null."},{signature:"static Image ImageFromResource(string resourceName,Assembly assembly)",summary:"Load a Image from an embedded resource.",since:6,returns:"The Image resource if found and loaded otherwise null."},{signature:"static Bitmap LoadBitmapWithScaleDown(string iconName,int sizeDesired,Assembly assembly)",summary:"Loads an icon from an embedded resource and converts it to a bitmap.\n     If the icon is not a standard size, this function scales down a larger\n     image.",since:6,returns:"The icon converted to a bitmap if successful, None otherwise."},{signature:"static Icon LoadIconWithScaleDown(string iconName,int sizeDesired,Assembly assembly)",summary:"Loads an icon from an embedded resource.\n     If the icon is not a standard size, this function scales down a larger\n     image.",since:6,returns:"The icon if successful, None otherwise."}]},{name:"Rhino.UI.Fonts",dataType:1,summary:"Rhino.Rumtime.UI",properties:[{signature:"static Font BoldHeadingFont",summary:"Returns a font that is 1.2x NormalFont and Bold",since:6},{signature:"static Font HeadingFont",summary:"Returns a font used for dialog headings. 1.2x the size of NormalFont.",since:6},{signature:"static Font NormalFont",summary:"Returns the normal font used for dialog boxes and buttons.",since:6},{signature:"static Font SmallFont",summary:"Returns a font use for small text in dialog boxes. 0.8x the size of NormalFont.",since:6},{signature:"static Font TitleFont",summary:"Returns a font used for dialog titles. 2x the size of NormalFont, and bold.",since:6}],methods:[{signature:"static Font GetUiFont(Style style,Size size)",summary:"GetUiFont provides access to a set of unmanaged fonts used by Rhino.",since:6}]},{name:"Rhino.UI.GetColorEventArgs",dataType:1,summary:"",properties:[{signature:"bool IncludeButtonColors",since:5},{signature:"Color InputColor",since:5},{signature:"Color SelectedColor",since:5},{signature:"string Title",since:5}]},{name:"Rhino.UI.Gumball.GumballAppearanceSettings",dataType:1,summary:"",constructors:[{signature:"GumballAppearanceSettings()",since:5}],properties:[{signature:"int ArcThickness",summary:"in pixels.",since:5},{signature:"int ArrowHeadLength",summary:"in pixels.",since:5},{signature:"int ArrowHeadWidth",summary:"in pixels.",since:5},{signature:"int AxisThickness",summary:"in pixels.",since:5},{signature:"Color ColorMenuButton",since:5},{signature:"Color ColorX",summary:"Default is Red.",since:5},{signature:"Color ColorY",summary:"Default is Green.",since:5},{signature:"Color ColorZ",summary:"Default is Blue.",since:5},{signature:"int FreeTranslate",summary:"When FreeTranslate is 1, the center translation control can be dragged\n     in any direction and moves the object the gumball controls. When\n     FreeTranslate is 2, the center translation control can be dragged in any\n     direction and moves the object the gumball itself. The default value is 2.",since:5},{signature:"int MenuDistance",summary:"Distance of menu ball from center.",since:5},{signature:"bool MenuEnabled",summary:'When MenuEnabled is true, the menu "button" is drawn on the gumball.\n     The default setting is true.',since:5},{signature:"int MenuSize",summary:"Radius of menu circle.",since:5},{signature:"int PlanarTranslationGripCorner",summary:"in pixels.",since:5},{signature:"int PlanarTranslationGripSize",summary:"in pixels.",since:5},{signature:"int Radius",summary:"in pixels.",since:5},{signature:"bool RelocateEnabled",summary:"When RelocateEnabled is true, the user can reposition the gumball by\n     tapping the control key while dragging.  Once the repostion drag is\n     terminated by releasing the/ mouse button, ordinary editing resumes.\n     The default setting is true.",since:5},{signature:"bool RotateXEnabled",summary:"When RotateX is true, the X rotation control is available. The default\n     setting is true.",since:5},{signature:"bool RotateYEnabled",summary:"When RotateY is true, the Y rotation control is available. The default\n     setting is true.",since:5},{signature:"bool RotateZEnabled",summary:"When RotateZ is true, the Z rotation control is available. The default\n     setting is true.",since:5},{signature:"int ScaleGripSize",summary:"in pixels.",since:5},{signature:"bool ScaleXEnabled",summary:"When ScaleXEnabled is true, the X scale control is available. The\n     default setting is true.",since:5},{signature:"bool ScaleYEnabled",summary:"When ScaleYEnabled is true, the Y scale control is available. The\n     default setting is true.",since:5},{signature:"bool ScaleZEnabled",summary:"When ScaleZEnabled is true, the Z scale control is available. The\n     default setting is true.",since:5},{signature:"bool TranslateXEnabled",summary:"TranslateXEnabled is true, the X axis translation control is available.\n     The default setting is true.",since:5},{signature:"bool TranslateXYEnabled",summary:"When TranslateXY is true, the XY plane translation control is available\n     in appropriate views. The default setting is true.",since:5},{signature:"bool TranslateYEnabled",summary:"TranslateYEnabled is true, the Y axis translation control is available.\n     The default setting is true.",since:5},{signature:"bool TranslateYZEnabled",summary:"When TranslateYZ is true, the YZ plane translation control is available\n     in appropriate views. The default setting is true.",since:5},{signature:"bool TranslateZEnabled",summary:"TranslateZEnabled is true, the Z axis translation control is available.\n     The default setting is true.",since:5},{signature:"bool TranslateZXEnabled",summary:"When TranslateZX is true, the ZX plane translation control is available\n     in appropriate views. The default setting is true.",since:5}]},{name:"Rhino.UI.Gumball.GumballDisplayConduit",dataType:1,summary:"",constructors:[{signature:"GumballDisplayConduit()",since:5}],properties:[{signature:"GumballObject BaseGumball",summary:"Starting location.",since:5},{signature:"bool Enabled",since:5},{signature:"GumballObject Gumball",since:5},{signature:"Transform GumballTransform",summary:"The gumball transformation is the transformation calculated by comparing\n     the current gumball to the starting BaseGumball.",since:5},{signature:"bool InRelocate",since:5},{signature:"GumballPickResult PickResult",summary:"The inital mouse down event sets PickResult.",since:5},{signature:"Transform PreTransform",summary:"The pre-transform is a transformation that needs to be applied before\n     the gumball transformation.",since:5},{signature:"Transform TotalTransform",summary:"The total transformation is GumballTransform * PreTransform.",since:5}],methods:[{signature:"void CheckShiftAndControlKeys()",since:5},{signature:"void Dispose()",since:5},{signature:"bool PickGumball(PickContext pickContext,GetPoint getPoint)",since:5},{signature:"void SetBaseGumball(GumballObject gumball)",summary:"Contents of the gumball are copied to the base gumball of this class.",since:5},{signature:"void SetBaseGumball(GumballObject gumball,GumballAppearanceSettings appearanceSettings)",summary:"Contents of the gumball are copied to the base gumball of this class.",since:5},{signature:"bool UpdateGumball(Point3d point,Line worldLine)",since:5}]},{name:"Rhino.UI.Gumball.GumballFrame",dataType:2,summary:"",properties:[{signature:"Plane Plane",since:5},{signature:"Vector3d ScaleGripDistance",since:5},{signature:"GumballScaleMode ScaleMode",since:5}]},{name:"Rhino.UI.Gumball.GumballMode",dataType:3,summary:"Transformation modes for gumballs."},{name:"Rhino.UI.Gumball.GumballObject",dataType:1,summary:"",constructors:[{signature:"GumballObject()",since:5}],properties:[{signature:"GumballFrame Frame",since:5}],methods:[{signature:"void Dispose()",since:5},{signature:"bool SetFromArc(Arc arc)",since:5},{signature:"bool SetFromBoundingBox(BoundingBox boundingBox)",since:5},{signature:"bool SetFromBoundingBox(Plane frame,BoundingBox frameBoundingBox)",summary:"Sets the gumball bounding box with respect to a frame.",since:5,returns:"True if input is valid and gumball is set. False if input is not valid.\n     In this case, gumball is set to the default."},{signature:"bool SetFromCircle(Circle circle)",since:5},{signature:"bool SetFromCurve(Curve curve)",since:5},{signature:"bool SetFromEllipse(Ellipse ellipse)",since:5},{signature:"bool SetFromExtrusion(Extrusion extrusion)",since:5},{signature:"bool SetFromHatch(Hatch hatch)",since:5},{signature:"bool SetFromLight(Light light)",since:5},{signature:"bool SetFromLine(Line line)",since:5},{signature:"bool SetFromPlane(Plane plane)",since:5}]},{name:"Rhino.UI.Gumball.GumballPickResult",dataType:1,summary:"",properties:[{signature:"GumballMode Mode",since:5}],methods:[{signature:"void SetToDefault()",since:5}]},{name:"Rhino.UI.Gumball.GumballScaleMode",dataType:3,summary:""},{name:"Rhino.UI.IDialogService",dataType:4,summary:""},{name:"Rhino.UI.IHelp",dataType:4,summary:"Implement this class to add help to a modeless UI panel."},{name:"Rhino.UI.ILocalizationService",dataType:4,summary:""},{name:"Rhino.UI.IPanel",dataType:4,summary:""},{name:"Rhino.UI.IPanelsService",dataType:4,summary:"For internal use, the IPanels service is implemented in RhinoWindows\n     or RhinoMac as appropriate and handles the communication with core\n     Rhino"},{name:"Rhino.UI.IRhinoUiDialogService",dataType:4,summary:"Used by Rhino.UI.Dialogs to access generic Eto dialogs from Rhino Common"},{name:"Rhino.UI.IStackedDialogPageService",dataType:4,summary:"For internal use, the IStackedDialogPageService service is implemented in\n   RhinoWindows or RhinoMac as appropriate and handles the communication\n   with core Rhino"},{name:"Rhino.UI.LOC",dataType:1,summary:"Used a placeholded which is used by LocalizationProcessor application to create contextId\n   mapped localized strings.",methods:[{signature:"static string COMMANDNAME(string english)",summary:"Command names that need to be localized should call this function. The COMMANDNAME function doesn't actually\n     do anything but return the original string. The LocalizationProcessor application walks\n     through the source code of a project and looks for LOC.COMMANDNAME and builds a record for each command\n     name for the translators that can be used by developers in a commands overridden Rhino.Commands.Command.LocalName\n     which should call Rhino.UI.Localization.LocalizeCommandName(EnglishName)",since:5},{signature:"static LocalizeStringPair CON(string english)",summary:"Command option name strings that need to be localized should call this function. The CON function\n     doesn't actually do anything but return the original string. The LocalizationProcessor application walks\n     through the source code of a project and looks for LOC.CON. The function is then replaced with a\n     call to Localization.LocalizeCommandOptionName using a unique context ID.",since:5,returns:"Returns localized string pair with both the English and local names set to the English value."},{signature:"static LocalizeStringPair CON(string english,object assemblyFromObject)",summary:"Command option name strings that need to be localized should call this function. The CON function\n     doesn't actually do anything but return the original string. The LocalizationProcessor application walks\n     through the source code of a project and looks for LOC.CON. The function is then replaced with a\n     call to Localization.LocalizeCommandOptionName using a unique context ID.",since:5,returns:"Returns localized string pair with both the English and local names set to the English value."},{signature:"static LocalizeStringPair COV(string english)",summary:"Command option name strings that need to be localized should call this function. The COV function\n     doesn't actually do anything but return the original string. The LocalizationProcessor application walks\n     through the source code of a project and looks for LOC.COV. The function is then replaced with a\n     call to Localization.LocalizeCommandOptionValue using a unique context ID.",since:5,returns:"Returns localized string pair with both the English and local names set to the English value."},{signature:"static LocalizeStringPair COV(string english,object assemblyFromObject)",summary:"Command option name strings that need to be localized should call this function. The COV function\n     doesn't actually do anything but return the original string. The LocalizationProcessor application walks\n     through the source code of a project and looks for LOC.COV. The function is then replaced with a\n     call to Localization.LocalizeCommandOptionValue using a unique context ID.",since:5,returns:"Returns localized string pair with both the English and local names set to the English value."},{signature:"static string STR(string english)",summary:"Strings that need to be localized should call this function. The STR function doesn't actually\n     do anything but return the original string. The LocalizationProcessor application walks\n     through the source code of a project and looks for LOC.STR. The function is then replaced with a\n     call to Localization.LocalizeString using a unique context ID.",since:5},{signature:"static string STR(string english,object assemblyOrObject)",summary:"Similar to  function.",since:5,returns:"English name."}]},{name:"Rhino.UI.Localization",dataType:1,summary:"",properties:[{signature:"static int CurrentLanguageId",since:6},{signature:"static bool RunningAsEnglish",since:6}],methods:[{signature:"static string FormatArea(double area,UnitSystem units,DimensionStyle dimStyle,bool alternate)",summary:"Format an Area string from a number",since:7},{signature:"static string FormatDistanceAndTolerance(double distance,UnitSystem units,DimensionStyle dimStyle,bool alternate)",since:7},{signature:"static string FormatNumber(double x,UnitSystem units,DistanceDisplayMode mode,int precision,bool appendUnitSystemName)",summary:"Get a string version of a number in a given unit system / display mode.",since:5,returns:"The formatted number."},{signature:"static string FormatVolume(double volume,UnitSystem units,DimensionStyle dimStyle,bool alternate)",summary:"Format a Volume string from a number",since:7},{signature:"static string LocalizeCommandName(string english)",summary:"Commands that need to be localized should call this function.",since:5},{signature:"static string LocalizeCommandName(string english,object assemblyOrObject)",since:5},{signature:"static LocalizeStringPair LocalizeCommandOptionName(string english,int contextId)",since:5},{signature:"static LocalizeStringPair LocalizeCommandOptionName(string english,object assemblyOrObject,int contextId)",since:5},{signature:"static LocalizeStringPair LocalizeCommandOptionValue(string english,int contextId)",since:5},{signature:"static LocalizeStringPair LocalizeCommandOptionValue(string english,object assemblyOrObject,int contextId)",since:5},{signature:"static string LocalizeDialogItem(object assemblyOrObject,string key,string english)",summary:"Look in the dialog item list for the specified key and return the translated\n     localized string if the key is found otherwise return the English string.",since:5.5,returns:"Look in the dialog item list for the specified key and return the translated\n     localized string if the key is found otherwise return the English string."},{signature:"static void LocalizeForm(object formOrUserControl)",summary:"Look in the dialog item list for the specified key and return the translated\n     localized string if the key is found otherwise return the English string.",since:6},{signature:"static string LocalizeString(string english,int contextId)",summary:"Returns localized version of a given English string. This function should be autogenerated by the\n     RmaLDotNetLocalizationProcessor application for every function that uses RMASTR.",since:5,returns:"The localized string."},{signature:"static string LocalizeString(string english,object assemblyOrObject,int contextId)",summary:"Returns localized version of a given English string. This function should be autogenerated by the\n     RmaLDotNetLocalizationProcessor application for every function that uses RMASTR.",since:5,returns:"The localized string."},{signature:"static bool SetLanguageId(int id)",summary:"Sets the Id used for Localization in RhinoCommon.  Only useful for when\n     using RhinoCommon outside of the Rhino process",since:5,returns:"True if the language id could be set"},{signature:"static string UnitSystemName(UnitSystem units,bool capitalize,bool singular,bool abbreviate)",summary:"Gets localized unit system name.  Uses current application locale id.",since:5,returns:"The unit system name."}]},{name:"Rhino.UI.LocalizeStringPair",dataType:1,summary:"Pair of strings used for localization.",constructors:[{signature:"LocalizeStringPair(string english,string local)",since:5}],properties:[{signature:"string English",since:5},{signature:"string Local",since:5}],methods:[{signature:"string ToString()"}]},{name:"Rhino.UI.ModifierKey",dataType:3,summary:""},{name:"Rhino.UI.MouseButton",dataType:3,summary:""},{name:"Rhino.UI.MouseCallback",dataType:1,summary:"Used for intercepting mouse events in the Rhino views.",properties:[{signature:"bool Enabled",since:5}]},{name:"Rhino.UI.MouseCallbackEventArgs",dataType:1,summary:"",properties:[{signature:"MouseButtons Button",since:5},{signature:"bool CtrlKeyDown",since:6},{signature:"MouseButton MouseButton",since:6},{signature:"bool ShiftKeyDown",since:6},{signature:"RhinoView View",since:5},{signature:"Point ViewportPoint",since:5}]},{name:"Rhino.UI.MouseCursor",dataType:1,summary:"Contains static methods to control the mouse icon.",properties:[{signature:"static Point2d Location",summary:"Retrieves the position of the mouse cursor, in screen coordinates",since:5.8}],methods:[{signature:"static void SetToolTip(string tooltip)",summary:"Sets a cursor tooltip string shown next to the mouse cursor.\n     Overrides all cursor tooltip panes.",since:5}]},{name:"Rhino.UI.ObjectPropertiesPage",dataType:1,summary:"Base class used to add object property user interface panels",properties:[{signature:"bool AllObjectsMustBeSupported",summary:"Returns True when running on Mac which requires only objects of \n     SupportedTypes.  Returns False when running on Windows which only\n     requires a single item of SupportedTypes to be selected.\n     \n     Override if you wish to change the above behavior.",since:6.7},{signature:"string EnglishPageTitle",summary:"English string used to describe this page",since:5},{signature:"Icon Icon",summary:"(OBSOLETE - Override PageIcon instead)\n     Icon to display in the object properties tab control",since:5},{signature:"string LocalPageTitle",summary:"Localized page description string, returns the EnglishPageTitle by\n     default.",since:5},{signature:"object PageControl",summary:"The control that represents this page. Rhino Windows supports classes\n     that implement the IWin32Windows interface, are derived from\n     System.Windows.FrameworkElement or Eto.Forms.Control.  Mac Rhino\n     supports controls that are derived from NSview or Eto.Forms.Control.",since:5},{signature:"string PageIconEmbeddedResourceString",summary:"Resource string for a embedded icon resource in the assembly containing\n     the page instance.  If this returns a valid resource and Rhino can\n     load the icon the loaed icon will get used directly otherwise;\n     the PageIcon method will get called.",since:6.4},{signature:"PropertyPageType PageType",summary:"Override this and return the page you want to replace a specific object\n     properties page.",since:5.11},{signature:"RhinoObject[] SelectedObjects",summary:"Return a list of Rhino objects to be processed by this object properties page",since:5.11},{signature:"ObjectType SupportedTypes",summary:"Override to specify which objects this page supports",since:6},{signature:"bool SupportsSubObjects",summary:"If your object properties page supports sub-object selection, you\n     should override this method and return true.  This is ignored for view\n     pages.  The default implementation returns false.",since:6}],methods:[{signature:"bool AnySelectedObject()",summary:"Return True if any of the selected objects match the given type",since:6},{signature:"bool AnySelectedObject(bool allMustMatch)",summary:"Return True if any of the selected objects match the given type",since:6.7},{signature:"T[] GetSelectedObjects()",summary:"Get selected objects of a given type",since:6},{signature:"RhinoObject[] GetSelectedObjects(ObjectType filter)",summary:"Get selected objects that match a given filter",since:6},{signature:"void InitializeControls(RhinoObject rhObj)",summary:"Called on the active page after the selected objects list has changed\n     to notify the page to initialize its content to reflect the new\n     object list.",since:5},{signature:"void ModifyPage(Action<ObjectPropertiesPageEventArgs> callbackAction)",summary:"Call this method when the page is ready to modify the selected objects\n     list.  Rhino will suspend UpdatePageNotfictaion, call the passed action\n     then restore UpdatePageNotfictaion.",since:6},{signature:"bool OnActivate(bool active)",summary:"Called when this page is activated/deactivated.",since:5,returns:"If True then the page is hidden and the requested page is not\n    activated otherwise will not allow you to change the current page.\n    Default returns true.  The return value is currently ignored."},{signature:"void OnCreateParent(IntPtr hwndParent)",summary:"Called when the parent container is initially created.",since:5},{signature:"void OnHelp()",summary:"Called when the F1 key or help button is pressed, override to display\n     plug-in specific help for this page.",since:5},{signature:"void OnSizeParent(int width,int height)",summary:"Called when the parent containers client rectangle size has changed and\n     the PageControl has been resized.",since:5},{signature:"System.Drawing.Icon PageIcon(Size sizeInPixels)",summary:"Icon to display in the object properties tab control.  Will not get called\n     if PageIconEmbeddedResourceString is overriden and provides a string for a \n     successfully loaded icon resrouce.",since:6},{signature:"Commands.Result RunScript(ObjectPropertiesPageEventArgs e)",summary:"This method is called when scripting the Rhino Properties command and\n     choosing this page.",since:6},{signature:"Commands.Result RunScript(RhinoDoc doc,RhinoObject[] objectList)",summary:"This method is called when scripting the Rhino Properties command and\n     choosing this page.",since:6},{signature:"bool ShouldDisplay(ObjectPropertiesPageEventArgs e)",summary:"Called when the selected objects list changes, return True if the\n     object list contains one or more object the page can modify.",since:6},{signature:"bool ShouldDisplay(RhinoObject rhObj)",summary:"Called when the selected objects list changes, return True if the\n     object list contains one or more object the page can modify.",since:5},{signature:"void UpdatePage(ObjectPropertiesPageEventArgs e)",summary:"Called on the active page after the selected objects list has changed\n     to notify the page to initialize its content to reflect the new\n     object list.",since:6}]},{name:"Rhino.UI.ObjectPropertiesPageCollection",dataType:1,summary:"Passed to Rhino.PlugIns.PlugIn.ObjectPropertiesPages to allow a plug-in\n   to add custom ObjectPropertiesPage pages to the Rhino properties panel.",properties:[{signature:"RhinoDoc Document",summary:"Document associated with the Rhino properties panel.",since:7},{signature:"uint DocumentRuntimeSerailNumber",summary:"Document associated with the Rhino properties panel.",since:7}],methods:[{signature:"void Add(ObjectPropertiesPage page)",summary:"Custom page to add",since:7}]},{name:"Rhino.UI.ObjectPropertiesPageEventArgs",dataType:1,summary:"",constructors:[{signature:"ObjectPropertiesPageEventArgs(ObjectPropertiesPage page)",summary:"Used by  to notify the page when\n     updating, modifying or determining if the page should be included\n     in the navigation bar",since:6}],properties:[{signature:"uint DocRuntimeSerialNumber",summary:"Document containing the objects and views",since:6},{signature:"RhinoDoc Document",summary:"Document containing the objects and views",since:6},{signature:"uint EventRuntimeSerialNumber",summary:"Gets the runtime serial number.",since:6.14},{signature:"int ObjectCount",since:6},{signature:"RhinoObject[] Objects",summary:"Return a list of Rhino objects to be processed by this object properties page",since:6},{signature:"uint ObjectTypes",since:6},{signature:"ObjectPropertiesPage Page",summary:"The page sending these arguments",since:6},{signature:"RhinoView View",summary:"Active view",since:6},{signature:"RhinoViewport Viewport",summary:"Active viewport",since:6}],methods:[{signature:"T[] GetObjects()",summary:"Get selected objects of a given type",since:6},{signature:"RhinoObject[] GetObjects(ObjectType filter)",summary:"Get selected objects that match a given filter",since:6},{signature:"bool IncludesObjectsType()",summary:"Return True if any of the selected objects match the given type",since:6},{signature:"bool IncludesObjectsType(bool allMustMatch)",summary:"Return True if any of the selected objects match the given type",since:6.7},{signature:"bool IncludesObjectsType(ObjectType objectTypes)",since:6},{signature:"bool IncludesObjectsType(ObjectType objectTypes,bool allMustMatch)",since:6.7}]},{name:"Rhino.UI.OpenFileDialog",dataType:1,summary:"Similar to the System.Windows.Forms.OpenFileDialog, but with customized\n   Rhino user interface.",constructors:[{signature:"OpenFileDialog()",summary:"Create a new open file dialog.",since:5}],properties:[{signature:"string DefaultExt",summary:"The default file name extension. The returned string does not include the period.",since:5},{signature:"string FileName",summary:"Gets or sets a string containing the file name selected in the file dialog box.",since:5},{signature:"string[] FileNames",summary:"Gets the names of all of the selected files in the dialog box",since:5},{signature:"string Filter",summary:'Gets or sets the current file name filter string, which determines\n     the choices that appear in the "Save as file type" or "Files of type"\n     box in the dialog box. See System.Windows.Forms.FileDialog for details.',since:5},{signature:"string InitialDirectory",summary:"Gets or sets the initial directory displayed by the file dialog box.",since:5},{signature:"bool MultiSelect",summary:"Gets or sets a value indicating whether the dialog box allows multiple files to be selected",since:5},{signature:"string Title",summary:"Gets or sets the file dialog box title.",since:5}],methods:[{signature:"System.Windows.Forms.DialogResult ShowDialog()",since:5},{signature:"bool ShowOpenDialog()",summary:"Show the actual dialog to allow the user to select a file.",since:5.1,returns:"True if a file was selected. False if the dialog was cancelled"}]},{name:"Rhino.UI.OptionsDialogPage",dataType:1,summary:"",methods:[{signature:"Commands.Result RunScript(RhinoDoc doc,RunMode mode)",since:5}]},{name:"Rhino.UI.PanelEventArgs",dataType:1,summary:"Panels.Show event arguments",constructors:[{signature:"PanelEventArgs(Guid panelId,uint documentSerialNumber)",since:6}],properties:[{signature:"RhinoDoc Document",since:6},{signature:"uint DocumentSerialNumber",since:6},{signature:"Guid PanelId",summary:"Class Id for panel being shown or hidden",since:6}]},{name:"Rhino.UI.PanelIds",dataType:1,summary:"Standard Rhino panel Id's",properties:[{signature:"static Guid ContextHelp",summary:"Rhino context sensitive help panel.",since:5},{signature:"static Guid Display",since:5},{signature:"static Guid Environment",summary:"Rhino environment panel",since:5},{signature:"static Guid GroundPlane",summary:"Rhino ground plane panel",since:5},{signature:"static Guid Layers",summary:"Rhino Layer panel",since:5},{signature:"static Guid Libraries",summary:"Rhino render properties panel",since:5.9},{signature:"static Guid LightManager",summary:"Rhino light manager panel",since:5},{signature:"static Guid Materials",summary:"Rhino material browser",since:5},{signature:"static Guid Notes",summary:"Rhino notes panel",since:5.9},{signature:"static Guid ObjectProperties",summary:"Rhino object properties panel",since:5},{signature:"static Guid Rendering",summary:"Rhino rendering properties panel",since:6},{signature:"static Guid Sun",summary:"Rhino sun panel",since:5},{signature:"static Guid Texture",summary:"Rhino texture panel",since:5.3}]},{name:"Rhino.UI.Panels",dataType:1,summary:"Access to Rhino panels and register custom panels",properties:[{signature:"static string EtoPanelStyleName",summary:"Style applied to Eto controls hosted by the Rhino.UI.Panels and\n       Rhino.UI.ObjectProperties systems.",since:6.15},{signature:"static Size IconSize",summary:"Gets the panel icon size in logical units.",since:6.12},{signature:"static Size ScaledIconSize",summary:"Gets the panel icon size in pixels with DPI scaling applied.",since:6.12}],methods:[{signature:"static void ChangePanelIcon(Type panelType,Icon icon)",summary:"Update the icon used for a panel tab.",since:6},{signature:"static void ClosePanel(Guid panelId)",summary:"Will close or hide the specified panel type, in Windows Rhino, if it\n       is the only visible tab the tab dock bar will be closed as well.  In\n       Mac Rhino it will always close the modeless dialog hosting the panel.",since:5},{signature:"static void ClosePanel(Type panelType)",summary:"Will close or hide the specified panel type, in Windows Rhino, if it\n       is the only visible tab the tab dock bar will be closed as well.  In\n       Mac Rhino it will always close the modeless dialog hosting the panel.",since:5},{signature:"static bool FloatPanel(Guid panelTypeId,FloatPanelMode mode)",summary:"Mac support:\n         Display the specified panel in a floating window on Mac, the floating\n         window will only contain the specified panel.\n       \n       Windows support:\n         On Windows this will show or hide the floating continer containing the\n         specified panel.  If the tab is docked with other tabs it will be\n         floated in a new container.",since:6.2,returns:"Return true if the panel visibility state was changed, false otherwise."},{signature:"static bool FloatPanel(Type panelType,FloatPanelMode mode)",summary:"Mac support:\n         Display the specified panel in a floating window on Mac, the floating\n         window will only contain the specified panel.\n       \n       Windows support:\n         On Windows this will show or hide the floating continer containing the\n         specified panel.  If the tab is docked with other tabs it will be\n         floated in a new container.",since:6.2,returns:"Return true if the panel visibility state was changed, false otherwise."},{signature:"static Guid[] GetOpenPanelIds()",summary:"Get a list of the currently open panel tabs in Windows Rhino, on Mac\n       Rhino it will be a list of the currently visible modeless panel\n       dialogs.",since:5,returns:"Returns an array of panel class Id's for the currently open panels,\n       if there are no open panels it will be an empty array."},{signature:"static T GetPanel()",summary:"Return an instance of a .Net panel",since:6},{signature:"static object GetPanel(Guid panelId)",summary:"Will return an instance of a .Net panel if the panel has been\n       displayed at least once.  Panel instances are not created until a\n       panel is displayed.",since:5,returns:"Returns the one and only instance of a panel if it has been properly\n       registered and displayed at least once.  If the panel has never been\n       displayed then None will be returned even if the panel is properly\n       registered."},{signature:"static object GetPanel(Guid panelId,RhinoDoc rhinoDoc)",summary:"Will return an instance of a .Net panel if the panel has been\n       displayed at least once.  Panel instances are not created until a\n       panel is displayed.",since:6,returns:"Returns the one and only instance of a panel if it has been properly\n       registered and displayed at least once.  If the panel has never been\n       displayed then None will be returned even if the panel is properly\n       registered."},{signature:"static object GetPanel(Guid panelId,uint documentSerialNumber)",summary:"Will return an instance of a .Net panel if the panel has been\n       displayed at least once.  Panel instances are not created until a\n       panel is displayed.",since:6,returns:"Returns the one and only instance of a panel if it has been properly\n       registered and displayed at least once.  If the panel has never been\n       displayed then None will be returned even if the panel is properly\n       registered."},{signature:"static T GetPanel(RhinoDoc rhinoDoc)",summary:"Return an instance of a .Net panel",since:6},{signature:"static T GetPanel(uint documentSerialNumber)",summary:"Return an instance of a .Net panel",since:6},{signature:"static object [] GetPanels(Guid panelId,RhinoDoc doc)",summary:"Gets the panels.",since:6.3,returns:"The panels."},{signature:"static object[] GetPanels(Guid panelId,uint documentRuntimeSerialNumber)",summary:"Gets the panels.",since:6.3,returns:"The panels."},{signature:"static T[] GetPanels(RhinoDoc doc)",since:6.3},{signature:"static T [] GetPanels(uint documentRuntimeSerialNumber)",summary:"Gets the panels.",since:6.3,returns:"The panels."},{signature:"static bool IsHiding(ShowPanelReason reason)",summary:"Check to see if reason is equal to any of the show events",since:6},{signature:"static bool IsPanelVisible(Guid panelId)",summary:"Check to see if a panel is currently visible, on Windows this means\n       you can see the tab, it does not necessarily mean it is the current\n       tab.",since:5,returns:"Returns True if the tab is visible otherwise it returns false."},{signature:"static bool IsPanelVisible(Guid panelId,bool isSelectedTab)",summary:"Check to see if a panel is currently visible, if isSelectedTab\n       is True then the tab must be the active tab as well.",since:6,returns:"On Windows:\n         The return value is demendant on the isSelectedTab value.  If\n         isSelectedTab is True then the panel must be included in a\n         visible tabbed container and must also be the active tab to be\n         true.  If isSelectedTab is False then the panel only has to be \n         included in a visible tabbed container to be true.\n       On Mac:\n         isSelected is ignored and True is returned if the panel appears\n         in any inspector panel."},{signature:"static bool IsPanelVisible(Type panelType)",summary:"Check to see if a panel is currently visible, on Windows this means\n       you can see the tab, it does not necessarily mean it is the current\n       tab.",since:5,returns:"Returns True if panelType is non None and the tab is visible otherwise\n       it returns false."},{signature:"static bool IsPanelVisible(Type panelType,bool isSelectedTab)",summary:"Check to see if a panel is currently visible, if isSelectedTab\n       is True then the tab must be the active tab as well.",since:6,returns:"On Windows:\n         The return value is demendant on the isSelectedTab value.  If\n         isSelectedTab is True then the panel must be included in a\n         visible tabbed container and must also be the active tab to be\n         true.  If isSelectedTab is False then the panel only has to be \n         included in a visible tabbed container to be true.\n       On Mac:\n         isSelected is ignored and True is returned if the panel appears\n         in any inspector panel."},{signature:"static bool IsShowing(ShowPanelReason reason)",summary:"Check to see if reason is equal to any of the hide events",since:6},{signature:"static void OnClosePanel(Guid panelId,uint documentSerialNumber)",summary:"Call this method to raise the Closed event",since:6},{signature:"static void OnShowPanel(Guid panelId,uint documentSerialNumber,bool show)",summary:"Call this method to raise the Show event",since:6},{signature:"static void OpenPanel(Guid panelId)",summary:"Open the specified panel in its current or default location and if it\n       is in a dock bar containing more than one tab, make it the current tab.",since:5},{signature:"static void OpenPanel(Guid panelId,bool makeSelectedPanel)",summary:"Open the specified panel in its current or default location and if it\n       is in a dock bar containing more than one tab, make it the current tab.",since:6},{signature:"static Guid OpenPanel(Guid dockBarId,Guid panelId)",summary:"In Mac Rhino this will just call the version of OpenPanel that takes\n       a class type Id.  In Windows Rhino this will look for a dock bar with\n       the specified Id and open or move the specified panel to that dock\n       bar.",since:5.12,returns:"Returns True if the"},{signature:"static Guid OpenPanel(Guid dockBarId,Guid panelId,bool makeSelectedPanel)",summary:"In Mac Rhino this will just call the version of OpenPanel that takes\n       a class type Id.  In Windows Rhino this will look for a dock bar with\n       the specified Id and open or move the specified panel to that dock\n       bar.",since:6,returns:"Returns True if the"},{signature:"static Guid OpenPanel(Guid dockBarId,Type panelType)",summary:"In Mac Rhino this will just call the version of OpenPanel that takes\n       a class type Id.  In Windows Rhino this will look for a dock bar with\n       the specified Id and open or move the specified panel to that dock\n       bar.",since:5.12,returns:"Returns True if the"},{signature:"static Guid OpenPanel(Guid dockBarId,Type panelType,bool makeSelectedPanel)",summary:"In Mac Rhino this will just call the version of OpenPanel that takes\n       a class type Id.  In Windows Rhino this will look for a dock bar with\n       the specified Id and open or move the specified panel to that dock\n       bar.",since:6,returns:"Returns True if the"},{signature:"static void OpenPanel(Type panelType)",summary:"Open the specified panel in its current or default location and if it\n       is in a dock bar containing more than one tab, make it the current tab.",since:5},{signature:"static void OpenPanel(Type panelType,bool makeSelectedPanel)",summary:"Open the specified panel in its current or default location and if it\n       is in a dock bar containing more than one tab, make it the current tab.",since:6},{signature:"static bool OpenPanelAsSibling(Guid panelId,Guid siblingPanelId)",summary:"In Mac Rhino this will currently just call OpenPanel, in Windows Rhino\n       this will look for a dock bar which contains the sibling panel and add\n       this panel to that dock bar as necessary, if the panel was in another\n       dock bar it will be moved to this dock bar.",since:5,returns:"Returns True if the panel was successfully opened."},{signature:"static bool OpenPanelAsSibling(Guid panelId,Guid siblingPanelId,bool makeSelectedPanel)",summary:"In Mac Rhino this will currently just call OpenPanel, in Windows Rhino\n       this will look for a dock bar which contains the sibling panel and add\n       this panel to that dock bar as necessary, if the panel was in another\n       dock bar it will be moved to this dock bar.",since:6,returns:"Returns True if the panel was successfully opened."},{signature:"static Guid PanelDockBar(Guid panelId)",summary:"Will always return Guid.Emty in Mac Rhino.  In Windows Rhino it will\n       look for the dock bar which contains the specified panel class Id and\n       return the dock bar Id.",since:5.12,returns:"Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will\n       return the Id for the dock bar which host the specified panel or \n       Guid.Empty if the panel is not currently visible."},{signature:"static Guid PanelDockBar(Type panelType)",summary:"Will always return Guid.Emty in Mac Rhino.  In Windows Rhino it will\n       look for the dock bar which contains the specified panel class Id and\n       return the dock bar Id.",since:5.12,returns:"Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will\n       return the Id for the dock bar which host the specified panel or \n       Guid.Empty if the panel is not currently visible."},{signature:"static Guid[] PanelDockBars(Guid panelId)",summary:"Will always return a empty array in Mac Rhino.  In Windows Rhino it will\n       look for any panel dock bars that contain the specified panel class Id and\n       return the dock bar Id's.",since:6.1,returns:"Always returns Guid.Empty on Mac Rhino.  On Windows Rhino it will\n       return the Id for the dock bar which host the specified panel or \n       Guid.Empty if the panel is not currently visible."},{signature:"static void RegisterPanel(PlugIn plugin,Type panelType,string caption,Icon icon)",summary:"You typically register your panel class in your plug-in's OnLoad\n       function.  This will register your custom call with Rhino, Rhino will\n       create an instance of your class the first time your panel is created\n       and embed this instance of your class in a panel container.",since:5},{signature:"static void RegisterPanel(PlugIn plugIn,Type type,string caption,Icon icon,PanelType panelType)",summary:"Call once to register a panel type which will get dynamically created\n       and embedded in a Rhino docking/floating location.",since:6.1}]},{name:"Rhino.UI.Panels.FloatPanelMode",dataType:3,summary:"Used by the FloatPanel method to detemine if the floating panel\n       should be shown or hidden."},{name:"Rhino.UI.PanelType",dataType:3,summary:"Panel type"},{name:"Rhino.UI.RhinoHelp",dataType:1,summary:"Provides access to the built in Rhino help system",methods:[{signature:"static bool Show(string helpLink)",summary:"Call this method to display standard Rhino help",since:6}]},{name:"Rhino.UI.RhinoPageInterop",dataType:1,summary:"For internal use only, provides access to unmanaged core\n   Rhino.",methods:[{signature:"static IntPtr NewPropertiesPanelPagePointer(ObjectPropertiesPage page,uint rhinoDocRuntimeSn)",summary:"For internal use only, provides access to unmanaged core",since:6},{signature:"static StackedDialogPage StackedDialogPageFromUnmanagedPointer(IntPtr pointer)",summary:"For internal use only, provides access to unmanaged core",since:6.4}]},{name:"Rhino.UI.RuiUpdateUi",dataType:1,summary:"",properties:[{signature:"bool Checked",summary:"Set to True to enable menu item or False to check menu item",since:5.11},{signature:"bool Enabled",summary:"Set to True to enable menu item or False to disable menu item",since:5.11},{signature:"Guid FileId",summary:"Id of the RUI file that owns this menu item",since:5.11},{signature:"IntPtr MenuHandle",summary:"Windows menu handle of menu that contains this item",since:5.11},{signature:"Guid MenuId",summary:"Id of the menu that owns this menu item",since:5.11},{signature:"int MenuIndex",summary:"Zero based index of item in the Windows menu",since:5.11},{signature:"Guid MenuItemId",summary:"Id of the menu item that owns this menu item",since:5.11},{signature:"bool RadioChecked",summary:"Set to True to enable menu item or False to check menu item",since:5.11},{signature:"string Text",summary:"Menu item text",since:5.11},{signature:"uint WindowsMenuItemId",summary:"Windows menu item ID",since:5.11}],methods:[{signature:"static bool RegisterMenuItem(Guid file,Guid menu,Guid item,UpdateMenuItemEventHandler callBack)",summary:"Register menu item update delegate",since:5.11,returns:"True if Registered otherwise false"},{signature:"static bool RegisterMenuItem(string fileId,string menuId,string itemId,UpdateMenuItemEventHandler callBack)",summary:"Register menu item update delegate",since:5.11,returns:"True if Registered otherwise false"}]},{name:"Rhino.UI.SaveFileDialog",dataType:1,summary:"Similar to the System.Windows.Forms.SaveFileDialog, but with customized\n   Rhino user interface.",constructors:[{signature:"SaveFileDialog()",since:5}],properties:[{signature:"string DefaultExt",summary:"The default file name extension. The returned string does not include the period.",since:5},{signature:"string FileName",summary:"Gets or sets a string containing the file name selected in the file dialog box.",since:5},{signature:"string Filter",summary:'Gets or sets the current file name filter string, which determines\n     the choices that appear in the "Save as file type" or "Files of type"\n     box in the dialog box. See System.Windows.Forms.FileDialog for details.',since:5},{signature:"string InitialDirectory",summary:"Gets or sets the initial directory displayed by the file dialog box.",since:5},{signature:"string Title",summary:"Gets or sets the file dialog box title.",since:5}],methods:[{signature:"System.Windows.Forms.DialogResult ShowDialog()",since:5},{signature:"bool ShowSaveDialog()",since:5.1,returns:"True if a file was selected. False if the dialog was cancelled"}]},{name:"Rhino.UI.ShowMessageButton",dataType:3,summary:""},{name:"Rhino.UI.ShowMessageDefaultButton",dataType:3,summary:""},{name:"Rhino.UI.ShowMessageIcon",dataType:3,summary:""},{name:"Rhino.UI.ShowMessageMode",dataType:3,summary:""},{name:"Rhino.UI.ShowMessageOptions",dataType:3,summary:""},{name:"Rhino.UI.ShowMessageResult",dataType:3,summary:""},{name:"Rhino.UI.ShowPanelEventArgs",dataType:1,summary:"Panels.Show event arguments",constructors:[{signature:"ShowPanelEventArgs(Guid panelId,uint documentSerialNumber,bool show)",since:6}],properties:[{signature:"bool Show",summary:"Will be True if showing or False if hiding",since:6}]},{name:"Rhino.UI.StackedDialogPage",dataType:1,summary:"Base class to inherit from for the addition of stacked dialog pages.",properties:[{signature:"List<StackedDialogPage> Children",summary:"List of child (sub) pages of this page",since:5},{signature:"string EnglishPageTitle",summary:'English string used when scripting this page and a user prefixes a\n     command option with "_"',since:5},{signature:"IntPtr Handle",summary:"When running on Windows return the window handle for the parent of this\n     page otherwise; return IntPtr.Zero.",since:6},{signature:"bool HasChildren",summary:"Will be True if this page contains sub pages.",since:5},{signature:"string LocalPageTitle",summary:"Localized page title that will appear on a tab or other page navigation\n     control.  This is also uses as a command line option when scripting\n     this page.",since:5},{signature:"bool Modified",summary:"Check to see if the page has been marked as modified or not.  Marking\n     the page as modified will cause the Apply button to get enabled if this\n     is currently the visible page and the page includes the Apply button.",since:6},{signature:"Color NavigationTextColor",summary:"Currently only used by Windows Rhino.  If this is set to True then the\n     tree control item text be drawn using this color.  Set the color to\n     System.Drawing.Color.Empty to use the default color.",since:6},{signature:"bool NavigationTextIsBold",summary:"Currently only used by Windows Rhino.  If this is set to True then the\n     tree control item text will be bold.",since:6},{signature:"object PageControl",summary:"Return the control that represents this page. Rhino Windows supports\n     classes that implement the IWin32Windows interface or are derived from\n     some form of System.Windows.FrameworkElement or Eto.Forms.Control.  Mac\n     Rhino supports controls that are derived from NSview or\n     Eto.Forms.Control.",since:5},{signature:"Image PageImage",summary:"Optionally override to provide a image to display in \n     the Mac Rhino UI",since:6},{signature:"bool ShowApplyButton",summary:"Called when this page is activated",since:6},{signature:"bool ShowDefaultsButton",summary:"Called when this page is activated.",since:5}],methods:[{signature:"void AddChildPage(StackedDialogPage pageToAdd)",summary:"Currently only supported on Windows.  Call this method to add a child\n     page to a page after the parent dialog has been created.",since:6},{signature:"void MakeActivePage()",summary:"Make this page the active, visible page",since:6},{signature:"bool OnActivate(bool active)",summary:"Called when this page is activated/deactivated.",since:5,returns:"If True then the page is hidden and the requested page is not\n    activated otherwise will not allow you to change the current page.\n    Default returns true"},{signature:"bool OnApply()",summary:"Called when stacked dialog OK button is pressed.",since:5,returns:"If return value is True then the dialog will be closed. A return of False means\n     there was an error and dialog remains open so page can be properly updated."},{signature:"void OnCancel()",summary:"Called when stacked dialog Cancel button is pressed.",since:5},{signature:"void OnCreateParent(IntPtr hwndParent)",summary:"Called when the parent window has been created on Windows platforms\n     only.",since:5},{signature:"void OnDefaults()",summary:"Called when stacked dialog Defaults button is pressed (see ShowDefaultsButton).",since:5},{signature:"void OnHelp()",summary:"Called when the parent dialog requests help for this page.",since:5},{signature:"void OnSizeParent(int width,int height)",summary:"Called when the parent window has been resized",since:5},{signature:"void RemovePage()",summary:"Remove this page from the dialog box",since:6},{signature:"void SetEnglishPageTitle(string newPageTile)",summary:"Change the title passed to the constructor and, this will cause\n     LocalPageTitle to get called also.",since:6}]},{name:"Rhino.UI.StatusBar",dataType:1,summary:"Contains static methods to control the application status bar.",methods:[{signature:"static void ClearMessagePane()",summary:"Removes the message from the message pane.",since:5},{signature:"static void HideProgressMeter()",summary:"Ends, or hides, Rhino's status bar progress meter.",since:5},{signature:"static void HideProgressMeter(uint docSerialNumber)",summary:"Ends, or hides, Rhino's status bar progress meter.",since:6.12},{signature:"static void SetDistancePane(double distance)",summary:"Sets the distance pane to a distance value.",since:5},{signature:"static void SetMessagePane(string message)",summary:"Sets the message pane to a message.",since:5},{signature:"static void SetNumberPane(double number)",summary:"Sets the number pane to a number value",since:6},{signature:"static void SetPointPane(Point3d point)",summary:"Sets the point pane to a point value.",since:5},{signature:"static int ShowProgressMeter(int lowerLimit,int upperLimit,string label,bool embedLabel,bool showPercentComplete)",summary:"Starts, or shows, Rhino's status bar progress meter.",since:5,returns:"1 - The progress meter was created successfully.\n     0 - The progress meter was not created.\n     -1 - The progress meter was not created because some other process has already created it."},{signature:"static int ShowProgressMeter(uint docSerialNumber,int lowerLimit,int upperLimit,string label,bool embedLabel,bool showPercentComplete)",summary:"Starts, or shows, Rhino's status bar progress meter.",since:6.12,returns:"1 - The progress meter was created successfully.\n     0 - The progress meter was not created.\n     -1 - The progress meter was not created because some other process has already created it."},{signature:"static int UpdateProgressMeter(int position,bool absolute)",summary:"Sets the current position of Rhino's status bar progress meter.",since:5,returns:"The previous position if successful."},{signature:"static int UpdateProgressMeter(uint docSerialNumber,int position,bool absolute)",summary:"Sets the current position of Rhino's status bar progress meter.",since:6.12,returns:"The previous position if successful."}]},{name:"Rhino.UI.Toolbar",dataType:1,summary:"",properties:[{signature:"static Size BitmapSize",since:6},{signature:"static Size TabSize",since:6},{signature:"Guid Id",since:5},{signature:"string Name",since:5}]},{name:"Rhino.UI.ToolbarFile",dataType:1,summary:"",properties:[{signature:"int GroupCount",since:5},{signature:"Guid Id",since:5},{signature:"string Name",since:5},{signature:"string Path",summary:"Full path to this file on disk",since:5},{signature:"int ToolbarCount",since:5}],methods:[{signature:"bool Close(bool prompt)",since:5},{signature:"ToolbarGroup GetGroup(int index)",since:5},{signature:"ToolbarGroup GetGroup(string name)",since:5},{signature:"Toolbar GetToolbar(int index)",since:5},{signature:"bool Save()",since:5},{signature:"bool SaveAs(string path)",since:5}]},{name:"Rhino.UI.ToolbarFileCollection",dataType:1,summary:"",properties:[{signature:"static bool MruSidebarIsVisible",since:5},{signature:"static bool SidebarIsVisible",since:5},{signature:"int Count",summary:"Number of open toolbar files",since:5}],methods:[{signature:"ToolbarFile FindByName(string name,bool ignoreCase)",since:5},{signature:"ToolbarFile FindByPath(string path)",since:5},{signature:"IEnumerator<ToolbarFile> GetEnumerator()",since:5},{signature:"ToolbarFile Open(string path)",since:5}]},{name:"Rhino.UI.ToolbarGroup",dataType:1,summary:"",properties:[{signature:"Guid Id",since:5},{signature:"bool IsDocked",since:5},{signature:"string Name",since:5},{signature:"bool Visible",since:5}]},{name:"Rhino.UI.WaitCursor",dataType:1,summary:"",constructors:[{signature:"WaitCursor()",since:5.1}],methods:[{signature:"void Clear()",since:5.1},{signature:"void Dispose()",since:5.1},{signature:"void Set()",since:5.1}]},{name:"RhinoMobile.Display.ColorExtensions",dataType:1,summary:""},{name:"UnsafeNativeMethods.Point",dataType:2,summary:""}],s=null,r=null;function a(e,t,n){if(e&&!(e.length<1)){var i=e.splice(0,1)[0];if(e.length<1)return t.children||(t.children=[]),void t.children.push({label:i,path:n});t.label||(t.label=i,t.path=n,t.children=[]);for(var s=0;s<t.children.length;s++)if(t.children[s].label===i)return void a(e,t.children[s],n);var r=n.indexOf(i),o=n.substring(0,r)+i;t.children.push({label:i,path:o,children:[]}),a(e,t.children[t.children.length-1],n)}}var o={getTree:function(){if(!s){var e={label:"Rhino",path:"Rhino",children:[]};i.forEach((function(t){var n=t.name.split("."),i=t.name;"Rhino"===n[0]&&(n.splice(0,1),a(n,e,i))})),s=e}return s},setSelectedItemChangedCallback:function(e){r=e},setSelectedItem:function(e){e=e.toLowerCase();for(var t=0;t<i.length;t++){var n=i[t];if(n.name.toLowerCase()===e)return void r(n)}},namespaceFromItem:function(e){var t=e.name.lastIndexOf(".");return e.name.substring(0,t)}};t["a"]=o}}]);